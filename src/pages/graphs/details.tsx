/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  CheckOutlined,
  CloseOutlined,
  DeleteOutlined,
  DownloadOutlined,
  DownOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  LoadingOutlined,
  MessageFilled,
  MessageOutlined,
  PlayCircleFilled,
  RightOutlined,
  SaveFilled,
  XFilled,
} from '@ant-design/icons';
import {
  NodeChange,
  useEdgesState,
  useNodesState,
  Viewport,
} from '@xyflow/react';
import {
  Button,
  Input,
  Layout,
  message,
  Modal,
  Popconfirm,
  Popover,
  Space,
  Spin,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate, useParams } from 'react-router';

import {
  graphRevisionsApi,
  graphsApi,
  templatesApi,
  threadsApi,
} from '../../api';
import {
  CreateGraphDtoSchemaEdgesInner,
  CreateGraphDtoSchemaNodesInner,
  ExecuteTriggerDto,
  GraphDto,
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  GraphRevisionDto,
  GraphRevisionDtoStatusEnum,
  TemplateDto,
  ThreadDto,
  ThreadDtoStatusEnum,
  ThreadMessageDto,
} from '../../autogenerated';
import { useGraphDraftState } from '../../hooks/useGraphDraftState';
import { useThreadMessageStore } from '../../hooks/useThreadMessageStore';
import { useWebSocket } from '../../hooks/useWebSocket';
import {
  type GraphDiffState,
  GraphStorageService,
} from '../../services/GraphStorageService';
import { GraphValidationService } from '../../services/GraphValidationService';
import type {
  AgentMessageNotification,
  GraphNodeUpdateNotification,
  GraphRevisionNotification,
  GraphUpdateNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import { extractApiErrorMessage } from '../../utils/errors';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
} from '../../utils/graphThreads';
import {
  buildIdSet,
  clearStreamingReasoningForContext,
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../utils/threadMessages';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import ThreadChatPanel from '../chats/components/ThreadChatPanel';
import {
  createEdge,
  GraphCanvas,
  resolveHandlesForNodes,
} from './components/GraphCanvas';
import { NodeEditSidebar } from './components/NodeEditSidebar';
import { TemplateModal } from './components/TemplateModal';
import { TemplateSidebar } from './components/TemplateSidebar';
import { TriggerModal } from './components/TriggerModal';
import type {
  GraphEdge,
  GraphMetadata,
  GraphNode,
  GraphNodeData,
  NodeMetadata,
} from './types';
import type { MessageScopeKey, PendingMessage } from './types/messages';

const { Header, Sider, Content } = Layout;
const { Title } = Typography;

const REVISION_FETCH_LIMIT = 50;
const MESSAGE_PAGE_SIZE = 100;

const isDraftThreadId = (threadId?: string | null): boolean => {
  return Boolean(threadId && threadId.startsWith('draft-'));
};

const ensureThreadStatusPulseStyle = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('thread-status-pulse-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'thread-status-pulse-style';
    style.textContent = `
      @keyframes thread-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(24, 144, 255, 0.45); }
        70% { box-shadow: 0 0 0 8px rgba(24, 144, 255, 0); }
        100% { box-shadow: 0 0 0 0 rgba(24, 144, 255, 0); }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const REVISION_STATUS_STYLES: Record<
  GraphRevisionDtoStatusEnum,
  { label: string; color: string; pulse?: boolean }
> = {
  [GraphRevisionDtoStatusEnum.Pending]: {
    label: 'Pending',
    color: '#d9d9d9',
  },
  [GraphRevisionDtoStatusEnum.Applying]: {
    label: 'Applying',
    color: '#faad14',
    pulse: true,
  },
  [GraphRevisionDtoStatusEnum.Applied]: {
    label: 'Applied',
    color: '#52c41a',
  },
  [GraphRevisionDtoStatusEnum.Failed]: {
    label: 'Failed',
    color: '#ff4d4f',
  },
} as const;

const REVISION_DIFF_OP_META: Record<string, { label: string; color: string }> =
  {
    add: { label: 'Add', color: '#52c41a' },
    remove: { label: 'Remove', color: '#ff4d4f' },
    replace: { label: 'Replace', color: '#1890ff' },
    move: { label: 'Move', color: '#722ed1' },
    copy: { label: 'Copy', color: '#13c2c2' },
    test: { label: 'Test', color: '#595959' },
  };

type MessageMeta = {
  loading: boolean;
  loadingMore: boolean;
  hasMore: boolean;
  offset: number;
};

type MessageMetaState = Record<string, Record<MessageScopeKey, MessageMeta>>;

const createDefaultMessageMeta = (): MessageMeta => ({
  loading: false,
  loadingMore: false,
  hasMore: true,
  offset: 0,
});

const ensureRevisionStatusPulseStyle = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('revision-status-pulse-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'revision-status-pulse-style';
    style.textContent = `
      @keyframes revision-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(250, 173, 20, 0.45); }
        70% { box-shadow: 0 0 0 8px rgba(250, 173, 20, 0); }
        100% { box-shadow: 0 0 0 0 rgba(250, 173, 20, 0); }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const sortRevisions = (list: GraphRevisionDto[]): GraphRevisionDto[] => {
  return [...list].sort((a, b) => {
    const aTime = new Date(a.updatedAt || a.createdAt).getTime();
    const bTime = new Date(b.updatedAt || b.createdAt).getTime();
    if (bTime === aTime) {
      return b.toVersion.localeCompare(a.toVersion);
    }
    return bTime - aTime;
  });
};

export const GraphPage = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();

  useEffect(() => {
    ensureThreadStatusPulseStyle();
    ensureRevisionStatusPulseStyle();
  }, []);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [leftSidebarCollapsed, setLeftSidebarCollapsed] = useState(false);
  const [graph, setGraph] = useState<GraphDto | null>(null);

  // Server state for the draft hook (initialized with empty state, updated after load)
  const [serverGraphState, setServerGraphState] = useState<GraphDiffState>({
    nodes: [],
    edges: [],
    viewport: { x: 0, y: 0, zoom: 1 },
    selectedThreadId: undefined,
    graphName: '',
  });

  // React Flow state (will be synced with draft state via onStateChange)
  const [nodes, setNodes, baseOnNodesChange] = useNodesState<GraphNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<GraphEdge>([]);
  const [viewport, setViewport] = useState<Viewport>(() => {
    if (!id) return { x: 0, y: 0, zoom: 1 };
    if (GraphStorageService.hasDraft(id)) return { x: 0, y: 0, zoom: 1 };
    return GraphStorageService.loadViewport(id) ?? { x: 0, y: 0, zoom: 1 };
  });
  const viewportRef = useRef<Viewport>(viewport);
  useEffect(() => {
    viewportRef.current = viewport;
  }, [viewport]);

  const [selectedThreadId, setSelectedThreadId] = useState<
    string | undefined
  >();
  const selectedThreadIdRef = useRef<string | undefined>();
  useEffect(() => {
    selectedThreadIdRef.current = selectedThreadId;
  }, [selectedThreadId]);

  // Draft is our persisted source of truth, but ReactFlow is the immediate UI state.
  // When we update the draft *from* ReactFlow (onNodesChange/onEdgesChange), we must
  // not immediately "sync back" into ReactFlow, otherwise partial draft updates
  // (e.g. edges update arriving before nodes update) can resurrect deleted nodes.
  const nextDraftChangeOriginRef = useRef<'draft' | 'reactflow'>('draft');

  const pendingViewportSaveRef = useRef<Viewport | null>(null);
  const viewportSaveRafRef = useRef<number | null>(null);

  useEffect(() => {
    return () => {
      if (viewportSaveRafRef.current != null) {
        cancelAnimationFrame(viewportSaveRafRef.current);
        viewportSaveRafRef.current = null;
      }
    };
  }, []);

  // Callback to sync draft state changes to React Flow
  const handleDraftStateChange = useCallback(
    (newState: GraphDiffState) => {
      const origin = nextDraftChangeOriginRef.current;
      nextDraftChangeOriginRef.current = 'draft';
      if (origin === 'reactflow') {
        // ReactFlow already has the latest UI state; avoid overwriting it with a
        // partial draft update (which can be briefly out of sync).
        return;
      }

      isSyncingFromDraftRef.current = true;

      setNodes(newState.nodes);
      setEdges(newState.edges);
      setViewport(newState.viewport);
      if (newState.selectedThreadId !== selectedThreadIdRef.current) {
        setSelectedThreadId(newState.selectedThreadId);
      }

      requestAnimationFrame(() => {
        isSyncingFromDraftRef.current = false;
      });
    },
    [setNodes, setEdges, setViewport],
  );

  // Central draft state management - single source of truth!
  const draftState = useGraphDraftState({
    graphId: id || '',
    serverState: serverGraphState,
    onStateChange: handleDraftStateChange,
  });

  // Ref for draft state to use in callbacks without recreating them
  const draftStateRef = useRef(draftState);
  useEffect(() => {
    draftStateRef.current = draftState;
  }, [draftState]);

  const isHydratingRef = useRef(true);
  const userInteractedRef = useRef(false);
  const isSyncingFromDraftRef = useRef(false);
  const nodeChangeQueueRef = useRef<NodeChange[]>([]);
  const nodeChangeRafRef = useRef<number | null>(null);

  const [selectedTemplate, setSelectedTemplate] = useState<TemplateDto | null>(
    null,
  );
  const [templateModalVisible, setTemplateModalVisible] = useState(false);

  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [nodeEditSidebarVisible, setNodeEditSidebarVisible] = useState(false);
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  // Incremented after successful save to signal NodeEditSidebar to reset initialFormValues
  const [draftNodeConfigVersion, setDraftNodeConfigVersion] = useState(0);
  const templatesById = useMemo(
    () =>
      templates.reduce<Record<string, TemplateDto>>((acc, template) => {
        acc[template.id] = template;
        return acc;
      }, {}),
    [templates],
  );

  const isAgentNodeIdInCurrentGraph = useCallback(
    (candidateNodeId?: string) => {
      if (!candidateNodeId) return false;
      const schemaNode = graph?.schema?.nodes?.find(
        (n) => n.id === candidateNodeId,
      );
      if (!schemaNode) return false;
      const template = templatesById[schemaNode.template];
      return (template?.kind || '').toLowerCase() === 'simpleagent';
    },
    [graph?.schema?.nodes, templatesById],
  );

  const buildAgentMessageScopeKeys = useCallback(
    (candidateNodeId?: string): (string | undefined)[] => {
      return isAgentNodeIdInCurrentGraph(candidateNodeId)
        ? [undefined, candidateNodeId]
        : [undefined];
    },
    [isAgentNodeIdInCurrentGraph],
  );

  const [triggerModalVisible, setTriggerModalVisible] = useState(false);
  const [triggerNodeId, setTriggerNodeId] = useState<string | null>(null);
  const [triggerNodeName, setTriggerNodeName] = useState<string | null>(null);
  const [triggerLoading, setTriggerLoading] = useState(false);
  const triggerStartedRef = useRef(false);
  const pendingThreadSelectionRef = useRef<string | null>(null);

  const [isEditingName, setIsEditingName] = useState(false);
  const [editingName, setEditingName] = useState('');

  const [actionLoading, setActionLoading] = useState(false);
  const [graphError, setGraphError] = useState<string | null>(null);

  const isGraphRunning = graph?.status === GraphDtoStatusEnum.Running;
  const isGraphCompiling = graph?.status === GraphDtoStatusEnum.Compiling;

  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const threadsRef = useRef<ThreadDto[]>([]);
  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadPopoverVisible, setThreadPopoverVisible] = useState(false);
  const [deletingThreadId, setDeletingThreadId] = useState<string | null>(null);
  const [stoppingThreadId, setStoppingThreadId] = useState<string | null>(null);
  const [threadChatThreadId, setThreadChatThreadId] = useState<string | null>(
    null,
  );
  const [compiledNodesMap, setCompiledNodesMap] = useState<
    Record<string, GraphNodeWithStatusDto>
  >({});
  const [compiledNodesLoading, setCompiledNodesLoading] = useState(false);
  const {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
  } = useThreadMessageStore();

  // Helper to rebuild state from server graph response
  // This is called after loading graph from server

  const rebuildStateFromGraph = useCallback(
    (graphData: GraphDto): GraphDiffState => {
      const metadata = (graphData.metadata as GraphMetadata) || {};
      const nodeMetadata = metadata.nodes || [];

      const nodeMetadataMap = nodeMetadata.reduce(
        (acc, nodeMeta) => {
          acc[nodeMeta.id] = nodeMeta;
          return acc;
        },
        {} as Record<string, NodeMetadata>,
      );

      const apiNodes = graphData.schema?.nodes || [];
      const refreshedNodes: GraphNode[] = apiNodes.map((node, index) => {
        const nodeMeta = nodeMetadataMap[node.id];
        const template = templates.find((t) => t.id === node.template);
        return {
          id: node.id,
          type: 'custom',
          position: nodeMeta
            ? { x: nodeMeta.x, y: nodeMeta.y }
            : {
                x: 100 + (index % 3) * 250,
                y: 100 + Math.floor(index / 3) * 150,
              },
          data: {
            label: nodeMeta?.name || template?.name || node.template,
            template: node.template,
            templateKind: template?.kind,
            templateSchema: template?.schema,
            config: node.config || {},
          },
        };
      });

      const nodeById: Record<string, GraphNode> = Object.fromEntries(
        refreshedNodes.map((n) => [n.id, n]),
      );

      const apiEdges = graphData.schema?.edges || [];
      const refreshedEdges: GraphEdge[] = apiEdges.map((edge) => {
        const src = nodeById[edge.from];
        const dst = nodeById[edge.to];
        const { sourceHandle, targetHandle } = resolveHandlesForNodes(
          src,
          dst,
          templates,
        );
        return createEdge(
          edge.from,
          edge.to,
          sourceHandle,
          targetHandle,
          typeof edge.label === 'string' ? edge.label : undefined,
        );
      });

      const refreshedViewport: Viewport =
        metadata.x !== undefined &&
        metadata.y !== undefined &&
        metadata.zoom !== undefined
          ? {
              x: metadata.x,
              y: metadata.y,
              zoom: metadata.zoom,
            }
          : viewportRef.current;

      return {
        nodes: refreshedNodes,
        edges: refreshedEdges,
        viewport: refreshedViewport,
        selectedThreadId,
        graphName: graphData.name,
        baseVersion: graphData.version,
      };
    },
    [templates, selectedThreadId],
  );

  // Use draft state flags - single source of truth!
  const hasUnsavedChanges = draftState.hasUnsavedChanges;
  const hasStructuralChanges = draftState.hasStructuralChanges;
  const handleViewportPersistChange = useCallback(
    (nextViewport: Viewport) => {
      setViewport(nextViewport);

      if (!id) return;
      if (loading) return;
      if (isSyncingFromDraftRef.current) return;

      // Update draft state immediately so it stays in sync
      draftStateRef.current.updateViewport(nextViewport);

      pendingViewportSaveRef.current = nextViewport;

      if (viewportSaveRafRef.current != null) {
        return;
      }

      viewportSaveRafRef.current = requestAnimationFrame(() => {
        viewportSaveRafRef.current = null;
        const vp = pendingViewportSaveRef.current;
        if (!vp) return;

        GraphStorageService.saveViewport(id, vp);
      });
    },
    [id, loading, setViewport],
  );
  const selectedNodeUnsavedFromServer = useMemo(() => {
    if (!selectedNode?.id) return false;
    return draftState.hasNodeChanges(selectedNode.id);
  }, [selectedNode?.id, draftState]);

  const [messageMeta, setMessageMeta] = useState<MessageMetaState>({});
  const defaultNewMessageMode = useMemo<
    'inject_after_tool_call' | 'wait_for_completion'
  >(() => {
    const firstAgentNode = nodes.find((n) => {
      const data = n.data as unknown as GraphNodeData;
      return (data?.templateKind || '').toLowerCase() === 'simpleagent';
    });

    const modeFromNode = (firstAgentNode?.data as GraphNodeData | undefined)
      ?.config?.newMessageMode as
      | 'inject_after_tool_call'
      | 'wait_for_completion'
      | undefined;
    return modeFromNode ?? 'wait_for_completion';
  }, [nodes]);

  const getMessageMeta = useCallback(
    (threadId?: string, nodeId?: string): MessageMeta => {
      if (!threadId) {
        return createDefaultMessageMeta();
      }
      return (
        messageMeta[threadId]?.[nodeId ?? 'all'] ?? createDefaultMessageMeta()
      );
    },
    [messageMeta],
  );

  const updateMessageMeta = useCallback(
    (
      threadId: string,
      nodeId: string | undefined,
      updater: (prev: MessageMeta) => MessageMeta,
    ) => {
      setMessageMeta((prev) => {
        const key = nodeId ?? 'all';
        const existing = prev[threadId]?.[key] ?? createDefaultMessageMeta();
        const next = updater(existing);
        return {
          ...prev,
          [threadId]: {
            ...(prev[threadId] ?? {}),
            [key]: next,
          },
        };
      });
    },
    [],
  );

  const resolveInternalThreadId = useCallback((externalThreadId?: string) => {
    if (!externalThreadId) return undefined;
    const found = threadsRef.current.find(
      (thread) => thread.externalThreadId === externalThreadId,
    );
    return found?.id;
  }, []);

  const getThreadTimestamp = useCallback((thread: ThreadDto) => {
    const value = thread.updatedAt ?? thread.createdAt;
    return value ? Date.parse(value) : Number.NaN;
  }, []);

  const sortThreadsByTimestampDesc = useCallback(
    (list: ThreadDto[]) => {
      return [...list].sort((a, b) => {
        const bTs = getThreadTimestamp(b);
        const aTs = getThreadTimestamp(a);
        const safeBTs = Number.isFinite(bTs) ? bTs : -Infinity;
        const safeATs = Number.isFinite(aTs) ? aTs : -Infinity;
        if (safeBTs !== safeATs) {
          return safeBTs - safeATs;
        }
        return (b.createdAt ?? '').localeCompare(a.createdAt ?? '');
      });
    },
    [getThreadTimestamp],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadDtoStatusEnum.Done ||
        existing.status === ThreadDtoStatusEnum.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === ThreadDtoStatusEnum.Running
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  const loadMessagesForScope = useCallback(
    async (threadId: string, nodeId?: string, force = false) => {
      // Draft threads are local-only; they can never have persisted messages.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
        return;
      }

      const meta = getMessageMeta(threadId, nodeId);
      if (!force && (meta.loading || meta.offset > 0)) {
        return;
      }

      updateMessageMeta(threadId, nodeId, (prev) => ({
        ...prev,
        loading: true,
        loadingMore: false,
        hasMore: true,
        offset: force ? 0 : prev.offset,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          nodeId,
          MESSAGE_PAGE_SIZE,
          0,
        );
        const fetched = response.data?.reverse() || [];

        // Merge fetched with existing messages, preserving timestamps we already have
        updateMessages(
          threadId,
          (prev) => {
            // Build maps for efficient lookup
            const existingById = new Map<string, ThreadMessageDto>();
            const existingOptimistic = new Map<string, ThreadMessageDto>();

            prev.forEach((msg) => {
              const isOptimistic =
                typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
              if (isOptimistic) {
                // Map optimistic messages by content for matching
                if (msg.message?.role === 'human') {
                  const content =
                    typeof msg.message.content === 'string'
                      ? msg.message.content.trim()
                      : '';
                  if (content) {
                    existingOptimistic.set(content, msg);
                  }
                }
              } else {
                // Map real messages by ID
                existingById.set(msg.id, msg);
              }
            });

            // Process fetched messages
            const result: ThreadMessageDto[] = [];
            const processedOptimistic = new Set<string>();

            fetched.forEach((fetchedMsg) => {
              const existingMsg = existingById.get(fetchedMsg.id);

              if (existingMsg) {
                // Message already exists - preserve its timestamp
                result.push({
                  ...fetchedMsg,
                  createdAt: existingMsg.createdAt,
                });
              } else if (fetchedMsg.message?.role === 'human') {
                // New human message - check if it matches an optimistic one
                const content =
                  typeof fetchedMsg.message.content === 'string'
                    ? fetchedMsg.message.content.trim()
                    : '';

                const optimisticMatch = content
                  ? existingOptimistic.get(content)
                  : undefined;

                if (optimisticMatch) {
                  // Replace optimistic with real, preserve timestamp
                  result.push({
                    ...fetchedMsg,
                    createdAt: optimisticMatch.createdAt,
                  });
                  processedOptimistic.add(content);
                } else {
                  // New message with no match
                  result.push(fetchedMsg);
                }
              } else {
                // New non-human message
                result.push(fetchedMsg);
              }
            });

            // Add any optimistic messages that weren't matched
            existingOptimistic.forEach((optMsg, content) => {
              if (!processedOptimistic.has(content)) {
                result.push(optMsg);
              }
            });

            // Sort by timestamp
            result.sort((a, b) => {
              const timeA = new Date(a.createdAt).getTime();
              const timeB = new Date(b.createdAt).getTime();
              return timeA - timeB;
            });

            return result;
          },
          nodeId,
        );

        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: fetched.length === MESSAGE_PAGE_SIZE,
          offset: fetched.length,
        }));

        const extId =
          fetched.find((m) => m.externalThreadId)?.externalThreadId ??
          externalThreadIds[threadId];
        if (extId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: extId,
          }));
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load messages',
        );
        message.error(errorMessage);
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateMessages, externalThreadIds],
  );

  const loadMoreMessagesForScope = useCallback(
    async (threadId: string, nodeId?: string) => {
      // Draft threads are local-only; there is nothing to paginate from the API.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
        return;
      }

      const meta = getMessageMeta(threadId, nodeId);
      if (meta.loadingMore || !meta.hasMore || meta.loading) {
        return;
      }

      updateMessageMeta(threadId, nodeId, (prev) => ({
        ...prev,
        loadingMore: true,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          nodeId,
          MESSAGE_PAGE_SIZE,
          meta.offset,
        );
        const fetched = response.data?.reverse() || [];

        if (fetched.length > 0) {
          updateMessages(
            threadId,
            (prev) => mergeMessagesReplacingStreaming(prev, fetched),
            nodeId,
          );
          updateMessageMeta(threadId, nodeId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: fetched.length === MESSAGE_PAGE_SIZE,
            offset: prev.offset + fetched.length,
          }));
        } else {
          updateMessageMeta(threadId, nodeId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: false,
          }));
        }
      } catch (error) {
        console.error('Error loading more messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load more messages',
        );
        message.error(errorMessage);
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateMessages],
  );

  useEffect(() => {
    if (
      !nodeEditSidebarVisible ||
      !selectedThreadId ||
      !selectedNode?.id ||
      !selectedNode.data
    ) {
      return;
    }
    if (isDraftThreadId(selectedThreadId)) {
      return;
    }
    const nodeData = selectedNode.data as unknown as GraphNodeData;
    const isAgentNode =
      (nodeData?.templateKind || '').toLowerCase() === 'simpleagent';
    if (!isAgentNode) {
      return;
    }

    const meta = getMessageMeta(selectedThreadId, selectedNode.id);
    if (meta.offset === 0 && !meta.loading && meta.hasMore) {
      void loadMessagesForScope(selectedThreadId, selectedNode.id);
    }
  }, [
    nodeEditSidebarVisible,
    selectedThreadId,
    selectedNode,
    getMessageMeta,
    loadMessagesForScope,
  ]);

  const [revisions, setRevisions] = useState<GraphRevisionDto[]>([]);
  const [revisionsLoading, setRevisionsLoading] = useState(false);
  const [revisionPopoverVisible, setRevisionPopoverVisible] = useState(false);
  const [revisionDiffRevision, setRevisionDiffRevision] =
    useState<GraphRevisionDto | null>(null);
  const [hoveredRevisionId, setHoveredRevisionId] = useState<string | null>(
    null,
  );

  const triggerNodesForGraph = useMemo(() => {
    if (!graph) return [];
    return buildTriggerNodes(graph, templatesById);
  }, [graph, templatesById]);

  const nodeDisplayNames = useMemo(
    () => (graph ? buildNodeDisplayNames(graph) : {}),
    [graph],
  );

  const chatThread = useMemo(
    () =>
      threadChatThreadId
        ? (threads.find((thread) => thread.id === threadChatThreadId) ?? null)
        : null,
    [threads, threadChatThreadId],
  );

  const handleOpenThreadChat = useCallback((threadId: string) => {
    setThreadChatThreadId(threadId);
  }, []);

  const handleCloseThreadChat = useCallback(() => {
    setThreadChatThreadId(null);
  }, []);

  useEffect(() => {
    if (!selectedThreadId) return;
    if (isDraftThreadId(selectedThreadId)) return;
    const meta = getMessageMeta(selectedThreadId, undefined);
    if (meta.offset === 0 && !meta.loading && meta.hasMore) {
      void loadMessagesForScope(selectedThreadId);
    }
  }, [selectedThreadId, getMessageMeta, loadMessagesForScope]);

  useEffect(() => {
    if (!chatThread) return;
    if (isDraftThreadId(chatThread.id)) return;
    const meta = getMessageMeta(chatThread.id, undefined);
    if (meta.offset === 0 && !meta.loading && meta.hasMore) {
      void loadMessagesForScope(chatThread.id);
    }
  }, [chatThread, getMessageMeta, loadMessagesForScope]);

  useEffect(() => {
    if (!id) return;

    let mounted = true;
    (async () => {
      try {
        const templatesRes = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templatesList = templatesRes.data || [];
        setTemplates(templatesList);

        const res = await graphsApi.findGraphById(id);
        if (!mounted) return;

        const graphData = res.data;
        const pendingRevision = GraphStorageService.loadPendingRevision(id);
        const storedDraftName = GraphStorageService.loadDraft(id)?.graphName;
        const effectiveGraphName =
          pendingRevision?.graphName ?? storedDraftName ?? graphData.name;

        setGraph(
          pendingRevision && pendingRevision.toVersion !== graphData.version
            ? { ...graphData, version: pendingRevision.toVersion }
            : graphData,
        );
        setEditingName(effectiveGraphName);

        const metadata = (graphData.metadata as GraphMetadata) || {};
        const nodeMetadata = metadata.nodes || [];

        if (
          metadata.x !== undefined &&
          metadata.y !== undefined &&
          metadata.zoom !== undefined
        ) {
          // Viewport will be set via server state below
        }

        const nodeMetadataMap = nodeMetadata.reduce(
          (acc, nodeMeta) => {
            acc[nodeMeta.id] = nodeMeta;
            return acc;
          },
          {} as Record<string, NodeMetadata>,
        );

        const apiNodes = graphData.schema?.nodes || [];
        const reactFlowNodes: GraphNode[] = apiNodes.map((node, index) => {
          const nodeMeta = nodeMetadataMap[node.id];
          const template = templatesList.find((t) => t.id === node.template);
          return {
            id: node.id,
            type: 'custom',
            position: nodeMeta
              ? { x: nodeMeta.x, y: nodeMeta.y }
              : {
                  x: 100 + (index % 3) * 250,
                  y: 100 + Math.floor(index / 3) * 150,
                },
            data: {
              label: nodeMeta?.name || template?.name || node.template,
              template: node.template,
              templateKind: template?.kind,
              templateSchema: template?.schema,
              config: node.config || {},
            },
          };
        });
        const nodeById: Record<string, GraphNode> = Object.fromEntries(
          reactFlowNodes.map((n) => [n.id, n]),
        );

        const apiEdges = graphData.schema?.edges || [];
        const reactFlowEdges: GraphEdge[] = apiEdges.map((edge) => {
          const src = nodeById[edge.from];
          const dst = nodeById[edge.to];
          const { sourceHandle, targetHandle } = resolveHandlesForNodes(
            src,
            dst,
            templatesList,
          );
          return createEdge(
            edge.from,
            edge.to,
            sourceHandle,
            targetHandle,
            typeof edge.label === 'string' ? edge.label : undefined,
          );
        });

        // Create server baseline state from the loaded graph
        // Prioritize localStorage viewport over server metadata
        const storedViewport = !GraphStorageService.hasDraft(id)
          ? GraphStorageService.loadViewport(id)
          : null;

        const serverViewport =
          metadata.x !== undefined &&
          metadata.y !== undefined &&
          metadata.zoom !== undefined
            ? { x: metadata.x, y: metadata.y, zoom: metadata.zoom }
            : null;

        const serverState: GraphDiffState = {
          nodes: reactFlowNodes,
          edges: reactFlowEdges,
          viewport: storedViewport ?? serverViewport ?? { x: 0, y: 0, zoom: 1 },
          selectedThreadId,
          graphName: graphData.name,
          baseVersion: graphData.version,
        };

        // If we have a locally saved "pending revision" snapshot and the backend
        // is still on an older version, prefer the pending snapshot as the
        // baseline/UI state so reload shows the latest user-visible graph.
        if (
          pendingRevision &&
          pendingRevision.toVersion &&
          pendingRevision.toVersion !== graphData.version
        ) {
          const pendingState: GraphDiffState = {
            nodes: pendingRevision.nodes,
            edges: pendingRevision.edges,
            viewport: pendingRevision.viewport,
            selectedThreadId,
            graphName: effectiveGraphName,
            baseVersion: pendingRevision.toVersion,
          };

          setServerGraphState(pendingState);
          draftState.updateServerBaseline(pendingState);
          return;
        }

        // If the backend has caught up to our pending snapshot, it is safe to clear it.
        if (
          pendingRevision &&
          pendingRevision.toVersion &&
          pendingRevision.toVersion === graphData.version
        ) {
          GraphStorageService.clearPendingRevision(id);
        }

        // Check if stored draft is compatible with current server version
        const storedDraft = GraphStorageService.loadDraft(id);
        if (
          storedDraft &&
          storedDraft.baseVersion &&
          storedDraft.baseVersion !== graphData.version
        ) {
          // Draft is based on an old version - check if it has structural changes
          // If it's only viewport changes, we can keep it
          const hasStructuralChanges =
            JSON.stringify(
              storedDraft.nodes.map((n) => ({
                id: n.id,
                data: n.data,
              })),
            ) !==
              JSON.stringify(
                reactFlowNodes.map((n) => ({ id: n.id, data: n.data })),
              ) ||
            JSON.stringify(
              storedDraft.edges.map((e) => ({
                source: e.source,
                target: e.target,
              })),
            ) !==
              JSON.stringify(
                reactFlowEdges.map((e) => ({
                  source: e.source,
                  target: e.target,
                })),
              );

          if (hasStructuralChanges) {
            // Draft has real changes based on old version - discard it and warn user
            console.warn(
              `Discarding draft: based on version ${storedDraft.baseVersion}, but server is at version ${graphData.version}`,
            );
            GraphStorageService.clearDraft(id);
            message.warning(
              'Your local changes were based on an outdated version and have been discarded. Please make your changes again.',
              5,
            );
          } else {
            // Only viewport/metadata changes - keep the draft but update baseVersion
            console.log(
              `Keeping draft (viewport-only changes): updating baseVersion from ${storedDraft.baseVersion} to ${graphData.version}`,
            );
            // Update the draft's baseVersion to match current server version
            GraphStorageService.saveDraft(id, {
              ...storedDraft,
              baseVersion: graphData.version,
            });
          }
        }

        // Update server baseline - the hook will automatically apply any stored local changes
        setServerGraphState(serverState);
        draftState.updateServerBaseline(serverState);
      } catch (e) {
        console.error('Error fetching graph:', e);
        const errorMessage = extractApiErrorMessage(e, 'Failed to load graph');
        message.error(errorMessage);
        navigate('/');
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [id, navigate, setNodes, setEdges]);

  const loadThreads = useCallback(async () => {
    if (!id) return;

    try {
      setThreadsLoading(true);
      const response = await threadsApi.getThreads(id, undefined, 100, 0);
      setThreads(sortThreadsByTimestampDesc(response.data || []));
    } catch (error) {
      console.error('Error loading threads:', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to load threads',
      );
      message.error(errorMessage);
      setThreads([]);
    } finally {
      setThreadsLoading(false);
    }
  }, [id, sortThreadsByTimestampDesc]);

  const fetchCompiledNodes = useCallback(
    async (options?: {
      threadId?: string;
      graphStatusOverride?: GraphDtoStatusEnum | null;
    }) => {
      if (!id) return;

      const currentGraphStatus =
        options &&
        Object.prototype.hasOwnProperty.call(options, 'graphStatusOverride')
          ? options.graphStatusOverride
          : (graph?.status ?? null);

      if (currentGraphStatus === GraphDtoStatusEnum.Compiling) {
        setCompiledNodesLoading(false);
        return;
      }

      if (currentGraphStatus !== GraphDtoStatusEnum.Running) {
        setCompiledNodesMap((prev) => {
          // Only update if not already empty to prevent unnecessary rerenders
          return Object.keys(prev).length === 0 ? prev : {};
        });
        setCompiledNodesLoading(false);
        return;
      }

      const threadIdToUse =
        options && Object.prototype.hasOwnProperty.call(options, 'threadId')
          ? options.threadId
          : selectedThreadId;

      const selectedThread = threads.find((t) => t.id === threadIdToUse);
      const externalThreadId = selectedThread?.externalThreadId;

      try {
        setCompiledNodesLoading(true);
        const response = await graphsApi.getCompiledNodes(
          id,
          externalThreadId || undefined,
        );
        const nodesWithStatus = response.data || [];
        setCompiledNodesMap((prevMap) => {
          const next = nodesWithStatus.reduce<
            Record<string, GraphNodeWithStatusDto>
          >((acc, node) => {
            acc[node.id] = node;
            return acc;
          }, {});

          // Only update if the data actually changed to prevent unnecessary rerenders
          const prevKeys = Object.keys(prevMap).sort();
          const nextKeys = Object.keys(next).sort();

          if (
            prevKeys.length !== nextKeys.length ||
            !prevKeys.every((key, i) => key === nextKeys[i])
          ) {
            return next;
          }

          // Check if any node data changed
          const hasChanges = nextKeys.some((key) => {
            const prevNode = prevMap[key];
            const nextNode = next[key];
            return (
              !prevNode ||
              prevNode.status !== nextNode.status ||
              JSON.stringify(prevNode) !== JSON.stringify(nextNode)
            );
          });

          return hasChanges ? next : prevMap;
        });
      } catch (error) {
        console.error('Error loading compiled nodes:', error);
      } finally {
        setCompiledNodesLoading(false);
      }
    },
    [graph?.status, id, selectedThreadId, threads],
  );

  const loadRevisions = useCallback(
    async (options?: { silent?: boolean }) => {
      if (!id) return;
      try {
        setRevisionsLoading(true);
        const response = await graphRevisionsApi.getGraphRevisions(
          id,
          undefined,
          REVISION_FETCH_LIMIT,
        );
        const revisionList = response.data || [];
        setRevisions(
          sortRevisions(revisionList).slice(0, REVISION_FETCH_LIMIT),
        );
      } catch (error) {
        console.error('Error loading graph revisions:', error);
        if (!options?.silent) {
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load graph revisions',
          );
          message.error(errorMessage);
        }
      } finally {
        setRevisionsLoading(false);
      }
    },
    [id],
  );

  useEffect(() => {
    loadThreads();
  }, [loadThreads]);

  useEffect(() => {
    fetchCompiledNodes();
  }, [fetchCompiledNodes]);

  useEffect(() => {
    void loadRevisions({ silent: true });
  }, [loadRevisions]);

  const upsertRevision = useCallback((revision: GraphRevisionDto) => {
    setRevisions((prev) => {
      const next = prev.slice();
      const index = next.findIndex((item) => item.id === revision.id);
      if (index === -1) {
        next.push(revision);
      } else {
        next[index] = revision;
      }
      return sortRevisions(next).slice(0, REVISION_FETCH_LIMIT);
    });
  }, []);

  const activeRevision = useMemo(() => {
    if (!revisions.length) {
      return null;
    }

    const applyingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
    );
    if (applyingRevision) {
      return applyingRevision;
    }

    const pendingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Pending,
    );
    if (pendingRevision) {
      return pendingRevision;
    }

    if (graph?.version) {
      const matchingApplied = revisions.find(
        (revision) =>
          revision.toVersion === graph.version &&
          revision.status === GraphRevisionDtoStatusEnum.Applied,
      );
      if (matchingApplied) {
        return matchingApplied;
      }
    }

    const appliedRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applied,
    );
    if (appliedRevision) {
      return appliedRevision;
    }

    return revisions[0];
  }, [revisions, graph?.version]);

  const isRevisionApplying = useMemo(
    () =>
      revisions.some(
        (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
      ),
    [revisions],
  );

  const handleResetAllLocalChanges = useCallback(() => {
    if (saving || isRevisionApplying) return;

    Modal.confirm({
      title: 'Reset all local changes?',
      content:
        'This will discard all unsaved changes and restore the last saved version from the server.',
      okText: 'Reset changes',
      okButtonProps: { danger: true },
      cancelText: 'Cancel',
      onOk: () => {
        draftStateRef.current.resetToServer();
        message.success('Local changes reset');
      },
    });
  }, [saving, isRevisionApplying]);

  const unsavedChangesPopoverContent = useMemo(() => {
    return (
      <Space direction="vertical" size={8}>
        <Typography.Text>You have unsaved changes.</Typography.Text>
        <Button
          danger
          size="small"
          onClick={handleResetAllLocalChanges}
          disabled={saving || isRevisionApplying}>
          Reset all local changes
        </Button>
      </Space>
    );
  }, [handleResetAllLocalChanges, saving, isRevisionApplying]);

  const displayedRevisionMeta: {
    label: string;
    color: string;
    pulse?: boolean;
  } | null = useMemo(() => {
    if (activeRevision) {
      const meta =
        REVISION_STATUS_STYLES[
          activeRevision.status as GraphRevisionDtoStatusEnum
        ] ?? null;

      if (
        activeRevision.status === GraphRevisionDtoStatusEnum.Applying &&
        meta
      ) {
        return { ...meta, label: `Applying` };
      }
      if (meta) {
        return meta;
      }
    }
    if (graph) {
      return {
        label: 'Applied',
        color: '#52c41a',
      };
    }
    return null;
  }, [activeRevision, graph]);

  const displayedVersion = useMemo(() => {
    if (activeRevision) {
      const isAppliedActive =
        activeRevision.status === GraphRevisionDtoStatusEnum.Applied;
      if (!isAppliedActive || activeRevision.toVersion !== graph?.version) {
        return activeRevision.toVersion;
      }
    }
    return graph?.version ?? 'â€”';
  }, [activeRevision, graph?.version]);

  const formatRevisionDiffValue = useCallback((value: unknown) => {
    if (value === undefined) {
      return null;
    }
    if (value === null) {
      return (
        <Typography.Text code style={{ fontSize: 12 }}>
          null
        </Typography.Text>
      );
    }
    if (
      typeof value === 'string' ||
      typeof value === 'number' ||
      typeof value === 'boolean'
    ) {
      return (
        <Typography.Text code style={{ fontSize: 12 }}>
          {JSON.stringify(value)}
        </Typography.Text>
      );
    }
    return (
      <pre
        style={{
          background: '#f5f5f5',
          borderRadius: 6,
          padding: '8px 10px',
          margin: 0,
          fontSize: 12,
          whiteSpace: 'pre-wrap',
        }}>
        {JSON.stringify(value, null, 2)}
      </pre>
    );
  }, []);

  const handleOpenRevisionDiff = useCallback((revision: GraphRevisionDto) => {
    setRevisionDiffRevision(revision);
    setRevisionPopoverVisible(false);
  }, []);

  const handleDownloadGraphBackup = useCallback(() => {
    if (!graph) {
      message.warning('Graph is not loaded yet');
      return;
    }

    try {
      const backupPayload = {
        exportedAt: new Date().toISOString(),
        graph,
        nodes: draftState.draftState.nodes,
        edges: draftState.draftState.edges,
        viewport: draftState.draftState.viewport,
      };

      const blob = new Blob([JSON.stringify(backupPayload, null, 2)], {
        type: 'application/json',
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const safeVersion = graph.version ? `v${graph.version}` : 'draft';
      link.href = url;
      link.download = `graph-${graph.id ?? 'graph'}-${safeVersion}.json`;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Failed to export graph backup', error);
      message.error('Failed to download graph backup');
    }
  }, [graph]);

  const handleCloseRevisionDiff = useCallback(() => {
    setRevisionDiffRevision(null);
  }, []);

  const revisionDiffModalVisible = useMemo(
    () => revisionDiffRevision !== null,
    [revisionDiffRevision],
  );

  const revisionPopoverContent = useMemo(() => {
    if (revisionsLoading) {
      return (
        <div
          style={{
            minWidth: 280,
            minHeight: 80,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Spin size="small" />
        </div>
      );
    }

    if (revisions.length === 0) {
      return (
        <div style={{ minWidth: 280 }}>
          <Typography.Text type="secondary" style={{ fontSize: 12 }}>
            No revisions available yet.
          </Typography.Text>
        </div>
      );
    }

    return (
      <div style={{ minWidth: 320, maxHeight: 320, overflowY: 'auto' }}>
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          {revisions.map((revision) => {
            const meta = REVISION_STATUS_STYLES[
              revision.status as GraphRevisionDtoStatusEnum
            ] ?? {
              label: revision.status,
              color: '#d9d9d9',
            };
            const isActive = activeRevision?.id === revision.id;
            const isHovered = hoveredRevisionId === revision.id;
            const timestamp = new Date(
              revision.updatedAt || revision.createdAt,
            ).toLocaleString();

            return (
              <div
                key={revision.id}
                role="button"
                tabIndex={0}
                onClick={() => handleOpenRevisionDiff(revision)}
                onKeyDown={(event) => {
                  if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleOpenRevisionDiff(revision);
                  }
                }}
                onMouseEnter={() => setHoveredRevisionId(revision.id)}
                onMouseLeave={() =>
                  setHoveredRevisionId((prev) =>
                    prev === revision.id ? null : prev,
                  )
                }
                style={{
                  border: '1px solid #f0f0f0',
                  borderRadius: 6,
                  padding: '8px 12px',
                  background: isActive
                    ? '#fffbe6'
                    : isHovered
                      ? '#f0f5ff'
                      : '#fff',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  cursor: 'pointer',
                  outline: 'none',
                  transition:
                    'background-color 0.2s ease, border-color 0.2s ease',
                }}>
                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: 8,
                  }}>
                  <Typography.Text strong style={{ fontSize: 13 }}>
                    v{revision.toVersion}
                  </Typography.Text>
                  <Tag
                    color={meta.color}
                    style={{
                      margin: 0,
                      borderRadius: 999,
                      fontSize: 11,
                      lineHeight: '18px',
                      padding: '0 8px',
                    }}>
                    {meta.label}
                  </Tag>
                </div>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  From v{revision.baseVersion}
                </Typography.Text>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  Updated {timestamp}
                </Typography.Text>
                {revision.error && (
                  <Typography.Text
                    type="danger"
                    style={{ fontSize: 12, display: 'block', marginTop: 2 }}>
                    {revision.error}
                  </Typography.Text>
                )}
              </div>
            );
          })}
        </Space>
      </div>
    );
  }, [
    revisionsLoading,
    revisions,
    activeRevision?.id,
    hoveredRevisionId,
    handleOpenRevisionDiff,
  ]);

  useWebSocket({
    autoConnect: true,
    graphId: id,
    handlers: {
      'graph.update': (notification) => {
        const data = notification as GraphUpdateNotification;
        if (data.graphId !== id) return;

        const newStatus = data.data.status;

        if (
          newStatus === GraphDtoStatusEnum.Compiling ||
          newStatus === GraphDtoStatusEnum.Stopped
        ) {
          setCompiledNodesMap((prev) => {
            // Only update if not already empty to prevent unnecessary rerenders
            return Object.keys(prev).length === 0 ? prev : {};
          });
        }

        setGraph((prev) => {
          if (!prev) {
            return prev;
          }

          return {
            ...prev,
            status: newStatus,
          };
        });
      },

      'agent.message': (notification) => {
        const data = notification as AgentMessageNotification;
        if (data.graphId !== id) return;
        if (!data.internalThreadId) return;

        const threadId = data.internalThreadId;
        const nodeId = data.nodeId;
        const incomingMessage = data.data;

        const applyMessageKeys = buildAgentMessageScopeKeys(nodeId);

        // Add incoming message to all relevant scopes
        // The store will automatically handle:
        // - Replacing optimistic messages with real ones (by content matching)
        // - Deduplication by message ID
        // - Sorting by timestamp
        applyMessageKeys.forEach((key) => {
          updateMessages(
            threadId,
            (prev) => mergeMessagesReplacingStreaming(prev, [incomingMessage]),
            key,
          );
        });

        // Clear backend pending messages that match this incoming message
        const incomingContent =
          typeof incomingMessage.message?.content === 'string'
            ? (incomingMessage.message?.content as string)
            : undefined;
        const incomingRole = incomingMessage.message?.role as
          | string
          | undefined;
        if (incomingContent && incomingRole === 'human') {
          applyMessageKeys.forEach((key) => {
            updatePendingMessages(
              threadId,
              (prev) =>
                prev.filter(
                  (p) =>
                    typeof p.content !== 'string' ||
                    p.content !== incomingContent,
                ),
              key,
            );
          });
        }

        if (incomingMessage.externalThreadId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: incomingMessage.externalThreadId,
          }));
        }
      },

      'thread.create': (notification) => {
        const data = notification as ThreadCreateNotification;
        if (data.graphId !== id) return;

        const externalThreadId = data.threadId;
        if (!externalThreadId) {
          triggerStartedRef.current = false;
          return;
        }

        void (async () => {
          try {
            const response =
              await threadsApi.getThreadByExternalId(externalThreadId);
            const fetchedThread = response.data;
            if (!fetchedThread) {
              return;
            }

            setThreads((prevThreads) => {
              const exists = prevThreads.some((t) => t.id === fetchedThread.id);
              if (exists) {
                return sortThreadsByTimestampDesc(prevThreads);
              }
              return sortThreadsByTimestampDesc([
                fetchedThread,
                ...prevThreads,
              ]);
            });

            if (
              pendingThreadSelectionRef.current &&
              pendingThreadSelectionRef.current === externalThreadId
            ) {
              handleThreadChange(fetchedThread.id);
              pendingThreadSelectionRef.current = null;
            }
          } catch (error) {
            console.error('Error fetching thread by external ID:', error);
          } finally {
            triggerStartedRef.current = false;
          }
        })();
      },

      'thread.update': (notification) => {
        const data = notification as ThreadUpdateNotification;
        if (data.graphId !== id) return;

        const updatedThread = data.data;
        const externalThreadId = updatedThread.externalThreadId;

        setThreads((prevThreads) => {
          const existingIndex = prevThreads.findIndex(
            (thread) => thread.id === updatedThread.id,
          );

          if (existingIndex === -1) {
            return prevThreads;
          }

          const existingThread = prevThreads[existingIndex];
          if (!shouldApplyThreadUpdate(existingThread, updatedThread)) {
            return prevThreads;
          }

          const updatedThreads = [...prevThreads];
          updatedThreads[existingIndex] = updatedThread;
          return sortThreadsByTimestampDesc(updatedThreads);
        });

        if (
          externalThreadId &&
          pendingThreadSelectionRef.current &&
          pendingThreadSelectionRef.current === externalThreadId
        ) {
          handleThreadChange(updatedThread.id);
          pendingThreadSelectionRef.current = null;
        }

        triggerStartedRef.current = false;
      },

      'thread.delete': (notification) => {
        const data = notification as ThreadDeleteNotification;
        if (data.graphId !== id) return;

        const deletedThread = data.data;

        setThreads((prevThreads) =>
          prevThreads.filter((thread) => thread.id !== deletedThread.id),
        );

        if (
          deletedThread.externalThreadId === pendingThreadSelectionRef.current
        ) {
          pendingThreadSelectionRef.current = null;
        }

        if (selectedThreadId === deletedThread.id) {
          handleThreadChange(undefined);
        }

        triggerStartedRef.current = false;
      },

      'graph.node.update': (notification) => {
        const data = notification as GraphNodeUpdateNotification;
        if (data.graphId !== id) return;
        const eventThreadId =
          (typeof data.threadId === 'string' && data.threadId.length > 0
            ? data.threadId
            : undefined) ??
          (typeof data.data?.metadata?.threadId === 'string'
            ? data.data.metadata.threadId
            : undefined);
        const eventInternalThreadId =
          typeof data.internalThreadId === 'string' &&
          data.internalThreadId.length > 0
            ? data.internalThreadId
            : undefined;
        const metadataRunId =
          typeof data.data?.metadata?.runId === 'string'
            ? data.data.metadata.runId
            : undefined;
        const internalThreadId =
          eventInternalThreadId || resolveInternalThreadId(eventThreadId);

        const targetThreadId = internalThreadId ?? eventThreadId;
        if (!targetThreadId) {
          return;
        }

        const externalThreadIdForTarget =
          externalThreadIds[targetThreadId] ?? eventThreadId;

        if (eventThreadId) {
          setExternalThreadIds((prev) => {
            const existing = prev[targetThreadId];
            if (existing === eventThreadId) return prev;
            return { ...prev, [targetThreadId]: eventThreadId };
          });
        }
        const targetRunIds = buildIdSet(data.runId, metadataRunId);

        setCompiledNodesMap((prev) => {
          const existing = prev[data.nodeId];
          const nextStatus = data.data.status;
          const nextError = data.data.error ?? existing?.error ?? null;
          const nextMetadata = data.data.metadata ?? existing?.metadata;
          const nextAdditionalNodeMetadata =
            data.data.additionalNodeMetadata ??
            existing?.additionalNodeMetadata;

          if (!existing) {
            const graphNode = nodes.find(
              (n: GraphNode) => n.id === data.nodeId,
            );
            if (!graphNode) {
              return prev;
            }

            const nodeData = graphNode.data as unknown as GraphNodeData;
            const rawKind = (nodeData.templateKind as string | undefined) ?? '';
            const normalizedKind = rawKind.toLowerCase();
            let inferredType: GraphNodeWithStatusDto['type'] = 'runtime';
            if (normalizedKind === 'tool') {
              inferredType = 'tool';
            } else if (normalizedKind === 'simpleagent') {
              inferredType = 'simpleAgent';
            } else if (normalizedKind === 'trigger') {
              inferredType = 'trigger';
            } else if (normalizedKind === 'resource') {
              inferredType = 'resource';
            }

            return {
              ...prev,
              [data.nodeId]: {
                id: data.nodeId,
                name:
                  (nodeData.label as string) ||
                  (nodeData.template as string) ||
                  data.nodeId,
                template: (nodeData.template as string) || '',
                type: inferredType,
                status: nextStatus,
                config: nodeData.config ?? {},
                error: nextError,
                metadata: nextMetadata,
                additionalNodeMetadata: nextAdditionalNodeMetadata,
              },
            };
          }

          return {
            ...prev,
            [data.nodeId]: {
              ...existing,
              status: nextStatus,
              error: nextError,
              metadata: nextMetadata,
              additionalNodeMetadata: nextAdditionalNodeMetadata,
            },
          };
        });

        // Propagate pending messages to the shared store so both popup and sidebar see them
        const pendingMessagesFromNode =
          data.data?.additionalNodeMetadata?.pendingMessages;
        if (internalThreadId && Array.isArray(pendingMessagesFromNode)) {
          const pendingDtos: PendingMessage[] = pendingMessagesFromNode.map(
            (pendingMessage) => {
              const messageRecord = pendingMessage as Record<string, unknown>;
              const rawAdditionalKwargs = messageRecord.additionalKwargs;
              const sanitizedAdditionalKwargs =
                typeof rawAdditionalKwargs === 'object' &&
                rawAdditionalKwargs !== null
                  ? (rawAdditionalKwargs as Record<string, unknown>)
                  : {};
              const createdAt =
                typeof messageRecord.createdAt === 'string'
                  ? messageRecord.createdAt
                  : typeof sanitizedAdditionalKwargs.__createdAt === 'string'
                    ? sanitizedAdditionalKwargs.__createdAt
                    : typeof sanitizedAdditionalKwargs.created_at === 'string'
                      ? sanitizedAdditionalKwargs.created_at
                      : new Date().toISOString();
              const runId =
                data.runId ??
                metadataRunId ??
                (typeof sanitizedAdditionalKwargs.__runId === 'string'
                  ? sanitizedAdditionalKwargs.__runId
                  : typeof sanitizedAdditionalKwargs.run_id === 'string'
                    ? sanitizedAdditionalKwargs.run_id
                    : undefined);
              const content =
                typeof messageRecord.content === 'string'
                  ? messageRecord.content
                  : '';
              const roleCandidate = messageRecord.role;
              const role =
                roleCandidate === 'human' || roleCandidate === 'ai'
                  ? (roleCandidate as 'human' | 'ai')
                  : 'ai';
              return {
                content,
                role,
                additionalKwargs: {
                  ...sanitizedAdditionalKwargs,
                  __runId: runId,
                  __createdAt: createdAt,
                },
                createdAt,
              };
            },
          );

          const applyPendingToKeys = buildAgentMessageScopeKeys(data.nodeId);
          applyPendingToKeys.forEach((key) => {
            updatePendingMessages(
              internalThreadId,
              () => {
                // Filter out pending messages that match optimistic messages already in the timeline
                // This prevents duplication when we've already added an optimistic message locally
                const threadMessages = messages[internalThreadId];
                if (!threadMessages || key === undefined) {
                  return pendingDtos;
                }

                const currentMessages = threadMessages[key] || [];
                const optimisticContents = new Set<string>();

                currentMessages.forEach((msg: ThreadMessageDto) => {
                  const isOptimistic =
                    typeof msg.id === 'string' &&
                    msg.id.startsWith('optimistic-');
                  if (isOptimistic && msg.message?.role === 'human') {
                    const content =
                      typeof msg.message.content === 'string'
                        ? msg.message.content.trim()
                        : '';
                    if (content) {
                      optimisticContents.add(content);
                    }
                  }
                });

                return pendingDtos.filter((pendingMsg) => {
                  if (pendingMsg.role === 'human') {
                    const content = pendingMsg.content.trim();
                    return !optimisticContents.has(content);
                  }
                  return true;
                });
              },
              key,
            );
          });
        } else if (internalThreadId) {
          // If no pending messages, clear any existing pending entries for this node/thread
          const applyPendingToKeys = buildAgentMessageScopeKeys(data.nodeId);
          applyPendingToKeys.forEach((key) => {
            updatePendingMessages(targetThreadId, () => [], key);
          });
        }

        const reasoningChunks =
          data.data?.additionalNodeMetadata?.reasoningChunks;

        const applyUpdateToKeys = buildAgentMessageScopeKeys(data.nodeId);

        if (!reasoningChunks) {
          applyUpdateToKeys.forEach((key) => {
            updateMessages(
              targetThreadId,
              (prev) =>
                clearStreamingReasoningForContext(prev, {
                  targetThreadId: externalThreadIdForTarget,
                  selectedThreadId: targetThreadId,
                  runIds: targetRunIds,
                }),
              key,
            );
          });
          return;
        }

        const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
          eventThreadId,
          externalThreadIdForTarget,
          data.runId ?? metadataRunId,
        ]);
        const reasoningEntries = extractReasoningEntries(reasoningContainer, {
          threadId: externalThreadIdForTarget ?? eventThreadId,
          runId: data.runId ?? metadataRunId,
        });

        if (!reasoningEntries.length) {
          applyUpdateToKeys.forEach((key) => {
            updateMessages(
              targetThreadId,
              (prev) =>
                clearStreamingReasoningForContext(prev, {
                  targetThreadId: externalThreadIdForTarget,
                  selectedThreadId: targetThreadId,
                  runIds: targetRunIds,
                }),
              key,
            );
          });
          return;
        }

        applyUpdateToKeys.forEach((key) => {
          updateMessages(
            targetThreadId,
            (prev) =>
              upsertReasoningEntries(prev, reasoningEntries, {
                externalThreadId: externalThreadIdForTarget,
                runId: data.runId ?? metadataRunId,
                selectedThreadId: targetThreadId,
                nodeId: key,
              }),
            key,
          );
        });
      },

      'graph.revision.create': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        upsertRevision(data.data);
      },

      'graph.revision.applying': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);

        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'loading',
          content: `Applying revision ${revision.toVersion}`,
          duration: 0,
        });
      },

      'graph.revision.applied': async (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        GraphStorageService.clearPendingRevision(id);

        // Refetch the graph to get the updated data
        try {
          const res = await graphsApi.findGraphById(id);
          const updatedGraph = res.data;

          // Check if there are local unsaved changes
          const hasLocalChanges = draftStateRef.current.hasUnsavedChanges;

          if (hasLocalChanges) {
            // User has local changes - warn them that the server was updated
            message.warning({
              key: `graph-revision-${revision.id}`,
              content: `Revision ${revision.toVersion} applied.`,
              duration: 8,
            });
            // Update the graph metadata but don't override local changes
            setGraph(updatedGraph);

            // Fetch updated node states
            void fetchCompiledNodes({
              graphStatusOverride: updatedGraph.status,
              threadId: selectedThreadId,
            });
          } else {
            // No local changes - safely update everything
            const refreshedState = rebuildStateFromGraph(updatedGraph);

            // Clear any potential draft state
            draftStateRef.current.clearAllChanges();

            // Update server baseline and apply the new state
            setServerGraphState(refreshedState);
            draftStateRef.current.updateServerBaseline(refreshedState);

            // Force update the visual state immediately
            handleDraftStateChange(refreshedState);

            setGraph(updatedGraph);

            message.success({
              key: `graph-revision-${revision.id}`,
              content: `Revision ${revision.toVersion} applied`,
              duration: 3,
            });

            // Fetch updated node states
            void fetchCompiledNodes({
              graphStatusOverride: updatedGraph.status,
              threadId: selectedThreadId,
            });
          }
        } catch (error) {
          console.error(
            'Error refetching graph after revision applied:',
            error,
          );
          // Fallback: just update the version
          setGraph((prev) =>
            prev ? { ...prev, version: revision.toVersion } : prev,
          );
          message.open({
            key: `graph-revision-${revision.id}`,
            type: 'success',
            content: `Revision ${revision.toVersion} applied`,
            duration: 3,
          });
        }
      },

      'graph.revision.failed': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'error',
          content: revision.error
            ? `Revision ${revision.toVersion} failed: ${revision.error}`
            : `Revision ${revision.toVersion} failed`,
          duration: 5,
        });
      },
    },
  });

  useEffect(() => {
    if (!loading) {
      const t = requestAnimationFrame(() => {
        isHydratingRef.current = false;
      });
      return () => cancelAnimationFrame(t);
    }
  }, [loading]);

  useEffect(() => {
    // Keep selectedNode in sync with the latest node data from nodes array
    // This ensures NodeEditSidebar always sees the current draftGraph state
    if (selectedNode) {
      const updatedNode = nodes.find((n) => n.id === selectedNode.id);
      if (updatedNode && updatedNode !== selectedNode) {
        // Only update if the node actually changed (by reference)
        setSelectedNode(updatedNode);
      } else if (!updatedNode) {
        // Node was deleted, clear selection
        setSelectedNode(null);
        setNodeEditSidebarVisible(false);
      }
    }
  }, [nodes, selectedNode]);

  useEffect(
    () => () => {
      if (nodeChangeRafRef.current !== null) {
        cancelAnimationFrame(nodeChangeRafRef.current);
      }
      nodeChangeQueueRef.current = [];
    },
    [],
  );

  const handleValidationError = useCallback((error: string) => {
    message.error(`Connection validation failed: ${error}`);
  }, []);

  const handleTemplateClick = useCallback((template: TemplateDto) => {
    setSelectedTemplate(template);
    setTemplateModalVisible(true);
  }, []);

  // Stabilize callbacks to prevent nodeTypes recreation
  // Use refs for draft state access to avoid dependencies
  // (draftStateRef is already defined earlier in the component)

  const handleNodeAdd = useCallback((node: GraphNode) => {
    const newNodes = [...draftStateRef.current.draftState.nodes, node];
    draftStateRef.current.updateNodes(newNodes);
  }, []);

  const handleNodeEdit = useCallback((node: GraphNode) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(true);
  }, []);

  const handleNodeSelect = useCallback((node: GraphNode | null) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(!!node);
  }, []);

  const handleNodeSave = useCallback(
    (
      nodeId: string,
      updates: { name?: string; config?: Record<string, unknown> },
    ) => {
      // Use the draft state's updateNodeConfig method
      draftStateRef.current.updateNodeConfig(nodeId, updates);
    },
    [],
  );

  const handleNodeDelete = useCallback((nodeId: string) => {
    const newNodes = draftStateRef.current.draftState.nodes.filter(
      (node) => node.id !== nodeId,
    );
    const newEdges = draftStateRef.current.draftState.edges.filter(
      (edge) => edge.source !== nodeId && edge.target !== nodeId,
    );
    draftStateRef.current.updateNodes(newNodes);
    draftStateRef.current.updateEdges(newEdges);
  }, []);

  // Store nodes and edges in refs to avoid recreating callbacks
  const nodesRef = useRef<GraphNode[]>([]);
  const edgesRef = useRef<GraphEdge[]>([]);
  useEffect(() => {
    nodesRef.current = nodes;
  }, [nodes]);
  useEffect(() => {
    edgesRef.current = edges;
  }, [edges]);

  const handleTriggerClick = useCallback((nodeId: string) => {
    const node = nodesRef.current.find((n) => n.id === nodeId);
    if (!node) return;
    setTriggerNodeId(nodeId);
    setTriggerNodeName(node.data.label as string);
    setTriggerModalVisible(true);
  }, []);

  const handleThreadChange = useCallback(
    (newThreadId: string | undefined) => {
      draftStateRef.current.updateSelectedThread(newThreadId);
      void fetchCompiledNodes({ threadId: newThreadId });
    },
    [fetchCompiledNodes],
  );

  const handleThreadSelect = useCallback(
    (newThreadId: string | undefined) => {
      handleThreadChange(newThreadId);
      setThreadPopoverVisible(false);
    },
    [handleThreadChange],
  );

  const handleSave = async () => {
    if (!graph || !id) return;

    setSaving(true);
    try {
      // Defensive cleanup: ReactFlow may keep "dangling" edges in state even if they
      // are no longer renderable. The backend rejects edges pointing to missing nodes.
      const nodeIdSet = new Set(nodes.map((n) => n.id));
      const validEdges = edges.filter(
        (e) => nodeIdSet.has(e.source) && nodeIdSet.has(e.target),
      );
      if (validEdges.length !== edges.length) {
        setEdges(validEdges);
        draftStateRef.current.updateEdges(validEdges);
      }

      const connectionValidation = GraphValidationService.validateGraph(
        nodes,
        validEdges,
        templates,
      );
      if (!connectionValidation.isValid) {
        const first = connectionValidation.errors[0];
        message.error(first?.message ?? 'Invalid connections');
        return;
      }

      const configValidation =
        await GraphValidationService.validateAndNormalizeNodeConfigs(
          nodes,
          templates,
        );
      if (!configValidation.isValid) {
        const first = configValidation.errors[0];
        message.error(first?.message ?? 'Invalid node configuration');
        return;
      }

      const apiNodes: CreateGraphDtoSchemaNodesInner[] = nodes.map((node) => ({
        id: node.id,
        template: node.data.template as string,
        config: configValidation.normalizedConfigsByNodeId[node.id] ?? {},
      }));

      const apiEdges: CreateGraphDtoSchemaEdgesInner[] = validEdges.map(
        (edge) => ({
          from: edge.source,
          to: edge.target,
          label: typeof edge.label === 'string' ? edge.label : undefined,
        }),
      );

      const nodeMetadata: NodeMetadata[] = nodes.map((node) => ({
        id: node.id,
        x: node.position.x,
        y: node.position.y,
        name: node.data.label as string,
      }));

      const metadata: GraphMetadata = {
        ...((graph.metadata as GraphMetadata) || {}),
        nodes: nodeMetadata,
        x: viewport.x,
        y: viewport.y,
        zoom: viewport.zoom,
      };

      const response = await graphsApi.updateGraph(id, {
        name: draftStateRef.current.draftState.graphName ?? graph.name,
        description: graph.description || undefined,
        schema: {
          nodes: apiNodes,
          edges: apiEdges,
        },
        metadata: metadata || undefined,
        currentVersion: graph.version,
      });
      const updatedGraph = response.data.graph;
      const revision = response.data.revision;

      if (revision) {
        upsertRevision(revision);
      }

      // Update the graph metadata (version, status, etc)
      setGraph(updatedGraph);
      setEditingName(updatedGraph.name);

      // Check if revision is pending/applying (async apply)
      const revisionNeedsTime =
        revision &&
        (revision.status === GraphRevisionDtoStatusEnum.Pending ||
          revision.status === GraphRevisionDtoStatusEnum.Applying);

      if (revisionNeedsTime) {
        message.success(
          'Graph saved successfully. Revision is being applied...',
        );
      } else {
        message.success('Graph saved successfully');
      }

      if (revisionNeedsTime) {
        // Revision will be applied asynchronously
        // Keep current visual state (showing the changes we just saved)
        // Clear the unsaved draft since we've saved, but persist a snapshot
        // separately so reload still shows the latest changes while the backend
        // revision is pending/applying.
        GraphStorageService.clearDraft(id);
        const pendingToVersion =
          revision?.toVersion ?? updatedGraph.version ?? graph.version;
        if (pendingToVersion) {
          GraphStorageService.savePendingRevision(id, {
            nodes,
            edges,
            viewport,
            selectedThreadId,
            graphName: updatedGraph.name,
            baseVersion: pendingToVersion,
            toVersion: pendingToVersion,
            revisionId: revision?.id,
            savedAt: Date.now(),
          });
        }

        // Update the server baseline with the current state we're displaying
        // This represents what we JUST saved (even though server hasn't applied it yet)
        // Use the NEW version from the response so future drafts are based on this save
        const currentState: GraphDiffState = {
          nodes,
          edges,
          viewport,
          selectedThreadId,
          graphName: updatedGraph.name,
          baseVersion: updatedGraph.version,
        };
        setServerGraphState(currentState);
        // Update baseline WITHOUT triggering a draft save
        draftStateRef.current.updateServerBaseline(currentState);
      } else {
        // Revision applied immediately (or no revision needed)
        // Update visual state with the new graph data
        const refreshedState = rebuildStateFromGraph(updatedGraph);

        // Clear all local changes
        draftState.clearAllChanges();

        // Update server baseline and apply the new state
        setServerGraphState(refreshedState);
        draftStateRef.current.updateServerBaseline(refreshedState);

        // Force update the visual state immediately
        handleDraftStateChange(refreshedState);
      }

      userInteractedRef.current = false;
      // Signal NodeEditSidebar to reset its initialFormValues baseline
      setDraftNodeConfigVersion((prev) => prev + 1);
    } catch (e: unknown) {
      console.error('Error saving graph:', e);
      const errorMessage = extractApiErrorMessage(e, 'Failed to save graph');
      message.error(errorMessage);
    } finally {
      setSaving(false);
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const handleTriggerNode = useCallback(
    async (triggerMessage: string, targetThreadId?: string) => {
      if (!triggerNodeId || !id) return;

      try {
        setTriggerLoading(true);
        if (hasUnsavedChanges) {
          await handleSave();
        }

        const threadForExecution = threads.find((t) => t.id === targetThreadId);
        const parts = threadForExecution?.externalThreadId.split(':') || [];
        const finalThreadSubId = parts[parts.length - 1];

        const executeTriggerDto: ExecuteTriggerDto = {
          messages: [triggerMessage],
          async: true,
          ...(finalThreadSubId ? { threadSubId: finalThreadSubId } : {}),
        };

        const response = await graphsApi.executeTrigger(
          id,
          triggerNodeId,
          executeTriggerDto,
        );

        const returnedExternalThreadId = response.data?.externalThreadId;
        const currentExternalThreadId = threadForExecution?.externalThreadId;
        const shouldSelectNewThread =
          returnedExternalThreadId &&
          returnedExternalThreadId !== currentExternalThreadId;

        triggerStartedRef.current = Boolean(shouldSelectNewThread);
        pendingThreadSelectionRef.current = shouldSelectNewThread
          ? returnedExternalThreadId
          : null;

        message.success('Trigger sent successfully');
        setTriggerModalVisible(false);
        setTriggerNodeId(null);
        setTriggerNodeName(null);
      } catch (error) {
        triggerStartedRef.current = false;
        pendingThreadSelectionRef.current = null;
        console.error('Error triggering node:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to trigger node';
        message.error(errorMessage);
        throw error;
      } finally {
        if (!pendingThreadSelectionRef.current) {
          triggerStartedRef.current = false;
        }
        setTriggerLoading(false);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [triggerNodeId, id, threads, hasUnsavedChanges, handleSave],
  );

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        setDeletingThreadId(threadId);
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          handleThreadChange(undefined);
        }
        setThreadPopoverVisible(false);
        message.success('Thread deleted');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to delete thread';
        message.error(errorMessage);
      } finally {
        setDeletingThreadId(null);
      }
    },
    [handleThreadChange, selectedThreadId],
  );

  const handleStopThread = useCallback(async (threadId: string) => {
    try {
      setStoppingThreadId(threadId);
      const response = await threadsApi.stopThread(threadId);
      const stoppedThread = response.data;
      if (stoppedThread) {
        setThreads((prev) =>
          prev.map((t) => (t.id === stoppedThread.id ? stoppedThread : t)),
        );
      }
      message.success('Thread stop requested');
    } catch (error) {
      console.error('Error stopping thread:', error);
      message.error(
        extractApiErrorMessage(error, 'Failed to stop thread execution'),
      );
    } finally {
      setStoppingThreadId(null);
    }
  }, []);

  const handleNodesChange = useCallback(
    (changes: NodeChange[]) => {
      // If nodes are being removed, also prune any incident edges immediately
      // to guarantee "delete node => delete all its edges".
      const removedNodeIds = changes
        .filter(
          (c): c is Extract<NodeChange, { type: 'remove' }> =>
            c.type === 'remove',
        )
        .map((c) => ('id' in c ? (c.id as string) : ''))
        .filter(Boolean);

      if (removedNodeIds.length > 0) {
        // Compute the next snapshots immediately from refs to avoid races where
        // nodesRef/edgesRef haven't updated yet when we persist the draft.
        const nextNodesSnapshot = nodesRef.current.filter(
          (n) => !removedNodeIds.includes(n.id),
        );
        const nextEdgesSnapshot = edgesRef.current.filter(
          (e) =>
            !removedNodeIds.includes(e.source) &&
            !removedNodeIds.includes(e.target),
        );

        // Ensure the UI drops incident edges even if ReactFlow doesn't emit edge removals.
        setEdges(nextEdgesSnapshot);

        // Persist node+edge deletion into the draft as a ReactFlow-origin change,
        // and prevent syncing back into ReactFlow (it already reflects the deletion).
        if (
          !isHydratingRef.current &&
          userInteractedRef.current &&
          !isSyncingFromDraftRef.current
        ) {
          setTimeout(() => {
            if (isSyncingFromDraftRef.current) return;
            nextDraftChangeOriginRef.current = 'reactflow';
            draftStateRef.current.updateEdges(nextEdgesSnapshot);
            draftStateRef.current.updateNodes(nextNodesSnapshot);
          }, 0);
        }
      }

      const isDragging = changes.some(
        (change) =>
          change.type === 'position' &&
          (change as Extract<NodeChange, { type: 'position' }>).dragging,
      );

      const enqueueChanges = () => {
        nodeChangeQueueRef.current = [
          ...nodeChangeQueueRef.current,
          ...changes,
        ];
        if (nodeChangeRafRef.current === null) {
          nodeChangeRafRef.current = requestAnimationFrame(() => {
            const queue = nodeChangeQueueRef.current;
            nodeChangeQueueRef.current = [];
            nodeChangeRafRef.current = null;

            if (queue.length === 0) return;

            const mergedMap = new Map<string, NodeChange>();
            const getChangeKey = (change: NodeChange) => {
              const normalizedId =
                'id' in change && typeof change.id === 'string'
                  ? change.id
                  : 'na';
              if (change.type === 'dimensions') {
                const dimensionsChange = change as Extract<
                  NodeChange,
                  { type: 'dimensions' }
                >;
                return `${change.type}-${normalizedId}-${dimensionsChange.resizing ?? ''}`;
              }
              return `${change.type}-${normalizedId}`;
            };
            queue.forEach((change) => {
              const key = getChangeKey(change);
              mergedMap.set(key, change);
            });
            baseOnNodesChange(Array.from(mergedMap.values()));
          });
        }
      };

      enqueueChanges();

      if (isHydratingRef.current) return;
      if (!userInteractedRef.current) return;
      if (isDragging) return;
      if (isSyncingFromDraftRef.current) return; // Don't update draft if we're syncing FROM draft

      // Update draft state with the new nodes after changes are applied
      setTimeout(() => {
        if (!isSyncingFromDraftRef.current) {
          // For remove events we already persisted the correct snapshots above.
          if (removedNodeIds.length > 0) return;
          nextDraftChangeOriginRef.current = 'reactflow';
          draftStateRef.current.updateNodes(nodesRef.current);
        }
      }, 100);
    },
    [baseOnNodesChange],
  );

  const handleEdgesChange = useCallback(
    (changes: Parameters<typeof onEdgesChange>[0]) => {
      onEdgesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      if (isSyncingFromDraftRef.current) return; // Don't update draft if we're syncing FROM draft

      // Update draft state with the new edges after changes are applied
      setTimeout(() => {
        if (!isSyncingFromDraftRef.current) {
          nextDraftChangeOriginRef.current = 'reactflow';
          draftStateRef.current.updateEdges(edgesRef.current);
        }
      }, 100);
    },
    [onEdgesChange],
  );

  const handleNameEdit = () => {
    setEditingName(
      draftStateRef.current.draftState.graphName ?? (graph?.name || ''),
    );
    setIsEditingName(true);
  };

  const handleNameSave = async () => {
    if (!graph || !id) return;

    const nextName = editingName.trim();
    if (!nextName) {
      message.warning('Graph name cannot be empty');
      return;
    }

    // Local-only: treat name change as an unsaved draft change.
    draftStateRef.current.updateGraphName(nextName);
    setGraph((prev) => (prev ? { ...prev, name: nextName } : prev));
    setEditingName(nextName);
    setIsEditingName(false);
  };

  const handleNameCancel = () => {
    setEditingName(
      draftStateRef.current.draftState.graphName ?? (graph?.name || ''),
    );
    setIsEditingName(false);
  };

  const handleGraphAction = async () => {
    if (!graph || !id) return;
    if (graph.status === GraphDtoStatusEnum.Compiling) {
      return;
    }

    try {
      setActionLoading(true);
      setGraphError(null);

      if (graph.status === GraphDtoStatusEnum.Running) {
        await graphsApi.destroyGraph(id);
        message.success('Graph stopped successfully');
        const response = await graphsApi.findGraphById(id);
        setGraph(response.data);
        void fetchCompiledNodes({
          graphStatusOverride: response.data.status,
          threadId: selectedThreadId,
        });
      } else {
        const response = await graphsApi.runGraph(id);
        const updatedGraph = response.data;
        setGraph(updatedGraph);
        void fetchCompiledNodes({
          graphStatusOverride: updatedGraph.status,
          threadId: selectedThreadId,
        });

        if (updatedGraph.status === GraphDtoStatusEnum.Error) {
          const executionErrorMessage =
            (updatedGraph as GraphDto & { error?: string }).error ||
            'Graph execution failed';
          message.error(executionErrorMessage);
          setGraphError(executionErrorMessage);
        } else {
          message.success('Graph started successfully');
        }
      }
    } catch (error) {
      console.error('Error with graph action:', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to perform graph action',
      );
      message.error(errorMessage);
      setGraphError(errorMessage);
    } finally {
      setActionLoading(false);
    }
  };

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Layout style={{ overflow: 'hidden' }}>
      <Header
        style={{
          background: '#fff',
          padding: '0 24px',
          borderBottom: '1px solid #f0f0f0',
          flexShrink: 0,
          height: 70,
        }}>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            gap: 24,
            height: '100%',
          }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              flexWrap: 'wrap',
            }}>
            {isEditingName ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Input
                  value={editingName}
                  onChange={(e) => setEditingName(e.target.value)}
                  onPressEnter={handleNameSave}
                  onBlur={handleNameSave}
                  autoFocus
                  style={{ width: 300 }}
                />
                <Button
                  type="text"
                  icon={<CheckOutlined />}
                  onClick={handleNameSave}
                  size="small"
                />
                <Button
                  type="text"
                  icon={<CloseOutlined />}
                  onClick={handleNameCancel}
                  size="small"
                />
              </div>
            ) : (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Title level={4} style={{ margin: 0 }}>
                  {draftState.draftState.graphName ||
                    graph?.name ||
                    'Graph Editor'}
                </Title>
                <Button
                  type="text"
                  icon={<EditOutlined />}
                  onClick={handleNameEdit}
                  size="small"
                />
              </div>
            )}
            {graph && (
              <div style={{ marginLeft: 16 }}>
                <Popover
                  open={revisionPopoverVisible}
                  onOpenChange={(open) => {
                    setRevisionPopoverVisible(open);
                    if (open) {
                      void loadRevisions();
                    }
                  }}
                  trigger="click"
                  placement="bottomLeft"
                  content={revisionPopoverContent}>
                  <Button
                    type="text"
                    size="small"
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: 6,
                      padding: '4px 8px',
                      height: 'auto',
                      borderRadius: 6,
                      backgroundColor: revisionPopoverVisible
                        ? '#f5f5f5'
                        : 'transparent',
                    }}>
                    <Typography.Text style={{ fontSize: 12, color: '#595959' }}>
                      Version {displayedVersion}
                    </Typography.Text>
                    {displayedRevisionMeta && (
                      <Tag
                        color={displayedRevisionMeta.color}
                        style={{
                          margin: 0,
                          borderRadius: 999,
                          fontSize: 11,
                          lineHeight: '18px',
                          padding: '0 8px',
                          boxShadow: displayedRevisionMeta.pulse
                            ? '0 0 0 0 rgba(250, 173, 20, 0.45)'
                            : 'none',
                          animation: displayedRevisionMeta.pulse
                            ? 'revision-status-pulse 1.5s ease-out infinite'
                            : undefined,
                        }}>
                        {displayedRevisionMeta.label}
                      </Tag>
                    )}
                    <DownOutlined style={{ fontSize: 10, color: '#8c8c8c' }} />
                  </Button>
                </Popover>
              </div>
            )}
            <Tooltip
              title="Download current graph as JSON backup"
              placement="bottom">
              <Button
                type="text"
                size="small"
                icon={<DownloadOutlined />}
                onClick={handleDownloadGraphBackup}
                aria-label="Download graph JSON backup"
                disabled={!graph}
                style={{ padding: '4px 8px', color: 'gray' }}
              />
            </Tooltip>
          </div>

          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                }}>
                <Popover
                  open={threadPopoverVisible}
                  placement="bottomLeft"
                  content={
                    <div
                      style={{
                        maxHeight: 300,
                        overflowY: 'auto',
                        minWidth: 320,
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        gap: 4,
                      }}>
                      <Button
                        key="__new_thread__"
                        type="text"
                        style={{
                          textAlign: 'left',
                          padding: '8px 12px',
                          height: 'auto',
                          lineHeight: 1.2,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'flex-start',
                          border: '1px solid #f0f0f0',
                          borderRadius: 6,
                          width: '100%',
                        }}
                        onClick={() => handleThreadSelect(undefined)}>
                        <Typography.Text
                          strong
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          + New thread
                        </Typography.Text>
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          Clear current selection
                        </Typography.Text>
                      </Button>

                      {threadsLoading ? (
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px' }}>
                          Loading threads...
                        </Typography.Text>
                      ) : threads.length === 0 ? (
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px' }}>
                          No threads available
                        </Typography.Text>
                      ) : (
                        threads.map((thread) => {
                          const statusMeta = getThreadStatusDisplay(
                            thread.status,
                          );
                          const isThreadRunning =
                            thread.status === ThreadDtoStatusEnum.Running;
                          return (
                            <div
                              key={thread.id}
                              style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8,
                                width: '100%',
                                border: '1px solid #f0f0f0',
                                borderRadius: 6,
                                padding: '4px 4px',
                              }}>
                              <Button
                                type="text"
                                style={{
                                  textAlign: 'left',
                                  padding: '8px 12px',
                                  height: 'auto',
                                  lineHeight: 1.2,
                                  display: 'flex',
                                  flexDirection: 'column',
                                  alignItems: 'flex-start',
                                  border: 'none',
                                  boxShadow: 'none',
                                  flex: 1,
                                  gap: 0,
                                }}
                                onClick={() => handleThreadSelect(thread.id)}>
                                <div
                                  style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 8,
                                    width: '100%',
                                    justifyContent: 'space-between',
                                  }}>
                                  <div
                                    style={{
                                      display: 'flex',
                                      alignItems: 'center',
                                      gap: 8,
                                      minWidth: 0,
                                    }}>
                                    <Typography.Text
                                      strong
                                      style={{
                                        fontSize: '12px',
                                        lineHeight: 1.2,
                                        maxWidth: '400px',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                      }}>
                                      {thread.name || thread.id}
                                    </Typography.Text>
                                    <Popconfirm
                                      title="Delete thread"
                                      description="Are you sure you want to delete this thread?"
                                      okText="Delete"
                                      okButtonProps={{
                                        danger: true,
                                        loading: deletingThreadId === thread.id,
                                      }}
                                      cancelText="Cancel"
                                      disabled={deletingThreadId === thread.id}
                                      onConfirm={(e) => {
                                        e?.stopPropagation?.();
                                        handleDeleteThread(thread.id);
                                      }}>
                                      <span
                                        role="button"
                                        aria-label={`Delete thread ${thread.name || thread.id}`}
                                        tabIndex={0}
                                        style={{
                                          display: 'inline-flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          width: 24,
                                          height: 24,
                                          borderRadius: '50%',
                                          color: '#ff4d4f',
                                          backgroundColor: 'transparent',
                                          transition: 'background-color 0.2s',
                                          cursor: 'pointer',
                                        }}
                                        onClick={(e) => {
                                          e.stopPropagation();
                                        }}
                                        onKeyDown={(e) => {
                                          if (
                                            e.key === 'Enter' ||
                                            e.key === ' '
                                          ) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            (
                                              e.currentTarget as HTMLElement
                                            ).click();
                                          }
                                        }}
                                        onMouseEnter={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'rgba(255, 77, 79, 0.08)';
                                        }}
                                        onMouseLeave={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'transparent';
                                        }}>
                                        {deletingThreadId === thread.id ? (
                                          <LoadingOutlined
                                            style={{ fontSize: 12 }}
                                            spin
                                          />
                                        ) : (
                                          <DeleteOutlined />
                                        )}
                                      </span>
                                    </Popconfirm>
                                  </div>
                                  {statusMeta && (
                                    <Tag
                                      color={statusMeta.color}
                                      style={{
                                        margin: 0,
                                        borderRadius: 999,
                                        fontSize: '11px',
                                        lineHeight: '18px',
                                        padding: '0 8px',
                                        boxShadow: isThreadRunning
                                          ? '0 0 0 0 rgba(24, 144, 255, 0.45)'
                                          : 'none',
                                        animation: isThreadRunning
                                          ? 'thread-status-pulse 1.5s ease-out infinite'
                                          : undefined,
                                      }}>
                                      {statusMeta.label}
                                    </Tag>
                                  )}
                                </div>
                                <Typography.Text
                                  type="secondary"
                                  style={{ fontSize: '12px', lineHeight: 1.2 }}>
                                  {new Date(thread.createdAt).toLocaleString()}
                                </Typography.Text>
                                {thread.source ? (
                                  <Typography.Text
                                    type="secondary"
                                    style={{
                                      fontSize: '12px',
                                      lineHeight: 1.2,
                                      marginTop: '10px',
                                    }}>
                                    Source: {thread.source}
                                  </Typography.Text>
                                ) : null}
                              </Button>
                            </div>
                          );
                        })
                      )}
                    </div>
                  }
                  trigger="click"
                  onOpenChange={setThreadPopoverVisible}>
                  <div
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start',
                      cursor: 'pointer',
                      padding: '4px 8px',
                      borderRadius: '4px',
                      transition: 'background-color 0.2s',
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f5f5f5';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    {(() => {
                      const t = threads.find(
                        (thr) => thr.id === selectedThreadId,
                      );
                      const source = t?.source;
                      const label = (
                        <Typography.Text
                          strong
                          style={{ fontSize: '14px', lineHeight: 1 }}>
                          Thread
                        </Typography.Text>
                      );
                      return source ? (
                        <Tooltip title={`Source: ${source}`}>{label}</Tooltip>
                      ) : (
                        label
                      );
                    })()}
                    {selectedThreadId ? (
                      (() => {
                        const t = threads.find(
                          (thr) => thr.id === selectedThreadId,
                        );
                        const statusMeta = getThreadStatusDisplay(t?.status);
                        return (
                          <>
                            <div
                              style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: 6,
                                flexWrap: 'wrap',
                              }}>
                              <div
                                style={{
                                  display: 'flex',
                                  alignItems: 'center',
                                  gap: 6,
                                }}>
                                <Typography.Text
                                  style={{
                                    fontSize: '12px',
                                    lineHeight: 1.2,
                                    maxWidth: '400px',
                                    whiteSpace: 'nowrap',
                                    overflow: 'hidden',
                                    textOverflow: 'ellipsis',
                                  }}>
                                  {t?.name || selectedThreadId}
                                </Typography.Text>
                                {selectedThreadId && (
                                  <>
                                    {t?.status ===
                                      ThreadDtoStatusEnum.Running && (
                                      <Tooltip title="Stop thread execution">
                                        <span
                                          role="button"
                                          aria-label="Stop current thread"
                                          tabIndex={0}
                                          style={{
                                            display: 'inline-flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            width: 24,
                                            height: 24,
                                            borderRadius: '50%',
                                            color: '#ff4242',
                                            backgroundColor: 'transparent',
                                            transition: 'background-color 0.2s',
                                            cursor:
                                              stoppingThreadId ===
                                              selectedThreadId
                                                ? 'default'
                                                : 'pointer',
                                            marginLeft: 4,
                                            opacity:
                                              stoppingThreadId ===
                                              selectedThreadId
                                                ? 0.7
                                                : 1,
                                          }}
                                          onClick={(e) => {
                                            e.stopPropagation();
                                            if (
                                              stoppingThreadId ===
                                              selectedThreadId
                                            ) {
                                              return;
                                            }
                                            handleStopThread(selectedThreadId);
                                          }}
                                          onKeyDown={(e) => {
                                            if (
                                              e.key === 'Enter' ||
                                              e.key === ' '
                                            ) {
                                              e.preventDefault();
                                              e.stopPropagation();
                                              if (
                                                stoppingThreadId ===
                                                selectedThreadId
                                              ) {
                                                return;
                                              }
                                              handleStopThread(
                                                selectedThreadId,
                                              );
                                            }
                                          }}
                                          onMouseEnter={(e) => {
                                            if (
                                              stoppingThreadId ===
                                              selectedThreadId
                                            ) {
                                              return;
                                            }
                                            e.currentTarget.style.backgroundColor =
                                              'rgba(255, 66, 66, 0.08)';
                                          }}
                                          onMouseLeave={(e) => {
                                            e.currentTarget.style.backgroundColor =
                                              'transparent';
                                          }}>
                                          {stoppingThreadId ===
                                          selectedThreadId ? (
                                            <LoadingOutlined
                                              style={{ fontSize: 12 }}
                                              spin
                                            />
                                          ) : (
                                            <XFilled />
                                          )}
                                        </span>
                                      </Tooltip>
                                    )}
                                    <Tooltip title="Open chat for thread">
                                      <span
                                        role="button"
                                        aria-label="Open chat for current thread"
                                        tabIndex={0}
                                        style={{
                                          display: 'inline-flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          width: 24,
                                          height: 24,
                                          borderRadius: '50%',
                                          color: '#1677ff',
                                          backgroundColor: 'transparent',
                                          transition: 'background-color 0.2s',
                                          cursor: 'pointer',
                                          marginLeft: 4,
                                        }}
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          handleOpenThreadChat(
                                            selectedThreadId,
                                          );
                                        }}
                                        onKeyDown={(e) => {
                                          if (
                                            e.key === 'Enter' ||
                                            e.key === ' '
                                          ) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            handleOpenThreadChat(
                                              selectedThreadId,
                                            );
                                          }
                                        }}
                                        onMouseEnter={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'rgba(22, 119, 255, 0.08)';
                                        }}
                                        onMouseLeave={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'transparent';
                                        }}>
                                        <MessageOutlined />
                                      </span>
                                    </Tooltip>
                                    <Popconfirm
                                      title="Delete thread"
                                      description="Are you sure you want to delete the selected thread?"
                                      okText="Delete"
                                      okButtonProps={{
                                        danger: true,
                                        loading:
                                          deletingThreadId === selectedThreadId,
                                      }}
                                      cancelText="Cancel"
                                      disabled={
                                        deletingThreadId === selectedThreadId
                                      }
                                      onConfirm={(e) => {
                                        e?.stopPropagation?.();
                                        handleDeleteThread(selectedThreadId);
                                      }}>
                                      <span
                                        role="button"
                                        aria-label="Delete current thread"
                                        tabIndex={0}
                                        style={{
                                          display: 'inline-flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          width: 24,
                                          height: 24,
                                          borderRadius: '50%',
                                          color: '#ff4d4f',
                                          backgroundColor: 'transparent',
                                          transition: 'background-color 0.2s',
                                          cursor: 'pointer',
                                        }}
                                        onClick={(e) => {
                                          e.stopPropagation();
                                        }}
                                        onKeyDown={(e) => {
                                          if (
                                            e.key === 'Enter' ||
                                            e.key === ' '
                                          ) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            (
                                              e.currentTarget as HTMLElement
                                            ).click();
                                          }
                                        }}
                                        onMouseEnter={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'rgba(255, 77, 79, 0.08)';
                                        }}
                                        onMouseLeave={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'transparent';
                                        }}>
                                        {deletingThreadId ===
                                        selectedThreadId ? (
                                          <LoadingOutlined
                                            style={{ fontSize: 12 }}
                                            spin
                                          />
                                        ) : (
                                          <DeleteOutlined />
                                        )}
                                      </span>
                                    </Popconfirm>
                                  </>
                                )}
                              </div>
                              {statusMeta && (
                                <Tag
                                  color={statusMeta.color}
                                  style={{
                                    margin: 0,
                                    borderRadius: 999,
                                    fontSize: '11px',
                                    lineHeight: '18px',
                                    padding: '0 8px',
                                    boxShadow:
                                      t?.status === ThreadDtoStatusEnum.Running
                                        ? '0 0 0 0 rgba(24, 144, 255, 0.45)'
                                        : 'none',
                                    animation:
                                      t?.status === ThreadDtoStatusEnum.Running
                                        ? 'thread-status-pulse 1.5s ease-out infinite'
                                        : undefined,
                                  }}>
                                  {statusMeta.label}
                                </Tag>
                              )}
                            </div>
                            <Typography.Text
                              type="secondary"
                              style={{ fontSize: '12px', lineHeight: 1.2 }}>
                              {t
                                ? `${new Date(t.createdAt).toLocaleString()} | ${t.source || 'unknown source'}`
                                : ''}
                            </Typography.Text>
                          </>
                        );
                      })()
                    ) : (
                      <>
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          No active thread.
                        </Typography.Text>
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          It will be created automatically after first
                          execution.
                        </Typography.Text>
                      </>
                    )}
                  </div>
                </Popover>
              </div>
            </div>

            {(graph?.error || graphError) && (
              <Popover
                content={
                  <div style={{ maxWidth: 500 }}>
                    <div style={{ fontWeight: 'bold', marginBottom: 8 }}>
                      Graph Error:
                    </div>
                    <div>{graph?.error || graphError}</div>
                  </div>
                }
                title="Error Details"
                trigger="hover"
                color="#ffd7d9"
                placement="bottomRight">
                <ExclamationCircleOutlined
                  style={{
                    color: '#ff4d4f',
                    fontSize: 16,
                    cursor: 'pointer',
                  }}
                />
              </Popover>
            )}
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: 0,
              }}>
              {graph && (
                <Tooltip title="Open chats" placement="bottom">
                  <span
                    role="button"
                    aria-label="Open chats for this graph"
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 8,
                      color: '#cbcbcb',
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor: 'pointer',
                      transition: 'background-color 0.2s',
                    }}
                    onClick={() => navigate(`/chats?graphId=${graph.id}`)}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f0f0f0';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    <MessageFilled style={{ fontSize: 20 }} />
                  </span>
                </Tooltip>
              )}
              <Tooltip
                title={
                  isRevisionApplying
                    ? 'Applying revision...'
                    : hasStructuralChanges
                      ? 'Save (unsaved changes)'
                      : 'Save'
                }
                placement="bottom">
                <Popover
                  content={unsavedChangesPopoverContent}
                  title="Unsaved Changes"
                  open={hasStructuralChanges ? undefined : false}
                  trigger="hover">
                  <span
                    role="button"
                    aria-label="Save graph"
                    aria-disabled={saving || isRevisionApplying}
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 8,
                      color: hasStructuralChanges ? '#ffd421' : '#3085e0',
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor:
                        saving || isRevisionApplying ? 'progress' : 'pointer',
                      transition: 'background-color 0.2s',
                    }}
                    onClick={() => {
                      if (!saving && !isRevisionApplying) {
                        handleSave();
                      }
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f0f0f0';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    {saving || isRevisionApplying ? (
                      <LoadingOutlined style={{ fontSize: 20 }} spin />
                    ) : (
                      <SaveFilled style={{ fontSize: 20 }} />
                    )}
                  </span>
                </Popover>
              </Tooltip>
              {graph && (
                <Tooltip
                  title={
                    isGraphRunning
                      ? 'Stop graph'
                      : isGraphCompiling
                        ? 'Compiling...'
                        : 'Run graph'
                  }
                  placement="bottom">
                  <span
                    role="button"
                    aria-label={
                      isGraphRunning ? 'Stop graph' : 'Start graph execution'
                    }
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 8,
                      color: isGraphRunning ? '#ff4242' : '#52c41a',
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor:
                        actionLoading || isGraphCompiling
                          ? 'progress'
                          : 'pointer',
                      transition: 'background-color 0.2s',
                    }}
                    onClick={() => {
                      if (!actionLoading && !isGraphCompiling) {
                        handleGraphAction();
                      }
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f0f0f0';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    {actionLoading || isGraphCompiling ? (
                      <LoadingOutlined style={{ fontSize: 20 }} spin />
                    ) : isGraphRunning ? (
                      <XFilled style={{ fontSize: 20 }} />
                    ) : (
                      <PlayCircleFilled style={{ fontSize: 20 }} />
                    )}
                  </span>
                </Tooltip>
              )}
            </div>
          </div>
        </div>
      </Header>

      <Layout
        style={{
          height: 'calc(100vh - 135px)',
          overflow: 'hidden',
          position: 'relative',
        }}>
        {leftSidebarCollapsed && (
          <Button
            type="default"
            shape="circle"
            icon={<RightOutlined />}
            aria-label="Expand template sidebar"
            onClick={() => setLeftSidebarCollapsed(false)}
            style={{
              position: 'absolute',
              top: 16,
              left: 16,
              zIndex: 100,
              width: 36,
              height: 36,
              minWidth: 36,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              border: '1px solid #d9d9d9',
              background: '#fff',
            }}
          />
        )}
        <Sider
          width={280}
          collapsible={true}
          defaultCollapsed={false}
          collapsed={leftSidebarCollapsed}
          collapsedWidth={0}
          trigger={null}
          style={{
            background: '#fff',
            borderRight: '1px solid #f0f0f0',
            overflow: 'auto',
            height: '100%',
          }}>
          <TemplateSidebar
            onTemplateClick={handleTemplateClick}
            onClose={() => setLeftSidebarCollapsed(true)}
            templates={templates}
            selectedNode={selectedNode ?? undefined}
            allNodes={nodes}
          />
        </Sider>

        <Content
          style={{
            background: '#f5f5f5',
            height: '100%',
            overflow: 'hidden',
            minHeight: '500px',
          }}>
          <div
            style={{ height: '100%' }}
            onPointerDown={() => {
              userInteractedRef.current = true;
            }}
            onWheel={() => {
              userInteractedRef.current = true;
            }}>
            <GraphCanvas
              nodes={nodes}
              edges={edges}
              onNodesChange={handleNodesChange}
              onEdgesChange={handleEdgesChange}
              onNodeAdd={handleNodeAdd}
              onNodeEdit={handleNodeEdit}
              onNodeDelete={handleNodeDelete}
              onNodeSelect={handleNodeSelect}
              onViewportChange={handleViewportPersistChange}
              initialViewport={viewport}
              templates={templates}
              graphStatus={graph?.status}
              onTriggerClick={handleTriggerClick}
              onValidationError={handleValidationError}
              compiledNodes={compiledNodesMap}
              compiledNodesLoading={compiledNodesLoading}
            />
          </div>
        </Content>

        <NodeEditSidebar
          node={selectedNode}
          visible={nodeEditSidebarVisible}
          onClose={() => setNodeEditSidebarVisible(false)}
          onNodeDraftChange={handleNodeSave}
          templates={templates}
          graphStatus={graph?.status}
          hasGlobalUnsavedChanges={hasUnsavedChanges}
          hasNodeUnsavedChangesFromServer={selectedNodeUnsavedFromServer}
          onTriggerClick={handleTriggerClick}
          selectedThreadId={selectedThreadId}
          selectedThreadStatus={
            threads.find((t) => t.id === selectedThreadId)?.status
          }
          selectedThreadLastRunId={
            threads.find((t) => t.id === selectedThreadId)?.lastRunId
          }
          compiledNode={
            selectedNode ? compiledNodesMap[selectedNode.id] : undefined
          }
          compiledNodesLoading={compiledNodesLoading}
          nodeDisplayNames={nodeDisplayNames}
          messages={
            selectedThreadId && selectedNode?.id
              ? messages[selectedThreadId]?.[selectedNode.id] || []
              : selectedThreadId
                ? messages[selectedThreadId]?.['all'] || []
                : []
          }
          messagesLoading={
            selectedThreadId
              ? getMessageMeta(selectedThreadId, selectedNode?.id).loading
              : false
          }
          hasMoreMessages={
            selectedThreadId
              ? getMessageMeta(selectedThreadId, selectedNode?.id).hasMore
              : false
          }
          loadingMoreMessages={
            selectedThreadId
              ? getMessageMeta(selectedThreadId, selectedNode?.id).loadingMore
              : false
          }
          pendingMessages={
            selectedThreadId && selectedNode?.id
              ? pendingMessages[selectedThreadId]?.[selectedNode.id] || []
              : selectedThreadId
                ? pendingMessages[selectedThreadId]?.['all'] || []
                : []
          }
          graphId={id}
          onLoadMoreMessages={
            selectedThreadId
              ? isDraftThreadId(selectedThreadId)
                ? undefined
                : () =>
                    loadMoreMessagesForScope(selectedThreadId, selectedNode?.id)
              : undefined
          }
          draftNodeConfigVersion={draftNodeConfigVersion}
        />
      </Layout>

      <TemplateModal
        template={selectedTemplate}
        visible={templateModalVisible}
        onClose={() => setTemplateModalVisible(false)}
        allTemplates={templates}
      />

      <TriggerModal
        visible={triggerModalVisible}
        onCancel={() => {
          setTriggerModalVisible(false);
          setTriggerNodeId(null);
          setTriggerNodeName(null);
          triggerStartedRef.current = false;
          pendingThreadSelectionRef.current = null;
        }}
        onTrigger={handleTriggerNode}
        nodeId={triggerNodeId || undefined}
        nodeName={triggerNodeName || undefined}
        loading={triggerLoading}
        selectedThreadId={selectedThreadId}
        selectedThreadName={
          threads.find((t) => t.id === selectedThreadId)?.name ?? null
        }
        selectedThreadSource={
          threads.find((t) => t.id === selectedThreadId)?.source ?? null
        }
      />

      <Modal
        open={Boolean(chatThread && graph)}
        onCancel={handleCloseThreadChat}
        footer={null}
        width={900}
        bodyStyle={{
          height: '70vh',
          display: 'flex',
          flexDirection: 'column',
        }}
        title={
          chatThread ? (
            <Typography.Text
              ellipsis={{
                tooltip: `Thread chat â€” ${
                  chatThread.name || chatThread.id.slice(-6)
                }`,
              }}
              style={{
                display: 'inline-block',
                maxWidth: 'calc(100% - 64px)',
              }}>
              {`Thread chat â€” ${chatThread.name || chatThread.id.slice(-6)}`}
            </Typography.Text>
          ) : undefined
        }
        destroyOnClose>
        {chatThread && graph ? (
          <ThreadChatPanel
            graphId={graph.id}
            thread={chatThread}
            triggerNodes={triggerNodesForGraph}
            nodeDisplayNames={nodeDisplayNames}
            graphLoaded
            newMessageMode={defaultNewMessageMode}
            messages={messages[chatThread.id]?.['all'] || []}
            messagesLoading={getMessageMeta(chatThread.id, undefined).loading}
            hasMoreMessages={getMessageMeta(chatThread.id, undefined).hasMore}
            loadingMoreMessages={
              getMessageMeta(chatThread.id, undefined).loadingMore
            }
            pendingMessages={pendingMessages[chatThread.id]?.['all'] || []}
            externalThreadId={externalThreadIds[chatThread.id]}
            onLoadMoreMessages={() =>
              loadMoreMessagesForScope(chatThread.id, undefined)
            }
            onUpdateSharedMessages={updateMessages}
          />
        ) : null}
      </Modal>

      <Modal
        open={revisionDiffModalVisible}
        onCancel={handleCloseRevisionDiff}
        footer={null}
        title={
          revisionDiffRevision
            ? `Revision v${revisionDiffRevision.toVersion} diff`
            : 'Revision diff'
        }
        width={640}
        destroyOnClose>
        {revisionDiffRevision ? (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            {revisionDiffRevision.configDiff.length === 0 ? (
              <Typography.Text type="secondary">
                No configuration changes.
              </Typography.Text>
            ) : (
              revisionDiffRevision.configDiff.map((operation, index) => {
                const meta = REVISION_DIFF_OP_META[operation.op] ?? {
                  label: operation.op,
                  color: '#d9d9d9',
                };
                const key = `${operation.op}-${operation.path}-${index}`;
                const value =
                  (operation as { value?: unknown }).value ?? undefined;
                const fromPath =
                  (operation as { from?: string }).from ?? undefined;
                return (
                  <div
                    key={key}
                    style={{
                      border: '1px solid #f0f0f0',
                      borderLeft: `4px solid ${meta.color}`,
                      borderRadius: 6,
                      padding: '12px 14px',
                      background: '#fafafa',
                    }}>
                    <Space
                      direction="vertical"
                      size={6}
                      style={{ width: '100%' }}>
                      <Space
                        align="center"
                        wrap
                        style={{ justifyContent: 'space-between' }}>
                        <Tag
                          color={meta.color}
                          style={{
                            margin: 0,
                            fontSize: 11,
                            padding: '0 10px',
                          }}>
                          {meta.label}
                        </Tag>
                        <Typography.Text code style={{ fontSize: 12 }}>
                          {operation.path || '(root)'}
                        </Typography.Text>
                      </Space>
                      {fromPath ? (
                        <Typography.Text style={{ fontSize: 12 }}>
                          From{' '}
                          <Typography.Text code>{fromPath}</Typography.Text>
                        </Typography.Text>
                      ) : null}
                      {value !== undefined
                        ? formatRevisionDiffValue(value)
                        : null}
                    </Space>
                  </div>
                );
              })
            )}
            {revisionDiffRevision.error && (
              <Typography.Text type="danger">
                Error: {revisionDiffRevision.error}
              </Typography.Text>
            )}
          </Space>
        ) : null}
      </Modal>
    </Layout>
  );
};
