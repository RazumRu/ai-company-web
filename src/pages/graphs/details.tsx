/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate, useParams } from 'react-router';
import {
  Button,
  Input,
  Layout,
  message,
  Modal,
  Popconfirm,
  Popover,
  Space,
  Spin,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  CheckOutlined,
  CloseOutlined,
  DeleteOutlined,
  DownOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  LoadingOutlined,
  MessageFilled,
  MessageOutlined,
  PlayCircleFilled,
  RightOutlined,
  SaveFilled,
  XFilled,
} from '@ant-design/icons';
import {
  NodeChange,
  useEdgesState,
  useNodesState,
  Viewport,
} from '@xyflow/react';
import { isAxiosError } from 'axios';
import {
  graphRevisionsApi,
  graphsApi,
  templatesApi,
  threadsApi,
} from '../../api';
import { useWebSocket } from '../../hooks/useWebSocket';
import type {
  AgentMessageNotification,
  GraphNodeUpdateNotification,
  GraphRevisionNotification,
  GraphUpdateNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import type {
  PendingMessage,
  MessagesState,
  PendingMessagesState,
  MessageScopeKey,
} from './types/messages';
import {
  CreateGraphDtoSchemaEdgesInner,
  CreateGraphDtoSchemaNodesInner,
  ExecuteTriggerDto,
  GraphDto,
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  GraphRevisionDto,
  GraphRevisionDtoStatusEnum,
  TemplateDto,
  ThreadDto,
  ThreadDtoStatusEnum,
  ThreadMessageDto,
} from '../../autogenerated';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import {
  mergeMessagesReplacingStreaming,
  extractReasoningEntries,
  narrowReasoningContainer,
  removeStreamingReasoningMessages,
  buildIdSet,
  getMessageRunId,
  STREAMING_REASONING_FLAG,
  type ReasoningChunkEntry,
  sortMessagesChronologically,
} from '../../utils/threadMessages';
import { TemplateSidebar } from './components/TemplateSidebar';
import { TemplateModal } from './components/TemplateModal';
import { NodeEditSidebar } from './components/NodeEditSidebar';
import { TriggerModal } from './components/TriggerModal';
import ThreadChatPanel from '../chats/components/ThreadChatPanel';
import {
  createEdge,
  GraphCanvas,
  resolveHandlesForNodes,
} from './components/GraphCanvas';
import { GraphStorageService } from '../../services/GraphStorageService';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
} from '../../utils/graphThreads';
import type {
  GraphEdge,
  GraphMetadata,
  GraphNode,
  GraphNodeData,
  NodeMetadata,
  SchemaProperty,
} from './types';

const { Header, Sider, Content } = Layout;
const { Title } = Typography;

const REVISION_FETCH_LIMIT = 50;
const MESSAGE_PAGE_SIZE = 50;

const ensureThreadStatusPulseStyle = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('thread-status-pulse-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'thread-status-pulse-style';
    style.textContent = `
      @keyframes thread-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(24, 144, 255, 0.45); }
        70% { box-shadow: 0 0 0 8px rgba(24, 144, 255, 0); }
        100% { box-shadow: 0 0 0 0 rgba(24, 144, 255, 0); }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const REVISION_STATUS_STYLES: Record<
  GraphRevisionDtoStatusEnum,
  { label: string; color: string; pulse?: boolean }
> = {
  [GraphRevisionDtoStatusEnum.Pending]: {
    label: 'Pending',
    color: '#d9d9d9',
  },
  [GraphRevisionDtoStatusEnum.Applying]: {
    label: 'Applying',
    color: '#faad14',
    pulse: true,
  },
  [GraphRevisionDtoStatusEnum.Applied]: {
    label: 'Applied',
    color: '#52c41a',
  },
  [GraphRevisionDtoStatusEnum.Failed]: {
    label: 'Failed',
    color: '#ff4d4f',
  },
} as const;

const REVISION_DIFF_OP_META: Record<string, { label: string; color: string }> =
  {
    add: { label: 'Add', color: '#52c41a' },
    remove: { label: 'Remove', color: '#ff4d4f' },
    replace: { label: 'Replace', color: '#1890ff' },
    move: { label: 'Move', color: '#722ed1' },
    copy: { label: 'Copy', color: '#13c2c2' },
    test: { label: 'Test', color: '#595959' },
  };

type MessageMeta = {
  loading: boolean;
  loadingMore: boolean;
  hasMore: boolean;
  offset: number;
};

type MessageMetaState = Record<string, Record<MessageScopeKey, MessageMeta>>;

const createDefaultMessageMeta = (): MessageMeta => ({
  loading: false,
  loadingMore: false,
  hasMore: true,
  offset: 0,
});

const ensureRevisionStatusPulseStyle = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('revision-status-pulse-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'revision-status-pulse-style';
    style.textContent = `
      @keyframes revision-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(250, 173, 20, 0.45); }
        70% { box-shadow: 0 0 0 8px rgba(250, 173, 20, 0); }
        100% { box-shadow: 0 0 0 0 rgba(250, 173, 20, 0); }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const sortRevisions = (list: GraphRevisionDto[]): GraphRevisionDto[] => {
  return [...list].sort((a, b) => {
    const aTime = new Date(a.updatedAt || a.createdAt).getTime();
    const bTime = new Date(b.updatedAt || b.createdAt).getTime();
    if (bTime === aTime) {
      return b.toVersion.localeCompare(a.toVersion);
    }
    return bTime - aTime;
  });
};

const extractMessageFromUnknown = (value: unknown): string | null => {
  if (!value) {
    return null;
  }
  if (typeof value === 'string') {
    return value;
  }
  if (Array.isArray(value)) {
    for (const item of value) {
      const extracted = extractMessageFromUnknown(item);
      if (extracted) {
        return extracted;
      }
    }
    return null;
  }
  if (typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const keysToCheck = ['message', 'error', 'detail', 'details'];
    for (const key of keysToCheck) {
      if (key in obj) {
        const extracted = extractMessageFromUnknown(obj[key]);
        if (extracted) {
          return extracted;
        }
      }
    }
  }
  return null;
};

const extractApiErrorMessage = (error: unknown, fallback: string): string => {
  if (isAxiosError(error)) {
    const data = error.response?.data;
    if (typeof data === 'string') {
      return data;
    }
    if (data && typeof data === 'object') {
      const extracted = extractMessageFromUnknown(data);
      if (extracted) {
        return extracted;
      }
    }
  }

  if (error instanceof Error) {
    return error.message;
  }

  return fallback;
};

export const GraphPage = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();

  useEffect(() => {
    ensureThreadStatusPulseStyle();
    ensureRevisionStatusPulseStyle();
  }, []);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [leftSidebarCollapsed, setLeftSidebarCollapsed] = useState(false);
  const [graph, setGraph] = useState<GraphDto | null>(null);
  const [nodes, setNodes, baseOnNodesChange] = useNodesState<GraphNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<GraphEdge>([]);
  const [viewport, setViewport] = useState<Viewport>({ x: 0, y: 0, zoom: 1 });
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [hasStructuralChanges, setHasStructuralChanges] = useState(false);
  const [hasPositionChanges, setHasPositionChanges] = useState(false);
  const isHydratingRef = useRef(true);
  const userInteractedRef = useRef(false);

  const nodesRef = useRef<GraphNode[]>([]);
  const edgesRef = useRef<GraphEdge[]>([]);
  const viewportRef = useRef<Viewport>({ x: 0, y: 0, zoom: 1 });
  const nodeChangeQueueRef = useRef<NodeChange[]>([]);
  const nodeChangeRafRef = useRef<number | null>(null);

  const [selectedTemplate, setSelectedTemplate] = useState<TemplateDto | null>(
    null,
  );
  const [templateModalVisible, setTemplateModalVisible] = useState(false);

  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [nodeEditSidebarVisible, setNodeEditSidebarVisible] = useState(false);
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const templatesById = useMemo(
    () =>
      templates.reduce<Record<string, TemplateDto>>((acc, template) => {
        acc[template.id] = template;
        return acc;
      }, {}),
    [templates],
  );

  const [triggerModalVisible, setTriggerModalVisible] = useState(false);
  const [triggerNodeId, setTriggerNodeId] = useState<string | null>(null);
  const [triggerNodeName, setTriggerNodeName] = useState<string | null>(null);
  const [triggerLoading, setTriggerLoading] = useState(false);
  const triggerStartedRef = useRef(false);
  const pendingThreadSelectionRef = useRef<string | null>(null);

  const [isEditingName, setIsEditingName] = useState(false);
  const [editingName, setEditingName] = useState('');

  const [actionLoading, setActionLoading] = useState(false);
  const [graphError, setGraphError] = useState<string | null>(null);

  const isGraphRunning = graph?.status === GraphDtoStatusEnum.Running;
  const isGraphCompiling = graph?.status === GraphDtoStatusEnum.Compiling;

  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [selectedThreadId, setSelectedThreadId] = useState<
    string | undefined
  >();
  const threadsRef = useRef<ThreadDto[]>([]);
  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadPopoverVisible, setThreadPopoverVisible] = useState(false);
  const [deletingThreadId, setDeletingThreadId] = useState<string | null>(null);
  const [threadChatThreadId, setThreadChatThreadId] = useState<string | null>(
    null,
  );
  const [compiledNodesMap, setCompiledNodesMap] = useState<
    Record<string, GraphNodeWithStatusDto>
  >({});
  const [compiledNodesLoading, setCompiledNodesLoading] = useState(false);

  const [sharedMessages, setSharedMessages] = useState<MessagesState>({});

  const [sharedPendingMessages, setSharedPendingMessages] =
    useState<PendingMessagesState>({});

  const [sharedExternalThreadIds, setSharedExternalThreadIds] = useState<
    Record<string, string | undefined>
  >({});

  const [messageMeta, setMessageMeta] = useState<MessageMetaState>({});

  const getMessageMeta = useCallback(
    (threadId?: string, nodeId?: string): MessageMeta => {
      if (!threadId) {
        return createDefaultMessageMeta();
      }
      return (
        messageMeta[threadId]?.[nodeId ?? 'all'] ?? createDefaultMessageMeta()
      );
    },
    [messageMeta],
  );

  const updateMessageMeta = useCallback(
    (
      threadId: string,
      nodeId: string | undefined,
      updater: (prev: MessageMeta) => MessageMeta,
    ) => {
      setMessageMeta((prev) => {
        const key = nodeId ?? 'all';
        const existing =
          prev[threadId]?.[key] ?? createDefaultMessageMeta();
        const next = updater(existing);
        return {
          ...prev,
          [threadId]: {
            ...(prev[threadId] ?? {}),
            [key]: next,
          },
        };
      });
    },
    [],
  );

  const updateSharedMessages = useCallback(
    (
      threadId: string,
      updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
      nodeId?: string,
    ) => {
      setSharedMessages((prev) => {
        const threadMessages = prev[threadId] || {};
        const key = nodeId || 'all';
        const currentMessages = threadMessages[key] || [];
        const updatedMessages = updater(currentMessages);

        // Deduplicate optimistic messages when real messages arrive
        const realIds = new Set<string>();
        const realContents = new Map<string, string>(); // content -> id
        updatedMessages.forEach((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
          if (!isOptimistic) {
            realIds.add(msg.id);
            const content =
              typeof msg.message?.content === 'string'
                ? msg.message.content
                : undefined;
            if (content && msg.message?.role === 'human') {
              realContents.set(content, msg.id);
            }
          }
        });

        const dedupedMessages = updatedMessages.filter((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
          if (!isOptimistic) return true;
          // Remove optimistic if a real message with same content exists
          const content =
            typeof msg.message?.content === 'string'
              ? msg.message.content
              : undefined;
          if (content && realContents.has(content)) {
            return false;
          }
          return true;
        });

        return {
          ...prev,
          [threadId]: {
            ...threadMessages,
            [key]: dedupedMessages,
          },
        };
      });
    },
    [],
  );
  const resolveInternalThreadId = useCallback((externalThreadId?: string) => {
    if (!externalThreadId) return undefined;
    const found = threadsRef.current.find(
      (thread) => thread.externalThreadId === externalThreadId,
    );
    return found?.id;
  }, []);

  const updateSharedPendingMessages = useCallback(
    (
      threadId: string,
      updater: (prev: PendingMessage[]) => PendingMessage[],
      nodeId?: string,
    ) => {
      setSharedPendingMessages((prev) => {
        const threadPendings = prev[threadId] || {};
        const key = nodeId || 'all';
        const current = threadPendings[key] || [];
        const next = updater(current);
        // Deduplicate by role+content to avoid duplicate pendings from send + socket
        const seen = new Set<string>();
        const deduped = next.filter((p) => {
          const contentKey = `${p.role}-${p.content}`;
          if (seen.has(contentKey)) return false;
          seen.add(contentKey);
          return true;
        });
        return {
          ...prev,
          [threadId]: {
            ...threadPendings,
            [key]: deduped,
          },
        };
      });
    },
    [],
  );

  const loadMessagesForScope = useCallback(
    async (threadId: string, nodeId?: string, force = false) => {
      const meta = getMessageMeta(threadId, nodeId);
      if (!force && (meta.loading || meta.offset > 0)) {
        return;
      }

      updateMessageMeta(threadId, nodeId, (prev) => ({
        ...prev,
        loading: true,
        loadingMore: false,
        hasMore: true,
        offset: force ? 0 : prev.offset,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          nodeId,
          MESSAGE_PAGE_SIZE,
          0,
        );
        const fetched = response.data?.reverse() || [];
        updateSharedMessages(threadId, () => fetched, nodeId);
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: fetched.length === MESSAGE_PAGE_SIZE,
          offset: fetched.length,
        }));

        const extId =
          fetched.find((m) => m.externalThreadId)?.externalThreadId ??
          sharedExternalThreadIds[threadId];
        if (extId) {
          setSharedExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: extId,
          }));
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        message.error('Failed to load messages');
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [
      getMessageMeta,
      updateMessageMeta,
      updateSharedMessages,
      sharedExternalThreadIds,
    ],
  );

  const loadMoreMessagesForScope = useCallback(
    async (threadId: string, nodeId?: string) => {
      const meta = getMessageMeta(threadId, nodeId);
      if (meta.loadingMore || !meta.hasMore || meta.loading) {
        return;
      }

      updateMessageMeta(threadId, nodeId, (prev) => ({
        ...prev,
        loadingMore: true,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          nodeId,
          MESSAGE_PAGE_SIZE,
          meta.offset,
        );
        const fetched = response.data?.reverse() || [];

        if (fetched.length > 0) {
          updateSharedMessages(
            threadId,
            (prev) => mergeMessagesReplacingStreaming(prev, fetched),
            nodeId,
          );
          updateMessageMeta(threadId, nodeId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: fetched.length === MESSAGE_PAGE_SIZE,
            offset: prev.offset + fetched.length,
          }));
        } else {
          updateMessageMeta(threadId, nodeId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: false,
          }));
        }
      } catch (error) {
        console.error('Error loading more messages:', error);
        message.error('Failed to load more messages');
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateSharedMessages],
  );

  useEffect(() => {
    if (
      !nodeEditSidebarVisible ||
      !selectedThreadId ||
      !selectedNode?.id ||
      !selectedNode.data
    ) {
      return;
    }
    const nodeData = selectedNode.data as unknown as GraphNodeData;
    const isAgentNode =
      (nodeData?.templateKind || '').toLowerCase() === 'simpleagent';
    if (!isAgentNode) {
      return;
    }

    const meta = getMessageMeta(selectedThreadId, selectedNode.id);
    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForScope(selectedThreadId, selectedNode.id);
    }
  }, [
    nodeEditSidebarVisible,
    selectedThreadId,
    selectedNode,
    getMessageMeta,
    loadMessagesForScope,
  ]);

  const buildReasoningThreadMessage = useCallback(
    (
      entry: ReasoningChunkEntry,
      existing: ThreadMessageDto | undefined,
      context: {
        externalThreadId?: string;
        runId?: string;
        selectedThreadId?: string;
        nodeId?: string;
      },
    ): ThreadMessageDto => {
      const nowIso = new Date().toISOString();
      const existingMessage = existing?.message as any;
      const existingAdditional =
        (existingMessage?.additionalKwargs as Record<string, unknown>) ?? {};

      const resolvedExternalThreadId =
        context.externalThreadId ??
        entry.threadId ??
        existing?.externalThreadId ??
        context.selectedThreadId ??
        '';

      const createdAt =
        existing?.createdAt ??
        entry.createdAt ??
        (typeof existingAdditional.created_at === 'string'
          ? (existingAdditional.created_at as string)
          : nowIso);
      const updatedAt = entry.updatedAt ?? existing?.updatedAt ?? nowIso;

      const additionalKwargs: Record<string, unknown> = {
        ...existingAdditional,
        reasoningId: entry.reasoningId,
        hideForLlm: true,
        [STREAMING_REASONING_FLAG]: true,
      };

      const resolvedRunId =
        context.runId ??
        entry.runId ??
        (typeof existingAdditional.run_id === 'string'
          ? (existingAdditional.run_id as string)
          : undefined);
      if (resolvedRunId) {
        additionalKwargs.run_id = resolvedRunId;
      }

      if (entry.createdAt) {
        additionalKwargs.created_at = entry.createdAt;
      } else if (!additionalKwargs.created_at) {
        additionalKwargs.created_at = createdAt;
      }

      if (!additionalKwargs.reasoningId) {
        additionalKwargs.reasoningId = entry.reasoningId;
      }

      return {
        id: entry.reasoningId,
        threadId: context.selectedThreadId ?? '',
        nodeId: context.nodeId ?? entry.reasoningId,
        externalThreadId: resolvedExternalThreadId,
        createdAt,
        updatedAt,
        message: {
          id: entry.reasoningId,
          role: 'reasoning' as any,
          content: entry.content,
          additionalKwargs,
        } as any,
      };
    },
    [],
  );

  const upsertReasoningEntries = useCallback(
    (
      prev: ThreadMessageDto[],
      entries: ReasoningChunkEntry[],
      context: {
        externalThreadId?: string;
        runId?: string;
        selectedThreadId?: string;
        nodeId?: string;
      },
    ): ThreadMessageDto[] => {
      if (!entries.length) return prev;

      let hasChanges = false;
      const byId = new Map<string, ThreadMessageDto>();
      prev.forEach((msg) => {
        byId.set(msg.id, msg);
      });

      entries.forEach((entry) => {
        const existing = byId.get(entry.reasoningId);
        const existingMessage = existing?.message as any;
        const existingAdditional =
          (existingMessage?.additionalKwargs as Record<string, unknown>) ?? {};
        const isExistingStreaming = Boolean(
          existingAdditional?.[STREAMING_REASONING_FLAG],
        );

        if (existing && !isExistingStreaming) {
          return;
        }

        const existingContent =
          typeof existingMessage?.content === 'string'
            ? existingMessage.content
            : '';

        const nextMessage = buildReasoningThreadMessage(
          entry,
          existing,
          context,
        );

        // If we already have a streaming message for this reasoningId, append
        // new chunk content instead of replacing so we accumulate text as it streams.
        const nextMessageContent =
          typeof (nextMessage.message as any)?.content === 'string'
            ? ((nextMessage.message as any).content as string)
            : '';

        const shouldAppend =
          isExistingStreaming &&
          existingContent.length > 0 &&
          nextMessageContent.length > 0 &&
          nextMessageContent !== existingContent &&
          !nextMessageContent.includes(existingContent);

        if (shouldAppend) {
          (nextMessage.message as any).content = `${existingContent}${nextMessageContent}`;
        }

        const nextContent = entry.content;
        const additionalChanged =
          JSON.stringify(existingAdditional) !==
          JSON.stringify(
            (nextMessage.message as any)?.additionalKwargs ?? {},
          );

        if (
          !existing ||
          existingContent !== nextContent ||
          existing.updatedAt !== nextMessage.updatedAt ||
          additionalChanged ||
          Boolean(
            (nextMessage.message as any)?.additionalKwargs?.[
              STREAMING_REASONING_FLAG
            ],
          )
        ) {
          hasChanges = true;
        }

        byId.set(entry.reasoningId, nextMessage);
      });

      if (!hasChanges) {
        return prev;
      }

      return sortMessagesChronologically(Array.from(byId.values()));
    },
    [buildReasoningThreadMessage],
  );

  const clearStreamingReasoningForContext = useCallback(
    (
      prev: ThreadMessageDto[],
      options: {
        targetThreadId?: string;
        selectedThreadId?: string;
        runIds?: Set<string>;
      },
    ) => {
      const { targetThreadId, selectedThreadId: selectedThreadIdForContext, runIds } =
        options;

      const predicate = (msg: ThreadMessageDto) => {
        const threadMatches = targetThreadId
          ? msg.externalThreadId === targetThreadId ||
            (!msg.externalThreadId &&
              targetThreadId === selectedThreadIdForContext)
          : !msg.externalThreadId ||
            msg.externalThreadId === selectedThreadIdForContext;

        if (!threadMatches) {
          return false;
        }

        if (runIds && runIds.size > 0) {
          const msgRunId = getMessageRunId(msg);
          if (!msgRunId || !runIds.has(msgRunId)) {
            return false;
          }
        }

        return true;
      };

      return removeStreamingReasoningMessages(prev, predicate);
    },
    [],
  );
  const [revisions, setRevisions] = useState<GraphRevisionDto[]>([]);
  const [revisionsLoading, setRevisionsLoading] = useState(false);
  const [revisionPopoverVisible, setRevisionPopoverVisible] = useState(false);
  const [revisionDiffRevision, setRevisionDiffRevision] =
    useState<GraphRevisionDto | null>(null);
  const [hoveredRevisionId, setHoveredRevisionId] = useState<string | null>(
    null,
  );

  const triggerNodesForGraph = useMemo(() => {
    if (!graph) return [];
    return buildTriggerNodes(graph, templatesById);
  }, [graph, templatesById]);

  const nodeDisplayNames = useMemo(
    () => (graph ? buildNodeDisplayNames(graph) : {}),
    [graph],
  );

  const chatThread = useMemo(
    () =>
      threadChatThreadId
        ? (threads.find((thread) => thread.id === threadChatThreadId) ?? null)
        : null,
    [threads, threadChatThreadId],
  );

  const handleOpenThreadChat = useCallback((threadId: string) => {
    setThreadChatThreadId(threadId);
  }, []);

  const handleCloseThreadChat = useCallback(() => {
    setThreadChatThreadId(null);
  }, []);

  useEffect(() => {
    if (!selectedThreadId) return;
    const meta = getMessageMeta(selectedThreadId, undefined);
    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForScope(selectedThreadId);
    }
  }, [selectedThreadId, getMessageMeta, loadMessagesForScope]);

  useEffect(() => {
    if (!chatThread) return;
    const meta = getMessageMeta(chatThread.id, undefined);
    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForScope(chatThread.id);
    }
  }, [chatThread, getMessageMeta, loadMessagesForScope]);

  useEffect(() => {
    if (!id) return;

    let mounted = true;
    (async () => {
      try {
        const templatesRes = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templatesList = templatesRes.data || [];
        setTemplates(templatesList);

        const res = await graphsApi.findGraphById(id);
        if (!mounted) return;

        const graphData = res.data;
        setGraph(graphData);
        setEditingName(graphData.name);

        const metadata = (graphData.metadata as GraphMetadata) || {};
        const nodeMetadata = metadata.nodes || [];

        if (
          metadata.x !== undefined &&
          metadata.y !== undefined &&
          metadata.zoom !== undefined
        ) {
          const savedViewport = {
            x: metadata.x,
            y: metadata.y,
            zoom: metadata.zoom,
          };
          setViewport(savedViewport);
          viewportRef.current = savedViewport;
        }

        const nodeMetadataMap = nodeMetadata.reduce(
          (acc, nodeMeta) => {
            acc[nodeMeta.id] = nodeMeta;
            return acc;
          },
          {} as Record<string, NodeMetadata>,
        );

        const apiNodes = graphData.schema?.nodes || [];
        const reactFlowNodes: GraphNode[] = apiNodes.map((node, index) => {
          const nodeMeta = nodeMetadataMap[node.id];
          const template = templatesList.find((t) => t.id === node.template);
          return {
            id: node.id,
            type: 'custom',
            position: nodeMeta
              ? { x: nodeMeta.x, y: nodeMeta.y }
              : {
                  x: 100 + (index % 3) * 250,
                  y: 100 + Math.floor(index / 3) * 150,
                },
            data: {
              label: nodeMeta?.name || template?.name || node.template,
              template: node.template,
              templateKind: template?.kind,
              templateSchema: template?.schema,
              config: node.config || {},
            },
          };
        });
        setNodes(reactFlowNodes);
        nodesRef.current = reactFlowNodes;

        const nodeById: Record<string, GraphNode> = Object.fromEntries(
          reactFlowNodes.map((n) => [n.id, n]),
        );

        const apiEdges = graphData.schema?.edges || [];
        const reactFlowEdges: GraphEdge[] = apiEdges.map((edge) => {
          const src = nodeById[edge.from];
          const dst = nodeById[edge.to];
          const { sourceHandle, targetHandle } = resolveHandlesForNodes(
            src,
            dst,
            templatesList,
          );
          return createEdge(
            edge.from,
            edge.to,
            sourceHandle,
            targetHandle,
            typeof edge.label === 'string' ? edge.label : undefined,
          );
        });
        setEdges(reactFlowEdges);
        edgesRef.current = reactFlowEdges;

        const savedState = GraphStorageService.loadGraphState(id);
        if (savedState) {
          const nodesWithTemplates = savedState.nodes.map((node) => {
            if (!node.data.templateKind || !node.data.templateSchema) {
              const template = templatesList.find(
                (t) =>
                  t.id === (node.data as unknown as GraphNodeData).template,
              );

              if (template) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    templateKind: template.kind,
                    templateSchema: template.schema,
                  },
                };
              }
            }
            return node;
          });

          setNodes(nodesWithTemplates);
          const nodeByIdRestored: Record<string, GraphNode> =
            Object.fromEntries(nodesWithTemplates.map((n) => [n.id, n]));
          const restoredEdges: GraphEdge[] = savedState.edges.map((e) => {
            const src = nodeByIdRestored[e.source];
            const dst = nodeByIdRestored[e.target];
            const { sourceHandle, targetHandle } = resolveHandlesForNodes(
              src,
              dst,
              templatesList,
            );
            return createEdge(
              e.source,
              e.target,
              sourceHandle ?? e.sourceHandle ?? undefined,
              targetHandle ?? e.targetHandle ?? undefined,
              typeof e.label === 'string' ? e.label : undefined,
            );
          });
          setEdges(restoredEdges);
          setViewport(savedState.viewport);

          nodesRef.current = nodesWithTemplates;
          edgesRef.current = restoredEdges;
          viewportRef.current = savedState.viewport;
          setHasUnsavedChanges(!!savedState.dirty);
          setHasStructuralChanges(!!savedState.hasStructuralChanges);
          setHasPositionChanges(!!savedState.hasPositionChanges);

          if (savedState.selectedThreadId) {
            setSelectedThreadId(savedState.selectedThreadId);
          }
        } else {
          setHasUnsavedChanges(false);
          setHasStructuralChanges(false);
          setHasPositionChanges(false);
        }
      } catch (e) {
        console.error('Error fetching graph:', e);
        message.error('Failed to load graph');
        navigate('/');
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [id, navigate, setNodes, setEdges]);

  const loadThreads = useCallback(async () => {
    if (!id) return;

    try {
      setThreadsLoading(true);
      const response = await threadsApi.getThreads(id, 100, 0);
      setThreads(response.data || []);
    } catch (error) {
      console.error('Error loading threads:', error);
      message.error('Failed to load threads');
      setThreads([]);
    } finally {
      setThreadsLoading(false);
    }
  }, [id]);

  const fetchCompiledNodes = useCallback(
    async (options?: {
      threadId?: string;
      graphStatusOverride?: GraphDtoStatusEnum | null;
    }) => {
      if (!id) return;

      const currentGraphStatus =
        options &&
        Object.prototype.hasOwnProperty.call(options, 'graphStatusOverride')
          ? options.graphStatusOverride
          : (graph?.status ?? null);

      if (currentGraphStatus === GraphDtoStatusEnum.Compiling) {
        setCompiledNodesLoading(false);
        return;
      }

      if (currentGraphStatus !== GraphDtoStatusEnum.Running) {
        setCompiledNodesMap({});
        setCompiledNodesLoading(false);
        return;
      }

      const threadIdToUse =
        options && Object.prototype.hasOwnProperty.call(options, 'threadId')
          ? options.threadId
          : selectedThreadId;

      const selectedThread = threads.find((t) => t.id === threadIdToUse);
      const externalThreadId = selectedThread?.externalThreadId;

      try {
        setCompiledNodesLoading(true);
        const response = await graphsApi.getCompiledNodes(
          id,
          externalThreadId || undefined,
        );
        const nodesWithStatus = response.data || [];
        setCompiledNodesMap(() => {
          const next = nodesWithStatus.reduce<
            Record<string, GraphNodeWithStatusDto>
          >((acc, node) => {
            acc[node.id] = node;
            return acc;
          }, {});
          return next;
        });
      } catch (error) {
        console.error('Error loading compiled nodes:', error);
      } finally {
        setCompiledNodesLoading(false);
      }
    },
    [graph?.status, id, selectedThreadId, threads],
  );

  const loadRevisions = useCallback(
    async (options?: { silent?: boolean }) => {
      if (!id) return;
      try {
        setRevisionsLoading(true);
        const response = await graphRevisionsApi.getGraphRevisions(
          id,
          undefined,
          REVISION_FETCH_LIMIT,
        );
        const revisionList = response.data || [];
        setRevisions(
          sortRevisions(revisionList).slice(0, REVISION_FETCH_LIMIT),
        );
      } catch (error) {
        console.error('Error loading graph revisions:', error);
        if (!options?.silent) {
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load graph revisions',
          );
          message.error(errorMessage);
        }
      } finally {
        setRevisionsLoading(false);
      }
    },
    [id],
  );

  useEffect(() => {
    loadThreads();
  }, [loadThreads]);

  useEffect(() => {
    fetchCompiledNodes();
  }, [fetchCompiledNodes]);

  useEffect(() => {
    void loadRevisions({ silent: true });
  }, [loadRevisions]);

  const upsertRevision = useCallback((revision: GraphRevisionDto) => {
    setRevisions((prev) => {
      const next = prev.slice();
      const index = next.findIndex((item) => item.id === revision.id);
      if (index === -1) {
        next.push(revision);
      } else {
        next[index] = revision;
      }
      return sortRevisions(next).slice(0, REVISION_FETCH_LIMIT);
    });
  }, []);

  const activeRevision = useMemo(() => {
    if (!revisions.length) {
      return null;
    }

    const applyingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
    );
    if (applyingRevision) {
      return applyingRevision;
    }

    const pendingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Pending,
    );
    if (pendingRevision) {
      return pendingRevision;
    }

    if (graph?.version) {
      const matchingApplied = revisions.find(
        (revision) =>
          revision.toVersion === graph.version &&
          revision.status === GraphRevisionDtoStatusEnum.Applied,
      );
      if (matchingApplied) {
        return matchingApplied;
      }
    }

    const appliedRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applied,
    );
    if (appliedRevision) {
      return appliedRevision;
    }

    return revisions[0];
  }, [revisions, graph?.version]);

  const displayedRevisionMeta: {
    label: string;
    color: string;
    pulse?: boolean;
  } | null = useMemo(() => {
    if (activeRevision) {
      const meta =
        REVISION_STATUS_STYLES[
          activeRevision.status as GraphRevisionDtoStatusEnum
        ] ?? null;

      if (
        activeRevision.status === GraphRevisionDtoStatusEnum.Applying &&
        meta
      ) {
        return { ...meta, label: `Applying` };
      }
      if (meta) {
        return meta;
      }
    }
    if (graph) {
      return {
        label: 'Applied',
        color: '#52c41a',
      };
    }
    return null;
  }, [activeRevision, graph]);

  const displayedVersion = useMemo(() => {
    if (activeRevision) {
      const isAppliedActive =
        activeRevision.status === GraphRevisionDtoStatusEnum.Applied;
      if (!isAppliedActive || activeRevision.toVersion !== graph?.version) {
        return activeRevision.toVersion;
      }
    }
    return graph?.version ?? 'â€”';
  }, [activeRevision, graph?.version]);

  const formatRevisionDiffValue = useCallback((value: unknown) => {
    if (value === undefined) {
      return null;
    }
    if (value === null) {
      return (
        <Typography.Text code style={{ fontSize: 12 }}>
          null
        </Typography.Text>
      );
    }
    if (
      typeof value === 'string' ||
      typeof value === 'number' ||
      typeof value === 'boolean'
    ) {
      return (
        <Typography.Text code style={{ fontSize: 12 }}>
          {JSON.stringify(value)}
        </Typography.Text>
      );
    }
    return (
      <pre
        style={{
          background: '#f5f5f5',
          borderRadius: 6,
          padding: '8px 10px',
          margin: 0,
          fontSize: 12,
          whiteSpace: 'pre-wrap',
        }}>
        {JSON.stringify(value, null, 2)}
      </pre>
    );
  }, []);

  const handleOpenRevisionDiff = useCallback((revision: GraphRevisionDto) => {
    setRevisionDiffRevision(revision);
    setRevisionPopoverVisible(false);
  }, []);

  const handleCloseRevisionDiff = useCallback(() => {
    setRevisionDiffRevision(null);
  }, []);

  const revisionDiffModalVisible = useMemo(
    () => revisionDiffRevision !== null,
    [revisionDiffRevision],
  );

  const revisionPopoverContent = useMemo(() => {
    if (revisionsLoading) {
      return (
        <div
          style={{
            minWidth: 280,
            minHeight: 80,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Spin size="small" />
        </div>
      );
    }

    if (revisions.length === 0) {
      return (
        <div style={{ minWidth: 280 }}>
          <Typography.Text type="secondary" style={{ fontSize: 12 }}>
            No revisions available yet.
          </Typography.Text>
        </div>
      );
    }

    return (
      <div style={{ minWidth: 320, maxHeight: 320, overflowY: 'auto' }}>
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          {revisions.map((revision) => {
            const meta = REVISION_STATUS_STYLES[
              revision.status as GraphRevisionDtoStatusEnum
            ] ?? {
              label: revision.status,
              color: '#d9d9d9',
            };
            const isActive = activeRevision?.id === revision.id;
            const isHovered = hoveredRevisionId === revision.id;
            const timestamp = new Date(
              revision.updatedAt || revision.createdAt,
            ).toLocaleString();

            return (
              <div
                key={revision.id}
                role="button"
                tabIndex={0}
                onClick={() => handleOpenRevisionDiff(revision)}
                onKeyDown={(event) => {
                  if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleOpenRevisionDiff(revision);
                  }
                }}
                onMouseEnter={() => setHoveredRevisionId(revision.id)}
                onMouseLeave={() =>
                  setHoveredRevisionId((prev) =>
                    prev === revision.id ? null : prev,
                  )
                }
                style={{
                  border: '1px solid #f0f0f0',
                  borderRadius: 6,
                  padding: '8px 12px',
                  background: isActive
                    ? '#fffbe6'
                    : isHovered
                      ? '#f0f5ff'
                      : '#fff',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  cursor: 'pointer',
                  outline: 'none',
                  transition:
                    'background-color 0.2s ease, border-color 0.2s ease',
                }}>
                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: 8,
                  }}>
                  <Typography.Text strong style={{ fontSize: 13 }}>
                    v{revision.toVersion}
                  </Typography.Text>
                  <Tag
                    color={meta.color}
                    style={{
                      margin: 0,
                      borderRadius: 999,
                      fontSize: 11,
                      lineHeight: '18px',
                      padding: '0 8px',
                    }}>
                    {meta.label}
                  </Tag>
                </div>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  From v{revision.baseVersion}
                </Typography.Text>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  Updated {timestamp}
                </Typography.Text>
                {revision.error && (
                  <Typography.Text
                    type="danger"
                    style={{ fontSize: 12, display: 'block', marginTop: 2 }}>
                    {revision.error}
                  </Typography.Text>
                )}
              </div>
            );
          })}
        </Space>
      </div>
    );
  }, [
    revisionsLoading,
    revisions,
    activeRevision?.id,
    hoveredRevisionId,
    handleOpenRevisionDiff,
  ]);

  useWebSocket({
    autoConnect: true,
    graphId: id,
    handlers: {
      'graph.update': (notification) => {
        const data = notification as GraphUpdateNotification;
        if (data.graphId !== id) return;

        const newStatus = data.data.status;

        if (
          newStatus === GraphDtoStatusEnum.Compiling ||
          newStatus === GraphDtoStatusEnum.Stopped
        ) {
          setCompiledNodesMap({});
        }

        setGraph((prev) => {
          if (!prev) {
            return prev;
          }

          return {
            ...prev,
            status: newStatus,
          };
        });
      },

      'agent.message': (notification) => {
        const data = notification as AgentMessageNotification;
        if (data.graphId !== id) return;
        if (!data.internalThreadId) return;

        const threadId = data.internalThreadId;
        const nodeId = data.nodeId;
        const incomingMessage = data.data;

        updateSharedMessages(threadId, (prev) => {
          return mergeMessagesReplacingStreaming(prev, [incomingMessage]);
        });

        if (nodeId) {
          updateSharedMessages(
            threadId,
            (prev) => {
              return mergeMessagesReplacingStreaming(prev, [incomingMessage]);
            },
            nodeId,
          );
        }

        // Clear pending that matches this incoming message (by content for human messages)
        const incomingContent =
          typeof incomingMessage.message?.content === 'string'
            ? (incomingMessage.message?.content as string)
            : undefined;
        const incomingRole = incomingMessage.message?.role as string | undefined;
        if (incomingContent && incomingRole === 'human') {
          const applyPendingToKeys = [undefined, nodeId];
          applyPendingToKeys.forEach((key) => {
            updateSharedPendingMessages(
              threadId,
              (prev) =>
                prev.filter(
                  (p) =>
                    typeof p.content !== 'string' ||
                    p.content !== incomingContent,
                ),
              key,
            );
          });
        }

        if (incomingMessage.externalThreadId) {
          setSharedExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: incomingMessage.externalThreadId,
          }));
        }
      },

      'thread.create': (notification) => {
        const data = notification as ThreadCreateNotification;
        if (data.graphId !== id) return;

        const externalThreadId = data.threadId;
        if (!externalThreadId) {
          triggerStartedRef.current = false;
          return;
        }

        void (async () => {
          try {
            const response =
              await threadsApi.getThreadByExternalId(externalThreadId);
            const fetchedThread = response.data;
            if (!fetchedThread) {
              return;
            }

            setThreads((prevThreads) => {
              const exists = prevThreads.some((t) => t.id === fetchedThread.id);
              if (exists) {
                return prevThreads;
              }
              return [fetchedThread, ...prevThreads];
            });

            if (
              pendingThreadSelectionRef.current &&
              pendingThreadSelectionRef.current === externalThreadId
            ) {
              handleThreadChange(fetchedThread.id);
              pendingThreadSelectionRef.current = null;
            }
          } catch (error) {
            console.error('Error fetching thread by external ID:', error);
          } finally {
            triggerStartedRef.current = false;
          }
        })();
      },

      'thread.update': (notification) => {
        const data = notification as ThreadUpdateNotification;
        if (data.graphId !== id) return;

        const updatedThread = data.data;
        const externalThreadId = updatedThread.externalThreadId;

        setThreads((prevThreads) => {
          const existingIndex = prevThreads.findIndex(
            (thread) => thread.id === updatedThread.id,
          );

          if (existingIndex === -1) {
            return prevThreads;
          }

          const updatedThreads = [...prevThreads];
          updatedThreads[existingIndex] = updatedThread;
          return updatedThreads;
        });

        if (
          externalThreadId &&
          pendingThreadSelectionRef.current &&
          pendingThreadSelectionRef.current === externalThreadId
        ) {
          handleThreadChange(updatedThread.id);
          pendingThreadSelectionRef.current = null;
        }

        triggerStartedRef.current = false;
      },

      'thread.delete': (notification) => {
        const data = notification as ThreadDeleteNotification;
        if (data.graphId !== id) return;

        const deletedThread = data.data;

        setThreads((prevThreads) =>
          prevThreads.filter((thread) => thread.id !== deletedThread.id),
        );

        if (
          deletedThread.externalThreadId === pendingThreadSelectionRef.current
        ) {
          pendingThreadSelectionRef.current = null;
        }

        if (selectedThreadId === deletedThread.id) {
          handleThreadChange(undefined);
        }

        triggerStartedRef.current = false;
      },

      'graph.node.update': (notification) => {
        const data = notification as GraphNodeUpdateNotification;
        if (data.graphId !== id) return;
        const eventThreadId =
          (typeof data.threadId === 'string' && data.threadId.length > 0
            ? data.threadId
            : undefined) ??
          (typeof data.data?.metadata?.threadId === 'string'
            ? data.data.metadata.threadId
            : undefined);
        const eventInternalThreadId =
          typeof data.internalThreadId === 'string' &&
          data.internalThreadId.length > 0
            ? data.internalThreadId
            : undefined;
        const metadataRunId =
          typeof data.data?.metadata?.runId === 'string'
            ? data.data.metadata.runId
            : undefined;
        const internalThreadId =
          eventInternalThreadId || resolveInternalThreadId(eventThreadId);

        const externalThreadIdForTarget =
          internalThreadId && sharedExternalThreadIds[internalThreadId]
            ? sharedExternalThreadIds[internalThreadId]
            : eventThreadId;

        if (eventThreadId && internalThreadId) {
          setSharedExternalThreadIds((prev) => {
            const existing = prev[internalThreadId];
            if (existing === eventThreadId) return prev;
            return { ...prev, [internalThreadId]: eventThreadId };
          });
        }
        const targetRunIds = buildIdSet(data.runId, metadataRunId);

        setCompiledNodesMap((prev) => {
          const existing = prev[data.nodeId];
          const nextStatus = data.data.status;
          const nextError = data.data.error ?? existing?.error ?? null;
          const nextMetadata = data.data.metadata ?? existing?.metadata;
          const nextAdditionalNodeMetadata =
            data.data.additionalNodeMetadata ??
            existing?.additionalNodeMetadata;

          if (!existing) {
            const graphNode = nodesRef.current.find(
              (n) => n.id === data.nodeId,
            );
            if (!graphNode) {
              return prev;
            }

            const nodeData = graphNode.data as unknown as GraphNodeData;
            const rawKind = (nodeData.templateKind as string | undefined) ?? '';
            const normalizedKind = rawKind.toLowerCase();
            let inferredType: GraphNodeWithStatusDto['type'] = 'runtime';
            if (normalizedKind === 'tool') {
              inferredType = 'tool';
            } else if (normalizedKind === 'simpleagent') {
              inferredType = 'simpleAgent';
            } else if (normalizedKind === 'trigger') {
              inferredType = 'trigger';
            } else if (normalizedKind === 'resource') {
              inferredType = 'resource';
            }

            return {
              ...prev,
              [data.nodeId]: {
                id: data.nodeId,
                name:
                  (nodeData.label as string) ||
                  (nodeData.template as string) ||
                  data.nodeId,
                template: (nodeData.template as string) || '',
                type: inferredType,
                status: nextStatus,
                config: nodeData.config ?? {},
                error: nextError,
                metadata: nextMetadata,
                additionalNodeMetadata: nextAdditionalNodeMetadata,
              },
            };
          }

          return {
            ...prev,
            [data.nodeId]: {
              ...existing,
              status: nextStatus,
              error: nextError,
              metadata: nextMetadata,
              additionalNodeMetadata: nextAdditionalNodeMetadata,
            },
          };
        });

        // Propagate pending messages to the shared store so both popup and sidebar see them
        const pendingMessagesFromNode =
          data.data?.additionalNodeMetadata?.pendingMessages;
        if (internalThreadId && Array.isArray(pendingMessagesFromNode)) {
          const pendingDtos: PendingMessage[] = pendingMessagesFromNode.map(
            (p) => {
              const createdAt =
                typeof p.createdAt === 'string'
                  ? p.createdAt
                  : typeof p.additionalKwargs?.created_at === 'string'
                    ? p.additionalKwargs.created_at
                    : new Date().toISOString();
              const runId =
                data.runId ??
                metadataRunId ??
                (typeof p.additionalKwargs?.run_id === 'string'
                  ? p.additionalKwargs.run_id
                  : undefined);
              return {
                content: p.content,
                role: p.role,
                additionalKwargs: {
                  ...(p.additionalKwargs || {}),
                  run_id: runId,
                  created_at: createdAt,
                },
                createdAt,
              };
            },
          );

          const applyPendingToKeys = [undefined, data.nodeId];
          applyPendingToKeys.forEach((key) => {
            updateSharedPendingMessages(
              internalThreadId,
              () => pendingDtos,
              key,
            );
          });
        } else if (internalThreadId) {
          // If no pending messages, clear any existing pending entries for this node/thread
          const applyPendingToKeys = [undefined, data.nodeId];
          applyPendingToKeys.forEach((key) => {
            updateSharedPendingMessages(internalThreadId, () => [], key);
          });
        }

        const reasoningChunks =
          data.data?.additionalNodeMetadata?.reasoningChunks;

        const applyUpdateToKeys = [undefined, data.nodeId];

        if (!reasoningChunks) {
          applyUpdateToKeys.forEach((key) => {
            if (!internalThreadId) return;
            updateSharedMessages(
              internalThreadId,
              (prev) =>
                clearStreamingReasoningForContext(prev, {
                  targetThreadId: externalThreadIdForTarget,
                  selectedThreadId: internalThreadId,
                  runIds: targetRunIds,
                }),
              key,
            );
          });
          return;
        }

        const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
          eventThreadId,
          externalThreadIdForTarget,
          data.runId ?? metadataRunId,
        ]);
        const reasoningEntries = extractReasoningEntries(reasoningContainer, {
          threadId: externalThreadIdForTarget ?? eventThreadId,
          runId: data.runId ?? metadataRunId,
        });

        if (!reasoningEntries.length) {
          applyUpdateToKeys.forEach((key) => {
            if (!internalThreadId) return;
            updateSharedMessages(
              internalThreadId,
              (prev) =>
                clearStreamingReasoningForContext(prev, {
                  targetThreadId: externalThreadIdForTarget,
                  selectedThreadId: internalThreadId,
                  runIds: targetRunIds,
                }),
              key,
            );
          });
          return;
        }

        applyUpdateToKeys.forEach((key) => {
          if (!internalThreadId) return;
          updateSharedMessages(
            internalThreadId,
            (prev) =>
              upsertReasoningEntries(prev, reasoningEntries, {
                externalThreadId: externalThreadIdForTarget,
                runId: data.runId ?? metadataRunId,
                selectedThreadId: internalThreadId,
                nodeId: key,
              }),
            key,
          );
        });
      },

      'graph.revision.create': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        upsertRevision(data.data);
      },

      'graph.revision.applying': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);

        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'loading',
          content: `Applying revision ${revision.toVersion}`,
          duration: 0,
        });
      },

      'graph.revision.applied': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        setGraph((prev) =>
          prev ? { ...prev, version: revision.toVersion } : prev,
        );
        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'success',
          content: `Revision ${revision.toVersion} applied`,
          duration: 3,
        });
      },

      'graph.revision.failed': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'error',
          content: revision.error
            ? `Revision ${revision.toVersion} failed: ${revision.error}`
            : `Revision ${revision.toVersion} failed`,
          duration: 5,
        });
      },
    },
  });

  useEffect(() => {
    if (!loading) {
      const t = requestAnimationFrame(() => {
        isHydratingRef.current = false;
      });
      return () => cancelAnimationFrame(t);
    }
  }, [loading]);

  useEffect(() => {
    nodesRef.current = nodes;
  }, [nodes]);

  useEffect(() => {
    edgesRef.current = edges;
  }, [edges]);

  useEffect(
    () => () => {
      if (nodeChangeRafRef.current !== null) {
        cancelAnimationFrame(nodeChangeRafRef.current);
      }
      nodeChangeQueueRef.current = [];
    },
    [],
  );

  const handleTemplateClick = useCallback((template: TemplateDto) => {
    setSelectedTemplate(template);
    setTemplateModalVisible(true);
  }, []);

  const handleNodeAdd = useCallback(
    (node: GraphNode) => {
      setNodes((nds) => {
        const newNodes = nds.concat(node);
        nodesRef.current = newNodes;
        setHasUnsavedChanges(true);
        setHasStructuralChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: newNodes,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }
        return newNodes;
      });
    },
    [setNodes, id, hasPositionChanges, selectedThreadId],
  );

  const handleNodeEdit = useCallback((node: GraphNode) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(true);
  }, []);

  const handleNodeSelect = useCallback((node: GraphNode | null) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(!!node);
  }, []);

  const handleNodeSave = useCallback(
    (
      nodeId: string,
      updates: { name?: string; config?: Record<string, unknown> },
    ) => {
      setNodes((prevNodes) => {
        const updatedNodes = prevNodes.map((node) => {
          if (node.id !== nodeId) return node;
          const nodeData = node.data;
          return {
            ...node,
            data: {
              ...nodeData,
              label: updates.name ?? nodeData.label,
              config: updates.config ?? nodeData.config,
            },
          };
        });
        nodesRef.current = updatedNodes;
        setHasUnsavedChanges(true);
        setHasStructuralChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: updatedNodes,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }
        return updatedNodes;
      });
    },
    [setNodes, id, hasPositionChanges, selectedThreadId],
  );

  const handleNodeDelete = useCallback(
    (nodeId: string) => {
      setNodes((prevNodes) => {
        const newNodes = prevNodes.filter((node) => node.id !== nodeId);
        nodesRef.current = newNodes;
        setHasUnsavedChanges(true);
        setHasStructuralChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: newNodes,
            edges: edgesRef.current.filter(
              (edge) => edge.source !== nodeId && edge.target !== nodeId,
            ),
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }
        return newNodes;
      });
      setEdges((prevEdges) => {
        const newEdges = prevEdges.filter(
          (edge) => edge.source !== nodeId && edge.target !== nodeId,
        );
        edgesRef.current = newEdges;
        return newEdges;
      });
    },
    [setNodes, setEdges, id, hasPositionChanges, selectedThreadId],
  );

  const handleTriggerClick = useCallback((nodeId: string) => {
    const node = nodesRef.current.find((n) => n.id === nodeId);
    if (!node) return;
    setTriggerNodeId(nodeId);
    setTriggerNodeName(node.data.label as string);
    setTriggerModalVisible(true);
  }, []);

  const handleThreadChange = useCallback(
    (newThreadId: string | undefined) => {
      setSelectedThreadId(newThreadId);

      if (id) {
        GraphStorageService.saveGraphState(id, {
          nodes: nodesRef.current,
          edges: edgesRef.current,
          viewport: viewportRef.current,
          dirty: hasUnsavedChanges,
          hasStructuralChanges: hasStructuralChanges,
          hasPositionChanges: hasPositionChanges,
          selectedThreadId: newThreadId,
        });
      }

      void fetchCompiledNodes({ threadId: newThreadId });
    },
    [
      id,
      hasUnsavedChanges,
      hasStructuralChanges,
      hasPositionChanges,
      fetchCompiledNodes,
    ],
  );

  const handleThreadSelect = useCallback(
    (newThreadId: string | undefined) => {
      handleThreadChange(newThreadId);
      setThreadPopoverVisible(false);
    },
    [handleThreadChange],
  );

  const handleSave = async () => {
    if (!graph || !id) return;

    setSaving(true);
    try {
      const apiNodes: CreateGraphDtoSchemaNodesInner[] = nodes.map((node) => {
        const template = templatesById[node.data.template as string];
        const nodeConfig = node.data.config as Record<string, unknown>;

        // Merge const values from template schema into config
        const mergedConfig = { ...nodeConfig };
        if (template?.schema?.properties) {
          Object.entries(template.schema.properties).forEach(([key, prop]) => {
            const schemaProp = prop as SchemaProperty;
            if (schemaProp.const !== undefined) {
              // Always include const values, even if they're not in the current config
              mergedConfig[key] = schemaProp.const;
            }
          });
        }

        return {
          id: node.id,
          template: node.data.template as string,
          config: mergedConfig,
        };
      });

      const apiEdges: CreateGraphDtoSchemaEdgesInner[] = edges.map((edge) => ({
        from: edge.source,
        to: edge.target,
        label: typeof edge.label === 'string' ? edge.label : undefined,
      }));

      const nodeMetadata: NodeMetadata[] = nodes.map((node) => ({
        id: node.id,
        x: node.position.x,
        y: node.position.y,
        name: node.data.label as string,
      }));

      const metadata: GraphMetadata = {
        ...((graph.metadata as GraphMetadata) || {}),
        nodes: nodeMetadata,
        x: viewport.x,
        y: viewport.y,
        zoom: viewport.zoom,
      };

      const response = await graphsApi.updateGraph(id, {
        name: graph.name,
        description: graph.description || undefined,
        schema: {
          nodes: apiNodes,
          edges: apiEdges,
        },
        metadata: metadata || undefined,
        currentVersion: graph.version,
      });
      const updatedGraph = response.data.graph;
      const revision = response.data.revision;

      if (revision) {
        upsertRevision(revision);
      }

      message.success('Graph saved successfully');
      setHasUnsavedChanges(false);
      setHasStructuralChanges(false);
      setHasPositionChanges(false);
      if (id) {
        GraphStorageService.clearGraphState(id);
      }
      setGraph(updatedGraph);
      setEditingName(updatedGraph.name);
      userInteractedRef.current = false;
    } catch (e: unknown) {
      console.error('Error saving graph:', e);
      const errorMessage = extractApiErrorMessage(e, 'Failed to save graph');
      message.error(errorMessage);
    } finally {
      setSaving(false);
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const handleTriggerNode = useCallback(
    async (triggerMessage: string, targetThreadId?: string) => {
      if (!triggerNodeId || !id) return;

      try {
        setTriggerLoading(true);
        if (hasUnsavedChanges) {
          await handleSave();
        }

        const threadForExecution = threads.find((t) => t.id === targetThreadId);
        const parts = threadForExecution?.externalThreadId.split(':') || [];
        const finalThreadSubId = parts[parts.length - 1];

        const executeTriggerDto: ExecuteTriggerDto = {
          messages: [triggerMessage],
          async: true,
          ...(finalThreadSubId ? { threadSubId: finalThreadSubId } : {}),
        };

        const response = await graphsApi.executeTrigger(
          id,
          triggerNodeId,
          executeTriggerDto,
        );

        const returnedExternalThreadId = response.data?.externalThreadId;
        const currentExternalThreadId = threadForExecution?.externalThreadId;
        const shouldSelectNewThread =
          returnedExternalThreadId &&
          returnedExternalThreadId !== currentExternalThreadId;

        triggerStartedRef.current = Boolean(shouldSelectNewThread);
        pendingThreadSelectionRef.current = shouldSelectNewThread
          ? returnedExternalThreadId
          : null;

        message.success('Trigger sent successfully');
        setTriggerModalVisible(false);
        setTriggerNodeId(null);
        setTriggerNodeName(null);
      } catch (error) {
        triggerStartedRef.current = false;
        pendingThreadSelectionRef.current = null;
        console.error('Error triggering node:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to trigger node';
        message.error(errorMessage);
        throw error;
      } finally {
        if (!pendingThreadSelectionRef.current) {
          triggerStartedRef.current = false;
        }
        setTriggerLoading(false);
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [triggerNodeId, id, threads, hasUnsavedChanges, handleSave],
  );

  const handleViewportChange = useCallback(
    (newViewport: Viewport) => {
      setViewport(newViewport);
      viewportRef.current = newViewport;
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      setHasPositionChanges(true);
      if (id) {
        GraphStorageService.saveGraphState(id, {
          nodes: nodesRef.current,
          edges: edgesRef.current,
          viewport: newViewport,
          dirty: true,
          hasStructuralChanges: hasStructuralChanges,
          hasPositionChanges: true,
          selectedThreadId: selectedThreadId,
        });
      }
    },
    [id, hasStructuralChanges, selectedThreadId],
  );

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        setDeletingThreadId(threadId);
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          handleThreadChange(undefined);
        }
        setThreadPopoverVisible(false);
        message.success('Thread deleted');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to delete thread';
        message.error(errorMessage);
      } finally {
        setDeletingThreadId(null);
      }
    },
    [handleThreadChange, selectedThreadId],
  );

  const handleNodesChange = useCallback(
    (changes: NodeChange[]) => {
      const isDragging = changes.some(
        (change) =>
          change.type === 'position' &&
          (change as Extract<NodeChange, { type: 'position' }>).dragging,
      );

      const enqueueChanges = () => {
        nodeChangeQueueRef.current = [
          ...nodeChangeQueueRef.current,
          ...changes,
        ];
        if (nodeChangeRafRef.current === null) {
          nodeChangeRafRef.current = requestAnimationFrame(() => {
            const queue = nodeChangeQueueRef.current;
            nodeChangeQueueRef.current = [];
            nodeChangeRafRef.current = null;

            if (queue.length === 0) return;

            const mergedMap = new Map<string, NodeChange>();
            queue.forEach((change) => {
              const key =
                change.type === 'dimensions'
                  ? `${change.type}-${(change as any).id}-${(change as any).resizing ?? ''}`
                  : `${change.type}-${(change as any).id ?? 'na'}`;
              mergedMap.set(key, change);
            });
            baseOnNodesChange(Array.from(mergedMap.values()));
          });
        }
      };

      enqueueChanges();

      if (isHydratingRef.current) return;
      if (!userInteractedRef.current) return;
      if (isDragging) return;

      setHasUnsavedChanges(true);
      setHasPositionChanges(true);

      if (id) {
        setTimeout(() => {
          GraphStorageService.saveGraphState(id, {
            nodes: nodesRef.current,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: hasStructuralChanges,
            hasPositionChanges: true,
            selectedThreadId: selectedThreadId,
          });
        }, 100);
      }
    },
    [baseOnNodesChange, id, hasStructuralChanges, selectedThreadId],
  );

  const handleEdgesChange = useCallback(
    (changes: Parameters<typeof onEdgesChange>[0]) => {
      onEdgesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      setHasStructuralChanges(true);
      if (id) {
        setTimeout(() => {
          GraphStorageService.saveGraphState(id, {
            nodes: nodesRef.current,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }, 100);
      }
    },
    [onEdgesChange, id, hasPositionChanges, selectedThreadId],
  );

  const handleNameEdit = () => {
    setIsEditingName(true);
  };

  const handleNameSave = async () => {
    if (!graph || !id) return;

    try {
      const response = await graphsApi.updateGraph(id, {
        name: editingName,
        description: graph.description || undefined,
        schema: graph.schema,
        metadata: graph.metadata || undefined,
        currentVersion: graph.version,
      });

      const updatedGraph = response.data.graph;
      const revision = response.data.revision;

      if (revision) {
        upsertRevision(revision);
      }

      setGraph(updatedGraph);
      setEditingName(updatedGraph.name);
      setIsEditingName(false);
      message.success('Graph name updated');
    } catch (e: unknown) {
      console.error('Error updating graph name:', e);
      const errorMessage = extractApiErrorMessage(
        e,
        'Failed to update graph name',
      );
      message.error(errorMessage);
      setEditingName(graph.name);
    }
  };

  const handleNameCancel = () => {
    setEditingName(graph?.name || '');
    setIsEditingName(false);
  };

  const handleGraphAction = async () => {
    if (!graph || !id) return;
    if (graph.status === GraphDtoStatusEnum.Compiling) {
      return;
    }

    try {
      setActionLoading(true);
      setGraphError(null);

      if (graph.status === GraphDtoStatusEnum.Running) {
        await graphsApi.destroyGraph(id);
        message.success('Graph stopped successfully');
        const response = await graphsApi.findGraphById(id);
        setGraph(response.data);
        void fetchCompiledNodes({
          graphStatusOverride: response.data.status,
          threadId: selectedThreadId,
        });
      } else {
        if (hasUnsavedChanges) {
          await handleSave();
        }
        const response = await graphsApi.runGraph(id);
        const updatedGraph = response.data;
        setGraph(updatedGraph);
        void fetchCompiledNodes({
          graphStatusOverride: updatedGraph.status,
          threadId: selectedThreadId,
        });

        if (updatedGraph.status === GraphDtoStatusEnum.Error) {
          message.error('Graph execution failed');
          setGraphError('Graph execution failed');
        } else {
          message.success('Graph saved and started successfully');
        }
      }
    } catch (error) {
      console.error('Error with graph action:', error);
      const errorMessage =
        error instanceof Error
          ? error.message
          : 'Failed to perform graph action';
      message.error(errorMessage);
      setGraphError(errorMessage);
    } finally {
      setActionLoading(false);
    }
  };

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Layout style={{ overflow: 'hidden' }}>
      <Header
        style={{
          background: '#fff',
          padding: '0 24px',
          borderBottom: '1px solid #f0f0f0',
          flexShrink: 0,
          height: 70,
        }}>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            gap: 24,
            height: '100%',
          }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 16,
              flexWrap: 'wrap',
            }}>
            {isEditingName ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Input
                  value={editingName}
                  onChange={(e) => setEditingName(e.target.value)}
                  onPressEnter={handleNameSave}
                  onBlur={handleNameSave}
                  autoFocus
                  style={{ width: 300 }}
                />
                <Button
                  type="text"
                  icon={<CheckOutlined />}
                  onClick={handleNameSave}
                  size="small"
                />
                <Button
                  type="text"
                  icon={<CloseOutlined />}
                  onClick={handleNameCancel}
                  size="small"
                />
              </div>
            ) : (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Title level={4} style={{ margin: 0 }}>
                  {graph?.name || 'Graph Editor'}
                </Title>
                <Button
                  type="text"
                  icon={<EditOutlined />}
                  onClick={handleNameEdit}
                  size="small"
                />
              </div>
            )}
            {graph && (
              <Popover
                open={revisionPopoverVisible}
                onOpenChange={(open) => {
                  setRevisionPopoverVisible(open);
                  if (open) {
                    void loadRevisions();
                  }
                }}
                trigger="click"
                placement="bottomLeft"
                content={revisionPopoverContent}>
                <Button
                  type="text"
                  size="small"
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 6,
                    padding: '4px 8px',
                    height: 'auto',
                    borderRadius: 6,
                    backgroundColor: revisionPopoverVisible
                      ? '#f5f5f5'
                      : 'transparent',
                  }}>
                  <Typography.Text style={{ fontSize: 12, color: '#595959' }}>
                    Version {displayedVersion}
                  </Typography.Text>
                  {displayedRevisionMeta && (
                    <Tag
                      color={displayedRevisionMeta.color}
                      style={{
                        margin: 0,
                        borderRadius: 999,
                        fontSize: 11,
                        lineHeight: '18px',
                        padding: '0 8px',
                        boxShadow: displayedRevisionMeta.pulse
                          ? '0 0 0 0 rgba(250, 173, 20, 0.45)'
                          : 'none',
                        animation: displayedRevisionMeta.pulse
                          ? 'revision-status-pulse 1.5s ease-out infinite'
                          : undefined,
                      }}>
                      {displayedRevisionMeta.label}
                    </Tag>
                  )}
                  <DownOutlined style={{ fontSize: 10, color: '#8c8c8c' }} />
                </Button>
              </Popover>
            )}
          </div>

          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                }}>
                <Popover
                  open={threadPopoverVisible}
                  placement="bottomLeft"
                  content={
                    <div
                      style={{
                        maxHeight: 300,
                        overflowY: 'auto',
                        minWidth: 320,
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        gap: 4,
                      }}>
                      <Button
                        key="__new_thread__"
                        type="text"
                        style={{
                          textAlign: 'left',
                          padding: '8px 12px',
                          height: 'auto',
                          lineHeight: 1.2,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'flex-start',
                          border: '1px solid #f0f0f0',
                          borderRadius: 6,
                          width: '100%',
                        }}
                        onClick={() => handleThreadSelect(undefined)}>
                        <Typography.Text
                          strong
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          + New thread
                        </Typography.Text>
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          Clear current selection
                        </Typography.Text>
                      </Button>

                      {threadsLoading ? (
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px' }}>
                          Loading threads...
                        </Typography.Text>
                      ) : threads.length === 0 ? (
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px' }}>
                          No threads available
                        </Typography.Text>
                      ) : (
                        threads.map((thread) => {
                          const statusMeta = getThreadStatusDisplay(
                            thread.status,
                          );
                          const isThreadRunning =
                            thread.status === ThreadDtoStatusEnum.Running;
                          return (
                            <div
                              key={thread.id}
                              style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8,
                                width: '100%',
                                border: '1px solid #f0f0f0',
                                borderRadius: 6,
                                padding: '4px 4px',
                              }}>
                              <Button
                                type="text"
                                style={{
                                  textAlign: 'left',
                                  padding: '8px 12px',
                                  height: 'auto',
                                  lineHeight: 1.2,
                                  display: 'flex',
                                  flexDirection: 'column',
                                  alignItems: 'flex-start',
                                  border: 'none',
                                  boxShadow: 'none',
                                  flex: 1,
                                  gap: 0,
                                }}
                                onClick={() => handleThreadSelect(thread.id)}>
                                <div
                                  style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 8,
                                    width: '100%',
                                    justifyContent: 'space-between',
                                  }}>
                                  <div
                                    style={{
                                      display: 'flex',
                                      alignItems: 'center',
                                      gap: 8,
                                      minWidth: 0,
                                    }}>
                                    <Typography.Text
                                      strong
                                      style={{
                                        fontSize: '12px',
                                        lineHeight: 1.2,
                                        maxWidth: '400px',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                      }}>
                                      {thread.name || thread.id}
                                    </Typography.Text>
                                    <Popconfirm
                                      title="Delete thread"
                                      description="Are you sure you want to delete this thread?"
                                      okText="Delete"
                                      okButtonProps={{
                                        danger: true,
                                        loading: deletingThreadId === thread.id,
                                      }}
                                      cancelText="Cancel"
                                      disabled={deletingThreadId === thread.id}
                                      onConfirm={(e) => {
                                        e?.stopPropagation?.();
                                        handleDeleteThread(thread.id);
                                      }}>
                                      <span
                                        role="button"
                                        aria-label={`Delete thread ${thread.name || thread.id}`}
                                        tabIndex={0}
                                        style={{
                                          display: 'inline-flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          width: 24,
                                          height: 24,
                                          borderRadius: '50%',
                                          color: '#ff4d4f',
                                          backgroundColor: 'transparent',
                                          transition: 'background-color 0.2s',
                                          cursor: 'pointer',
                                        }}
                                        onClick={(e) => {
                                          e.stopPropagation();
                                        }}
                                        onKeyDown={(e) => {
                                          if (
                                            e.key === 'Enter' ||
                                            e.key === ' '
                                          ) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            (
                                              e.currentTarget as HTMLElement
                                            ).click();
                                          }
                                        }}
                                        onMouseEnter={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'rgba(255, 77, 79, 0.08)';
                                        }}
                                        onMouseLeave={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'transparent';
                                        }}>
                                        {deletingThreadId === thread.id ? (
                                          <LoadingOutlined
                                            style={{ fontSize: 12 }}
                                            spin
                                          />
                                        ) : (
                                          <DeleteOutlined />
                                        )}
                                      </span>
                                    </Popconfirm>
                                  </div>
                                  {statusMeta && (
                                    <Tag
                                      color={statusMeta.color}
                                      style={{
                                        margin: 0,
                                        borderRadius: 999,
                                        fontSize: '11px',
                                        lineHeight: '18px',
                                        padding: '0 8px',
                                        boxShadow: isThreadRunning
                                          ? '0 0 0 0 rgba(24, 144, 255, 0.45)'
                                          : 'none',
                                        animation: isThreadRunning
                                          ? 'thread-status-pulse 1.5s ease-out infinite'
                                          : undefined,
                                      }}>
                                      {statusMeta.label}
                                    </Tag>
                                  )}
                                </div>
                                <Typography.Text
                                  type="secondary"
                                  style={{ fontSize: '12px', lineHeight: 1.2 }}>
                                  {new Date(thread.createdAt).toLocaleString()}
                                </Typography.Text>
                                {thread.source ? (
                                  <Typography.Text
                                    type="secondary"
                                    style={{
                                      fontSize: '12px',
                                      lineHeight: 1.2,
                                      marginTop: '10px',
                                    }}>
                                    Source: {thread.source}
                                  </Typography.Text>
                                ) : null}
                              </Button>
                            </div>
                          );
                        })
                      )}
                    </div>
                  }
                  trigger="click"
                  onOpenChange={setThreadPopoverVisible}>
                  <div
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start',
                      cursor: 'pointer',
                      padding: '4px 8px',
                      borderRadius: '4px',
                      transition: 'background-color 0.2s',
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f5f5f5';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    {(() => {
                      const t = threads.find(
                        (thr) => thr.id === selectedThreadId,
                      );
                      const source = t?.source;
                      const label = (
                        <Typography.Text
                          strong
                          style={{ fontSize: '14px', lineHeight: 1 }}>
                          Thread
                        </Typography.Text>
                      );
                      return source ? (
                        <Tooltip title={`Source: ${source}`}>{label}</Tooltip>
                      ) : (
                        label
                      );
                    })()}
                    {selectedThreadId ? (
                      (() => {
                        const t = threads.find(
                          (thr) => thr.id === selectedThreadId,
                        );
                        const statusMeta = getThreadStatusDisplay(t?.status);
                        return (
                          <>
                            <div
                              style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: 6,
                                flexWrap: 'wrap',
                              }}>
                              <div
                                style={{
                                  display: 'flex',
                                  alignItems: 'center',
                                  gap: 6,
                                }}>
                                <Typography.Text
                                  style={{
                                    fontSize: '12px',
                                    lineHeight: 1.2,
                                    maxWidth: '400px',
                                    whiteSpace: 'nowrap',
                                    overflow: 'hidden',
                                    textOverflow: 'ellipsis',
                                  }}>
                                  {t?.name || selectedThreadId}
                                </Typography.Text>
                                {selectedThreadId && (
                                  <>
                                    <Tooltip title="Open chat for thread">
                                      <span
                                        role="button"
                                        aria-label="Open chat for current thread"
                                        tabIndex={0}
                                        style={{
                                          display: 'inline-flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          width: 24,
                                          height: 24,
                                          borderRadius: '50%',
                                          color: '#1677ff',
                                          backgroundColor: 'transparent',
                                          transition: 'background-color 0.2s',
                                          cursor: 'pointer',
                                          marginLeft: 4,
                                        }}
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          handleOpenThreadChat(
                                            selectedThreadId,
                                          );
                                        }}
                                        onKeyDown={(e) => {
                                          if (
                                            e.key === 'Enter' ||
                                            e.key === ' '
                                          ) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            handleOpenThreadChat(
                                              selectedThreadId,
                                            );
                                          }
                                        }}
                                        onMouseEnter={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'rgba(22, 119, 255, 0.08)';
                                        }}
                                        onMouseLeave={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'transparent';
                                        }}>
                                        <MessageOutlined />
                                      </span>
                                    </Tooltip>
                                    <Popconfirm
                                      title="Delete thread"
                                      description="Are you sure you want to delete the selected thread?"
                                      okText="Delete"
                                      okButtonProps={{
                                        danger: true,
                                        loading:
                                          deletingThreadId === selectedThreadId,
                                      }}
                                      cancelText="Cancel"
                                      disabled={
                                        deletingThreadId === selectedThreadId
                                      }
                                      onConfirm={(e) => {
                                        e?.stopPropagation?.();
                                        handleDeleteThread(selectedThreadId);
                                      }}>
                                      <span
                                        role="button"
                                        aria-label="Delete current thread"
                                        tabIndex={0}
                                        style={{
                                          display: 'inline-flex',
                                          alignItems: 'center',
                                          justifyContent: 'center',
                                          width: 24,
                                          height: 24,
                                          borderRadius: '50%',
                                          color: '#ff4d4f',
                                          backgroundColor: 'transparent',
                                          transition: 'background-color 0.2s',
                                          cursor: 'pointer',
                                        }}
                                        onClick={(e) => {
                                          e.stopPropagation();
                                        }}
                                        onKeyDown={(e) => {
                                          if (
                                            e.key === 'Enter' ||
                                            e.key === ' '
                                          ) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            (
                                              e.currentTarget as HTMLElement
                                            ).click();
                                          }
                                        }}
                                        onMouseEnter={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'rgba(255, 77, 79, 0.08)';
                                        }}
                                        onMouseLeave={(e) => {
                                          e.currentTarget.style.backgroundColor =
                                            'transparent';
                                        }}>
                                        {deletingThreadId ===
                                        selectedThreadId ? (
                                          <LoadingOutlined
                                            style={{ fontSize: 12 }}
                                            spin
                                          />
                                        ) : (
                                          <DeleteOutlined />
                                        )}
                                      </span>
                                    </Popconfirm>
                                  </>
                                )}
                              </div>
                              {statusMeta && (
                                <Tag
                                  color={statusMeta.color}
                                  style={{
                                    margin: 0,
                                    borderRadius: 999,
                                    fontSize: '11px',
                                    lineHeight: '18px',
                                    padding: '0 8px',
                                    boxShadow:
                                      t?.status === ThreadDtoStatusEnum.Running
                                        ? '0 0 0 0 rgba(24, 144, 255, 0.45)'
                                        : 'none',
                                    animation:
                                      t?.status === ThreadDtoStatusEnum.Running
                                        ? 'thread-status-pulse 1.5s ease-out infinite'
                                        : undefined,
                                  }}>
                                  {statusMeta.label}
                                </Tag>
                              )}
                            </div>
                            <Typography.Text
                              type="secondary"
                              style={{ fontSize: '12px', lineHeight: 1.2 }}>
                              {t
                                ? `${new Date(t.createdAt).toLocaleString()} | ${t.source || 'unknown source'}`
                                : ''}
                            </Typography.Text>
                          </>
                        );
                      })()
                    ) : (
                      <>
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          No active thread.
                        </Typography.Text>
                        <Typography.Text
                          type="secondary"
                          style={{ fontSize: '12px', lineHeight: 1.2 }}>
                          It will be created automatically after first
                          execution.
                        </Typography.Text>
                      </>
                    )}
                  </div>
                </Popover>
              </div>
            </div>

            {(graph?.error || graphError) && (
              <Popover
                content={
                  <div style={{ maxWidth: 500 }}>
                    <div style={{ fontWeight: 'bold', marginBottom: 8 }}>
                      Graph Error:
                    </div>
                    <div>{graph?.error || graphError}</div>
                  </div>
                }
                title="Error Details"
                trigger="hover"
                color="#ffd7d9"
                placement="bottomRight">
                <ExclamationCircleOutlined
                  style={{
                    color: '#ff4d4f',
                    fontSize: 16,
                    cursor: 'pointer',
                  }}
                />
              </Popover>
            )}
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: 0,
              }}>
              {graph && (
                <Tooltip title="Open chats" placement="bottom">
                  <span
                    role="button"
                    aria-label="Open chats for this graph"
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 8,
                      color: '#cbcbcb',
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor: 'pointer',
                      transition: 'background-color 0.2s',
                    }}
                    onClick={() => navigate(`/chats?graphId=${graph.id}`)}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f0f0f0';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    <MessageFilled style={{ fontSize: 20 }} />
                  </span>
                </Tooltip>
              )}
              <Tooltip
                title={hasStructuralChanges ? 'Save (unsaved changes)' : 'Save'}
                placement="bottom">
                <Popover
                  content="You have unsaved changes"
                  title="Unsaved Changes"
                  open={hasStructuralChanges ? undefined : false}
                  trigger="hover">
                  <span
                    role="button"
                    aria-label="Save graph"
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 8,
                      color: hasStructuralChanges ? '#ffd421' : '#3085e0',
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor: saving ? 'progress' : 'pointer',
                      transition: 'background-color 0.2s',
                    }}
                    onClick={() => {
                      if (!saving) {
                        handleSave();
                      }
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f0f0f0';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    {saving ? (
                      <LoadingOutlined style={{ fontSize: 20 }} spin />
                    ) : (
                      <SaveFilled style={{ fontSize: 20 }} />
                    )}
                  </span>
                </Popover>
              </Tooltip>
              {graph && (
                <Tooltip
                  title={
                    isGraphRunning
                      ? 'Stop graph'
                      : isGraphCompiling
                        ? 'Compiling...'
                        : 'Run graph'
                  }
                  placement="bottom">
                  <span
                    role="button"
                    aria-label={
                      isGraphRunning ? 'Stop graph' : 'Start graph execution'
                    }
                    style={{
                      width: 36,
                      height: 36,
                      borderRadius: 8,
                      color: isGraphRunning ? '#ff4242' : '#52c41a',
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor:
                        actionLoading || isGraphCompiling
                          ? 'progress'
                          : 'pointer',
                      transition: 'background-color 0.2s',
                    }}
                    onClick={() => {
                      if (!actionLoading && !isGraphCompiling) {
                        handleGraphAction();
                      }
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#f0f0f0';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'transparent';
                    }}>
                    {actionLoading || isGraphCompiling ? (
                      <LoadingOutlined style={{ fontSize: 20 }} spin />
                    ) : isGraphRunning ? (
                      <XFilled style={{ fontSize: 20 }} />
                    ) : (
                      <PlayCircleFilled style={{ fontSize: 20 }} />
                    )}
                  </span>
                </Tooltip>
              )}
            </div>
          </div>
        </div>
      </Header>

      <Layout
        style={{
          height: 'calc(100vh - 135px)',
          overflow: 'hidden',
          position: 'relative',
        }}>
        {leftSidebarCollapsed && (
          <Button
            type="default"
            shape="circle"
            icon={<RightOutlined />}
            aria-label="Expand template sidebar"
            onClick={() => setLeftSidebarCollapsed(false)}
            style={{
              position: 'absolute',
              top: 16,
              left: 16,
              zIndex: 100,
              width: 36,
              height: 36,
              minWidth: 36,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              border: '1px solid #d9d9d9',
              background: '#fff',
            }}
          />
        )}
        <Sider
          width={280}
          collapsible={true}
          defaultCollapsed={false}
          collapsed={leftSidebarCollapsed}
          collapsedWidth={0}
          trigger={null}
          style={{
            background: '#fff',
            borderRight: '1px solid #f0f0f0',
            overflow: 'auto',
            height: '100%',
          }}>
          <TemplateSidebar
            onTemplateClick={handleTemplateClick}
            onClose={() => setLeftSidebarCollapsed(true)}
            templates={templates}
            selectedNode={selectedNode}
            allNodes={nodes}
          />
        </Sider>

        <Content
          style={{
            background: '#f5f5f5',
            height: '100%',
            overflow: 'hidden',
            minHeight: '500px',
          }}>
          <div
            style={{ height: '100%' }}
            onPointerDown={() => {
              userInteractedRef.current = true;
            }}
            onWheel={() => {
              userInteractedRef.current = true;
            }}>
            <GraphCanvas
              nodes={nodes}
              edges={edges}
              onNodesChange={handleNodesChange}
              onEdgesChange={handleEdgesChange}
              onNodeAdd={handleNodeAdd}
              onNodeEdit={handleNodeEdit}
              onNodeDelete={handleNodeDelete}
              onNodeSelect={handleNodeSelect}
              onViewportChange={handleViewportChange}
              initialViewport={viewport}
              templates={templates}
              graphStatus={graph?.status}
              onTriggerClick={handleTriggerClick}
              onValidationError={(error) => {
                message.error(`Connection validation failed: ${error}`);
              }}
              compiledNodes={compiledNodesMap}
              compiledNodesLoading={compiledNodesLoading}
            />
          </div>
        </Content>

        <NodeEditSidebar
          node={selectedNode}
          visible={nodeEditSidebarVisible}
          onClose={() => setNodeEditSidebarVisible(false)}
          onSave={handleNodeSave}
          templates={templates}
          graphStatus={graph?.status}
          onTriggerClick={handleTriggerClick}
          selectedThreadId={selectedThreadId}
          compiledNode={
            selectedNode ? compiledNodesMap[selectedNode.id] : undefined
          }
          compiledNodesLoading={compiledNodesLoading}
        messages={
            selectedThreadId && selectedNode?.id
              ? sharedMessages[selectedThreadId]?.[selectedNode.id] || []
              : selectedThreadId
                ? sharedMessages[selectedThreadId]?.['all'] || []
                : []
          }
        messagesLoading={
          selectedThreadId
            ? getMessageMeta(selectedThreadId, selectedNode?.id).loading
            : false
        }
        hasMoreMessages={
          selectedThreadId
            ? getMessageMeta(selectedThreadId, selectedNode?.id).hasMore
            : false
        }
        loadingMoreMessages={
          selectedThreadId
            ? getMessageMeta(selectedThreadId, selectedNode?.id).loadingMore
            : false
        }
        pendingMessages={
            selectedThreadId && selectedNode?.id
              ? sharedPendingMessages[selectedThreadId]?.[selectedNode.id] || []
              : selectedThreadId
                ? sharedPendingMessages[selectedThreadId]?.['all'] || []
                : []
          }
        onLoadMoreMessages={
          selectedThreadId
            ? () => loadMoreMessagesForScope(selectedThreadId, selectedNode?.id)
            : undefined
        }
        onRefreshMessages={
          selectedThreadId
            ? () => loadMessagesForScope(selectedThreadId, selectedNode?.id, true)
            : undefined
        }
        onUpdateSharedMessages={updateSharedMessages}
        />
      </Layout>

      <TemplateModal
        template={selectedTemplate}
        visible={templateModalVisible}
        onClose={() => setTemplateModalVisible(false)}
        allTemplates={templates}
      />

      <TriggerModal
        visible={triggerModalVisible}
        onCancel={() => {
          setTriggerModalVisible(false);
          setTriggerNodeId(null);
          setTriggerNodeName(null);
          triggerStartedRef.current = false;
          pendingThreadSelectionRef.current = null;
        }}
        onTrigger={handleTriggerNode}
        nodeId={triggerNodeId || undefined}
        nodeName={triggerNodeName || undefined}
        loading={triggerLoading}
        selectedThreadId={selectedThreadId}
        selectedThreadName={
          threads.find((t) => t.id === selectedThreadId)?.name ?? null
        }
        selectedThreadSource={
          threads.find((t) => t.id === selectedThreadId)?.source ?? null
        }
      />

      <Modal
        open={Boolean(chatThread && graph)}
        onCancel={handleCloseThreadChat}
        footer={null}
        width={900}
        bodyStyle={{
          height: '70vh',
          display: 'flex',
          flexDirection: 'column',
        }}
        title={
          chatThread ? (
            <Typography.Text
              ellipsis={{
                tooltip: `Thread chat â€” ${
                  chatThread.name || chatThread.id.slice(-6)
                }`,
              }}
              style={{
                display: 'inline-block',
                maxWidth: 'calc(100% - 64px)',
              }}>
              {`Thread chat â€” ${chatThread.name || chatThread.id.slice(-6)}`}
            </Typography.Text>
          ) : undefined
        }
        destroyOnClose>
        {chatThread && graph ? (
          <ThreadChatPanel
            graphId={graph.id}
            thread={chatThread}
            triggerNodes={triggerNodesForGraph}
            nodeDisplayNames={nodeDisplayNames}
            graphLoaded
          messages={sharedMessages[chatThread.id]?.['all'] || []}
          messagesLoading={getMessageMeta(chatThread.id, undefined).loading}
          hasMoreMessages={getMessageMeta(chatThread.id, undefined).hasMore}
          loadingMoreMessages={
            getMessageMeta(chatThread.id, undefined).loadingMore
          }
          pendingMessages={sharedPendingMessages[chatThread.id]?.['all'] || []}
          externalThreadId={sharedExternalThreadIds[chatThread.id]}
          onLoadMoreMessages={() =>
            loadMoreMessagesForScope(chatThread.id, undefined)
          }
            onUpdateSharedMessages={updateSharedMessages}
            onUpdateSharedPendingMessages={updateSharedPendingMessages}
          />
        ) : null}
      </Modal>

      <Modal
        open={revisionDiffModalVisible}
        onCancel={handleCloseRevisionDiff}
        footer={null}
        title={
          revisionDiffRevision
            ? `Revision v${revisionDiffRevision.toVersion} diff`
            : 'Revision diff'
        }
        width={640}
        destroyOnClose>
        {revisionDiffRevision ? (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            {revisionDiffRevision.configurationDiff.length === 0 ? (
              <Typography.Text type="secondary">
                No configuration changes.
              </Typography.Text>
            ) : (
              revisionDiffRevision.configurationDiff.map((operation, index) => {
                const meta = REVISION_DIFF_OP_META[operation.op] ?? {
                  label: operation.op,
                  color: '#d9d9d9',
                };
                const key = `${operation.op}-${operation.path}-${index}`;
                const value =
                  (operation as { value?: unknown }).value ?? undefined;
                const fromPath =
                  (operation as { from?: string }).from ?? undefined;
                return (
                  <div
                    key={key}
                    style={{
                      border: '1px solid #f0f0f0',
                      borderLeft: `4px solid ${meta.color}`,
                      borderRadius: 6,
                      padding: '12px 14px',
                      background: '#fafafa',
                    }}>
                    <Space
                      direction="vertical"
                      size={6}
                      style={{ width: '100%' }}>
                      <Space
                        align="center"
                        wrap
                        style={{ justifyContent: 'space-between' }}>
                        <Tag
                          color={meta.color}
                          style={{
                            margin: 0,
                            fontSize: 11,
                            padding: '0 10px',
                          }}>
                          {meta.label}
                        </Tag>
                        <Typography.Text code style={{ fontSize: 12 }}>
                          {operation.path || '(root)'}
                        </Typography.Text>
                      </Space>
                      {fromPath ? (
                        <Typography.Text style={{ fontSize: 12 }}>
                          From{' '}
                          <Typography.Text code>{fromPath}</Typography.Text>
                        </Typography.Text>
                      ) : null}
                      {value !== undefined
                        ? formatRevisionDiffValue(value)
                        : null}
                    </Space>
                  </div>
                );
              })
            )}
            {revisionDiffRevision.error && (
              <Typography.Text type="danger">
                Error: {revisionDiffRevision.error}
              </Typography.Text>
            )}
          </Space>
        ) : null}
      </Modal>
    </Layout>
  );
};
