import { useEffect, useState, useCallback, useRef } from 'react';
import { useParams, useNavigate } from 'react-router';
import { Layout, Button, message, Spin, Typography, Input } from 'antd';
import {
  SaveOutlined,
  ArrowLeftOutlined,
  EditOutlined,
  CheckOutlined,
  CloseOutlined,
  HomeOutlined,
  WarningOutlined,
} from '@ant-design/icons';
import { useNodesState, useEdgesState, Viewport } from '@xyflow/react';
import { graphsApi, templatesApi } from '../../api';
import type {
  GraphDto,
  TemplateDto,
  CreateGraphDtoSchemaNodesInner,
  CreateGraphDtoSchemaEdgesInner,
} from '../../autogenerated';
import { TemplateSidebar } from './components/TemplateSidebar';
import { TemplateModal } from './components/TemplateModal';
import { NodeEditSidebar } from './components/NodeEditSidebar';
import {
  GraphCanvas,
  resolveHandlesForNodes,
  createEdge,
} from './components/GraphCanvas';
import { GraphStorageService } from '../../services/GraphStorageService';
import type {
  GraphNode,
  GraphEdge,
  GraphMetadata,
  NodeMetadata,
  GraphNodeData,
} from './types';

const { Header, Sider, Content } = Layout;
const { Title } = Typography;

export const GraphPage = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [graph, setGraph] = useState<GraphDto | null>(null);
  const [nodes, setNodes, onNodesChange] = useNodesState<GraphNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<GraphEdge>([]);
  const [viewport, setViewport] = useState<Viewport>({ x: 0, y: 0, zoom: 1 });
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const isHydratingRef = useRef(true);
  const userInteractedRef = useRef(false);

  // Refs to track current state for localStorage
  const nodesRef = useRef<GraphNode[]>([]);
  const edgesRef = useRef<GraphEdge[]>([]);
  const viewportRef = useRef<Viewport>({ x: 0, y: 0, zoom: 1 });

  const [selectedTemplate, setSelectedTemplate] = useState<TemplateDto | null>(
    null,
  );
  const [templateModalVisible, setTemplateModalVisible] = useState(false);

  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [nodeEditSidebarVisible, setNodeEditSidebarVisible] = useState(false);
  const [templates, setTemplates] = useState<TemplateDto[]>([]);

  const [isEditingName, setIsEditingName] = useState(false);
  const [editingName, setEditingName] = useState('');

  // Load graph data
  useEffect(() => {
    if (!id) return;

    let mounted = true;
    (async () => {
      try {
        // Fetch templates first
        const templatesRes = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templatesList = templatesRes.data || [];
        setTemplates(templatesList);

        const res = await graphsApi.findGraphById(id);
        if (!mounted) return;

        const graphData = res.data;
        setGraph(graphData);
        setEditingName(graphData.name);

        // Get metadata for node positions and names
        const metadata = (graphData.metadata as GraphMetadata) || {};
        const nodeMetadata = metadata.nodes || [];

        // Set viewport from metadata
        if (
          metadata.x !== undefined &&
          metadata.y !== undefined &&
          metadata.zoom !== undefined
        ) {
          const savedViewport = {
            x: metadata.x,
            y: metadata.y,
            zoom: metadata.zoom,
          };
          setViewport(savedViewport);
          viewportRef.current = savedViewport;
        }

        // Create a lookup map for node metadata
        const nodeMetadataMap = nodeMetadata.reduce(
          (acc, nodeMeta) => {
            acc[nodeMeta.id] = nodeMeta;
            return acc;
          },
          {} as Record<string, NodeMetadata>,
        );

        // Convert API nodes to React Flow nodes
        const apiNodes = graphData.schema?.nodes || [];
        const reactFlowNodes: GraphNode[] = apiNodes.map((node, index) => {
          const nodeMeta = nodeMetadataMap[node.id];
          const template = templatesList.find((t) => t.name === node.template);
          return {
            id: node.id,
            type: 'custom',
            position: nodeMeta
              ? { x: nodeMeta.x, y: nodeMeta.y }
              : {
                  x: 100 + (index % 3) * 250,
                  y: 100 + Math.floor(index / 3) * 150,
                },
            data: {
              label: nodeMeta?.name || node.template,
              template: node.template,
              templateKind: template?.kind,
              templateSchema: template?.schema,
              config: node.config || {},
            },
          };
        });
        setNodes(reactFlowNodes);
        nodesRef.current = reactFlowNodes;

        const nodeById: Record<string, GraphNode> = Object.fromEntries(
          reactFlowNodes.map((n) => [n.id, n]),
        );

        // Convert API edges to React Flow edges
        const apiEdges = graphData.schema?.edges || [];
        const reactFlowEdges: GraphEdge[] = apiEdges.map((edge) => {
          const src = nodeById[edge.from];
          const dst = nodeById[edge.to];
          const { sourceHandle, targetHandle } = resolveHandlesForNodes(
            src,
            dst,
            templatesList,
          );
          return createEdge(
            edge.from,
            edge.to,
            sourceHandle,
            targetHandle,
            typeof edge.label === 'string' ? edge.label : undefined,
          );
        });
        setEdges(reactFlowEdges);
        edgesRef.current = reactFlowEdges;

        // Check if we have saved state in localStorage
        const savedState = GraphStorageService.loadGraphState(id);
        if (savedState) {
          // Ensure all nodes have template information
          const nodesWithTemplates = savedState.nodes.map((node) => {
            if (!node.data.templateKind || !node.data.templateSchema) {
                const template = templatesList.find(
                  (t) =>
                    t.name === (node.data as unknown as GraphNodeData).template,
                );

              if (template) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    templateKind: template.kind,
                    templateSchema: template.schema,
                  },
                };
              }
            }
            return node;
          });

          // Restore from localStorage
          setNodes(nodesWithTemplates);
          const nodeByIdRestored: Record<string, GraphNode> =
            Object.fromEntries(nodesWithTemplates.map((n) => [n.id, n]));
          const restoredEdges: GraphEdge[] = savedState.edges.map((e) => {
            const src = nodeByIdRestored[e.source];
            const dst = nodeByIdRestored[e.target];
            const { sourceHandle, targetHandle } = resolveHandlesForNodes(
              src,
              dst,
              templatesList,
            );
            return createEdge(
              e.source,
              e.target,
              sourceHandle ?? e.sourceHandle ?? undefined,
              targetHandle ?? e.targetHandle ?? undefined,
              typeof e.label === 'string' ? e.label : undefined,
            );
          });
          setEdges(restoredEdges);
          setViewport(savedState.viewport);
          // Update refs with restored state
          nodesRef.current = nodesWithTemplates;
          edgesRef.current = restoredEdges;
          viewportRef.current = savedState.viewport;
          setHasUnsavedChanges(!!savedState.dirty);
        } else {
          // Reset unsaved changes flag after loading from server
          setHasUnsavedChanges(false);
        }
      } catch (e) {
        console.error('Error fetching graph:', e);
        message.error('Failed to load graph');
        navigate('/');
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [id, navigate]);

  useEffect(() => {
    if (!loading) {
      const t = requestAnimationFrame(() => {
        isHydratingRef.current = false;
      });
      return () => cancelAnimationFrame(t);
    }
  }, [loading]);

  useEffect(() => {
    nodesRef.current = nodes;
  }, [nodes]);

  useEffect(() => {
    edgesRef.current = edges;
  }, [edges]);

  const handleTemplateClick = useCallback((template: TemplateDto) => {
    setSelectedTemplate(template);
    setTemplateModalVisible(true);
  }, []);

  const handleNodeAdd = useCallback(
    (node: GraphNode) => {
      setNodes((nds) => {
        const newNodes = nds.concat(node);
        nodesRef.current = newNodes;
        setHasUnsavedChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: newNodes,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
          });
        }
        return newNodes;
      });
    },
    [setNodes, id],
  );

  const handleNodeEdit = useCallback((node: GraphNode) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(true);
  }, []);

  const handleNodeSelect = useCallback((node: GraphNode | null) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(!!node);
  }, []);

  const handleNodeSave = useCallback(
    (
      nodeId: string,
      updates: { name?: string; config?: Record<string, unknown> },
    ) => {
      setNodes((prevNodes) => {
        const updatedNodes = prevNodes.map((node) => {
          if (node.id === nodeId) {
            const nodeData = node.data;
            return {
              ...node,
              data: {
                ...nodeData,
                label: updates.name ?? nodeData.label,
                config: updates.config ?? nodeData.config,
              },
            };
          }
          return node;
        });
        nodesRef.current = updatedNodes;
        setHasUnsavedChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: updatedNodes,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
          });
        }
        return updatedNodes;
      });
    },
    [setNodes, id],
  );

  const handleNodeDelete = useCallback(
    (nodeId: string) => {
      setNodes((prevNodes) => {
        const newNodes = prevNodes.filter((node) => node.id !== nodeId);
        nodesRef.current = newNodes;
        setHasUnsavedChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: newNodes,
            edges: edgesRef.current.filter(
              (edge) => edge.source !== nodeId && edge.target !== nodeId,
            ),
            viewport: viewportRef.current,
            dirty: true,
          });
        }
        return newNodes;
      });
      setEdges((prevEdges) => {
        const newEdges = prevEdges.filter(
          (edge) => edge.source !== nodeId && edge.target !== nodeId,
        );
        edgesRef.current = newEdges;
        return newEdges;
      });
    },
    [setNodes, setEdges, id],
  );

  const handleViewportChange = useCallback(
    (newViewport: Viewport) => {
      setViewport(newViewport);
      viewportRef.current = newViewport;
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      if (id) {
        GraphStorageService.saveGraphState(id, {
          nodes: nodesRef.current,
          edges: edgesRef.current,
          viewport: newViewport,
          dirty: true,
        });
      }
    },
    [id],
  );

  const handleNodesChange = useCallback(
    (changes: Parameters<typeof onNodesChange>[0]) => {
      onNodesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      if (id) {
        setTimeout(() => {
          GraphStorageService.saveGraphState(id, {
            nodes: nodesRef.current,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
          });
        }, 100);
      }
    },
    [onNodesChange, id],
  );

  const handleEdgesChange = useCallback(
    (changes: Parameters<typeof onEdgesChange>[0]) => {
      onEdgesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      if (id) {
        setTimeout(() => {
          GraphStorageService.saveGraphState(id, {
            nodes: nodesRef.current,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
          });
        }, 100);
      }
    },
    [onEdgesChange, id],
  );

  const handleSave = async () => {
    if (!graph || !id) return;

    setSaving(true);
    try {
      const apiNodes: CreateGraphDtoSchemaNodesInner[] = nodes.map((node) => ({
        id: node.id,
        template: node.data.template as string,
        config: node.data.config as Record<string, unknown>,
      }));

      const apiEdges: CreateGraphDtoSchemaEdgesInner[] = edges.map((edge) => ({
        from: edge.source,
        to: edge.target,
        label: typeof edge.label === 'string' ? edge.label : undefined,
      }));

      const nodeMetadata: NodeMetadata[] = nodes.map((node) => ({
        id: node.id,
        x: node.position.x,
        y: node.position.y,
        name: node.data.label as string,
      }));

      const metadata: GraphMetadata = {
        ...((graph.metadata as GraphMetadata) || {}),
        nodes: nodeMetadata,
        x: viewport.x,
        y: viewport.y,
        zoom: viewport.zoom,
      };

      await graphsApi.updateGraph(id, {
        name: graph.name,
        description: graph.description,
        version: graph.version,
        schema: {
          nodes: apiNodes,
          edges: apiEdges,
        },
        metadata: metadata,
      });

      message.success('Graph saved successfully');
      setHasUnsavedChanges(false);
      if (id) {
        GraphStorageService.clearGraphState(id);
      }
      setNodes(nodes);
      setEdges(edges);
      setViewport(viewport);
      userInteractedRef.current = false;
    } catch (e: unknown) {
      console.error('Error saving graph:', e);
      const errorMessage =
        e instanceof Error ? e.message : 'Failed to save graph';
      message.error(errorMessage);
    } finally {
      setSaving(false);
    }
  };

  const handleNameEdit = () => {
    setIsEditingName(true);
  };

  const handleNameSave = async () => {
    if (!graph || !id) return;

    try {
      await graphsApi.updateGraph(id, {
        name: editingName,
        description: graph.description,
        version: graph.version,
        schema: graph.schema,
        metadata: graph.metadata,
      });

      setGraph({ ...graph, name: editingName });
      setIsEditingName(false);
      message.success('Graph name updated');
    } catch (e: unknown) {
      console.error('Error updating graph name:', e);
      const errorMessage =
        e instanceof Error ? e.message : 'Failed to update graph name';
      message.error(errorMessage);
      setEditingName(graph.name);
    }
  };

  const handleNameCancel = () => {
    setEditingName(graph?.name || '');
    setIsEditingName(false);
  };

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Layout style={{ overflow: 'hidden' }}>
      <Header
        style={{
          background: '#fff',
          padding: '0 24px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          borderBottom: '1px solid #f0f0f0',
          flexShrink: 0,
        }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: 16 }}>
          <Button
            type="text"
            icon={<ArrowLeftOutlined />}
            onClick={() => navigate('/')}>
            Back
          </Button>
          {isEditingName ? (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <Input
                value={editingName}
                onChange={(e) => setEditingName(e.target.value)}
                onPressEnter={handleNameSave}
                onBlur={handleNameSave}
                autoFocus
                style={{ width: 300 }}
              />
              <Button
                type="text"
                icon={<CheckOutlined />}
                onClick={handleNameSave}
                size="small"
              />
              <Button
                type="text"
                icon={<CloseOutlined />}
                onClick={handleNameCancel}
                size="small"
              />
            </div>
          ) : (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <Title level={4} style={{ margin: 0 }}>
                {graph?.name || 'Graph Editor'}
              </Title>
              <Button
                type="text"
                icon={<EditOutlined />}
                onClick={handleNameEdit}
                size="small"
              />
            </div>
          )}
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
          {hasUnsavedChanges && (
            <div
              style={{
                color: '#ffb431',
                fontSize: 11,
                fontWeight: 500,
                display: 'flex',
                alignItems: 'center',
                gap: 4,
              }}>
              <WarningOutlined />
              Unsaved changes
            </div>
          )}
          <Button
            type="primary"
            icon={<SaveOutlined />}
            onClick={handleSave}
            loading={saving}>
            Save
          </Button>
        </div>
      </Header>

      <Layout style={{ height: 'calc(100vh - 173px)', overflow: 'hidden' }}>
        <Sider
          width={280}
          style={{
            background: '#fff',
            borderRight: '1px solid #f0f0f0',
            overflow: 'auto',
            height: '100%',
          }}>
          <TemplateSidebar
            onTemplateClick={handleTemplateClick}
            templates={templates}
            selectedNode={selectedNode}
            allNodes={nodes}
          />
        </Sider>

        <Content
          style={{
            background: '#f5f5f5',
            height: '100%',
            overflow: 'hidden',
            minHeight: '500px',
          }}>
          <div
            style={{ height: '100%' }}
            onPointerDown={() => {
              userInteractedRef.current = true;
            }}
            onWheel={() => {
              userInteractedRef.current = true;
            }}>
            <GraphCanvas
              nodes={nodes}
              edges={edges}
              onNodesChange={handleNodesChange}
              onEdgesChange={handleEdgesChange}
              onNodeAdd={handleNodeAdd}
              onNodeEdit={handleNodeEdit}
              onNodeDelete={handleNodeDelete}
              onNodeSelect={handleNodeSelect}
              onViewportChange={handleViewportChange}
              initialViewport={viewport}
              templates={templates}
              onValidationError={(error) => {
                message.error(`Connection validation failed: ${error}`);
              }}
            />
          </div>
        </Content>

        <NodeEditSidebar
          node={selectedNode}
          visible={nodeEditSidebarVisible}
          onClose={() => setNodeEditSidebarVisible(false)}
          onSave={handleNodeSave}
          templates={templates}
        />
      </Layout>

      <TemplateModal
        template={selectedTemplate}
        visible={templateModalVisible}
        onClose={() => setTemplateModalVisible(false)}
        allTemplates={templates}
      />
    </Layout>
  );
};
