import { useCallback, useEffect, useRef, useState } from 'react';
import { useNavigate, useParams } from 'react-router';
import {
  Button,
  Input,
  Layout,
  message,
  Popover,
  Popconfirm,
  Space,
  Spin,
  Typography,
  Tooltip,
} from 'antd';
import {
  ArrowLeftOutlined,
  CheckOutlined,
  CloseOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  PlayCircleOutlined,
  SaveOutlined,
  StopOutlined,
  WarningOutlined,
  DeleteOutlined,
} from '@ant-design/icons';
import { useEdgesState, useNodesState, Viewport } from '@xyflow/react';
import { graphsApi, templatesApi, threadsApi } from '../../api';
import {
  CreateGraphDtoSchemaEdgesInner,
  CreateGraphDtoSchemaNodesInner,
  ExecuteTriggerDto,
  GraphDto,
  TemplateDto,
  ThreadDto,
} from '../../autogenerated';
import { TemplateSidebar } from './components/TemplateSidebar';
import { TemplateModal } from './components/TemplateModal';
import { NodeEditSidebar } from './components/NodeEditSidebar';
import { TriggerModal } from './components/TriggerModal';
import {
  createEdge,
  GraphCanvas,
  resolveHandlesForNodes,
} from './components/GraphCanvas';
import { GraphStorageService } from '../../services/GraphStorageService';
import type {
  GraphEdge,
  GraphMetadata,
  GraphNode,
  GraphNodeData,
  NodeMetadata,
} from './types';

const { Header, Sider, Content } = Layout;
const { Title } = Typography;

export const GraphPage = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [graph, setGraph] = useState<GraphDto | null>(null);
  const [nodes, setNodes, onNodesChange] = useNodesState<GraphNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<GraphEdge>([]);
  const [viewport, setViewport] = useState<Viewport>({ x: 0, y: 0, zoom: 1 });
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [hasStructuralChanges, setHasStructuralChanges] = useState(false);
  const [hasPositionChanges, setHasPositionChanges] = useState(false);
  const isHydratingRef = useRef(true);
  const userInteractedRef = useRef(false);

  const nodesRef = useRef<GraphNode[]>([]);
  const edgesRef = useRef<GraphEdge[]>([]);
  const viewportRef = useRef<Viewport>({ x: 0, y: 0, zoom: 1 });

  const [selectedTemplate, setSelectedTemplate] = useState<TemplateDto | null>(
    null,
  );
  const [templateModalVisible, setTemplateModalVisible] = useState(false);

  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [nodeEditSidebarVisible, setNodeEditSidebarVisible] = useState(false);
  const [templates, setTemplates] = useState<TemplateDto[]>([]);

  const [triggerModalVisible, setTriggerModalVisible] = useState(false);
  const [triggerNodeId, setTriggerNodeId] = useState<string | null>(null);
  const [triggerNodeName, setTriggerNodeName] = useState<string | null>(null);
  const [triggerLoading, setTriggerLoading] = useState(false);
  const triggerStartedRef = useRef(false);

  const [isEditingName, setIsEditingName] = useState(false);
  const [editingName, setEditingName] = useState('');

  const [actionLoading, setActionLoading] = useState(false);
  const [graphError, setGraphError] = useState<string | null>(null);

  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [selectedThreadId, setSelectedThreadId] = useState<
    string | undefined
  >();
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadPopoverVisible, setThreadPopoverVisible] = useState(false);
  const [deletingThreadId, setDeletingThreadId] = useState<string | null>(null);

  useEffect(() => {
    if (!id) return;

    let mounted = true;
    (async () => {
      try {
        const templatesRes = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templatesList = templatesRes.data || [];
        setTemplates(templatesList);

        const res = await graphsApi.findGraphById(id);
        if (!mounted) return;

        const graphData = res.data;
        setGraph(graphData);
        setEditingName(graphData.name);

        const metadata = (graphData.metadata as GraphMetadata) || {};
        const nodeMetadata = metadata.nodes || [];

        if (
          metadata.x !== undefined &&
          metadata.y !== undefined &&
          metadata.zoom !== undefined
        ) {
          const savedViewport = {
            x: metadata.x,
            y: metadata.y,
            zoom: metadata.zoom,
          };
          setViewport(savedViewport);
          viewportRef.current = savedViewport;
        }

        const nodeMetadataMap = nodeMetadata.reduce(
          (acc, nodeMeta) => {
            acc[nodeMeta.id] = nodeMeta;
            return acc;
          },
          {} as Record<string, NodeMetadata>,
        );

        const apiNodes = graphData.schema?.nodes || [];
        const reactFlowNodes: GraphNode[] = apiNodes.map((node, index) => {
          const nodeMeta = nodeMetadataMap[node.id];
          const template = templatesList.find((t) => t.name === node.template);
          return {
            id: node.id,
            type: 'custom',
            position: nodeMeta
              ? { x: nodeMeta.x, y: nodeMeta.y }
              : {
                  x: 100 + (index % 3) * 250,
                  y: 100 + Math.floor(index / 3) * 150,
                },
            data: {
              label: nodeMeta?.name || node.template,
              template: node.template,
              templateKind: template?.kind,
              templateSchema: template?.schema,
              config: node.config || {},
            },
          };
        });
        setNodes(reactFlowNodes);
        nodesRef.current = reactFlowNodes;

        const nodeById: Record<string, GraphNode> = Object.fromEntries(
          reactFlowNodes.map((n) => [n.id, n]),
        );

        const apiEdges = graphData.schema?.edges || [];
        const reactFlowEdges: GraphEdge[] = apiEdges.map((edge) => {
          const src = nodeById[edge.from];
          const dst = nodeById[edge.to];
          const { sourceHandle, targetHandle } = resolveHandlesForNodes(
            src,
            dst,
            templatesList,
          );
          return createEdge(
            edge.from,
            edge.to,
            sourceHandle,
            targetHandle,
            typeof edge.label === 'string' ? edge.label : undefined,
          );
        });
        setEdges(reactFlowEdges);
        edgesRef.current = reactFlowEdges;

        const savedState = GraphStorageService.loadGraphState(id);
        if (savedState) {
          const nodesWithTemplates = savedState.nodes.map((node) => {
            if (!node.data.templateKind || !node.data.templateSchema) {
              const template = templatesList.find(
                (t) =>
                  t.name === (node.data as unknown as GraphNodeData).template,
              );

              if (template) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    templateKind: template.kind,
                    templateSchema: template.schema,
                  },
                };
              }
            }
            return node;
          });

          setNodes(nodesWithTemplates);
          const nodeByIdRestored: Record<string, GraphNode> =
            Object.fromEntries(nodesWithTemplates.map((n) => [n.id, n]));
          const restoredEdges: GraphEdge[] = savedState.edges.map((e) => {
            const src = nodeByIdRestored[e.source];
            const dst = nodeByIdRestored[e.target];
            const { sourceHandle, targetHandle } = resolveHandlesForNodes(
              src,
              dst,
              templatesList,
            );
            return createEdge(
              e.source,
              e.target,
              sourceHandle ?? e.sourceHandle ?? undefined,
              targetHandle ?? e.targetHandle ?? undefined,
              typeof e.label === 'string' ? e.label : undefined,
            );
          });
          setEdges(restoredEdges);
          setViewport(savedState.viewport);

          nodesRef.current = nodesWithTemplates;
          edgesRef.current = restoredEdges;
          viewportRef.current = savedState.viewport;
          setHasUnsavedChanges(!!savedState.dirty);
          setHasStructuralChanges(!!savedState.hasStructuralChanges);
          setHasPositionChanges(!!savedState.hasPositionChanges);

          if (savedState.selectedThreadId) {
            setSelectedThreadId(savedState.selectedThreadId);
          }
        } else {
          setHasUnsavedChanges(false);
          setHasStructuralChanges(false);
          setHasPositionChanges(false);
        }
      } catch (e) {
        console.error('Error fetching graph:', e);
        message.error('Failed to load graph');
        navigate('/');
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [id, navigate]);

  const loadThreads = useCallback(async () => {
    if (!id) return;

    try {
      setThreadsLoading(true);
      const response = await threadsApi.getThreads(id, 100, 0);
      setThreads(response.data || []);
    } catch (error) {
      console.error('Error loading threads:', error);
      message.error('Failed to load threads');
      setThreads([]);
    } finally {
      setThreadsLoading(false);
    }
  }, [id]);

  useEffect(() => {
    loadThreads();
  }, [loadThreads]);

  useEffect(() => {
    if (!loading) {
      const t = requestAnimationFrame(() => {
        isHydratingRef.current = false;
      });
      return () => cancelAnimationFrame(t);
    }
  }, [loading]);

  useEffect(() => {
    nodesRef.current = nodes;
  }, [nodes]);

  useEffect(() => {
    edgesRef.current = edges;
  }, [edges]);

  const handleTemplateClick = useCallback((template: TemplateDto) => {
    setSelectedTemplate(template);
    setTemplateModalVisible(true);
  }, []);

  const handleNodeAdd = useCallback(
    (node: GraphNode) => {
      setNodes((nds) => {
        const newNodes = nds.concat(node);
        nodesRef.current = newNodes;
        setHasUnsavedChanges(true);
        setHasStructuralChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: newNodes,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }
        return newNodes;
      });
    },
    [setNodes, id, hasPositionChanges, selectedThreadId],
  );

  const handleNodeEdit = useCallback((node: GraphNode) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(true);
  }, []);

  const handleNodeSelect = useCallback((node: GraphNode | null) => {
    setSelectedNode(node);
    setNodeEditSidebarVisible(!!node);
  }, []);

  const handleNodeSave = useCallback(
    (
      nodeId: string,
      updates: { name?: string; config?: Record<string, unknown> },
    ) => {
      setNodes((prevNodes) => {
        const updatedNodes = prevNodes.map((node) => {
          if (node.id === nodeId) {
            const nodeData = node.data;
            return {
              ...node,
              data: {
                ...nodeData,
                label: updates.name ?? nodeData.label,
                config: updates.config ?? nodeData.config,
              },
            };
          }
          return node;
        });
        nodesRef.current = updatedNodes;
        setHasUnsavedChanges(true);
        setHasStructuralChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: updatedNodes,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }
        return updatedNodes;
      });
    },
    [setNodes, id, hasPositionChanges, selectedThreadId],
  );

  const handleNodeDelete = useCallback(
    (nodeId: string) => {
      setNodes((prevNodes) => {
        const newNodes = prevNodes.filter((node) => node.id !== nodeId);
        nodesRef.current = newNodes;
        setHasUnsavedChanges(true);
        setHasStructuralChanges(true);
        if (id) {
          GraphStorageService.saveGraphState(id, {
            nodes: newNodes,
            edges: edgesRef.current.filter(
              (edge) => edge.source !== nodeId && edge.target !== nodeId,
            ),
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }
        return newNodes;
      });
      setEdges((prevEdges) => {
        const newEdges = prevEdges.filter(
          (edge) => edge.source !== nodeId && edge.target !== nodeId,
        );
        edgesRef.current = newEdges;
        return newEdges;
      });
    },
    [setNodes, setEdges, id, hasPositionChanges, selectedThreadId],
  );

  const handleTriggerClick = useCallback(
    (nodeId: string) => {
      const node = nodes.find((n) => n.id === nodeId);
      if (node) {
        setTriggerNodeId(nodeId);
        setTriggerNodeName(node.data.label as string);
        setTriggerModalVisible(true);
      }
    },
    [nodes],
  );

  const handleThreadChange = useCallback(
    (newThreadId: string | undefined) => {
      setSelectedThreadId(newThreadId);

      if (id) {
        GraphStorageService.saveGraphState(id, {
          nodes: nodesRef.current,
          edges: edgesRef.current,
          viewport: viewportRef.current,
          dirty: hasUnsavedChanges,
          hasStructuralChanges: hasStructuralChanges,
          hasPositionChanges: hasPositionChanges,
          selectedThreadId: newThreadId,
        });
      }
    },
    [id, hasUnsavedChanges, hasStructuralChanges, hasPositionChanges],
  );

  const handleThreadSelect = useCallback(
    (newThreadId: string | undefined) => {
      handleThreadChange(newThreadId);
      setThreadPopoverVisible(false);
    },
    [handleThreadChange],
  );

  const handleTriggerNode = useCallback(
    async (triggerMessage: string, selectedThreadId?: string) => {
      if (!triggerNodeId || !id) return;

      try {
        triggerStartedRef.current = true;
        setTriggerLoading(true);

        await handleSave();

        const selectedThread = threads.find((t) => t.id === selectedThreadId);
        const parts = selectedThread?.externalThreadId.split(':') || [];
        const finalThreadSubId = parts[parts.length - 1];

        const executeTriggerDto: ExecuteTriggerDto = {
          messages: [triggerMessage],
          threadSubId: finalThreadSubId,
          async: true,
        };

        await graphsApi.executeTrigger(id, triggerNodeId, executeTriggerDto);
        message.success('Trigger sent successfully');
        setTriggerModalVisible(false);
        setTriggerNodeId(null);
        setTriggerNodeName(null);

        if (selectedThreadId === undefined) {
          try {
            const response = await threadsApi.getThreads(id, 100, 0);
            const updatedThreads = response.data || [];
            setThreads(updatedThreads);

            if (updatedThreads.length > 0) {
              setSelectedThreadId(updatedThreads[0].id);
            }
          } catch (error) {
            console.error('Error refreshing threads:', error);
          }
        }
      } catch (error) {
        console.error('Error triggering node:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to trigger node';
        message.error(errorMessage);
        throw error;
      } finally {
        setTriggerLoading(false);
      }
    },
    [triggerNodeId, id, threads, selectedThreadId],
  );

  const handleViewportChange = useCallback(
    (newViewport: Viewport) => {
      setViewport(newViewport);
      viewportRef.current = newViewport;
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      setHasPositionChanges(true);
      if (id) {
        GraphStorageService.saveGraphState(id, {
          nodes: nodesRef.current,
          edges: edgesRef.current,
          viewport: newViewport,
          dirty: true,
          hasStructuralChanges: hasStructuralChanges,
          hasPositionChanges: true,
          selectedThreadId: selectedThreadId,
        });
      }
    },
    [id, hasStructuralChanges, selectedThreadId],
  );

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        setDeletingThreadId(threadId);
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          handleThreadChange(undefined);
        }
        setThreadPopoverVisible(false);
        message.success('Thread deleted');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to delete thread';
        message.error(errorMessage);
      } finally {
        setDeletingThreadId(null);
      }
    },
    [handleThreadChange, selectedThreadId],
  );

  const handleNodesChange = useCallback(
    (changes: Parameters<typeof onNodesChange>[0]) => {
      onNodesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      setHasPositionChanges(true);
      if (id) {
        setTimeout(() => {
          GraphStorageService.saveGraphState(id, {
            nodes: nodesRef.current,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: hasStructuralChanges,
            hasPositionChanges: true,
            selectedThreadId: selectedThreadId,
          });
        }, 100);
      }
    },
    [onNodesChange, id, hasStructuralChanges, selectedThreadId],
  );

  const handleEdgesChange = useCallback(
    (changes: Parameters<typeof onEdgesChange>[0]) => {
      onEdgesChange(changes);
      if (isHydratingRef.current) {
        return;
      }
      if (!userInteractedRef.current) {
        return;
      }
      setHasUnsavedChanges(true);
      setHasStructuralChanges(true);
      if (id) {
        setTimeout(() => {
          GraphStorageService.saveGraphState(id, {
            nodes: nodesRef.current,
            edges: edgesRef.current,
            viewport: viewportRef.current,
            dirty: true,
            hasStructuralChanges: true,
            hasPositionChanges: hasPositionChanges,
            selectedThreadId: selectedThreadId,
          });
        }, 100);
      }
    },
    [onEdgesChange, id, hasPositionChanges, selectedThreadId],
  );

  const handleSave = async () => {
    if (!graph || !id) return;

    setSaving(true);
    try {
      const apiNodes: CreateGraphDtoSchemaNodesInner[] = nodes.map((node) => ({
        id: node.id,
        template: node.data.template as string,
        config: node.data.config as Record<string, unknown>,
      }));

      const apiEdges: CreateGraphDtoSchemaEdgesInner[] = edges.map((edge) => ({
        from: edge.source,
        to: edge.target,
        label: typeof edge.label === 'string' ? edge.label : undefined,
      }));

      const nodeMetadata: NodeMetadata[] = nodes.map((node) => ({
        id: node.id,
        x: node.position.x,
        y: node.position.y,
        name: node.data.label as string,
      }));

      const metadata: GraphMetadata = {
        ...((graph.metadata as GraphMetadata) || {}),
        nodes: nodeMetadata,
        x: viewport.x,
        y: viewport.y,
        zoom: viewport.zoom,
      };

      await graphsApi.updateGraph(id, {
        name: graph.name,
        description: graph.description,
        version: graph.version,
        schema: {
          nodes: apiNodes,
          edges: apiEdges,
        },
        metadata: metadata,
      });

      message.success('Graph saved successfully');
      setHasUnsavedChanges(false);
      setHasStructuralChanges(false);
      setHasPositionChanges(false);
      if (id) {
        GraphStorageService.clearGraphState(id);
      }
      setNodes(nodes);
      setEdges(edges);
      setViewport(viewport);
      userInteractedRef.current = false;
    } catch (e: unknown) {
      console.error('Error saving graph:', e);
      const errorMessage =
        e instanceof Error ? e.message : 'Failed to save graph';
      message.error(errorMessage);
    } finally {
      setSaving(false);
    }
  };

  const handleNameEdit = () => {
    setIsEditingName(true);
  };

  const handleNameSave = async () => {
    if (!graph || !id) return;

    try {
      await graphsApi.updateGraph(id, {
        name: editingName,
        description: graph.description,
        version: graph.version,
        schema: graph.schema,
        metadata: graph.metadata,
      });

      setGraph({ ...graph, name: editingName });
      setIsEditingName(false);
      message.success('Graph name updated');
    } catch (e: unknown) {
      console.error('Error updating graph name:', e);
      const errorMessage =
        e instanceof Error ? e.message : 'Failed to update graph name';
      message.error(errorMessage);
      setEditingName(graph.name);
    }
  };

  const handleNameCancel = () => {
    setEditingName(graph?.name || '');
    setIsEditingName(false);
  };

  const handleGraphAction = async () => {
    if (!graph || !id) return;

    try {
      setActionLoading(true);
      setGraphError(null);

      if (graph.status === 'running') {
        await graphsApi.destroyGraph(id);
        message.success('Graph stopped successfully');
        const response = await graphsApi.findGraphById(id);
        setGraph(response.data);
      } else {
        await handleSave();
        const response = await graphsApi.runGraph(id);
        const updatedGraph = response.data;
        setGraph(updatedGraph);

        // Check if the graph run returned an error status
        if (updatedGraph.status === 'error') {
          message.error('Graph execution failed');
          setGraphError('Graph execution failed');
        } else {
          message.success('Graph saved and started successfully');
        }
      }
    } catch (error) {
      console.error('Error with graph action:', error);
      const errorMessage =
        error instanceof Error
          ? error.message
          : 'Failed to perform graph action';
      message.error(errorMessage);
      setGraphError(errorMessage);
    } finally {
      setActionLoading(false);
    }
  };

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Layout style={{ overflow: 'hidden' }}>
      <Header
        style={{
          background: '#fff',
          padding: '0 24px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          borderBottom: '1px solid #f0f0f0',
          flexShrink: 0,
        }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: 16 }}>
          <Button
            type="text"
            icon={<ArrowLeftOutlined />}
            onClick={() => navigate('/')}>
            Back
          </Button>
          {isEditingName ? (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <Input
                value={editingName}
                onChange={(e) => setEditingName(e.target.value)}
                onPressEnter={handleNameSave}
                onBlur={handleNameSave}
                autoFocus
                style={{ width: 300 }}
              />
              <Button
                type="text"
                icon={<CheckOutlined />}
                onClick={handleNameSave}
                size="small"
              />
              <Button
                type="text"
                icon={<CloseOutlined />}
                onClick={handleNameCancel}
                size="small"
              />
            </div>
          ) : (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <Title level={4} style={{ margin: 0 }}>
                {graph?.name || 'Graph Editor'}
              </Title>
              <Button
                type="text"
                icon={<EditOutlined />}
                onClick={handleNameEdit}
                size="small"
              />
            </div>
          )}
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 8,
            }}>
            <Popover
              open={threadPopoverVisible}
              placement="bottomLeft"
              content={
                <div
                  style={{
                    maxHeight: 300,
                    overflowY: 'auto',
                    minWidth: 320,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: 4,
                  }}>
                  <Button
                    key="__new_thread__"
                    type="text"
                    style={{
                      textAlign: 'left',
                      padding: '8px 12px',
                      height: 'auto',
                      lineHeight: 1.2,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start',
                      border: '1px solid #f0f0f0',
                      borderRadius: 6,
                      width: '100%',
                    }}
                    onClick={() => handleThreadSelect(undefined)}>
                    <Typography.Text
                      strong
                      style={{ fontSize: '12px', lineHeight: 1.2 }}>
                      + New thread
                    </Typography.Text>
                    <Typography.Text
                      type="secondary"
                      style={{ fontSize: '12px', lineHeight: 1.2 }}>
                      Clear current selection
                    </Typography.Text>
                  </Button>

                  {threadsLoading ? (
                    <Typography.Text
                      type="secondary"
                      style={{ fontSize: '12px' }}>
                      Loading threads...
                    </Typography.Text>
                  ) : threads.length === 0 ? (
                    <Typography.Text
                      type="secondary"
                      style={{ fontSize: '12px' }}>
                      No threads available
                    </Typography.Text>
                  ) : (
                    threads.map((thread) => (
                      <div
                        key={thread.id}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: 8,
                          width: '100%',
                          border: '1px solid #f0f0f0',
                          borderRadius: 6,
                          padding: '4px 4px',
                        }}>
                        <Button
                          type="text"
                          style={{
                            textAlign: 'left',
                            padding: '8px 12px',
                            height: 'auto',
                            lineHeight: 1.2,
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'flex-start',
                            border: 'none',
                            boxShadow: 'none',
                            flex: 1,
                          }}
                          onClick={() => handleThreadSelect(thread.id)}>
                          <Typography.Text
                            strong
                            style={{ fontSize: '12px', lineHeight: 1.2 }}>
                            {thread.name || thread.id}
                          </Typography.Text>
                          <Typography.Text
                            type="secondary"
                            style={{ fontSize: '12px', lineHeight: 1.2 }}>
                            {new Date(thread.createdAt).toLocaleString()}
                          </Typography.Text>
                          {thread.source ? (
                            <Typography.Text
                              type="secondary"
                              style={{ fontSize: '12px', lineHeight: 1.2 }}>
                              Source: {thread.source}
                            </Typography.Text>
                          ) : null}
                        </Button>
                        <Popconfirm
                          title="Delete thread"
                          description="Are you sure you want to delete this thread?"
                          okText="Delete"
                          okButtonProps={{
                            danger: true,
                            loading: deletingThreadId === thread.id,
                          }}
                          cancelText="Cancel"
                          onConfirm={(e) => {
                            e?.stopPropagation?.();
                            handleDeleteThread(thread.id);
                          }}>
                          <Button
                            size="small"
                            type="text"
                            danger
                            icon={<DeleteOutlined />}
                            loading={deletingThreadId === thread.id}
                            onClick={(e) => e.stopPropagation()}
                          />
                        </Popconfirm>
                      </div>
                    ))
                  )}
                </div>
              }
              trigger="click"
              onOpenChange={setThreadPopoverVisible}>
              <div
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'flex-start',
                  cursor: 'pointer',
                  padding: '4px 8px',
                  borderRadius: '4px',
                  transition: 'background-color 0.2s',
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#f5f5f5';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = 'transparent';
                }}>
                {(() => {
                  const t = threads.find((thr) => thr.id === selectedThreadId);
                  const source = t?.source;
                  const label = (
                    <Typography.Text
                      strong
                      style={{ fontSize: '14px', lineHeight: 1 }}>
                      Thread
                    </Typography.Text>
                  );
                  return source ? (
                    <Tooltip title={`Source: ${source}`}>{label}</Tooltip>
                  ) : (
                    label
                  );
                })()}
                {selectedThreadId ? (
                  <>
                    <Typography.Text
                      style={{ fontSize: '12px', lineHeight: 1.2 }}>
                      {(() => {
                        const t = threads.find(
                          (thr) => thr.id === selectedThreadId,
                        );
                        return t?.name || selectedThreadId;
                      })()}
                    </Typography.Text>
                    <Typography.Text
                      type="secondary"
                      style={{ fontSize: '12px', lineHeight: 1.2 }}>
                      {(() => {
                        const t = threads.find(
                          (thr) => thr.id === selectedThreadId,
                        );
                        return t
                          ? `${new Date(t.createdAt).toLocaleString()} | ${t.source || 'unknown source'}`
                          : '';
                      })()}
                    </Typography.Text>
                  </>
                ) : (
                  <>
                    <Typography.Text
                      type="secondary"
                      style={{ fontSize: '12px', lineHeight: 1.2 }}>
                      No active thread.
                    </Typography.Text>
                    <Typography.Text
                      type="secondary"
                      style={{ fontSize: '12px', lineHeight: 1.2 }}>
                      It will be created automatically after first execution.
                    </Typography.Text>
                  </>
                )}
              </div>
            </Popover>

            {selectedThreadId && (
              <Popconfirm
                title="Delete thread"
                description="Are you sure you want to delete the selected thread?"
                okText="Delete"
                okButtonProps={{
                  danger: true,
                  loading: deletingThreadId === selectedThreadId,
                }}
                cancelText="Cancel"
                onConfirm={() =>
                  selectedThreadId && handleDeleteThread(selectedThreadId)
                }>
                <Button
                  size="small"
                  type="text"
                  danger
                  icon={<DeleteOutlined />}
                  loading={deletingThreadId === selectedThreadId}
                />
              </Popconfirm>
            )}
          </div>

          {(graph?.error || graphError) && (
            <Popover
              content={
                <div style={{ maxWidth: 500 }}>
                  <div style={{ fontWeight: 'bold', marginBottom: 8 }}>
                    Graph Error:
                  </div>
                  <div>{graph?.error || graphError}</div>
                </div>
              }
              title="Error Details"
              trigger="hover"
              color="#ffd7d9"
              placement="bottomRight">
              <ExclamationCircleOutlined
                style={{
                  color: '#ff4d4f',
                  fontSize: 16,
                  cursor: 'pointer',
                }}
              />
            </Popover>
          )}
          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <Popover
              content="You have unsaved changes"
              title="Unsaved Changes"
              open={hasStructuralChanges ? undefined : false}
              trigger="hover">
              <Button
                type="primary"
                icon={
                  <Space size={4}>
                    {hasStructuralChanges ? (
                      <WarningOutlined style={{ color: '#ffb431' }} />
                    ) : (
                      <SaveOutlined />
                    )}
                  </Space>
                }
                onClick={handleSave}
                loading={saving}>
                Save
              </Button>
            </Popover>
          </div>
          {graph && (
            <Button
              type={graph.status === 'running' ? 'default' : 'primary'}
              icon={
                graph.status === 'running' ? (
                  <StopOutlined />
                ) : (
                  <PlayCircleOutlined />
                )
              }
              loading={actionLoading}
              onClick={handleGraphAction}>
              {graph.status === 'running' ? 'Stop Graph' : 'Run Graph'}
            </Button>
          )}
        </div>
      </Header>

      <Layout style={{ height: 'calc(100vh - 173px)', overflow: 'hidden' }}>
        <Sider
          width={280}
          style={{
            background: '#fff',
            borderRight: '1px solid #f0f0f0',
            overflow: 'auto',
            height: '100%',
          }}>
          <TemplateSidebar
            onTemplateClick={handleTemplateClick}
            templates={templates}
            selectedNode={selectedNode}
            allNodes={nodes}
          />
        </Sider>

        <Content
          style={{
            background: '#f5f5f5',
            height: '100%',
            overflow: 'hidden',
            minHeight: '500px',
          }}>
          <div
            style={{ height: '100%' }}
            onPointerDown={() => {
              userInteractedRef.current = true;
            }}
            onWheel={() => {
              userInteractedRef.current = true;
            }}>
            <GraphCanvas
              nodes={nodes}
              edges={edges}
              onNodesChange={handleNodesChange}
              onEdgesChange={handleEdgesChange}
              onNodeAdd={handleNodeAdd}
              onNodeEdit={handleNodeEdit}
              onNodeDelete={handleNodeDelete}
              onNodeSelect={handleNodeSelect}
              onViewportChange={handleViewportChange}
              initialViewport={viewport}
              templates={templates}
              graphStatus={graph?.status}
              onTriggerClick={handleTriggerClick}
              onValidationError={(error) => {
                message.error(`Connection validation failed: ${error}`);
              }}
            />
          </div>
        </Content>

        <NodeEditSidebar
          node={selectedNode}
          visible={nodeEditSidebarVisible}
          onClose={() => setNodeEditSidebarVisible(false)}
          onSave={handleNodeSave}
          templates={templates}
          graphStatus={graph?.status}
          onTriggerClick={handleTriggerClick}
          selectedThreadId={selectedThreadId}
          graphId={id}
        />
      </Layout>

      <TemplateModal
        template={selectedTemplate}
        visible={templateModalVisible}
        onClose={() => setTemplateModalVisible(false)}
        allTemplates={templates}
      />

      <TriggerModal
        visible={triggerModalVisible}
        onCancel={async () => {
          setTriggerModalVisible(false);
          setTriggerNodeId(null);
          setTriggerNodeName(null);
          if (triggerStartedRef.current) {
            try {
              await loadThreads();
            } finally {
              triggerStartedRef.current = false;
            }
          }
        }}
        onTrigger={handleTriggerNode}
        nodeId={triggerNodeId || undefined}
        nodeName={triggerNodeName || undefined}
        loading={triggerLoading}
        selectedThreadId={selectedThreadId}
        selectedThreadName={
          threads.find((t) => t.id === selectedThreadId)?.name ?? null
        }
        selectedThreadSource={
          threads.find((t) => t.id === selectedThreadId)?.source ?? null
        }
      />
    </Layout>
  );
};
