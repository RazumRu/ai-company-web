import { App } from 'antd';
import {
  type Dispatch,
  type MutableRefObject,
  type SetStateAction,
  useEffect,
} from 'react';
import { type NavigateFunction } from 'react-router';

import { graphsApi, templatesApi } from '../../../api';
import type { GraphDto, TemplateDto } from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import {
  type GraphDiffState,
  GraphStorageService,
} from '../../../services/GraphStorageService';
import { extractApiErrorMessage } from '../../../utils/errors';
import type { GraphEdge, GraphNode } from '../types';
import { buildGraphDiffState } from '../utils/graphPageUtils';

interface UseGraphLoaderOptions {
  graphId: string | undefined;
  navigate: NavigateFunction;
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
  setGraph: Dispatch<SetStateAction<GraphDto | null>>;
  setEditingName: Dispatch<SetStateAction<string>>;
  setTemplates: Dispatch<SetStateAction<TemplateDto[]>>;
  setLoading: Dispatch<SetStateAction<boolean>>;
  setNodes: (nodes: GraphNode[]) => void;
  setEdges: (edges: GraphEdge[]) => void;
  setServerGraphState: Dispatch<SetStateAction<GraphDiffState>>;
}

export const useGraphLoader = ({
  graphId,
  navigate,
  draftStateRef,
  setGraph,
  setEditingName,
  setTemplates,
  setLoading,
  setNodes,
  setEdges,
  setServerGraphState,
}: UseGraphLoaderOptions) => {
  const { message } = App.useApp();
  useEffect(() => {
    if (!graphId) return;

    let mounted = true;
    (async () => {
      try {
        const templatesRes = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templatesList = templatesRes.data || [];
        setTemplates(templatesList);

        const res = await graphsApi.findGraphById(graphId);
        if (!mounted) return;

        const graphData = res.data;
        const pendingRevision =
          GraphStorageService.loadPendingRevision(graphId);
        const storedDraftName =
          GraphStorageService.loadDraft(graphId)?.graphName;
        const effectiveGraphName =
          pendingRevision?.graphName ?? storedDraftName ?? graphData.name;

        setGraph(
          pendingRevision && pendingRevision.toVersion !== graphData.version
            ? { ...graphData, version: pendingRevision.toVersion }
            : graphData,
        );
        setEditingName(effectiveGraphName);

        // Build nodes/edges/viewport from the server graph using the shared utility
        const builtState = buildGraphDiffState(graphData, templatesList);

        const reactFlowNodes = builtState.nodes;
        const reactFlowEdges = builtState.edges;

        // Always prefer the dedicated viewport key (written on every pan/zoom)
        // over server metadata.  Previously this was skipped when a structural
        // draft existed, but the draft's viewport can be stale.
        const storedViewport = GraphStorageService.loadViewport(graphId);

        const serverState: GraphDiffState = {
          ...builtState,
          viewport: storedViewport ?? builtState.viewport,
        };

        // If we have a locally saved "pending revision" snapshot and the backend
        // is still on an older version, prefer the pending snapshot as the
        // baseline/UI state so reload shows the latest user-visible graph.
        if (
          pendingRevision &&
          pendingRevision.toVersion &&
          pendingRevision.toVersion !== graphData.version
        ) {
          const pendingState: GraphDiffState = {
            nodes: pendingRevision.nodes,
            edges: pendingRevision.edges,
            viewport: pendingRevision.viewport,
            graphName: effectiveGraphName,
            baseVersion: pendingRevision.toVersion,
          };

          setServerGraphState(pendingState);
          draftStateRef.current.updateServerBaseline(pendingState);
          return;
        }

        // If the backend has caught up to our pending snapshot, it is safe to clear it.
        if (
          pendingRevision &&
          pendingRevision.toVersion &&
          pendingRevision.toVersion === graphData.version
        ) {
          GraphStorageService.clearPendingRevision(graphId);
        }

        // Check if stored draft is compatible with current server version
        const storedDraft = GraphStorageService.loadDraft(graphId);
        if (
          storedDraft &&
          storedDraft.baseVersion &&
          storedDraft.baseVersion !== graphData.version
        ) {
          // Draft is based on an old version - check if it has structural changes
          // If it's only viewport changes, we can keep it
          const hasStructuralChanges =
            JSON.stringify(
              storedDraft.nodes.map((n) => ({
                id: n.id,
                data: n.data,
              })),
            ) !==
              JSON.stringify(
                reactFlowNodes.map((n) => ({ id: n.id, data: n.data })),
              ) ||
            JSON.stringify(
              storedDraft.edges.map((e) => ({
                source: e.source,
                target: e.target,
              })),
            ) !==
              JSON.stringify(
                reactFlowEdges.map((e) => ({
                  source: e.source,
                  target: e.target,
                })),
              );

          if (hasStructuralChanges) {
            // Draft has real changes based on old version - discard it and warn user
            console.warn(
              `Discarding draft: based on version ${storedDraft.baseVersion}, but server is at version ${graphData.version}`,
            );
            GraphStorageService.clearDraft(graphId);
            message.warning(
              'Your local changes were based on an outdated version and have been discarded. Please make your changes again.',
              5,
            );
          } else {
            // Only viewport/metadata changes - keep the draft but update baseVersion
            GraphStorageService.saveDraft(graphId, {
              ...storedDraft,
              baseVersion: graphData.version,
            });
          }
        }

        // Update server baseline - the hook will automatically apply any stored local changes
        setServerGraphState(serverState);
        draftStateRef.current.updateServerBaseline(serverState);
      } catch (e) {
        console.error('Error fetching graph:', e);
        const errorMessage = extractApiErrorMessage(e, 'Failed to load graph');
        message.error(errorMessage);
        navigate('/');
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graphId, message, navigate, setNodes, setEdges]);
};
