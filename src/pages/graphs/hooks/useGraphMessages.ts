import { message } from 'antd';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

import { threadsApi } from '../../../api';
import type {
  GraphDto,
  TemplateDto,
  ThreadDto,
  ThreadMessageDto,
} from '../../../autogenerated';
import type { useThreadMessageStore } from '../../../hooks/useThreadMessageStore';
import { extractApiErrorMessage } from '../../../utils/errors';
import { mergeMessagesReplacingStreaming } from '../../../utils/threadMessages';
import type { GraphNode, GraphNodeData } from '../types';
import type { MessageMeta, MessageMetaState } from '../types/graphPage';
import {
  createDefaultMessageMeta,
  isDraftThreadId,
  MESSAGE_PAGE_SIZE,
} from '../utils/graphPageUtils';

interface UseGraphMessagesOptions {
  graph: GraphDto | null;
  nodes: GraphNode[];
  templatesById: Record<string, TemplateDto>;
  selectedThreadId?: string;
  selectedNode: GraphNode | null;
  nodeEditSidebarVisible: boolean;
  chatThread: ThreadDto | null;
  messageStore: ReturnType<typeof useThreadMessageStore>;
}

export const useGraphMessages = ({
  graph,
  nodes,
  templatesById,
  selectedThreadId,
  selectedNode,
  nodeEditSidebarVisible,
  chatThread,
  messageStore,
}: UseGraphMessagesOptions) => {
  const { updateMessages, externalThreadIds, setExternalThreadIds } =
    messageStore;

  // Use a ref for externalThreadIds to avoid recreating loadMessagesForScope
  // on every message (externalThreadIds updates frequently via WS).
  const externalThreadIdsRef = useRef(externalThreadIds);
  useEffect(() => {
    externalThreadIdsRef.current = externalThreadIds;
  }, [externalThreadIds]);

  const [messageMeta, setMessageMeta] = useState<MessageMetaState>({});

  const defaultNewMessageMode = useMemo<
    'inject_after_tool_call' | 'wait_for_completion'
  >(() => {
    const firstAgentNode = nodes.find((n) => {
      const data = n.data as unknown as GraphNodeData;
      return (data?.templateKind || '').toLowerCase() === 'simpleagent';
    });

    const modeFromNode = (firstAgentNode?.data as GraphNodeData | undefined)
      ?.config?.newMessageMode as
      | 'inject_after_tool_call'
      | 'wait_for_completion'
      | undefined;
    return modeFromNode ?? 'wait_for_completion';
  }, [nodes]);

  const getMessageMeta = useCallback(
    (threadId?: string, nodeId?: string): MessageMeta => {
      if (!threadId) {
        return createDefaultMessageMeta();
      }
      return (
        messageMeta[threadId]?.[nodeId ?? 'all'] ?? createDefaultMessageMeta()
      );
    },
    [messageMeta],
  );

  const updateMessageMeta = useCallback(
    (
      threadId: string,
      nodeId: string | undefined,
      updater: (prev: MessageMeta) => MessageMeta,
    ) => {
      setMessageMeta((prev) => {
        const key = nodeId ?? 'all';
        const existing = prev[threadId]?.[key] ?? createDefaultMessageMeta();
        const next = updater(existing);
        return {
          ...prev,
          [threadId]: {
            ...(prev[threadId] ?? {}),
            [key]: next,
          },
        };
      });
    },
    [],
  );

  const loadMessagesForScope = useCallback(
    async (threadId: string, nodeId?: string, force = false) => {
      // Draft threads are local-only; they can never have persisted messages.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
        return;
      }

      const meta = getMessageMeta(threadId, nodeId);
      if (!force && (meta.loading || meta.offset > 0)) {
        return;
      }

      updateMessageMeta(threadId, nodeId, (prev) => ({
        ...prev,
        loading: true,
        loadingMore: false,
        hasMore: true,
        offset: force ? 0 : prev.offset,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          nodeId,
          MESSAGE_PAGE_SIZE,
          0,
        );
        const fetched = response.data?.reverse() || [];

        // Merge fetched with existing messages, preserving timestamps we already have
        updateMessages(
          threadId,
          (prev) => {
            // Build maps for efficient lookup
            const existingById = new Map<string, ThreadMessageDto>();
            const existingOptimistic = new Map<string, ThreadMessageDto>();

            prev.forEach((msg) => {
              const isOptimistic =
                typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
              if (isOptimistic) {
                // Map optimistic messages by content for matching
                if (msg.message?.role === 'human') {
                  const content =
                    typeof msg.message.content === 'string'
                      ? msg.message.content.trim()
                      : '';
                  if (content) {
                    existingOptimistic.set(content, msg);
                  }
                }
              } else {
                // Map real messages by ID
                existingById.set(msg.id, msg);
              }
            });

            // Process fetched messages
            const result: ThreadMessageDto[] = [];
            const processedOptimistic = new Set<string>();

            fetched.forEach((fetchedMsg) => {
              const existingMsg = existingById.get(fetchedMsg.id);

              if (existingMsg) {
                // Message already exists - preserve its timestamp
                result.push({
                  ...fetchedMsg,
                  createdAt: existingMsg.createdAt,
                });
              } else if (fetchedMsg.message?.role === 'human') {
                // New human message - check if it matches an optimistic one
                const content =
                  typeof fetchedMsg.message.content === 'string'
                    ? fetchedMsg.message.content.trim()
                    : '';

                const optimisticMatch = content
                  ? existingOptimistic.get(content)
                  : undefined;

                if (optimisticMatch) {
                  // Replace optimistic with real, preserve timestamp
                  result.push({
                    ...fetchedMsg,
                    createdAt: optimisticMatch.createdAt,
                  });
                  processedOptimistic.add(content);
                } else {
                  // New message with no match
                  result.push(fetchedMsg);
                }
              } else {
                // New non-human message
                result.push(fetchedMsg);
              }
            });

            // Add any optimistic messages that weren't matched
            existingOptimistic.forEach((optMsg, content) => {
              if (!processedOptimistic.has(content)) {
                result.push(optMsg);
              }
            });

            // Sort by timestamp
            result.sort((a, b) => {
              const timeA = new Date(a.createdAt).getTime();
              const timeB = new Date(b.createdAt).getTime();
              return timeA - timeB;
            });

            return result;
          },
          nodeId,
        );

        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: fetched.length === MESSAGE_PAGE_SIZE,
          offset: fetched.length,
        }));

        const extId =
          fetched.find((m) => m.externalThreadId)?.externalThreadId ??
          externalThreadIdsRef.current[threadId];
        if (extId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: extId,
          }));
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load messages',
        );
        message.error(errorMessage);
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    // externalThreadIdsRef is read via ref â€” not included as a dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [getMessageMeta, updateMessageMeta, updateMessages, setExternalThreadIds],
  );

  const loadMoreMessagesForScope = useCallback(
    async (threadId: string, nodeId?: string) => {
      // Draft threads are local-only; there is nothing to paginate from the API.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
        return;
      }

      const meta = getMessageMeta(threadId, nodeId);
      if (meta.loadingMore || !meta.hasMore || meta.loading) {
        return;
      }

      updateMessageMeta(threadId, nodeId, (prev) => ({
        ...prev,
        loadingMore: true,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          nodeId,
          MESSAGE_PAGE_SIZE,
          meta.offset,
        );
        const fetched = response.data?.reverse() || [];

        if (fetched.length > 0) {
          updateMessages(
            threadId,
            (prev) => mergeMessagesReplacingStreaming(prev, fetched),
            nodeId,
          );
          updateMessageMeta(threadId, nodeId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: fetched.length === MESSAGE_PAGE_SIZE,
            offset: prev.offset + fetched.length,
          }));
        } else {
          updateMessageMeta(threadId, nodeId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: false,
          }));
        }
      } catch (error) {
        console.error('Error loading more messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load more messages',
        );
        message.error(errorMessage);
        updateMessageMeta(threadId, nodeId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateMessages],
  );

  // Auto-load messages when node sidebar opens for an agent node
  useEffect(() => {
    if (
      !nodeEditSidebarVisible ||
      !selectedThreadId ||
      !selectedNode?.id ||
      !selectedNode.data
    ) {
      return;
    }
    if (isDraftThreadId(selectedThreadId)) {
      return;
    }
    const nodeData = selectedNode.data as unknown as GraphNodeData;
    const isAgentNode =
      (nodeData?.templateKind || '').toLowerCase() === 'simpleagent';
    if (!isAgentNode) {
      return;
    }

    const meta = getMessageMeta(selectedThreadId, selectedNode.id);
    if (meta.offset === 0 && !meta.loading && meta.hasMore) {
      void loadMessagesForScope(selectedThreadId, selectedNode.id);
    }
  }, [
    nodeEditSidebarVisible,
    selectedThreadId,
    selectedNode,
    getMessageMeta,
    loadMessagesForScope,
  ]);

  // Auto-load messages for selected thread
  useEffect(() => {
    if (!selectedThreadId) return;
    if (isDraftThreadId(selectedThreadId)) return;
    const meta = getMessageMeta(selectedThreadId, undefined);
    if (meta.offset === 0 && !meta.loading && meta.hasMore) {
      void loadMessagesForScope(selectedThreadId);
    }
  }, [selectedThreadId, getMessageMeta, loadMessagesForScope]);

  // Auto-load messages for chat thread modal
  useEffect(() => {
    if (!chatThread) return;
    if (isDraftThreadId(chatThread.id)) return;
    const meta = getMessageMeta(chatThread.id, undefined);
    if (meta.offset === 0 && !meta.loading && meta.hasMore) {
      void loadMessagesForScope(chatThread.id);
    }
  }, [chatThread, getMessageMeta, loadMessagesForScope]);

  // Check if a node ID corresponds to an agent node in the current graph
  const isAgentNodeIdInCurrentGraph = useCallback(
    (candidateNodeId?: string) => {
      if (!candidateNodeId) return false;
      const schemaNode = graph?.schema?.nodes?.find(
        (n) => n.id === candidateNodeId,
      );
      if (!schemaNode) return false;
      const template = templatesById[schemaNode.template];
      return (template?.kind || '').toLowerCase() === 'simpleagent';
    },
    [graph?.schema?.nodes, templatesById],
  );

  // Build scope keys for agent message updates
  const buildAgentMessageScopeKeys = useCallback(
    (candidateNodeId?: string): (string | undefined)[] => {
      return isAgentNodeIdInCurrentGraph(candidateNodeId)
        ? [undefined, candidateNodeId]
        : [undefined];
    },
    [isAgentNodeIdInCurrentGraph],
  );

  return {
    messageMeta,
    defaultNewMessageMode,
    getMessageMeta,
    updateMessageMeta,
    loadMessagesForScope,
    loadMoreMessagesForScope,
    isAgentNodeIdInCurrentGraph,
    buildAgentMessageScopeKeys,
  };
};
