import {
  DownloadOutlined,
  MessageOutlined,
  RobotOutlined,
} from '@ant-design/icons';
import type { Viewport } from '@xyflow/react';
import { message } from 'antd';
import {
  type Dispatch,
  type MutableRefObject,
  type SetStateAction,
  useCallback,
  useMemo,
  useState,
} from 'react';
import type { NavigateFunction } from 'react-router';

import { graphsApi } from '../../../api';
import type {
  CreateGraphDtoSchemaEdgesInner,
  CreateGraphDtoSchemaNodesInner,
  GraphDto,
  GraphRevisionDto,
  TemplateDto,
} from '../../../autogenerated';
import {
  GraphDtoStatusEnum,
  GraphRevisionDtoStatusEnum,
} from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import {
  type GraphDiffState,
  GraphStorageService,
} from '../../../services/GraphStorageService';
import { GraphValidationService } from '../../../services/GraphValidationService';
import { extractApiErrorMessage } from '../../../utils/errors';
import type {
  GraphEdge,
  GraphMetadata,
  GraphNode,
  NodeMetadata,
} from '../types';

interface UseGraphActionsOptions {
  graphId: string | undefined;
  graph: GraphDto | null;
  setGraph: Dispatch<SetStateAction<GraphDto | null>>;
  nodes: GraphNode[];
  edges: GraphEdge[];
  templates: TemplateDto[];
  setEdges: (edges: GraphEdge[]) => void;
  selectedThreadId: string | undefined;
  viewportRef: MutableRefObject<Viewport>;
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
  serverGraphState: GraphDiffState;
  setServerGraphState: Dispatch<SetStateAction<GraphDiffState>>;
  rebuildStateFromGraph: (graphData: GraphDto) => GraphDiffState;
  handleDraftStateChange: (newState: GraphDiffState) => void;
  upsertRevision: (revision: GraphRevisionDto) => void;
  handleDownloadGraphBackup: () => void;
  handleOpenGraphAiModal: () => void;
  hasAgentNodes: boolean;
  userInteractedRef: MutableRefObject<boolean>;
  fetchCompiledNodes: (options?: {
    threadId?: string;
    graphStatusOverride?: GraphDtoStatusEnum | null;
  }) => Promise<void>;
  navigate: NavigateFunction;
  editingName: string;
  setEditingName: Dispatch<SetStateAction<string>>;
  saving: boolean;
  setSaving: Dispatch<SetStateAction<boolean>>;
}

export const useGraphActions = ({
  graphId: id,
  graph,
  setGraph,
  nodes,
  edges,
  templates,
  setEdges,
  selectedThreadId,
  viewportRef,
  draftStateRef,
  serverGraphState,
  setServerGraphState,
  rebuildStateFromGraph,
  handleDraftStateChange,
  upsertRevision,
  handleDownloadGraphBackup,
  handleOpenGraphAiModal,
  hasAgentNodes,
  userInteractedRef,
  fetchCompiledNodes,
  navigate,
  editingName,
  setEditingName,
  saving,
  setSaving,
}: UseGraphActionsOptions) => {
  const [isSavingName, setIsSavingName] = useState(false);
  const [isEditingName, setIsEditingName] = useState(false);
  const [actionLoading, setActionLoading] = useState(false);
  const [graphError, setGraphError] = useState<string | null>(null);
  const [draftNodeConfigVersion, setDraftNodeConfigVersion] = useState(0);

  const handleSave = useCallback(async () => {
    if (!graph || !id) return;

    setSaving(true);
    try {
      // Defensive cleanup: ReactFlow may keep "dangling" edges in state even if they
      // are no longer renderable. The backend rejects edges pointing to missing nodes.
      const nodeIdSet = new Set(nodes.map((n) => n.id));
      const validEdges = edges.filter(
        (e) => nodeIdSet.has(e.source) && nodeIdSet.has(e.target),
      );
      if (validEdges.length !== edges.length) {
        setEdges(validEdges);
        draftStateRef.current.updateEdges(validEdges);
      }

      const connectionValidation = GraphValidationService.validateGraph(
        nodes,
        validEdges,
        templates,
      );
      if (!connectionValidation.isValid) {
        const first = connectionValidation.errors[0];
        message.error(first?.message ?? 'Invalid connections');
        return;
      }

      const configValidation =
        await GraphValidationService.validateAndNormalizeNodeConfigs(
          nodes,
          templates,
        );
      if (!configValidation.isValid) {
        const first = configValidation.errors[0];
        message.error(first?.message ?? 'Invalid node configuration');
        return;
      }

      const apiNodes: CreateGraphDtoSchemaNodesInner[] = nodes.map((node) => ({
        id: node.id,
        template: node.data.template as string,
        config: configValidation.normalizedConfigsByNodeId[node.id] ?? {},
      }));

      const apiEdges: CreateGraphDtoSchemaEdgesInner[] = validEdges.map(
        (edge) => ({
          from: edge.source,
          to: edge.target,
          label: typeof edge.label === 'string' ? edge.label : undefined,
        }),
      );

      const nodeMetadata: NodeMetadata[] = nodes.map((node) => ({
        id: node.id,
        x: node.position.x,
        y: node.position.y,
        name: node.data.label as string,
      }));

      const metadata: GraphMetadata = {
        ...((graph.metadata as GraphMetadata) || {}),
        nodes: nodeMetadata,
        x: viewportRef.current.x,
        y: viewportRef.current.y,
        zoom: viewportRef.current.zoom,
      };

      const response = await graphsApi.updateGraph(id, {
        name: draftStateRef.current.draftState.graphName ?? graph.name,
        description: graph.description || undefined,
        schema: {
          nodes: apiNodes,
          edges: apiEdges,
        },
        metadata: metadata || undefined,
        currentVersion: graph.version,
      });
      const updatedGraph = response.data.graph;
      const revision = response.data.revision;

      if (revision) {
        upsertRevision(revision);
      }

      // Update the graph metadata (version, status, etc)
      setGraph(updatedGraph);
      setEditingName(updatedGraph.name);

      // Check if revision is pending/applying (async apply)
      const revisionNeedsTime =
        revision &&
        (revision.status === GraphRevisionDtoStatusEnum.Pending ||
          revision.status === GraphRevisionDtoStatusEnum.Applying);

      if (revisionNeedsTime) {
        message.success(
          'Graph saved successfully. Revision is being applied...',
        );
      } else {
        message.success('Graph saved successfully');
      }

      if (revisionNeedsTime) {
        // Revision will be applied asynchronously
        // Keep current visual state (showing the changes we just saved)
        // Clear the unsaved draft since we've saved, but persist a snapshot
        // separately so reload still shows the latest changes while the backend
        // revision is pending/applying.
        GraphStorageService.clearDraft(id);
        const pendingToVersion =
          revision?.toVersion ?? updatedGraph.version ?? graph.version;
        if (pendingToVersion) {
          GraphStorageService.savePendingRevision(id, {
            nodes,
            edges,
            viewport: viewportRef.current,
            selectedThreadId,
            graphName: updatedGraph.name,
            baseVersion: pendingToVersion,
            toVersion: pendingToVersion,
            revisionId: revision?.id,
            savedAt: Date.now(),
          });
        }

        // Update the server baseline with the current state we're displaying
        // This represents what we JUST saved (even though server hasn't applied it yet)
        // Use the NEW version from the response so future drafts are based on this save
        const currentState: GraphDiffState = {
          nodes,
          edges,
          viewport: viewportRef.current,
          selectedThreadId,
          graphName: updatedGraph.name,
          baseVersion: updatedGraph.version,
        };
        setServerGraphState(currentState);
        // Update baseline WITHOUT triggering a draft save
        draftStateRef.current.updateServerBaseline(currentState);
      } else {
        // Revision applied immediately (or no revision needed)
        // Update visual state with the new graph data
        const refreshedState = rebuildStateFromGraph(updatedGraph);

        // Clear all local changes
        draftStateRef.current.clearAllChanges();

        // Update server baseline and apply the new state
        setServerGraphState(refreshedState);
        draftStateRef.current.updateServerBaseline(refreshedState);

        // Force update the visual state immediately
        handleDraftStateChange(refreshedState);
      }

      userInteractedRef.current = false;
      // Signal NodeEditSidebar to reset its initialFormValues baseline
      setDraftNodeConfigVersion((prev) => prev + 1);
    } catch (e: unknown) {
      console.error('Error saving graph:', e);
      const errorMessage = extractApiErrorMessage(e, 'Failed to save graph');
      message.error(errorMessage);
    } finally {
      setSaving(false);
    }
  }, [
    edges,
    graph,
    handleDraftStateChange,
    id,
    nodes,
    rebuildStateFromGraph,
    selectedThreadId,
    setEdges,
    setEditingName,
    setServerGraphState,
    setGraph,
    setSaving,
    templates,
    upsertRevision,
    userInteractedRef,
    viewportRef,
    draftStateRef,
  ]);

  const handleNameEdit = useCallback(() => {
    setEditingName(
      draftStateRef.current.draftState.graphName ?? (graph?.name || ''),
    );
    setIsEditingName(true);
  }, [draftStateRef, graph?.name, setEditingName]);

  const handleNameSave = useCallback(async () => {
    if (!graph || !id) return;

    const nextName = editingName.trim();
    if (!nextName) {
      message.warning('Graph name cannot be empty');
      return;
    }

    if (isSavingName) return;

    if (nextName === graph.name) {
      setEditingName(nextName);
      setIsEditingName(false);
      return;
    }

    try {
      setIsSavingName(true);
      const response = await graphsApi.updateGraph(id, {
        name: nextName,
        currentVersion: graph.version,
      });
      const updatedGraph = response.data.graph;

      setGraph(updatedGraph);
      setEditingName(updatedGraph.name);
      setIsEditingName(false);

      draftStateRef.current.updateGraphName(updatedGraph.name);

      const nextServerState: GraphDiffState = {
        ...serverGraphState,
        graphName: updatedGraph.name,
        baseVersion: updatedGraph.version ?? serverGraphState.baseVersion,
      };
      setServerGraphState(nextServerState);
      draftStateRef.current.updateServerBaseline(nextServerState);

      const existingDraft = GraphStorageService.loadDraft(id);
      if (existingDraft) {
        GraphStorageService.saveDraft(id, {
          ...existingDraft,
          graphName: updatedGraph.name,
          baseVersion: updatedGraph.version ?? existingDraft.baseVersion,
        });
      }

      message.success('Graph name updated');
    } catch (error) {
      console.error('Error updating graph name:', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to update graph name',
      );
      message.error(errorMessage);
    } finally {
      setIsSavingName(false);
    }
  }, [
    draftStateRef,
    editingName,
    graph,
    id,
    isSavingName,
    serverGraphState,
    setEditingName,
    setGraph,
    setServerGraphState,
  ]);

  const handleNameCancel = useCallback(() => {
    setEditingName(
      draftStateRef.current.draftState.graphName ?? (graph?.name || ''),
    );
    setIsEditingName(false);
  }, [draftStateRef, graph?.name, setEditingName]);

  const handleGraphAction = useCallback(async () => {
    if (!graph || !id) return;
    if (graph.status === GraphDtoStatusEnum.Compiling) {
      return;
    }

    try {
      setActionLoading(true);
      setGraphError(null);

      if (graph.status === GraphDtoStatusEnum.Running) {
        await graphsApi.destroyGraph(id);
        message.success('Graph stopped successfully');
        const response = await graphsApi.findGraphById(id);
        setGraph(response.data);
        void fetchCompiledNodes({
          graphStatusOverride: response.data.status,
          threadId: selectedThreadId,
        });
      } else {
        const response = await graphsApi.runGraph(id);
        const updatedGraph = response.data;
        setGraph(updatedGraph);
        void fetchCompiledNodes({
          graphStatusOverride: updatedGraph.status,
          threadId: selectedThreadId,
        });

        if (updatedGraph.status === GraphDtoStatusEnum.Error) {
          const executionErrorMessage =
            (updatedGraph as GraphDto & { error?: string }).error ||
            'Graph execution failed';
          message.error(executionErrorMessage);
          setGraphError(executionErrorMessage);
        } else {
          message.success('Graph started successfully');
        }
      }
    } catch (error) {
      console.error('Error with graph action:', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to perform graph action',
      );
      message.error(errorMessage);
      setGraphError(errorMessage);
    } finally {
      setActionLoading(false);
    }
  }, [fetchCompiledNodes, graph, id, selectedThreadId, setGraph]);

  const graphMenuItems = useMemo(
    () => [
      {
        key: 'download',
        disabled: !graph,
        label: (
          <div style={{ display: 'flex', gap: 8 }}>
            <DownloadOutlined />
            Download graph
          </div>
        ),
      },
      {
        key: 'chats',
        disabled: !graph,
        label: (
          <div style={{ display: 'flex', gap: 8 }}>
            <MessageOutlined />
            Open chats
          </div>
        ),
      },
      {
        key: 'improve',
        disabled: !hasAgentNodes,
        label: (
          <div style={{ display: 'flex', gap: 8 }}>
            <RobotOutlined />
            Improve workflow
          </div>
        ),
      },
    ],
    [graph, hasAgentNodes],
  );

  const handleGraphMenuAction = useCallback(
    (key: string) => {
      if (key === 'download') {
        if (!graph) return;
        handleDownloadGraphBackup();
      }
      if (key === 'chats') {
        if (!graph) return;
        navigate(`/chats?graphId=${graph.id}`);
      }
      if (key === 'improve') {
        handleOpenGraphAiModal();
      }
    },
    [graph, handleDownloadGraphBackup, handleOpenGraphAiModal, navigate],
  );

  return {
    saving,
    isSavingName,
    isEditingName,
    editingName,
    setEditingName,
    actionLoading,
    graphError,
    draftNodeConfigVersion,
    handleSave,
    handleNameEdit,
    handleNameSave,
    handleNameCancel,
    handleGraphAction,
    graphMenuItems,
    handleGraphMenuAction,
  };
};
