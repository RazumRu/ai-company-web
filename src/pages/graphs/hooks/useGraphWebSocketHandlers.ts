import type { Viewport } from '@xyflow/react';
import { message } from 'antd';
import type { Dispatch, MutableRefObject, SetStateAction } from 'react';

import { graphsApi, threadsApi } from '../../../api';
import {
  type GraphDto,
  GraphDtoStatusEnum,
  type GraphNodeWithStatusDto,
  type GraphRevisionDto,
  type ThreadDto,
  type ThreadMessageDto,
} from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import { useWebSocket } from '../../../hooks/useWebSocket';
import {
  type GraphDiffState,
  GraphStorageService,
} from '../../../services/GraphStorageService';
import type {
  AgentMessageNotification,
  GraphNodeUpdateNotification,
  GraphRevisionNotification,
  GraphUpdateNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../../services/WebSocketTypes';
import {
  buildIdSet,
  clearStreamingReasoningForContext,
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../../utils/threadMessages';
import type { GraphNode, GraphNodeData } from '../types';
import type { PendingMessage } from '../types/messages';
import type { MessagesState } from '../types/messages';

// ---------------------------------------------------------------------------
// Options interface
// ---------------------------------------------------------------------------

interface GraphState {
  id: string;
  nodes: GraphNode[];
  selectedThreadId?: string;
  messages: MessagesState;
  externalThreadIds: Record<string, string | undefined>;
}

interface GraphSetters {
  setGraph: Dispatch<SetStateAction<GraphDto | null>>;
  setCompiledNodesMap: Dispatch<
    SetStateAction<Record<string, GraphNodeWithStatusDto>>
  >;
  setThreads: Dispatch<SetStateAction<ThreadDto[]>>;
  setExternalThreadIds: Dispatch<
    SetStateAction<Record<string, string | undefined>>
  >;
  setServerGraphState: Dispatch<SetStateAction<GraphDiffState>>;
}

interface MessageActions {
  buildAgentMessageScopeKeys: (nodeId?: string) => (string | undefined)[];
  updateMessages: (
    threadId: string,
    updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
    nodeId?: string,
  ) => void;
  updatePendingMessages: (
    threadId: string,
    updater: (prev: PendingMessage[]) => PendingMessage[],
    nodeId?: string,
  ) => void;
}

interface ThreadActions {
  sortThreadsByTimestampDesc: (list: ThreadDto[]) => ThreadDto[];
  shouldApplyThreadUpdate: (
    existing: ThreadDto,
    incoming: ThreadDto,
  ) => boolean;
  handleThreadChange: (threadId: string | undefined) => void;
  resolveInternalThreadId: (externalThreadId?: string) => string | undefined;
}

interface RevisionActions {
  upsertRevision: (revision: GraphRevisionDto) => void;
  rebuildStateFromGraph: (graphData: GraphDto) => GraphDiffState;
  handleDraftStateChange: (newState: GraphDiffState) => void;
  fetchCompiledNodes: (options?: {
    threadId?: string;
    graphStatusOverride?: GraphDtoStatusEnum | null;
  }) => Promise<void>;
}

interface Refs {
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
  triggerStartedRef: MutableRefObject<boolean>;
  pendingThreadSelectionRef: MutableRefObject<string | null>;
  viewportRef: MutableRefObject<Viewport>;
}

export interface UseGraphWebSocketHandlersOptions {
  graphState: GraphState;
  setters: GraphSetters;
  messageActions: MessageActions;
  threadActions: ThreadActions;
  revisionActions: RevisionActions;
  refs: Refs;
}

// ---------------------------------------------------------------------------
// Hook
// ---------------------------------------------------------------------------

export const useGraphWebSocketHandlers = ({
  graphState,
  setters,
  messageActions,
  threadActions,
  revisionActions,
  refs,
}: UseGraphWebSocketHandlersOptions): void => {
  const { id, nodes, selectedThreadId, messages, externalThreadIds } =
    graphState;

  const {
    setGraph,
    setCompiledNodesMap,
    setThreads,
    setExternalThreadIds,
    setServerGraphState,
  } = setters;

  const { buildAgentMessageScopeKeys, updateMessages, updatePendingMessages } =
    messageActions;

  const {
    sortThreadsByTimestampDesc,
    shouldApplyThreadUpdate,
    handleThreadChange,
    resolveInternalThreadId,
  } = threadActions;

  const {
    upsertRevision,
    rebuildStateFromGraph,
    handleDraftStateChange,
    fetchCompiledNodes,
  } = revisionActions;

  const {
    draftStateRef,
    triggerStartedRef,
    pendingThreadSelectionRef,
    viewportRef,
  } = refs;

  useWebSocket({
    autoConnect: true,
    graphId: id,
    handlers: {
      'graph.update': (notification) => {
        const data = notification as GraphUpdateNotification;
        if (data.graphId !== id) return;

        const newStatus = data.data.status;

        if (
          newStatus === GraphDtoStatusEnum.Compiling ||
          newStatus === GraphDtoStatusEnum.Stopped
        ) {
          setCompiledNodesMap((prev) => {
            // Only update if not already empty to prevent unnecessary rerenders
            return Object.keys(prev).length === 0 ? prev : {};
          });
        }

        setGraph((prev) => {
          if (!prev) {
            return prev;
          }

          return {
            ...prev,
            status: newStatus,
          };
        });
      },

      'agent.message': (notification) => {
        const data = notification as AgentMessageNotification;
        if (data.graphId !== id) return;
        if (!data.internalThreadId) return;

        const threadId = data.internalThreadId;
        const nodeId = data.nodeId;
        const incomingMessage = data.data;

        const applyMessageKeys = buildAgentMessageScopeKeys(nodeId);

        // Add incoming message to all relevant scopes
        // The store will automatically handle:
        // - Replacing optimistic messages with real ones (by content matching)
        // - Deduplication by message ID
        // - Sorting by timestamp
        applyMessageKeys.forEach((key) => {
          updateMessages(
            threadId,
            (prev) => mergeMessagesReplacingStreaming(prev, [incomingMessage]),
            key,
          );
        });

        // Clear backend pending messages that match this incoming message
        const incomingContent =
          typeof incomingMessage.message?.content === 'string'
            ? (incomingMessage.message?.content as string)
            : undefined;
        const incomingRole = incomingMessage.message?.role as
          | string
          | undefined;
        if (incomingContent && incomingRole === 'human') {
          applyMessageKeys.forEach((key) => {
            updatePendingMessages(
              threadId,
              (prev) =>
                prev.filter(
                  (p) =>
                    typeof p.content !== 'string' ||
                    p.content !== incomingContent,
                ),
              key,
            );
          });
        }

        if (incomingMessage.externalThreadId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: incomingMessage.externalThreadId,
          }));
        }
      },

      'thread.create': (notification) => {
        const data = notification as ThreadCreateNotification;
        if (data.graphId !== id) return;

        const externalThreadId = data.threadId;
        if (!externalThreadId) {
          triggerStartedRef.current = false;
          return;
        }

        void (async () => {
          try {
            const response =
              await threadsApi.getThreadByExternalId(externalThreadId);
            const fetchedThread = response.data;
            if (!fetchedThread) {
              return;
            }

            setThreads((prevThreads) => {
              const exists = prevThreads.some((t) => t.id === fetchedThread.id);
              if (exists) {
                return sortThreadsByTimestampDesc(prevThreads);
              }
              return sortThreadsByTimestampDesc([
                fetchedThread,
                ...prevThreads,
              ]);
            });

            if (
              pendingThreadSelectionRef.current &&
              pendingThreadSelectionRef.current === externalThreadId
            ) {
              handleThreadChange(fetchedThread.id);
              pendingThreadSelectionRef.current = null;
            }
          } catch (error) {
            console.error('Error fetching thread by external ID:', error);
          } finally {
            triggerStartedRef.current = false;
          }
        })();
      },

      'thread.update': (notification) => {
        const data = notification as ThreadUpdateNotification;
        if (data.graphId !== id) return;

        const updatedThread = data.data;
        const externalThreadId = updatedThread.externalThreadId;

        setThreads((prevThreads) => {
          const existingIndex = prevThreads.findIndex(
            (thread) => thread.id === updatedThread.id,
          );

          if (existingIndex === -1) {
            return prevThreads;
          }

          const existingThread = prevThreads[existingIndex];
          if (!shouldApplyThreadUpdate(existingThread, updatedThread)) {
            return prevThreads;
          }

          const updatedThreads = [...prevThreads];
          updatedThreads[existingIndex] = updatedThread;
          return sortThreadsByTimestampDesc(updatedThreads);
        });

        if (
          externalThreadId &&
          pendingThreadSelectionRef.current &&
          pendingThreadSelectionRef.current === externalThreadId
        ) {
          handleThreadChange(updatedThread.id);
          pendingThreadSelectionRef.current = null;
        }

        triggerStartedRef.current = false;
      },

      'thread.delete': (notification) => {
        const data = notification as ThreadDeleteNotification;
        if (data.graphId !== id) return;

        const deletedThread = data.data;

        setThreads((prevThreads) =>
          prevThreads.filter((thread) => thread.id !== deletedThread.id),
        );

        if (
          deletedThread.externalThreadId === pendingThreadSelectionRef.current
        ) {
          pendingThreadSelectionRef.current = null;
        }

        if (selectedThreadId === deletedThread.id) {
          handleThreadChange(undefined);
        }

        triggerStartedRef.current = false;
      },

      'graph.node.update': (notification) => {
        const data = notification as GraphNodeUpdateNotification;
        if (data.graphId !== id) return;
        const eventThreadId =
          (typeof data.threadId === 'string' && data.threadId.length > 0
            ? data.threadId
            : undefined) ??
          (typeof data.data?.metadata?.threadId === 'string'
            ? data.data.metadata.threadId
            : undefined);
        const eventInternalThreadId =
          typeof data.internalThreadId === 'string' &&
          data.internalThreadId.length > 0
            ? data.internalThreadId
            : undefined;
        const metadataRunId =
          typeof data.data?.metadata?.runId === 'string'
            ? data.data.metadata.runId
            : undefined;
        const internalThreadId =
          eventInternalThreadId || resolveInternalThreadId(eventThreadId);

        const targetThreadId = internalThreadId ?? eventThreadId;
        if (!targetThreadId) {
          return;
        }

        const externalThreadIdForTarget =
          externalThreadIds[targetThreadId] ?? eventThreadId;

        if (eventThreadId) {
          setExternalThreadIds((prev) => {
            const existing = prev[targetThreadId];
            if (existing === eventThreadId) return prev;
            return { ...prev, [targetThreadId]: eventThreadId };
          });
        }
        const targetRunIds = buildIdSet(data.runId, metadataRunId);

        setCompiledNodesMap((prev) => {
          const existing = prev[data.nodeId];
          const nextStatus = data.data.status;
          const nextError = data.data.error ?? existing?.error ?? null;
          const nextMetadata = data.data.metadata ?? existing?.metadata;
          const nextAdditionalNodeMetadata =
            data.data.additionalNodeMetadata ??
            existing?.additionalNodeMetadata;

          if (!existing) {
            const graphNode = nodes.find(
              (n: GraphNode) => n.id === data.nodeId,
            );
            if (!graphNode) {
              return prev;
            }

            const nodeData = graphNode.data as unknown as GraphNodeData;
            const rawKind = (nodeData.templateKind as string | undefined) ?? '';
            const normalizedKind = rawKind.toLowerCase();
            let inferredType: GraphNodeWithStatusDto['type'] = 'runtime';
            if (normalizedKind === 'tool') {
              inferredType = 'tool';
            } else if (normalizedKind === 'simpleagent') {
              inferredType = 'simpleAgent';
            } else if (normalizedKind === 'trigger') {
              inferredType = 'trigger';
            } else if (normalizedKind === 'resource') {
              inferredType = 'resource';
            }

            return {
              ...prev,
              [data.nodeId]: {
                id: data.nodeId,
                name:
                  (nodeData.label as string) ||
                  (nodeData.template as string) ||
                  data.nodeId,
                template: (nodeData.template as string) || '',
                type: inferredType,
                status: nextStatus,
                config: nodeData.config ?? {},
                error: nextError,
                metadata: nextMetadata,
                additionalNodeMetadata: nextAdditionalNodeMetadata,
              },
            };
          }

          return {
            ...prev,
            [data.nodeId]: {
              ...existing,
              status: nextStatus,
              error: nextError,
              metadata: nextMetadata,
              additionalNodeMetadata: nextAdditionalNodeMetadata,
            },
          };
        });

        // Propagate pending messages to the shared store so both popup and sidebar see them
        const pendingMessagesFromNode =
          data.data?.additionalNodeMetadata?.pendingMessages;
        if (internalThreadId && Array.isArray(pendingMessagesFromNode)) {
          const pendingDtos: PendingMessage[] = pendingMessagesFromNode.map(
            (pendingMessage) => {
              const messageRecord = pendingMessage as Record<string, unknown>;
              const rawAdditionalKwargs = messageRecord.additionalKwargs;
              const sanitizedAdditionalKwargs =
                typeof rawAdditionalKwargs === 'object' &&
                rawAdditionalKwargs !== null
                  ? (rawAdditionalKwargs as Record<string, unknown>)
                  : {};
              const createdAt =
                typeof messageRecord.createdAt === 'string'
                  ? messageRecord.createdAt
                  : typeof sanitizedAdditionalKwargs.__createdAt === 'string'
                    ? sanitizedAdditionalKwargs.__createdAt
                    : typeof sanitizedAdditionalKwargs.created_at === 'string'
                      ? sanitizedAdditionalKwargs.created_at
                      : new Date().toISOString();
              const runId =
                data.runId ??
                metadataRunId ??
                (typeof sanitizedAdditionalKwargs.__runId === 'string'
                  ? sanitizedAdditionalKwargs.__runId
                  : typeof sanitizedAdditionalKwargs.run_id === 'string'
                    ? sanitizedAdditionalKwargs.run_id
                    : undefined);
              const content =
                typeof messageRecord.content === 'string'
                  ? messageRecord.content
                  : '';
              const roleCandidate = messageRecord.role;
              const role =
                roleCandidate === 'human' || roleCandidate === 'ai'
                  ? (roleCandidate as 'human' | 'ai')
                  : 'ai';
              return {
                content,
                role,
                additionalKwargs: {
                  ...sanitizedAdditionalKwargs,
                  __runId: runId,
                  __createdAt: createdAt,
                },
                createdAt,
              };
            },
          );

          const applyPendingToKeys = buildAgentMessageScopeKeys(data.nodeId);
          applyPendingToKeys.forEach((key) => {
            updatePendingMessages(
              internalThreadId,
              () => {
                // Filter out pending messages that match optimistic messages already in the timeline
                // This prevents duplication when we've already added an optimistic message locally
                const threadMessages = messages[internalThreadId];
                if (!threadMessages || key === undefined) {
                  return pendingDtos;
                }

                const currentMessages = threadMessages[key] || [];
                const optimisticContents = new Set<string>();

                currentMessages.forEach((msg: ThreadMessageDto) => {
                  const isOptimistic =
                    typeof msg.id === 'string' &&
                    msg.id.startsWith('optimistic-');
                  if (isOptimistic && msg.message?.role === 'human') {
                    const content =
                      typeof msg.message.content === 'string'
                        ? msg.message.content.trim()
                        : '';
                    if (content) {
                      optimisticContents.add(content);
                    }
                  }
                });

                return pendingDtos.filter((pendingMsg) => {
                  if (pendingMsg.role === 'human') {
                    const content = pendingMsg.content.trim();
                    return !optimisticContents.has(content);
                  }
                  return true;
                });
              },
              key,
            );
          });
        } else if (internalThreadId) {
          // If no pending messages, clear any existing pending entries for this node/thread
          const applyPendingToKeys = buildAgentMessageScopeKeys(data.nodeId);
          applyPendingToKeys.forEach((key) => {
            updatePendingMessages(targetThreadId, () => [], key);
          });
        }

        const reasoningChunks =
          data.data?.additionalNodeMetadata?.reasoningChunks;

        const applyUpdateToKeys = buildAgentMessageScopeKeys(data.nodeId);

        if (!reasoningChunks) {
          applyUpdateToKeys.forEach((key) => {
            updateMessages(
              targetThreadId,
              (prev) =>
                clearStreamingReasoningForContext(prev, {
                  targetThreadId: externalThreadIdForTarget,
                  selectedThreadId: targetThreadId,
                  runIds: targetRunIds,
                }),
              key,
            );
          });
          return;
        }

        const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
          eventThreadId,
          externalThreadIdForTarget,
          data.runId ?? metadataRunId,
        ]);
        const reasoningEntries = extractReasoningEntries(reasoningContainer, {
          threadId: externalThreadIdForTarget ?? eventThreadId,
          runId: data.runId ?? metadataRunId,
        });

        if (!reasoningEntries.length) {
          applyUpdateToKeys.forEach((key) => {
            updateMessages(
              targetThreadId,
              (prev) =>
                clearStreamingReasoningForContext(prev, {
                  targetThreadId: externalThreadIdForTarget,
                  selectedThreadId: targetThreadId,
                  runIds: targetRunIds,
                }),
              key,
            );
          });
          return;
        }

        applyUpdateToKeys.forEach((key) => {
          updateMessages(
            targetThreadId,
            (prev) =>
              upsertReasoningEntries(prev, reasoningEntries, {
                externalThreadId: externalThreadIdForTarget,
                runId: data.runId ?? metadataRunId,
                selectedThreadId: targetThreadId,
                nodeId: key,
              }),
            key,
          );
        });
      },

      'graph.revision.create': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        upsertRevision(data.data);
      },

      'graph.revision.applying': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);

        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'loading',
          content: `Applying revision ${revision.toVersion}`,
          duration: 0,
        });
      },

      'graph.revision.applied': async (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        GraphStorageService.clearPendingRevision(id);

        // Refetch the graph to get the updated data
        try {
          const res = await graphsApi.findGraphById(id);
          const updatedGraph = res.data;

          // Check if there are local unsaved changes
          const hasLocalChanges = draftStateRef.current.hasUnsavedChanges;

          if (hasLocalChanges) {
            // User has local changes - warn them that the server was updated
            message.warning({
              key: `graph-revision-${revision.id}`,
              content: `Revision ${revision.toVersion} applied.`,
              duration: 8,
            });
            // Update the graph metadata but don't override local changes
            setGraph(updatedGraph);

            // Fetch updated node states
            void fetchCompiledNodes({
              graphStatusOverride: updatedGraph.status,
              threadId: selectedThreadId,
            });
          } else {
            // No local changes - safely update everything
            const refreshedState = rebuildStateFromGraph(updatedGraph);

            // Preserve the current viewport â€” the server response contains a
            // round-tripped viewport that may be stale relative to the user's
            // current pan/zoom position.
            refreshedState.viewport = viewportRef.current;

            // Clear any potential draft state
            draftStateRef.current.clearAllChanges();

            // Update server baseline and apply the new state
            setServerGraphState(refreshedState);
            draftStateRef.current.updateServerBaseline(refreshedState);

            // Force update the visual state immediately
            handleDraftStateChange(refreshedState);

            setGraph(updatedGraph);

            message.success({
              key: `graph-revision-${revision.id}`,
              content: `Revision ${revision.toVersion} applied`,
              duration: 3,
            });

            // Fetch updated node states
            void fetchCompiledNodes({
              graphStatusOverride: updatedGraph.status,
              threadId: selectedThreadId,
            });
          }
        } catch (error) {
          console.error(
            'Error refetching graph after revision applied:',
            error,
          );
          // Fallback: just update the version
          setGraph((prev) =>
            prev ? { ...prev, version: revision.toVersion } : prev,
          );
          message.open({
            key: `graph-revision-${revision.id}`,
            type: 'success',
            content: `Revision ${revision.toVersion} applied`,
            duration: 3,
          });
        }
      },

      'graph.revision.failed': (notification) => {
        const data = notification as GraphRevisionNotification;
        if (data.graphId !== id) return;

        const revision = data.data;
        upsertRevision(revision);
        message.open({
          key: `graph-revision-${revision.id}`,
          type: 'error',
          content: revision.error
            ? `Revision ${revision.toVersion} failed: ${revision.error}`
            : `Revision ${revision.toVersion} failed`,
          duration: 5,
        });
      },
    },
  });
};
