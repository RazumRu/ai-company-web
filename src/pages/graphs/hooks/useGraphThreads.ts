import { message } from 'antd';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

import { threadsApi } from '../../../api';
import type {
  GraphDto,
  TemplateDto,
  ThreadDto,
  ThreadDtoStatusEnum,
} from '../../../autogenerated';
import { ThreadDtoStatusEnum as ThreadStatus } from '../../../autogenerated';
import { extractApiErrorMessage } from '../../../utils/errors';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
} from '../../../utils/graphThreads';

interface UseGraphThreadsOptions {
  graphId: string | undefined;
  graph: GraphDto | null;
  templatesById: Record<string, TemplateDto>;
  selectedThreadId: string | undefined;
  onThreadChange: (threadId: string | undefined) => void;
}

export const useGraphThreads = ({
  graphId,
  graph,
  templatesById,
  selectedThreadId,
  onThreadChange,
}: UseGraphThreadsOptions) => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const threadsRef = useRef<ThreadDto[]>([]);
  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);

  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadPopoverVisible, setThreadPopoverVisible] = useState(false);
  const [deletingThreadId, setDeletingThreadId] = useState<string | null>(null);
  const [stoppingThreadId, setStoppingThreadId] = useState<string | null>(null);
  const [threadChatThreadId, setThreadChatThreadId] = useState<string | null>(
    null,
  );

  const getThreadTimestamp = useCallback((thread: ThreadDto) => {
    const value = thread.updatedAt ?? thread.createdAt;
    return value ? Date.parse(value) : Number.NaN;
  }, []);

  const sortThreadsByTimestampDesc = useCallback(
    (list: ThreadDto[]) => {
      return [...list].sort((a, b) => {
        const bTs = getThreadTimestamp(b);
        const aTs = getThreadTimestamp(a);
        const safeBTs = Number.isFinite(bTs) ? bTs : -Infinity;
        const safeATs = Number.isFinite(aTs) ? aTs : -Infinity;
        if (safeBTs !== safeATs) {
          return safeBTs - safeATs;
        }
        return (b.createdAt ?? '').localeCompare(a.createdAt ?? '');
      });
    },
    [getThreadTimestamp],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadStatus.Done ||
        existing.status === ThreadStatus.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === (ThreadStatus.Running as ThreadDtoStatusEnum)
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  const resolveInternalThreadId = useCallback((externalThreadId?: string) => {
    if (!externalThreadId) return undefined;
    const found = threadsRef.current.find(
      (thread) => thread.externalThreadId === externalThreadId,
    );
    return found?.id;
  }, []);

  const loadThreads = useCallback(async () => {
    if (!graphId) return;

    try {
      setThreadsLoading(true);
      const response = await threadsApi.getThreads(graphId, undefined, 100, 0);
      setThreads(sortThreadsByTimestampDesc(response.data || []));
    } catch (error) {
      console.error('Error loading threads:', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to load threads',
      );
      message.error(errorMessage);
      setThreads([]);
    } finally {
      setThreadsLoading(false);
    }
  }, [graphId, sortThreadsByTimestampDesc]);

  useEffect(() => {
    loadThreads();
  }, [loadThreads]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        setDeletingThreadId(threadId);
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          onThreadChange(undefined);
        }
        setThreadPopoverVisible(false);
        message.success('Thread deleted');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to delete thread';
        message.error(errorMessage);
      } finally {
        setDeletingThreadId(null);
      }
    },
    [onThreadChange, selectedThreadId],
  );

  const handleStopThread = useCallback(async (threadId: string) => {
    try {
      setStoppingThreadId(threadId);
      const response = await threadsApi.stopThread(threadId);
      const stoppedThread = response.data;
      if (stoppedThread) {
        setThreads((prev) =>
          prev.map((t) => (t.id === stoppedThread.id ? stoppedThread : t)),
        );
      }
      message.success('Thread stop requested');
    } catch (error) {
      console.error('Error stopping thread:', error);
      message.error(
        extractApiErrorMessage(error, 'Failed to stop thread execution'),
      );
    } finally {
      setStoppingThreadId(null);
    }
  }, []);

  const handleThreadSelect = useCallback(
    (newThreadId: string | undefined) => {
      onThreadChange(newThreadId);
      setThreadPopoverVisible(false);
    },
    [onThreadChange],
  );

  const chatThread = useMemo(
    () =>
      threadChatThreadId
        ? (threads.find((thread) => thread.id === threadChatThreadId) ?? null)
        : null,
    [threads, threadChatThreadId],
  );

  const handleOpenThreadChat = useCallback((threadId: string) => {
    setThreadChatThreadId(threadId);
  }, []);

  const handleCloseThreadChat = useCallback(() => {
    setThreadChatThreadId(null);
  }, []);

  const triggerNodesForGraph = useMemo(() => {
    if (!graph) return [];
    return buildTriggerNodes(graph, templatesById);
  }, [graph, templatesById]);

  const nodeDisplayNames = useMemo(
    () => (graph ? buildNodeDisplayNames(graph) : {}),
    [graph],
  );

  return {
    threads,
    setThreads,
    threadsRef,
    threadsLoading,
    threadPopoverVisible,
    setThreadPopoverVisible,
    deletingThreadId,
    stoppingThreadId,
    threadChatThreadId,
    sortThreadsByTimestampDesc,
    shouldApplyThreadUpdate,
    resolveInternalThreadId,
    loadThreads,
    handleDeleteThread,
    handleStopThread,
    handleThreadSelect,
    chatThread,
    handleOpenThreadChat,
    handleCloseThreadChat,
    triggerNodesForGraph,
    nodeDisplayNames,
  };
};
