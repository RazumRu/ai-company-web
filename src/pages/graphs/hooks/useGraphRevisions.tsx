import { Button, message, Modal, Space, Spin, Tag, Typography } from 'antd';
import { createTwoFilesPatch } from 'diff';
import {
  type MutableRefObject,
  type ReactNode,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from 'react';

import { graphRevisionsApi } from '../../../api';
import {
  type GraphDto,
  type GraphRevisionDto,
  GraphRevisionDtoStatusEnum,
} from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import type { GraphDiffState } from '../../../services/GraphStorageService';
import { extractApiErrorMessage } from '../../../utils/errors';
import {
  normalizeGraphDiffSnapshot,
  REVISION_FETCH_LIMIT,
  REVISION_STATUS_STYLES,
  sortRevisions,
} from '../utils/graphPageUtils';

interface UseGraphRevisionsOptions {
  graphId: string | undefined;
  graph: GraphDto | null;
  serverGraphState: GraphDiffState;
  draftState: {
    draftState: GraphDiffState;
  };
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
  saving: boolean;
}

export const useGraphRevisions = ({
  graphId,
  graph,
  serverGraphState,
  draftState,
  draftStateRef,
  saving,
}: UseGraphRevisionsOptions) => {
  const [revisions, setRevisions] = useState<GraphRevisionDto[]>([]);
  const [revisionsLoading, setRevisionsLoading] = useState(false);
  const [revisionPopoverVisible, setRevisionPopoverVisible] = useState(false);
  const [revisionDiffRevision, setRevisionDiffRevision] =
    useState<GraphRevisionDto | null>(null);
  const [localDiffModalVisible, setLocalDiffModalVisible] = useState(false);
  const [hoveredRevisionId, setHoveredRevisionId] = useState<string | null>(
    null,
  );

  const loadRevisions = useCallback(
    async (options?: { silent?: boolean }) => {
      if (!graphId) return;
      try {
        setRevisionsLoading(true);
        const response = await graphRevisionsApi.getGraphRevisions(
          graphId,
          undefined,
          REVISION_FETCH_LIMIT,
        );
        const revisionList = response.data || [];
        setRevisions(
          sortRevisions(revisionList).slice(0, REVISION_FETCH_LIMIT),
        );
      } catch (error) {
        console.error('Error loading graph revisions:', error);
        if (!options?.silent) {
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load graph revisions',
          );
          message.error(errorMessage);
        }
      } finally {
        setRevisionsLoading(false);
      }
    },
    [graphId],
  );

  useEffect(() => {
    void loadRevisions({ silent: true });
  }, [loadRevisions]);

  const upsertRevision = useCallback((revision: GraphRevisionDto) => {
    setRevisions((prev) => {
      const next = prev.slice();
      const index = next.findIndex((item) => item.id === revision.id);
      if (index === -1) {
        next.push(revision);
      } else {
        next[index] = revision;
      }
      return sortRevisions(next).slice(0, REVISION_FETCH_LIMIT);
    });
  }, []);

  const activeRevision = useMemo(() => {
    if (!revisions.length) {
      return null;
    }

    const applyingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
    );
    if (applyingRevision) {
      return applyingRevision;
    }

    const pendingRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Pending,
    );
    if (pendingRevision) {
      return pendingRevision;
    }

    if (graph?.version) {
      const matchingApplied = revisions.find(
        (revision) =>
          revision.toVersion === graph.version &&
          revision.status === GraphRevisionDtoStatusEnum.Applied,
      );
      if (matchingApplied) {
        return matchingApplied;
      }
    }

    const appliedRevision = revisions.find(
      (revision) => revision.status === GraphRevisionDtoStatusEnum.Applied,
    );
    if (appliedRevision) {
      return appliedRevision;
    }

    return revisions[0];
  }, [revisions, graph?.version]);

  const isRevisionApplying = useMemo(
    () =>
      revisions.some(
        (revision) => revision.status === GraphRevisionDtoStatusEnum.Applying,
      ),
    [revisions],
  );

  const handleResetAllLocalChanges = useCallback(() => {
    if (saving || isRevisionApplying) return;

    Modal.confirm({
      title: 'Reset all local changes?',
      content:
        'This will discard all unsaved changes and restore the last saved version from the server.',
      okText: 'Reset changes',
      okButtonProps: { danger: true },
      cancelText: 'Cancel',
      onOk: () => {
        draftStateRef.current.resetToServer();
        message.success('Local changes reset');
      },
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [saving, isRevisionApplying]);

  const handleOpenLocalDiff = useCallback(() => {
    setLocalDiffModalVisible(true);
    setRevisionPopoverVisible(false);
  }, []);

  const handleCloseLocalDiff = useCallback(() => {
    setLocalDiffModalVisible(false);
  }, []);

  const unsavedChangesPopoverContent = useMemo(() => {
    return (
      <Space direction="vertical" size={8}>
        <Typography.Text>You have unsaved changes.</Typography.Text>
        <Button
          type="link"
          size="small"
          onClick={handleOpenLocalDiff}
          style={{ padding: 0, height: 'auto' }}>
          View local changes
        </Button>
        <Button
          danger
          size="small"
          onClick={handleResetAllLocalChanges}
          disabled={saving || isRevisionApplying}>
          Reset all local changes
        </Button>
      </Space>
    );
  }, [
    handleOpenLocalDiff,
    handleResetAllLocalChanges,
    saving,
    isRevisionApplying,
  ]);

  const displayedRevisionMeta: {
    label: string;
    color: string;
    pulse?: boolean;
  } | null = useMemo(() => {
    if (activeRevision) {
      const meta =
        REVISION_STATUS_STYLES[
          activeRevision.status as GraphRevisionDtoStatusEnum
        ] ?? null;

      if (
        activeRevision.status === GraphRevisionDtoStatusEnum.Applying &&
        meta
      ) {
        return { ...meta, label: `Applying` };
      }
      if (meta) {
        return meta;
      }
    }
    if (graph) {
      return {
        label: 'Applied',
        color: '#52c41a',
      };
    }
    return null;
  }, [activeRevision, graph]);

  const displayedVersion = useMemo(() => {
    if (activeRevision) {
      const isAppliedActive =
        activeRevision.status === GraphRevisionDtoStatusEnum.Applied;
      if (!isAppliedActive || activeRevision.toVersion !== graph?.version) {
        return activeRevision.toVersion;
      }
    }
    return graph?.version ?? 'â€”';
  }, [activeRevision, graph?.version]);

  const localDiffPatch = useMemo(() => {
    if (!graph) return '';
    const baseline = normalizeGraphDiffSnapshot(serverGraphState);
    const draft = normalizeGraphDiffSnapshot(draftState.draftState);
    const baselineJson = JSON.stringify(baseline, null, 2);
    const draftJson = JSON.stringify(draft, null, 2);
    if (baselineJson === draftJson) {
      return '';
    }
    const baseVersionLabel = serverGraphState.baseVersion ?? graph.version;
    const baseTitle = baseVersionLabel ? `v${baseVersionLabel}` : 'Server';
    return createTwoFilesPatch(
      baseTitle,
      'Local draft',
      baselineJson,
      draftJson,
      '',
      '',
      { context: 6 },
    ).trimEnd();
  }, [draftState.draftState, graph, serverGraphState]);

  const formatRevisionDiffValue = useCallback(
    (value: unknown): ReactNode | null => {
      if (value === undefined) {
        return null;
      }
      if (value === null) {
        return (
          <Typography.Text code style={{ fontSize: 12 }}>
            null
          </Typography.Text>
        );
      }
      if (
        typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean'
      ) {
        return (
          <Typography.Text code style={{ fontSize: 12 }}>
            {JSON.stringify(value)}
          </Typography.Text>
        );
      }
      return (
        <pre
          style={{
            background: '#f5f5f5',
            borderRadius: 6,
            padding: '8px 10px',
            margin: 0,
            fontSize: 12,
            whiteSpace: 'pre-wrap',
          }}>
          {JSON.stringify(value, null, 2)}
        </pre>
      );
    },
    [],
  );

  const handleOpenRevisionDiff = useCallback((revision: GraphRevisionDto) => {
    setRevisionDiffRevision(revision);
    setRevisionPopoverVisible(false);
  }, []);

  const handleDownloadGraphBackup = useCallback(() => {
    if (!graph) {
      message.warning('Graph is not loaded yet');
      return;
    }

    try {
      const backupPayload = {
        exportedAt: new Date().toISOString(),
        graph,
        viewport: draftStateRef.current.draftState.viewport,
      };

      const blob = new Blob([JSON.stringify(backupPayload, null, 2)], {
        type: 'application/json',
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const safeVersion = graph.version ? `v${graph.version}` : 'draft';
      link.href = url;
      link.download = `graph-${graph.id ?? 'graph'}-${safeVersion}.json`;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Failed to export graph backup', error);
      message.error('Failed to download graph backup');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graph]);

  const handleCloseRevisionDiff = useCallback(() => {
    setRevisionDiffRevision(null);
  }, []);

  const revisionDiffModalVisible = revisionDiffRevision !== null;

  const revisionPopoverContent = useMemo(() => {
    if (revisionsLoading) {
      return (
        <div
          style={{
            minWidth: 280,
            minHeight: 80,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Spin size="small" />
        </div>
      );
    }

    if (revisions.length === 0) {
      return (
        <div style={{ minWidth: 280 }}>
          <Typography.Text type="secondary" style={{ fontSize: 12 }}>
            No revisions available yet.
          </Typography.Text>
        </div>
      );
    }

    return (
      <div style={{ minWidth: 320, maxHeight: 320, overflowY: 'auto' }}>
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          {revisions.map((revision) => {
            const meta = REVISION_STATUS_STYLES[
              revision.status as GraphRevisionDtoStatusEnum
            ] ?? {
              label: revision.status,
              color: '#d9d9d9',
            };
            const isActive = activeRevision?.id === revision.id;
            const isHovered = hoveredRevisionId === revision.id;
            const timestamp = new Date(
              revision.updatedAt || revision.createdAt,
            ).toLocaleString();

            return (
              <div
                key={revision.id}
                role="button"
                tabIndex={0}
                onClick={() => handleOpenRevisionDiff(revision)}
                onKeyDown={(event) => {
                  if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleOpenRevisionDiff(revision);
                  }
                }}
                onMouseEnter={() => setHoveredRevisionId(revision.id)}
                onMouseLeave={() =>
                  setHoveredRevisionId((prev) =>
                    prev === revision.id ? null : prev,
                  )
                }
                style={{
                  border: '1px solid #f0f0f0',
                  borderRadius: 6,
                  padding: '8px 12px',
                  background: isActive
                    ? '#fffbe6'
                    : isHovered
                      ? '#f0f5ff'
                      : '#fff',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  cursor: 'pointer',
                  outline: 'none',
                  transition:
                    'background-color 0.2s ease, border-color 0.2s ease',
                }}>
                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: 8,
                  }}>
                  <Typography.Text strong style={{ fontSize: 13 }}>
                    v{revision.toVersion}
                  </Typography.Text>
                  <Tag
                    color={meta.color}
                    style={{
                      margin: 0,
                      borderRadius: 999,
                      fontSize: 11,
                      lineHeight: '18px',
                      padding: '0 8px',
                    }}>
                    {meta.label}
                  </Tag>
                </div>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  From v{revision.baseVersion}
                </Typography.Text>
                <Typography.Text
                  type="secondary"
                  style={{ fontSize: 12, display: 'block' }}>
                  Updated {timestamp}
                </Typography.Text>
                {revision.error && (
                  <Typography.Text
                    type="danger"
                    style={{ fontSize: 12, display: 'block', marginTop: 2 }}>
                    {revision.error}
                  </Typography.Text>
                )}
              </div>
            );
          })}
        </Space>
      </div>
    );
  }, [
    revisionsLoading,
    revisions,
    activeRevision?.id,
    hoveredRevisionId,
    handleOpenRevisionDiff,
  ]);

  return {
    revisionPopoverVisible,
    setRevisionPopoverVisible,
    revisionDiffRevision,
    localDiffModalVisible,
    loadRevisions,
    upsertRevision,
    isRevisionApplying,
    displayedVersion,
    displayedRevisionMeta,
    localDiffPatch,
    handleCloseLocalDiff,
    unsavedChangesPopoverContent,
    revisionPopoverContent,
    formatRevisionDiffValue,
    handleDownloadGraphBackup,
    handleCloseRevisionDiff,
    revisionDiffModalVisible,
  };
};
