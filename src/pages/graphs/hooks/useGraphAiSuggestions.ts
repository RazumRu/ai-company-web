import { App } from 'antd';
import {
  type MutableRefObject,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from 'react';

import { graphsApi, litellmApi } from '../../../api';
import type {
  GraphDto,
  LiteLlmModelDto,
  SuggestGraphInstructionsResponseDtoUpdatesInner,
  TemplateDto,
} from '../../../autogenerated';
import type { UseGraphDraftStateReturn } from '../../../hooks/useGraphDraftState';
import { extractApiErrorMessage } from '../../../utils/errors';
import type { GraphNode, GraphNodeData } from '../types';

interface UseGraphAiSuggestionsOptions {
  graph: GraphDto | null;
  isGraphRunning: boolean;
  nodes: GraphNode[];
  templatesById: Record<string, TemplateDto>;
  draftStateRef: MutableRefObject<UseGraphDraftStateReturn>;
}

export const useGraphAiSuggestions = ({
  graph,
  isGraphRunning,
  nodes,
  templatesById,
  draftStateRef,
}: UseGraphAiSuggestionsOptions) => {
  const { message } = App.useApp();
  const [graphAiModalOpen, setGraphAiModalOpen] = useState(false);
  const [graphAiUserRequest, setGraphAiUserRequest] = useState('');
  const [graphAiLoading, setGraphAiLoading] = useState(false);
  const [graphAiSelectedNodeId, setGraphAiSelectedNodeId] = useState<
    string | null
  >(null);
  const [graphAiModel, setGraphAiModel] = useState<string | undefined>(
    undefined,
  );
  const [graphAiModels, setGraphAiModels] = useState<LiteLlmModelDto[]>([]);
  const [graphAiModelsLoading, setGraphAiModelsLoading] = useState(false);
  const [graphAiUpdatesByNodeId, setGraphAiUpdatesByNodeId] = useState<
    Record<string, SuggestGraphInstructionsResponseDtoUpdatesInner>
  >({});

  const formatInstructionsValue = useCallback((value: unknown): string => {
    if (value === undefined || value === null) {
      return '';
    }
    if (typeof value === 'string') {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map((item) => String(item)).join('\n\n');
    }
    try {
      return JSON.stringify(value, null, 2);
    } catch {
      return String(value);
    }
  }, []);

  const resolveAiSuggestionFieldKey = useCallback((node: GraphNode) => {
    const data = node.data as unknown as GraphNodeData;
    const schemaProps = data?.templateSchema?.properties;
    if (schemaProps && typeof schemaProps === 'object') {
      const aiEntry = Object.entries(schemaProps).find(
        ([, prop]) => prop?.['x-ui:ai-suggestions'] === true,
      );
      if (aiEntry) return aiEntry[0];
      if (schemaProps.instructions) return 'instructions';
    }
    const config = data?.config as Record<string, unknown> | undefined;
    if (
      config &&
      Object.prototype.hasOwnProperty.call(config, 'instructions')
    ) {
      return 'instructions';
    }
    return null;
  }, []);

  const getCurrentNodeInstructions = useCallback(
    (node: GraphNode) => {
      const fieldKey = resolveAiSuggestionFieldKey(node);
      if (!fieldKey) return '';
      const data = node.data as unknown as GraphNodeData;
      const config = (data?.config ?? {}) as Record<string, unknown>;
      return formatInstructionsValue(config[fieldKey]);
    },
    [formatInstructionsValue, resolveAiSuggestionFieldKey],
  );

  const agentNodes = useMemo(() => {
    return nodes.filter((node) => {
      const data = node.data as unknown as GraphNodeData;
      const kind =
        data?.templateKind ?? templatesById[data?.template]?.kind ?? '';
      return String(kind).toLowerCase() === 'simpleagent';
    });
  }, [nodes, templatesById]);

  const hasAgentNodes = agentNodes.length > 0;
  const canSubmitGraphAi =
    Boolean(graph?.id) && hasAgentNodes && isGraphRunning;

  const handleOpenGraphAiModal = useCallback(() => {
    if (agentNodes.length === 0) {
      message.warning('No agent nodes available for AI suggestions');
      return;
    }
    setGraphAiModalOpen(true);
    setGraphAiUserRequest('');
    setGraphAiUpdatesByNodeId({});
    setGraphAiSelectedNodeId(agentNodes[0]?.id ?? null);
  }, [agentNodes, message]);

  const handleCloseGraphAiModal = useCallback(() => {
    setGraphAiModalOpen(false);
    setGraphAiUserRequest('');
    setGraphAiUpdatesByNodeId({});
    setGraphAiSelectedNodeId(null);
    setGraphAiLoading(false);
  }, []);

  useEffect(() => {
    if (!graphAiModalOpen) return;
    if (graphAiModels.length > 0) return;

    let isActive = true;

    const fetchGraphAiModels = async () => {
      try {
        setGraphAiModelsLoading(true);
        const response = await litellmApi.listModels();
        if (!isActive) return;
        setGraphAiModels(response.data ?? []);
      } catch (error) {
        if (!isActive) return;
        console.error('Failed to load LiteLLM models:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load LiteLLM models',
        );
        message.error(errorMessage);
      } finally {
        if (isActive) {
          setGraphAiModelsLoading(false);
        }
      }
    };

    fetchGraphAiModels();

    return () => {
      isActive = false;
    };
  }, [graphAiModalOpen, graphAiModels.length, message]);

  const handleGraphAiSuggestionSubmit = useCallback(async () => {
    if (!graph?.id) {
      message.error('Graph is missing for suggestions');
      return;
    }
    if (!isGraphRunning) {
      message.warning('Start the graph to use AI suggestions');
      return;
    }
    if (agentNodes.length === 0) {
      message.warning('No agent nodes available for AI suggestions');
      return;
    }
    const userRequest = graphAiUserRequest.trim();
    if (!userRequest) {
      message.warning('Enter a request for the AI suggestion');
      return;
    }

    setGraphAiLoading(true);
    try {
      const response = await graphsApi.suggestGraphInstructions(graph.id, {
        userRequest,
        model: graphAiModel,
      });
      const updates = response.data?.updates ?? [];
      const updatesById = updates.reduce(
        (acc, update) => {
          if (update?.nodeId) {
            acc[update.nodeId] = update;
          }
          return acc;
        },
        {} as Record<string, SuggestGraphInstructionsResponseDtoUpdatesInner>,
      );

      setGraphAiUpdatesByNodeId(updatesById);
      setGraphAiSelectedNodeId((prev) => {
        if (prev && updatesById[prev]) return prev;
        return updates[0]?.nodeId ?? prev ?? null;
      });
      setGraphAiUserRequest('');

      if (updates.length === 0) {
        message.info('No instruction changes returned');
      }
    } catch (error) {
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to fetch AI suggestions',
      );
      message.error(errorMessage);
    } finally {
      setGraphAiLoading(false);
    }
  }, [
    agentNodes.length,
    graph?.id,
    graphAiModel,
    graphAiUserRequest,
    isGraphRunning,
    message,
  ]);

  const handleApplyGraphAiSuggestions = useCallback(() => {
    if (Object.keys(graphAiUpdatesByNodeId).length === 0) return;

    const currentNodes = draftStateRef.current.draftState.nodes;
    const missingFields: string[] = [];
    const updatedNodes = currentNodes.map((node) => {
      const update = graphAiUpdatesByNodeId[node.id];
      if (!update) return node;

      const fieldKey = resolveAiSuggestionFieldKey(node);
      if (!fieldKey) {
        missingFields.push(node.id);
        return node;
      }

      const data = node.data as unknown as GraphNodeData;
      const nextConfig = {
        ...(data.config ?? {}),
        [fieldKey]: update.instructions,
      };

      return {
        ...node,
        data: {
          ...data,
          config: nextConfig,
        },
      };
    });

    draftStateRef.current.updateNodes(updatedNodes);
    setGraphAiModalOpen(false);
    setGraphAiUserRequest('');
    setGraphAiUpdatesByNodeId({});
    setGraphAiSelectedNodeId(null);

    if (missingFields.length > 0) {
      message.warning(
        `Applied suggestions, but ${missingFields.length} node(s) lack instruction fields.`,
      );
    } else {
      message.success('Applied AI suggestions to agent nodes');
    }
  }, [
    graphAiUpdatesByNodeId,
    message,
    resolveAiSuggestionFieldKey,
    draftStateRef,
  ]);

  return {
    graphAiModalOpen,
    graphAiUserRequest,
    setGraphAiUserRequest,
    graphAiLoading,
    graphAiSelectedNodeId,
    setGraphAiSelectedNodeId,
    graphAiModel,
    setGraphAiModel,
    graphAiModels,
    graphAiModelsLoading,
    graphAiUpdatesByNodeId,
    agentNodes,
    hasAgentNodes,
    canSubmitGraphAi,
    handleOpenGraphAiModal,
    handleCloseGraphAiModal,
    handleGraphAiSuggestionSubmit,
    handleApplyGraphAiSuggestions,
    getCurrentNodeInstructions,
  };
};
