/* eslint-disable @typescript-eslint/no-explicit-any */
// ThreadMessagesView.tsx
import React, {
  useEffect,
  useRef,
  useCallback,
  useMemo,
  useState,
} from 'react';
import { Typography, Space, Spin, Popover } from 'antd';
import { ToolOutlined } from '@ant-design/icons';
import type { ThreadMessageDto } from '../../../autogenerated';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import { getReasoningIdentifier } from '../../../utils/threadMessages';
import type { PendingMessage } from '../types/messages';
import { MarkdownContent } from './threadMessages/MarkdownContent';
import { ChatBubble } from './threadMessages/ChatBubble';
import { ShellToolDisplay } from './threadMessages/ShellToolDisplay';
import { ReasoningMessage } from './threadMessages/ReasoningMessage';
import { getAgentAvatarDataUri } from '../../../utils/agentAvatars';
import {
  formatMessageContent,
  isBlankContent,
} from './threadMessages/messageUtils';

interface ToolCallFunction {
  name?: string;
  arguments?: string | Record<string, unknown>;
  title?: string;
}

interface ToolCall {
  id?: string;
  name?: string;
  function?: ToolCallFunction;
  args?: string | Record<string, unknown>;
  title?: string;
}

interface ShellResult {
  command?: string;
  exitCode?: number;
  output?: string;
  stdout?: string;
  stderr?: string;
  [key: string]: unknown;
}

type JsonValue =
  | string
  | number
  | boolean
  | null
  | JsonValue[]
  | { [key: string]: JsonValue };

const { Text } = Typography;

export interface ThreadMessagesViewProps {
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  selectedThreadId?: string;
  nodeId?: string;
  nodeDisplayNames?: Record<string, string>;
  showNodeHeadings?: boolean;
  isAgentNode?: boolean;
  nodeTemplateKind?: string;
  onLoadMoreMessages?: () => void;
  hasMoreMessages?: boolean;
  loadingMore?: boolean;
  isNodeRunning?: boolean;
  /**
   * When true, the thread was explicitly stopped by the user. In this state we
   * must never render tool calls as "in progress" (e.g. with a spinner).
   */
  isThreadStopped?: boolean;
  /**
   * Current thread run identifier. Tool calls from a different run must never
   * render as "in progress".
   */
  currentThreadLastRunId?: string | null;
  pendingMessages?: PendingMessage[];
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

const ensureThinkingIndicatorStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-thinking-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-thinking-style';
    style.textContent = `
      @keyframes messages-tab-thinking-pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const ensureReasoningAnimationStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-reasoning-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-reasoning-style';
    style.textContent = `
      @keyframes messages-tab-reasoning-appear {
        0% {
          opacity: 0;
          transform: translateY(6px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes messages-tab-reasoning-streaming {
        0% {
          color: rgba(0, 0, 0, 0.4);
        }
        50% {
          color: rgba(0, 0, 0, 0.75);
        }
        100% {
          color: rgba(0, 0, 0, 0.4);
        }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

type MessagePayload = ThreadMessageDto['message'];

const getMessageRecord = (
  payload?: MessagePayload,
): Record<string, unknown> | undefined => {
  if (!payload || typeof payload !== 'object') {
    return undefined;
  }
  return payload as unknown as Record<string, unknown>;
};

const getMessageValue = <T = unknown,>(
  payload: MessagePayload | undefined,
  key: string,
): T | undefined => {
  const record = getMessageRecord(payload);
  if (!record) return undefined;
  return record[key] as T | undefined;
};

const getMessageString = (
  payload: MessagePayload | undefined,
  key: string,
): string | undefined => {
  const value = getMessageValue(payload, key);
  return typeof value === 'string' ? value : undefined;
};

const getMessageRunId = (payload?: MessagePayload): string | undefined => {
  const record = getMessageRecord(payload);
  if (!record) return undefined;

  // Prefer the normalized field coming from the API response.
  const direct = (record.runId as unknown) ?? (record.run_id as unknown);
  if (typeof direct === 'string' && direct.length > 0) {
    return direct;
  }

  const additional =
    (record.additionalKwargs as Record<string, unknown> | undefined) ??
    (record.additional_kwargs as Record<string, unknown> | undefined);

  const fromAdditional =
    additional && typeof additional === 'object'
      ? ((additional.run_id as unknown) ?? (additional.runId as unknown))
      : undefined;

  if (typeof fromAdditional === 'string' && fromAdditional.length > 0) {
    return fromAdditional;
  }
  return undefined;
};

const fullHeightColumnStyle: React.CSSProperties = {
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  minHeight: 0,
};

const centeredStateStyle: React.CSSProperties = {
  flex: 1,
  minHeight: 0,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
};

const scrollContainerStyle: React.CSSProperties = {
  flex: 1,
  minHeight: 0,
  overflowY: 'auto',
  overflowX: 'hidden',
  padding: '12px 16px',
};

const messageBlockStyle: React.CSSProperties = {
  marginBottom: '15px',
};

const ThreadMessagesView: React.FC<ThreadMessagesViewProps> = React.memo(
  ({
    messages,
    messagesLoading,
    selectedThreadId,
    nodeId,
    nodeDisplayNames,
    showNodeHeadings = false,
    isAgentNode = true,
    nodeTemplateKind,
    onLoadMoreMessages,
    hasMoreMessages,
    loadingMore,
    isNodeRunning = false,
    isThreadStopped = false,
    currentThreadLastRunId,
    pendingMessages = [],
    newMessageMode,
  }) => {
    const scrollContainerRef = useRef<HTMLDivElement | null>(null);
    const prevScrollHeightRef = useRef<number>(0);
    const isPrependingRef = useRef<boolean>(false);
    const pendingAutoScrollRef = useRef<boolean>(false);
    const autoScrollDisabledRef = useRef<boolean>(false);
    const lastMessageCountRef = useRef<number>(0);

    const [expandedReasoningIds, setExpandedReasoningIds] = useState<
      Set<string>
    >(() => new Set());
    const toggleReasoningMessage = useCallback((id: string) => {
      setExpandedReasoningIds((prev) => {
        const next = new Set(prev);
        if (next.has(id)) {
          next.delete(id);
        } else {
          next.add(id);
        }
        return next;
      });
    }, []);

    useEffect(() => {
      ensureThinkingIndicatorStyles();
      ensureReasoningAnimationStyles();
    }, []);

    useEffect(() => {
      pendingAutoScrollRef.current = true;
    }, [selectedThreadId, nodeId]);

    useEffect(() => {
      if (!isPrependingRef.current) return;
      const el = scrollContainerRef.current;
      if (el) {
        const diff = el.scrollHeight - prevScrollHeightRef.current;
        el.scrollTop = diff + el.scrollTop;
      }
      isPrependingRef.current = false;
    }, [messages.length]);

    useEffect(() => {
      if (messagesLoading) return;
      const el = scrollContainerRef.current;
      if (!el) return;

      const isInitiallyEmpty = lastMessageCountRef.current === 0;
      const shouldAutoScroll =
        pendingAutoScrollRef.current ||
        isInitiallyEmpty ||
        !autoScrollDisabledRef.current;

      if (shouldAutoScroll) {
        el.scrollTop = el.scrollHeight;
      }

      pendingAutoScrollRef.current = false;
      lastMessageCountRef.current = messages.length;
    }, [messagesLoading, messages.length]);

    useEffect(() => {
      if (!pendingMessages || pendingMessages.length === 0) return;
      pendingAutoScrollRef.current = true;
      const el = scrollContainerRef.current;
      if (!el) return;
      const shouldAutoScroll =
        pendingAutoScrollRef.current || !autoScrollDisabledRef.current;
      if (shouldAutoScroll) {
        el.scrollTop = el.scrollHeight;
        pendingAutoScrollRef.current = false;
      }
    }, [pendingMessages, pendingMessages?.length]);

    useEffect(() => {
      const styleId = 'shell-scrollbar-styles';
      if (document.getElementById(styleId)) return;

      const style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
      .shell-output-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .shell-output-container::-webkit-scrollbar-track {
        background: #2a2a2a;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb:hover {
        background: #666;
      }
    `;
      document.head.appendChild(style);

      return () => {
        const existingStyle = document.getElementById(styleId);
        if (existingStyle) {
          existingStyle.remove();
        }
      };
    }, []);

    const handleScroll = useCallback(() => {
      const el = scrollContainerRef.current;
      if (!el) return;
      const nearTop = el.scrollTop <= 100;
      if (
        nearTop &&
        hasMoreMessages &&
        !loadingMore &&
        typeof onLoadMoreMessages === 'function'
      ) {
        prevScrollHeightRef.current = el.scrollHeight;
        isPrependingRef.current = true;
        onLoadMoreMessages();
      }
      const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight <= 48;
      autoScrollDisabledRef.current = !nearBottom;
    }, [hasMoreMessages, loadingMore, onLoadMoreMessages]);

    const parseJsonSafe = (value: string): JsonValue | null => {
      try {
        return JSON.parse(value) as JsonValue;
      } catch {
        return null;
      }
    };

    const isToolLikeRole = (role?: string): boolean => {
      if (!role) return false;
      return role === 'tool' || role === 'tool-shell';
    };

    const buildToolCallResultIndex = useCallback(
      (allMessages: ThreadMessageDto[]): Record<string, ThreadMessageDto[]> => {
        return allMessages.reduce<Record<string, ThreadMessageDto[]>>(
          (acc, msg) => {
            if (!isToolLikeRole(msg.message?.role as string)) {
              return acc;
            }
            const toolCallId = getMessageString(msg.message, 'toolCallId');
            if (!toolCallId) {
              return acc;
            }
            if (!acc[toolCallId]) {
              acc[toolCallId] = [];
            }
            acc[toolCallId].push(msg);
            return acc;
          },
          {},
        );
      },
      [],
    );

    const getToolMessageKey = (msg?: ThreadMessageDto): string | undefined => {
      if (!msg) return undefined;
      if (msg.id) return msg.id;
      const messageLevelId = getMessageString(msg.message, 'id');
      if (messageLevelId) return messageLevelId;
      if (msg.createdAt) return `created-${msg.createdAt}`;
      const toolCallId = getMessageString(msg.message, 'toolCallId');
      if (toolCallId) return `toolCall-${toolCallId}`;
      return undefined;
    };

    const argsToObject = useCallback(
      (
        args?: string | Record<string, unknown>,
      ): Record<string, JsonValue> | null => {
        if (!args) return null;
        if (typeof args === 'string') {
          const parsed = parseJsonSafe(args);
          return parsed && typeof parsed === 'object' && !Array.isArray(parsed)
            ? (parsed as Record<string, JsonValue>)
            : null;
        }
        if (typeof args === 'object' && !Array.isArray(args)) {
          return args as Record<string, JsonValue>;
        }
        return null;
      },
      [],
    );

    const extractShellCommandFromArgs = useCallback(
      (args?: string | Record<string, unknown>): string | undefined => {
        const obj = argsToObject(args);
        if (!obj) return undefined;
        if (typeof obj.command === 'string') return obj.command;
        if (typeof obj.cmd === 'string') return obj.cmd;
        return undefined;
      },
      [argsToObject],
    );

    const renderToolPopoverContent = (
      value: unknown,
      toolOptions?: Record<string, JsonValue>,
    ): React.ReactNode => {
      let parsed: JsonValue | null = null;
      if (typeof value === 'string') {
        parsed = parseJsonSafe(value);
      } else if (value && typeof value === 'object' && !Array.isArray(value)) {
        parsed = value as JsonValue;
      }

      const containerStyle: React.CSSProperties = { maxWidth: 520 };
      const innerStyle: React.CSSProperties = {
        maxHeight: 300,
        overflow: 'auto',
        background: '#f5f5f5',
        border: '1px solid #eee',
        borderRadius: 6,
        padding: 12,
        fontFamily:
          'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
        fontSize: 12,
        whiteSpace: 'pre-wrap',
      };

      const sectionStyle: React.CSSProperties = {
        marginBottom: 16,
      };

      const sectionTitleStyle: React.CSSProperties = {
        fontWeight: 'bold',
        fontSize: 13,
        marginBottom: 8,
        color: '#333',
        borderBottom: '1px solid #ddd',
        paddingBottom: 4,
      };

      return (
        <div style={containerStyle}>
          {toolOptions && Object.keys(toolOptions).length > 0 && (
            <div style={sectionStyle}>
              <div style={sectionTitleStyle}>Tool Options:</div>
              <div style={innerStyle}>
                <JsonView value={toolOptions} style={lightTheme} />
              </div>
            </div>
          )}

          <div style={sectionStyle}>
            <div style={sectionTitleStyle}>Output:</div>
            <div style={innerStyle}>
              {parsed ? (
                <JsonView value={parsed as object} style={lightTheme} />
              ) : (
                <pre
                  style={{
                    margin: 0,
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                  }}>
                  {String(value ?? '')}
                </pre>
              )}
            </div>
          </div>
        </div>
      );
    };

    type ToolRenderStatus = 'calling' | 'executed' | 'stopped';

    type PreparedMessage =
      | {
          type: 'system';
          messages: ThreadMessageDto[];
          id: string;
          nodeId?: string;
          createdAt?: string;
        }
      | {
          type: 'reasoning';
          message: ThreadMessageDto;
          id: string;
          nodeId?: string;
          createdAt?: string;
        }
      | {
          type: 'chat';
          message: ThreadMessageDto;
          id: string;
          nodeId?: string;
          createdAt?: string;
        }
      | {
          type: 'tool';
          name: string;
          status: ToolRenderStatus;
          result?: unknown;
          id: string;
          toolKind?: 'generic' | 'shell';
          shellCommand?: string;
          toolOptions?: Record<string, JsonValue>;
          nodeId?: string;
          createdAt?: string;
          roleLabel?: string;
          title?: string;
        };

    const prepareReadyMessages = useCallback(
      (msgs: ThreadMessageDto[]): PreparedMessage[] => {
        const allowCallingIndicators = isNodeRunning && !isThreadStopped;
        const isLatestRun = (runId?: string): boolean => {
          if (!currentThreadLastRunId) return true;
          if (!runId) return false;
          return runId === currentThreadLastRunId;
        };
        const toolCallResultsById = buildToolCallResultIndex(msgs);
        const consumedToolCallIds = new Set<string>();
        const consumedToolMessageKeys = new Set<string>();

        const markToolMessageConsumed = (msg?: ThreadMessageDto) => {
          const key = getToolMessageKey(msg);
          if (key) {
            consumedToolMessageKeys.add(key);
          }
        };

        const markToolCallConsumed = (toolCallId?: string) => {
          if (toolCallId) {
            consumedToolCallIds.add(toolCallId);
          }
        };

        const consumeToolResultById = (
          toolCallId?: string,
        ): ThreadMessageDto | undefined => {
          if (!toolCallId) return undefined;
          const queue = toolCallResultsById[toolCallId];
          if (!queue || queue.length === 0) {
            return undefined;
          }
          const next = queue.shift();
          markToolCallConsumed(toolCallId);
          markToolMessageConsumed(next);
          return next;
        };

        // First pass: identify all tool calls from AI messages and mark their results as consumed
        // This prevents tool results from being rendered as standalone before we process the AI message
        msgs.forEach((m) => {
          const role = (m.message?.role as string) || '';
          if (role === 'ai') {
            const messageToolCalls = getMessageValue<ToolCall[]>(
              m.message,
              'toolCalls',
            );
            if (messageToolCalls && messageToolCalls.length > 0) {
              messageToolCalls.forEach((tc) => {
                if (tc.id) {
                  // Check if result exists for this tool call
                  const queue = toolCallResultsById[tc.id];
                  if (queue && queue.length > 0) {
                    // Mark as consumed so it won't be rendered as standalone
                    markToolCallConsumed(tc.id);
                    markToolMessageConsumed(queue[0]);
                  }
                }
              });
            }
          }
        });

        const prepared: PreparedMessage[] = [];
        let i = 0;

        while (i < msgs.length) {
          const m = msgs[i];
          const role = (m.message?.role as string) || '';

          if (role === 'reasoning') {
            if (!isBlankContent(m.message?.content)) {
              prepared.push({
                type: 'reasoning',
                message: m,
                id: `reasoning-${m.id || m.createdAt}`,
                nodeId: m.nodeId,
                createdAt: m.createdAt,
              });
            }
            i++;
            continue;
          }

          if (role === 'system') {
            const sys: ThreadMessageDto[] = [m];
            let j = i + 1;
            while (
              j < msgs.length &&
              (msgs[j].message?.role as string) === 'system'
            ) {
              sys.push(msgs[j]);
              j++;
            }
            prepared.push({
              type: 'system',
              messages: sys,
              id: `system-${sys[0].id || sys[0].createdAt}`,
              nodeId: sys[0]?.nodeId,
              createdAt: sys[0]?.createdAt,
            });
            i = j;
            continue;
          }

          const messageToolCalls = getMessageValue<ToolCall[]>(
            m.message,
            'toolCalls',
          );
          if (
            role === 'ai' &&
            messageToolCalls &&
            messageToolCalls.length > 0
          ) {
            const hasNonBlankContent = !isBlankContent(m.message?.content);

            if (hasNonBlankContent) {
              prepared.push({
                type: 'chat',
                message: m,
                id: `chat-${m.id || m.createdAt}`,
                nodeId: m.nodeId,
                createdAt: m.createdAt,
              });
            }

            const followingTools: ThreadMessageDto[] = [];
            let j = i + 1;
            while (
              j < msgs.length &&
              isToolLikeRole(msgs[j].message?.role as string)
            ) {
              followingTools.push(msgs[j]);
              j++;
            }

            const toolCalls = messageToolCalls;
            for (let idx = 0; idx < toolCalls.length; idx++) {
              const tc = toolCalls[idx];
              const name = tc.name || tc.function?.name || 'tool';
              const callTitle = tc.title || tc.function?.title;
              let matched = consumeToolResultById(tc.id);
              if (!matched) {
                matched = followingTools.find(
                  (tm) => getMessageString(tm.message, 'toolCallId') === tc.id,
                );
                if (matched) {
                  markToolCallConsumed(
                    tc.id || getMessageString(matched.message, 'toolCallId'),
                  );
                  markToolMessageConsumed(matched);
                }
              }
              const resultContent = matched?.message?.content;
              const toolArgs = tc.function?.arguments ?? tc.args;
              const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
              const resultObj =
                typeof resultContent === 'object' &&
                resultContent !== null &&
                !Array.isArray(resultContent)
                  ? (resultContent as ShellResult)
                  : null;
              const shellCommand = shellCmdFromArgs || resultObj?.command;
              const isShell = (name || '').toLowerCase() === 'shell';
              const toolOptions = argsToObject(toolArgs);
              const matchedTitle = getMessageString(matched?.message, 'title');
              const effectiveTitle = matchedTitle || callTitle;
              const toolCallRunId =
                getMessageRunId(m.message) ?? getMessageRunId(matched?.message);

              prepared.push({
                type: 'tool',
                name: name || 'tool',
                status: matched
                  ? 'executed'
                  : allowCallingIndicators && isLatestRun(toolCallRunId)
                    ? 'calling'
                    : 'stopped',
                result: resultContent,
                id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
                toolKind: isShell ? 'shell' : 'generic',
                shellCommand,
                toolOptions: toolOptions || undefined,
                nodeId: matched?.nodeId ?? m.nodeId,
                createdAt: matched?.createdAt ?? m.createdAt,
                roleLabel: effectiveTitle || name || 'tool',
                title: effectiveTitle,
              });
            }

            i = i + 1 + followingTools.length;
            continue;
          }

          if (isToolLikeRole(role)) {
            const toolCallId = getMessageString(m.message, 'toolCallId');
            const messageKey = getToolMessageKey(m);
            if (
              (toolCallId && consumedToolCallIds.has(toolCallId)) ||
              (messageKey && consumedToolMessageKeys.has(messageKey))
            ) {
              i++;
              continue;
            }

            const name = getMessageString(m.message, 'name') || 'tool';
            const title = getMessageString(m.message, 'title');
            const resultContent = m.message?.content;
            const resultObj =
              typeof resultContent === 'object' &&
              resultContent !== null &&
              !Array.isArray(resultContent)
                ? (resultContent as ShellResult)
                : null;
            const shellCommand = resultObj?.command;
            const isShell = (name || '').toLowerCase() === 'shell';
            const toolOptions = undefined;

            prepared.push({
              type: 'tool',
              name,
              status: 'executed',
              result: resultContent,
              id: `tool-standalone-${m.id || m.createdAt}`,
              toolKind: isShell ? 'shell' : 'generic',
              shellCommand,
              toolOptions,
              nodeId: m.nodeId,
              createdAt: m.createdAt,
              roleLabel: title || name || 'tool',
              title,
            });
            i++;
            continue;
          }

          if (!isBlankContent(m.message?.content)) {
            prepared.push({
              type: 'chat',
              message: m,
              id: `chat-${m.id || m.createdAt}`,
              nodeId: m.nodeId,
              createdAt: m.createdAt,
            });
          }
          i++;
        }

        return prepared;
      },
      [
        argsToObject,
        buildToolCallResultIndex,
        extractShellCommandFromArgs,
        isNodeRunning,
        isThreadStopped,
        currentThreadLastRunId,
      ],
    );

    // eslint-disable-next-line react-hooks/exhaustive-deps
    const preparedMessages = useMemo(() => {
      return prepareReadyMessages(messages);
    }, [messages, prepareReadyMessages]);
    const isThinkingVisible = isNodeRunning && isAgentNode;

    const renderFullHeightState = (content: React.ReactNode) => (
      <div style={fullHeightColumnStyle}>
        <div style={centeredStateStyle}>{content}</div>
      </div>
    );

    const renderSystemGroup = (
      systemMessages: ThreadMessageDto[],
      count: number,
    ) => {
      const firstMessage = systemMessages[0];
      const content = formatMessageContent(firstMessage.message?.content);
      const countSuffix = count > 1 ? ` (${count} system messages)` : '';
      const fullText = `${content}${countSuffix}`;

      const textContainerStyle: React.CSSProperties = {
        fontSize: '12px',
        color: '#afafaf',
        textAlign: 'center',
      };

      return (
        <div style={{ width: '100%' }}>
          <div style={textContainerStyle}>
            <MarkdownContent content={fullText} allowHorizontalScroll={true} />
          </div>
        </div>
      );
    };

    const renderFinishTool = (
      status: ToolRenderStatus,
      resultContent?: unknown,
      metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string },
    ) => {
      if (status !== 'executed') {
        return undefined;
      }

      let finishMessage = 'Task completed.';
      let needsMoreInfo = false;
      if (resultContent) {
        if (typeof resultContent === 'string') {
          finishMessage = resultContent;
        } else if (
          typeof resultContent === 'object' &&
          resultContent !== null
        ) {
          const obj = resultContent as Record<string, unknown>;
          finishMessage =
            (typeof obj.message === 'string' ? obj.message : '') ||
            (typeof obj.content === 'string' ? obj.content : '') ||
            (typeof obj.result === 'string' ? obj.result : '') ||
            'Task completed.';
          needsMoreInfo = Boolean(obj.needsMoreInfo);
        }
      }

      const messageColor = needsMoreInfo ? '#faad14' : '#52c41a';
      const statusTag = needsMoreInfo ? '⚠ Need more info' : '✓ Finished';
      const avatarSrc = metadata?.nodeId
        ? getAgentAvatarDataUri(metadata.nodeId)
        : undefined;

      return (
        <ChatBubble
          isHuman={false}
          avatarLabel="AI"
          avatarColor={messageColor}
          avatarSrc={avatarSrc}
          containerStyle={{ marginBottom: '8px' }}
          bubbleStyle={{
            backgroundColor: '#f3f3f3',
            borderLeft: `3px solid ${messageColor}`,
          }}
          footer={renderMetadataText(
            metadata?.createdAt,
            metadata?.roleLabel,
            metadata?.nodeId,
          )}>
          <Text
            type="secondary"
            style={{
              fontSize: '11px',
              marginBottom: '5px',
              display: 'block',
              color: messageColor,
              fontWeight: 'bold',
            }}>
            {statusTag}
          </Text>

          <MarkdownContent
            content={finishMessage}
            style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
          />
        </ChatBubble>
      );
    };

    const renderToolStatusLine = (
      name: string,
      status: ToolRenderStatus,
      resultContent?: unknown,
      toolOptions?: Record<string, JsonValue>,
      titleText?: string,
    ) => {
      const isClickable = status === 'executed' && resultContent !== undefined;
      const isCalling = status === 'calling';
      const statusText =
        status === 'calling'
          ? 'calling...'
          : status === 'stopped'
            ? 'stopped'
            : 'executed';
      const displayTitle =
        (titleText && titleText.trim().length > 0 ? titleText : undefined) ??
        (toolOptions?.purpose
          ? `${name} | ${String(toolOptions.purpose)}`
          : `tool ${name} is ${statusText}`);
      const accessibleName = displayTitle || name;
      const line = (
        <div
          className="hoverable-chat-message"
          style={{
            cursor: isClickable ? 'pointer' : 'default',
            animation: isCalling
              ? 'messages-tab-thinking-pulse 1.6s ease-in-out infinite'
              : undefined,
          }}
          aria-label={
            status === 'executed'
              ? `View tool result for ${accessibleName}`
              : status === 'stopped'
                ? `Tool ${accessibleName} is stopped`
                : `Tool ${accessibleName} is calling`
          }
          tabIndex={isClickable ? 0 : -1}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}>
            <Text
              type="secondary"
              className="tool-status-line__text"
              style={{ fontSize: '12px', color: 'inherit' }}>
              {displayTitle}
            </Text>
          </div>
        </div>
      );

      let baseLine: React.ReactNode = line;
      if (isClickable) {
        const contentNode = renderToolPopoverContent(
          resultContent,
          toolOptions,
        );
        baseLine = (
          <Popover
            content={contentNode}
            trigger={['click']}
            placement="topLeft">
            {line}
          </Popover>
        );
      }

      return baseLine;
    };

    const renderShellStatusLine = (
      name: string,
      status: ToolRenderStatus,
      resultContent?: unknown,
      shellCommand?: string,
      toolOptions?: Record<string, JsonValue>,
      metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string },
      titleText?: string,
    ) => {
      return (
        <ShellToolDisplay
          name={name}
          status={status}
          resultContent={resultContent}
          shellCommand={shellCommand}
          toolOptions={toolOptions}
          title={titleText}
          metadata={metadata}
        />
      );
    };

    const renderNonAgentNodeInfo = () => {
      if (isAgentNode) return null;

      return (
        <div style={{ padding: '16px', textAlign: 'center' }}>
          <Space direction="vertical" size="large">
            <ToolOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
            <div>
              <Text strong style={{ fontSize: '16px' }}>
                {nodeTemplateKind || 'Tool'} Node
              </Text>
              <br />
              <Text type="secondary" style={{ fontSize: '14px' }}>
                This node executes tool calls and doesn't participate in
                conversations.
              </Text>
            </div>
            <div
              style={{
                backgroundColor: '#f8f9fa',
                border: '1px solid #e9ecef',
                borderRadius: '8px',
                padding: '12px',
                textAlign: 'left',
              }}>
              <Text strong style={{ fontSize: '13px', color: '#495057' }}>
                Tool Call Information:
              </Text>
              <br />
              <Text type="secondary" style={{ fontSize: '12px' }}>
                • Tool calls are executed when this node is triggered
                <br />
                • Results are passed to connected nodes
                <br />• Check the execution logs for detailed information
              </Text>
            </div>
          </Space>
        </div>
      );
    };

    const renderMessage = (message: ThreadMessageDto) => {
      const role = (message.message?.role as string) || '';
      const content = formatMessageContent(message.message?.content);
      const metadataText =
        formatMetadataLine(message.createdAt, role, message.nodeId) ||
        (role ? `from ${role}` : undefined);

      if (isToolLikeRole(role)) {
        const name = getMessageString(message.message, 'name') || 'tool';
        const title = getMessageString(message.message, 'title');
        const resultContent = message.message?.content;
        return renderToolStatusLine(
          name,
          'executed',
          resultContent,
          undefined,
          title,
        );
      }

      if (isBlankContent(message.message?.content)) return null;

      const isHuman = role === 'human';
      const avatarSeedNodeId = message.nodeId || nodeId;
      const avatarSrc =
        !isHuman && avatarSeedNodeId
          ? getAgentAvatarDataUri(avatarSeedNodeId)
          : undefined;
      const avatarColor = isHuman
        ? '#1890ff'
        : role === 'ai'
          ? '#52c41a'
          : role === 'system'
            ? '#722ed1'
            : '#d9d9d9';

      return (
        <ChatBubble
          isHuman={isHuman}
          avatarLabel={isHuman ? 'ME' : 'AI'}
          avatarColor={avatarColor}
          avatarSrc={avatarSrc}
          footer={
            metadataText ? (
              <Text
                type="secondary"
                style={{
                  fontSize: '11px',
                  marginTop: '4px',
                  color: '#8c8c8c',
                }}>
                {metadataText}
              </Text>
            ) : undefined
          }>
          <MarkdownContent
            content={content}
            style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
          />
        </ChatBubble>
      );
    };

    const renderPendingMessage = (message: PendingMessage) => {
      const isHuman = message.role === 'human';
      const content = message.content;
      const avatarSrc =
        !isHuman && nodeId ? getAgentAvatarDataUri(nodeId) : undefined;

      const sendTimeText =
        newMessageMode === 'inject_after_tool_call'
          ? 'Will be sent after next tool execution'
          : newMessageMode === 'wait_for_completion'
            ? 'Will be sent after agent completes current task'
            : 'Pending';

      return (
        <ChatBubble
          isHuman={isHuman}
          avatarLabel={isHuman ? 'ME' : 'AI'}
          avatarColor={isHuman ? '#1890ff' : '#52c41a'}
          avatarSrc={avatarSrc}
          containerStyle={{ opacity: 0.6 }}
          bubbleStyle={{ border: '2px dashed #d9d9d9' }}
          footer={
            <Text
              type="secondary"
              style={{
                fontSize: '11px',
                marginTop: '4px',
                color: '#8c8c8c',
                fontStyle: 'italic',
              }}>
              {sendTimeText}
            </Text>
          }>
          <MarkdownContent
            content={content}
            style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
          />
        </ChatBubble>
      );
    };

    const formatNodeLabel = (nodeIdentifier?: string): string | undefined => {
      if (!nodeIdentifier) {
        return undefined;
      }
      const mapped = nodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) {
        return mapped;
      }
      if (nodeIdentifier.length <= 10) {
        return nodeIdentifier;
      }
      return `Node ${nodeIdentifier.slice(-6)}`;
    };

    const formatMetadataLine = (
      createdAt?: string,
      roleLabel?: string,
      sourceNodeId?: string,
    ): string | undefined => {
      const datePart = createdAt
        ? new Date(createdAt).toLocaleString()
        : undefined;
      const descriptorParts: string[] = [];
      if (roleLabel) {
        descriptorParts.push(`from ${roleLabel}`);
      }
      if (showNodeHeadings) {
        const label = formatNodeLabel(sourceNodeId || nodeId);
        if (label) {
          descriptorParts.push(`(${label} node)`);
        }
      }
      const descriptor = descriptorParts.join(' ');
      const parts = [datePart, descriptor].filter(
        (part) => part && part.length,
      );
      if (!parts.length) {
        return undefined;
      }
      return parts.join(' | ');
    };

    const renderMetadataText = (
      createdAt?: string,
      roleLabel?: string,
      sourceNodeId?: string,
    ): React.ReactNode => {
      const text = formatMetadataLine(createdAt, roleLabel, sourceNodeId);
      if (!text) {
        return null;
      }
      return (
        <Text
          type="secondary"
          style={{
            fontSize: '11px',
            marginTop: '4px',
            color: '#8c8c8c',
            display: 'block',
          }}>
          {text}
        </Text>
      );
    };

    const renderPreparedMessages = () => {
      const rows: React.ReactNode[] = [];
      let i = 0;

      const pushRow = (
        key: React.Key,
        content: React.ReactNode,
        extraStyle?: React.CSSProperties,
      ) => {
        rows.push(
          <div key={key} style={{ ...messageBlockStyle, ...extraStyle }}>
            {content}
          </div>,
        );
      };

      while (i < preparedMessages.length) {
        const item = preparedMessages[i];

        if (item.type === 'system') {
          pushRow(
            item.id,
            renderSystemGroup(item.messages, item.messages.length),
          );
          i++;
          continue;
        }

        if (item.type === 'reasoning') {
          const reasoningId =
            getReasoningIdentifier(item.message) ?? item.message.id;
          pushRow(
            item.id,
            <ReasoningMessage
              message={item.message}
              isExpanded={expandedReasoningIds.has(reasoningId)}
              onToggle={toggleReasoningMessage}
            />,
          );
          i++;
          continue;
        }

        if (item.type === 'chat') {
          pushRow(item.id, renderMessage(item.message));
          i++;
          continue;
        }

        if (item.type === 'tool') {
          if (item.name && item.name.toLowerCase() === 'finish') {
            pushRow(
              item.id || `finish-${i}`,
              renderFinishTool(item.status, item.result, {
                nodeId: item.nodeId,
                createdAt: item.createdAt,
                roleLabel: 'ai',
              }),
            );
            i++;
            continue;
          }

          if (item.toolKind === 'shell') {
            pushRow(
              item.id || `shell-${i}`,
              renderShellStatusLine(
                item.name,
                item.status,
                item.result,
                item.shellCommand,
                item.toolOptions,
                {
                  nodeId: item.nodeId,
                  createdAt: item.createdAt,
                  roleLabel: item.roleLabel ?? item.name,
                },
                item.title,
              ),
            );
            i++;
            continue;
          }

          pushRow(
            item.id || `generic-tool-${i}`,
            renderToolStatusLine(
              item.name,
              item.status,
              item.result,
              item.toolOptions,
              item.title,
            ),
          );
          i++;
          continue;
        }

        i++;
      }

      return rows;
    };

    if (!selectedThreadId) {
      return renderFullHeightState(
        <Text type="secondary">
          Select a thread from the header to view messages.
        </Text>,
      );
    }

    if (!isAgentNode) {
      return (
        <div style={fullHeightColumnStyle}>
          <div
            style={{
              ...scrollContainerStyle,
              overflowX: 'auto',
            }}>
            {renderNonAgentNodeInfo()}
          </div>
        </div>
      );
    }

    if (messagesLoading) {
      return renderFullHeightState(
        <Space direction="vertical" align="center" size="small">
          <Spin />
          <Text type="secondary">Loading messages...</Text>
        </Space>,
      );
    }

    if (messages.length === 0) {
      return renderFullHeightState(
        <Text type="secondary">No messages found for this thread.</Text>,
      );
    }

    return (
      <div style={fullHeightColumnStyle}>
        <div
          ref={scrollContainerRef}
          onScroll={handleScroll}
          style={scrollContainerStyle}>
          {loadingMore && (
            <div
              style={{
                padding: '8px 12px',
                textAlign: 'center',
                fontSize: '12px',
                color: '#8c8c8c',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '8px',
              }}>
              <Spin size="small" />
              <Text
                type="secondary"
                style={{ fontSize: '12px', color: '#8c8c8c' }}>
                Loading more messages...
              </Text>
            </div>
          )}

          {renderPreparedMessages()}
          {isThinkingVisible && !messagesLoading && (
            <div
              style={{
                textAlign: 'center',
                animation:
                  'messages-tab-thinking-pulse 1.6s ease-in-out infinite',
              }}>
              <div
                style={{
                  fontSize: '12px',
                  color: '#8c8c8c',
                  textAlign: 'center',
                  cursor: 'pointer',
                  display: '-webkit-box',
                  WebkitLineClamp: 3,
                  WebkitBoxOrient: 'vertical',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  lineHeight: '1.5',
                  wordBreak: 'break-word',
                  width: '100%',
                }}>
                Agent is thinking...
              </div>
            </div>
          )}
          {pendingMessages && pendingMessages.length > 0 && (
            <div
              style={{
                borderTop: '1px solid #ebebeb',
                paddingTop: '10px',
                marginTop: '8px',
              }}>
              {pendingMessages.map((msg, idx) => (
                <div
                  key={`pending-${msg.content}-${idx}`}
                  style={messageBlockStyle}>
                  {renderPendingMessage(msg)}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    );
  },
  (prevProps, nextProps) => {
    const messagesEqual =
      prevProps.messages === nextProps.messages ||
      (prevProps.messages.length === nextProps.messages.length &&
        prevProps.messages.every(
          (msg, idx) => msg.id === nextProps.messages[idx]?.id,
        ));

    const pendingMessagesEqual =
      prevProps.pendingMessages === nextProps.pendingMessages ||
      (prevProps.pendingMessages?.length ===
        nextProps.pendingMessages?.length &&
        (prevProps.pendingMessages?.every(
          (msg, idx) =>
            msg.content === nextProps.pendingMessages?.[idx]?.content &&
            msg.role === nextProps.pendingMessages?.[idx]?.role,
        ) ??
          false));

    return (
      messagesEqual &&
      prevProps.messagesLoading === nextProps.messagesLoading &&
      prevProps.selectedThreadId === nextProps.selectedThreadId &&
      prevProps.nodeId === nextProps.nodeId &&
      prevProps.isAgentNode === nextProps.isAgentNode &&
      prevProps.hasMoreMessages === nextProps.hasMoreMessages &&
      prevProps.loadingMore === nextProps.loadingMore &&
      prevProps.isNodeRunning === nextProps.isNodeRunning &&
      pendingMessagesEqual &&
      prevProps.newMessageMode === nextProps.newMessageMode &&
      prevProps.onLoadMoreMessages === nextProps.onLoadMoreMessages
    );
  },
);

export default ThreadMessagesView;
