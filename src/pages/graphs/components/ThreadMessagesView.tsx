/* eslint-disable @typescript-eslint/no-explicit-any */
// ThreadMessagesView.tsx
import { BarChartOutlined, ToolOutlined } from '@ant-design/icons';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import { Popover, Space, Spin, Typography } from 'antd';
import isPlainObject from 'lodash/isPlainObject';
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import type { JsonValue } from 'type-fest';

import type {
  ThreadMessageDto,
  ThreadMessageDtoRequestTokenUsage,
  ThreadMessageDtoTokenUsage,
} from '../../../autogenerated';
import { MarkdownContent } from '../../../components/markdown/MarkdownContent';
import { getAgentAvatarDataUri } from '../../../utils/agentAvatars';
import { getReasoningIdentifier } from '../../../utils/threadMessages';
import type { PendingMessage } from '../types/messages';
import { ChatBubble } from './threadMessages/ChatBubble';
import {
  formatMessageContent,
  isBlankContent,
} from './threadMessages/messageUtils';
import { ReasoningMessage } from './threadMessages/ReasoningMessage';
import { ShellToolDisplay } from './threadMessages/ShellToolDisplay';

interface ToolCallFunction {
  name?: string;
  arguments?: string | Record<string, unknown>;
  title?: string;
  __title?: string;
}

interface ToolCall {
  id?: string;
  name?: string;
  function?: ToolCallFunction;
  args?: string | Record<string, unknown>;
  title?: string;
  __title?: string;
}

interface ShellResult {
  command?: string;
  exitCode?: number;
  output?: string;
  stdout?: string;
  stderr?: string;
  [key: string]: unknown;
}

const { Text } = Typography;

const formatUsd = (amount?: number | null): string => {
  if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
  if (amount === 0 || (amount > 0 && amount < 0.01)) return '<$0.01';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
};

// NOTE: request cost formatting lives in `formatRequestUsdShort`.

const formatCompactNumber = (value: number): string => {
  if (!Number.isFinite(value)) return '—';
  return new Intl.NumberFormat('en-US', {
    notation: 'compact',
    compactDisplay: 'short',
    maximumFractionDigits: 0,
  }).format(value);
};

const formatTokenCount = (value: number): string => {
  if (!Number.isFinite(value)) return '—';
  return new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(
    value,
  );
};

const formatRequestTokenCount = (value: number): string => {
  if (!Number.isFinite(value)) return '—';

  const formatTruncatedDecimal = (raw: number): string => {
    const truncated = Math.floor(raw * 10) / 10;
    // `String(9.5)` -> "9.5" → "9,5"
    const normalized = String(truncated).replace('.', ',');
    return normalized.endsWith(',0') ? normalized.slice(0, -2) : normalized;
  };

  if (value < 1000) {
    return formatTokenCount(value);
  }

  if (value < 1_000_000) {
    return `${formatTruncatedDecimal(value / 1000)}k`;
  }

  return `${formatTruncatedDecimal(value / 1_000_000)}m`;
};

const formatRequestUsdShort = (amount?: number | null): string => {
  if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
  // Truncate (not round) to 3 decimals: 0.002592 -> 0.002
  const truncated = Math.floor(amount * 1000) / 1000;
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 3,
    maximumFractionDigits: 3,
  }).format(truncated);
};

const TokenUsagePopoverIcon: React.FC<{
  tokenUsage?: ThreadMessageDtoTokenUsage | null;
  requestTokenUsage?: ThreadMessageDtoRequestTokenUsage | null;
}> = ({ tokenUsage, requestTokenUsage }) => {
  if (!tokenUsage && !requestTokenUsage) {
    return null;
  }

  const tokenSummary = tokenUsage
    ? `Token usage: ${formatCompactNumber(tokenUsage.totalTokens)} (${formatUsd(
        tokenUsage.totalPrice,
      )})`
    : null;

  const requestSummary = requestTokenUsage
    ? `Request token usage: ${formatRequestTokenCount(
        requestTokenUsage.totalTokens,
      )} (${formatRequestUsdShort(requestTokenUsage.totalPrice)})`
    : null;

  const popoverContent = (
    <Space direction="vertical" size={4} style={{ maxWidth: 340 }}>
      {tokenSummary && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          {tokenSummary}
        </Text>
      )}

      {requestTokenUsage && requestSummary && (
        <>
          <Text type="secondary" style={{ fontSize: 12 }}>
            {requestSummary}
          </Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Input tokens: {formatTokenCount(requestTokenUsage.inputTokens)}
          </Text>
          {typeof requestTokenUsage.cachedInputTokens === 'number' && (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Cached input tokens:{' '}
              {formatTokenCount(requestTokenUsage.cachedInputTokens)}
            </Text>
          )}
          <Text type="secondary" style={{ fontSize: 12 }}>
            Output tokens: {formatTokenCount(requestTokenUsage.outputTokens)}
          </Text>
          {typeof requestTokenUsage.reasoningTokens === 'number' && (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Reasoning tokens:{' '}
              {formatTokenCount(requestTokenUsage.reasoningTokens)}
            </Text>
          )}
          {typeof requestTokenUsage.currentContext === 'number' && (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Current context:{' '}
              {formatTokenCount(requestTokenUsage.currentContext)}
            </Text>
          )}
        </>
      )}
    </Space>
  );

  return (
    <Popover
      content={popoverContent}
      trigger={['hover']}
      placement="bottomLeft">
      <span
        style={{
          display: 'inline-flex',
          alignItems: 'center',
          cursor: 'help',
        }}
        aria-label="View token usage details"
        title="View token usage details">
        <BarChartOutlined style={{ fontSize: 12 }} />
      </span>
    </Popover>
  );
};

const renderFooterLineWithUsage = (
  text: string,
  tokenUsage?: ThreadMessageDtoTokenUsage | null,
  requestTokenUsage?: ThreadMessageDtoRequestTokenUsage | null,
): React.ReactNode => {
  return (
    <span style={{ display: 'inline-flex', alignItems: 'center', gap: 6 }}>
      <span>{text}</span>
      <TokenUsagePopoverIcon
        tokenUsage={tokenUsage}
        requestTokenUsage={requestTokenUsage}
      />
    </span>
  );
};

export interface ThreadMessagesViewProps {
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  selectedThreadId?: string;
  nodeId?: string;
  nodeDisplayNames?: Record<string, string>;
  showNodeHeadings?: boolean;
  isAgentNode?: boolean;
  nodeTemplateKind?: string;
  onLoadMoreMessages?: () => void;
  hasMoreMessages?: boolean;
  loadingMore?: boolean;
  isNodeRunning?: boolean;
  /**
   * When true, the thread was explicitly stopped by the user. In this state we
   * must never render tool calls as "in progress" (e.g. with a spinner).
   */
  isThreadStopped?: boolean;
  /**
   * Current thread run identifier. Tool calls from a different run must never
   * render as "in progress".
   */
  currentThreadLastRunId?: string | null;
  pendingMessages?: PendingMessage[];
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

const ensureThinkingIndicatorStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-thinking-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-thinking-style';
    style.textContent = `
      @keyframes messages-tab-thinking-pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const ensureReasoningAnimationStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-reasoning-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-reasoning-style';
    style.textContent = `
      @keyframes messages-tab-reasoning-appear {
        0% {
          opacity: 0;
          transform: translateY(6px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes messages-tab-reasoning-streaming {
        0% {
          color: rgba(0, 0, 0, 0.4);
        }
        50% {
          color: rgba(0, 0, 0, 0.75);
        }
        100% {
          color: rgba(0, 0, 0, 0.4);
        }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

type MessagePayload = ThreadMessageDto['message'];

const getMessageRecord = (
  payload?: MessagePayload,
): Record<string, unknown> | undefined => {
  if (!payload || typeof payload !== 'object') {
    return undefined;
  }
  return payload as unknown as Record<string, unknown>;
};

const getMessageValue = <T = unknown,>(
  payload: MessagePayload | undefined,
  key: string,
): T | undefined => {
  const record = getMessageRecord(payload);
  if (!record) return undefined;
  return record[key] as T | undefined;
};

const getMessageString = (
  payload: MessagePayload | undefined,
  key: string,
): string | undefined => {
  const value = getMessageValue(payload, key);
  return typeof value === 'string' ? value : undefined;
};

const getMessageTitle = (payload?: MessagePayload): string | undefined => {
  const title = getMessageString(payload, 'title');
  if (title && title.trim().length > 0) {
    return title;
  }

  const legacy = getMessageString(payload, '__title');
  if (legacy && legacy.trim().length > 0) {
    return legacy;
  }

  return undefined;
};

const extractToolErrorText = (resultContent: unknown): string | undefined => {
  if (!isPlainObject(resultContent)) return undefined;
  const record = resultContent as Record<string, unknown>;
  const errorValue = record.error;

  if (typeof errorValue === 'string') {
    const trimmed = errorValue.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  }

  if (errorValue === null || errorValue === undefined) {
    return undefined;
  }

  try {
    const serialized = JSON.stringify(errorValue, null, 2);
    const trimmed = serialized.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  } catch {
    const asString = String(errorValue);
    const trimmed = asString.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  }
};

const getMessageRunId = (payload?: MessagePayload): string | undefined => {
  const record = getMessageRecord(payload);
  if (!record) return undefined;

  // Prefer the normalized field coming from the API response.
  const direct = (record.runId as unknown) ?? (record.run_id as unknown);
  if (typeof direct === 'string' && direct.length > 0) {
    return direct;
  }

  const additional =
    (record.additionalKwargs as Record<string, unknown> | undefined) ??
    (record.additional_kwargs as Record<string, unknown> | undefined);

  const normalizedAdditional = isPlainObject(additional)
    ? (additional as Record<string, unknown>)
    : undefined;

  const fromAdditional =
    normalizedAdditional &&
    ((normalizedAdditional.__runId as unknown) ??
      (normalizedAdditional.run_id as unknown) ??
      (normalizedAdditional.runId as unknown));

  if (typeof fromAdditional === 'string' && fromAdditional.length > 0) {
    return fromAdditional;
  }
  return undefined;
};

const fullHeightColumnStyle: React.CSSProperties = {
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  minHeight: 0,
};

const centeredStateStyle: React.CSSProperties = {
  flex: 1,
  minHeight: 0,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
};

const scrollContainerStyle: React.CSSProperties = {
  flex: 1,
  minHeight: 0,
  overflowY: 'auto',
  overflowX: 'hidden',
  padding: '12px 16px',
};

const messageBlockStyle: React.CSSProperties = {
  marginBottom: '15px',
};

const ThreadMessagesView: React.FC<ThreadMessagesViewProps> = React.memo(
  ({
    messages,
    messagesLoading,
    selectedThreadId,
    nodeId,
    nodeDisplayNames,
    showNodeHeadings = false,
    isAgentNode = true,
    nodeTemplateKind,
    onLoadMoreMessages,
    hasMoreMessages,
    loadingMore,
    isNodeRunning = false,
    isThreadStopped = false,
    currentThreadLastRunId,
    pendingMessages = [],
    newMessageMode,
  }) => {
    const scrollContainerRef = useRef<HTMLDivElement | null>(null);
    const prevScrollHeightRef = useRef<number>(0);
    const isPrependingRef = useRef<boolean>(false);
    const pendingAutoScrollRef = useRef<boolean>(false);
    const autoScrollDisabledRef = useRef<boolean>(false);
    const lastMessageCountRef = useRef<number>(0);

    const [expandedReasoningIds, setExpandedReasoningIds] = useState<
      Set<string>
    >(() => new Set());
    const toggleReasoningMessage = useCallback((id: string) => {
      setExpandedReasoningIds((prev) => {
        const next = new Set(prev);
        if (next.has(id)) {
          next.delete(id);
        } else {
          next.add(id);
        }
        return next;
      });
    }, []);

    useEffect(() => {
      ensureThinkingIndicatorStyles();
      ensureReasoningAnimationStyles();
    }, []);

    useEffect(() => {
      pendingAutoScrollRef.current = true;
    }, [selectedThreadId, nodeId]);

    useEffect(() => {
      if (!isPrependingRef.current) return;
      const el = scrollContainerRef.current;
      if (el) {
        const diff = el.scrollHeight - prevScrollHeightRef.current;
        el.scrollTop = diff + el.scrollTop;
      }
      isPrependingRef.current = false;
    }, [messages.length]);

    useEffect(() => {
      if (messagesLoading) return;
      const el = scrollContainerRef.current;
      if (!el) return;

      const isInitiallyEmpty = lastMessageCountRef.current === 0;
      const shouldAutoScroll =
        pendingAutoScrollRef.current ||
        isInitiallyEmpty ||
        !autoScrollDisabledRef.current;

      if (shouldAutoScroll) {
        el.scrollTop = el.scrollHeight;
      }

      pendingAutoScrollRef.current = false;
      lastMessageCountRef.current = messages.length;
    }, [messagesLoading, messages.length]);

    useEffect(() => {
      if (!pendingMessages || pendingMessages.length === 0) return;
      pendingAutoScrollRef.current = true;
      const el = scrollContainerRef.current;
      if (!el) return;
      const shouldAutoScroll =
        pendingAutoScrollRef.current || !autoScrollDisabledRef.current;
      if (shouldAutoScroll) {
        el.scrollTop = el.scrollHeight;
        pendingAutoScrollRef.current = false;
      }
    }, [pendingMessages, pendingMessages?.length]);

    useEffect(() => {
      const styleId = 'shell-scrollbar-styles';
      if (document.getElementById(styleId)) return;

      const style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
      .shell-output-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .shell-output-container::-webkit-scrollbar-track {
        background: #2a2a2a;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb:hover {
        background: #666;
      }
    `;
      document.head.appendChild(style);

      return () => {
        const existingStyle = document.getElementById(styleId);
        if (existingStyle) {
          existingStyle.remove();
        }
      };
    }, []);

    const handleScroll = useCallback(() => {
      const el = scrollContainerRef.current;
      if (!el) return;
      const nearTop = el.scrollTop <= 100;
      if (
        nearTop &&
        hasMoreMessages &&
        !loadingMore &&
        typeof onLoadMoreMessages === 'function'
      ) {
        prevScrollHeightRef.current = el.scrollHeight;
        isPrependingRef.current = true;
        onLoadMoreMessages();
      }
      const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight <= 48;
      autoScrollDisabledRef.current = !nearBottom;
    }, [hasMoreMessages, loadingMore, onLoadMoreMessages]);

    const parseJsonSafe = (value: string): JsonValue | null => {
      try {
        return JSON.parse(value) as JsonValue;
      } catch {
        return null;
      }
    };

    const isToolLikeRole = (role?: string): boolean => {
      if (!role) return false;
      return role === 'tool' || role === 'tool-shell';
    };

    const buildToolCallResultIndex = useCallback(
      (allMessages: ThreadMessageDto[]): Record<string, ThreadMessageDto[]> => {
        return allMessages.reduce<Record<string, ThreadMessageDto[]>>(
          (acc, msg) => {
            if (!isToolLikeRole(msg.message?.role as string)) {
              return acc;
            }
            const toolCallId = getMessageString(msg.message, 'toolCallId');
            if (!toolCallId) {
              return acc;
            }
            if (!acc[toolCallId]) {
              acc[toolCallId] = [];
            }
            acc[toolCallId].push(msg);
            return acc;
          },
          {},
        );
      },
      [],
    );

    const getToolMessageKey = (msg?: ThreadMessageDto): string | undefined => {
      if (!msg) return undefined;
      if (msg.id) return msg.id;
      const messageLevelId = getMessageString(msg.message, 'id');
      if (messageLevelId) return messageLevelId;
      if (msg.createdAt) return `created-${msg.createdAt}`;
      const toolCallId = getMessageString(msg.message, 'toolCallId');
      if (toolCallId) return `toolCall-${toolCallId}`;
      return undefined;
    };

    const argsToObject = useCallback(
      (
        args?: string | Record<string, unknown>,
      ): Record<string, JsonValue> | null => {
        if (!args) return null;
        if (typeof args === 'string') {
          const parsed = parseJsonSafe(args);
          return isPlainObject(parsed)
            ? (parsed as Record<string, JsonValue>)
            : null;
        }
        if (isPlainObject(args)) {
          return args as Record<string, JsonValue>;
        }
        return null;
      },
      [],
    );

    const extractShellCommandFromArgs = useCallback(
      (args?: string | Record<string, unknown>): string | undefined => {
        const obj = argsToObject(args);
        if (!obj) return undefined;
        if (typeof obj.command === 'string') return obj.command;
        if (typeof obj.cmd === 'string') return obj.cmd;
        return undefined;
      },
      [argsToObject],
    );

    const renderToolPopoverContent = (
      value: unknown,
      toolOptions?: Record<string, JsonValue>,
      toolLabel?: string,
    ): React.ReactNode => {
      let parsed: JsonValue | null = null;
      if (typeof value === 'string') {
        parsed = parseJsonSafe(value);
      } else if (isPlainObject(value)) {
        parsed = value as JsonValue;
      }

      const containerStyle: React.CSSProperties = { maxWidth: 520 };
      const innerStyle: React.CSSProperties = {
        maxHeight: 300,
        overflow: 'auto',
        background: '#f5f5f5',
        border: '1px solid #eee',
        borderRadius: 6,
        padding: 12,
        fontFamily:
          'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
        fontSize: 12,
        whiteSpace: 'pre-wrap',
      };

      const sectionStyle: React.CSSProperties = {
        marginBottom: 16,
      };

      const sectionTitleStyle: React.CSSProperties = {
        fontWeight: 'bold',
        fontSize: 13,
        marginBottom: 8,
        color: '#333',
        borderBottom: '1px solid #ddd',
        paddingBottom: 4,
      };

      return (
        <div style={containerStyle}>
          {toolLabel && toolLabel.trim().length > 0 && (
            <div style={{ marginBottom: 12 }}>
              <Text strong style={{ fontSize: 13 }}>
                Tool: {toolLabel}
              </Text>
            </div>
          )}
          {toolOptions && Object.keys(toolOptions).length > 0 && (
            <div style={sectionStyle}>
              <div style={sectionTitleStyle}>Tool Options:</div>
              <div style={innerStyle}>
                <JsonView value={toolOptions} style={lightTheme} />
              </div>
            </div>
          )}

          <div style={sectionStyle}>
            <div style={sectionTitleStyle}>Output:</div>
            <div style={innerStyle}>
              {parsed ? (
                <JsonView value={parsed as object} style={lightTheme} />
              ) : (
                <pre
                  style={{
                    margin: 0,
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                  }}>
                  {String(value ?? '')}
                </pre>
              )}
            </div>
          </div>
        </div>
      );
    };

    type ToolRenderStatus = 'calling' | 'executed' | 'stopped';

    type PreparedMessage =
      | {
          type: 'system';
          messages: ThreadMessageDto[];
          id: string;
          nodeId?: string;
          createdAt?: string;
          inCommunicationExec?: boolean;
          sourceAgentNodeId?: string;
        }
      | {
          type: 'reasoning';
          message: ThreadMessageDto;
          id: string;
          nodeId?: string;
          createdAt?: string;
          inCommunicationExec?: boolean;
          sourceAgentNodeId?: string;
        }
      | {
          type: 'chat';
          message: ThreadMessageDto;
          id: string;
          nodeId?: string;
          createdAt?: string;
          inCommunicationExec?: boolean;
          sourceAgentNodeId?: string;
        }
      | {
          type: 'tool';
          name: string;
          status: ToolRenderStatus;
          result?: unknown;
          id: string;
          toolKind?: 'generic' | 'shell';
          shellCommand?: string;
          toolOptions?: Record<string, JsonValue>;
          tokenUsage?: ThreadMessageDtoTokenUsage | null;
          tokenUsageIn?: ThreadMessageDtoTokenUsage | null;
          tokenUsageOut?: ThreadMessageDtoTokenUsage | null;
          requestTokenUsage?: ThreadMessageDtoRequestTokenUsage | null;
          requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
          requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
          nodeId?: string;
          createdAt?: string;
          roleLabel?: string;
          title?: string;
          inCommunicationExec?: boolean;
          sourceAgentNodeId?: string;
        };

    // Generate a consistent color from a string (node ID)
    const generateColorFromNodeId = useCallback((nodeId: string): string => {
      // Simple hash function to generate a number from string
      let hash = 0;
      for (let i = 0; i < nodeId.length; i++) {
        hash = nodeId.charCodeAt(i) + ((hash << 5) - hash);
        hash = hash & hash; // Convert to 32-bit integer
      }

      // Generate HSL color with fixed saturation and lightness for better visibility
      const hue = Math.abs(hash % 360);
      const saturation = 70; // Good saturation for distinct colors
      const lightness = 50; // Medium lightness for good visibility

      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }, []);

    const prepareReadyMessages = useCallback(
      (msgs: ThreadMessageDto[]): PreparedMessage[] => {
        const allowCallingIndicators = isNodeRunning && !isThreadStopped;
        const isLatestRun = (runId?: string): boolean => {
          if (!currentThreadLastRunId) return true;
          if (!runId) return false;
          return runId === currentThreadLastRunId;
        };
        const toolCallResultsById = buildToolCallResultIndex(msgs);
        const consumedToolCallIds = new Set<string>();
        const consumedToolMessageKeys = new Set<string>();

        const markToolMessageConsumed = (msg?: ThreadMessageDto) => {
          const key = getToolMessageKey(msg);
          if (key) {
            consumedToolMessageKeys.add(key);
          }
        };

        const markToolCallConsumed = (toolCallId?: string) => {
          if (toolCallId) {
            consumedToolCallIds.add(toolCallId);
          }
        };

        const consumeToolResultById = (
          toolCallId?: string,
        ): ThreadMessageDto | undefined => {
          if (!toolCallId) return undefined;
          const queue = toolCallResultsById[toolCallId];
          if (!queue || queue.length === 0) {
            return undefined;
          }
          const next = queue.shift();
          markToolCallConsumed(toolCallId);
          markToolMessageConsumed(next);
          return next;
        };

        // Helper to check if a message is part of inter-agent communication
        const isInterAgentCommunication = (msg: ThreadMessageDto): boolean => {
          const record = getMessageRecord(msg.message);
          if (!record) return false;

          const additional =
            (record.additionalKwargs as Record<string, unknown> | undefined) ??
            (record.additional_kwargs as Record<string, unknown> | undefined);

          const normalizedAdditional = isPlainObject(additional)
            ? (additional as Record<string, unknown>)
            : undefined;

          return Boolean(normalizedAdditional?.__interAgentCommunication);
        };

        // Helper to extract source agent node ID from message metadata
        const getSourceAgentNodeId = (
          msg: ThreadMessageDto,
        ): string | undefined => {
          const record = getMessageRecord(msg.message);
          if (!record) return undefined;

          const additional =
            (record.additionalKwargs as Record<string, unknown> | undefined) ??
            (record.additional_kwargs as Record<string, unknown> | undefined);

          const normalizedAdditional = isPlainObject(additional)
            ? (additional as Record<string, unknown>)
            : undefined;

          return typeof normalizedAdditional?.__sourceAgentNodeId === 'string'
            ? normalizedAdditional.__sourceAgentNodeId
            : undefined;
        };

        // Build a set of all tool call IDs that exist in current messages
        const existingToolCallIds = new Set<string>();
        msgs.forEach((m) => {
          const role = (m.message?.role as string) || '';
          if (role === 'ai') {
            const messageToolCalls = getMessageValue<ToolCall[]>(
              m.message,
              'toolCalls',
            );
            if (messageToolCalls && messageToolCalls.length > 0) {
              messageToolCalls.forEach((tc) => {
                if (tc.id) {
                  existingToolCallIds.add(tc.id);
                }
              });
            }
          }
        });

        // First pass: identify all tool calls from AI messages and mark their results as consumed
        // This prevents tool results from being rendered as standalone before we process the AI message
        msgs.forEach((m) => {
          const role = (m.message?.role as string) || '';
          if (role === 'ai') {
            const messageToolCalls = getMessageValue<ToolCall[]>(
              m.message,
              'toolCalls',
            );
            if (messageToolCalls && messageToolCalls.length > 0) {
              messageToolCalls.forEach((tc) => {
                if (tc.id) {
                  // Check if result exists for this tool call
                  const queue = toolCallResultsById[tc.id];
                  if (queue && queue.length > 0) {
                    // Mark as consumed so it won't be rendered as standalone
                    markToolCallConsumed(tc.id);
                    markToolMessageConsumed(queue[0]);
                  }
                }
              });
            }
          }
        });

        const prepared: PreparedMessage[] = [];
        let i = 0;

        while (i < msgs.length) {
          const m = msgs[i];
          const role = (m.message?.role as string) || '';
          const isInterAgent = isInterAgentCommunication(m);
          const sourceAgentNodeId = getSourceAgentNodeId(m);

          if (role === 'reasoning') {
            if (!isBlankContent(m.message?.content)) {
              prepared.push({
                type: 'reasoning',
                message: m,
                id: `reasoning-${m.id || m.createdAt}`,
                nodeId: m.nodeId,
                createdAt: m.createdAt,
                inCommunicationExec: isInterAgent,
                sourceAgentNodeId,
              });
            }
            i++;
            continue;
          }

          if (role === 'system') {
            const sys: ThreadMessageDto[] = [m];
            let j = i + 1;
            while (
              j < msgs.length &&
              (msgs[j].message?.role as string) === 'system'
            ) {
              sys.push(msgs[j]);
              j++;
            }
            prepared.push({
              type: 'system',
              messages: sys,
              id: `system-${sys[0].id || sys[0].createdAt}`,
              nodeId: sys[0]?.nodeId,
              createdAt: sys[0]?.createdAt,
              inCommunicationExec: isInterAgent,
              sourceAgentNodeId,
            });
            i = j;
            continue;
          }

          const messageToolCalls = getMessageValue<ToolCall[]>(
            m.message,
            'toolCalls',
          );
          if (
            role === 'ai' &&
            messageToolCalls &&
            messageToolCalls.length > 0
          ) {
            const hasNonBlankContent = !isBlankContent(m.message?.content);

            if (hasNonBlankContent) {
              prepared.push({
                type: 'chat',
                message: m,
                id: `chat-${m.id || m.createdAt}`,
                nodeId: m.nodeId,
                createdAt: m.createdAt,
                inCommunicationExec: isInterAgent,
                sourceAgentNodeId,
              });
            }

            const followingTools: ThreadMessageDto[] = [];
            let j = i + 1;
            while (
              j < msgs.length &&
              isToolLikeRole(msgs[j].message?.role as string)
            ) {
              followingTools.push(msgs[j]);
              j++;
            }

            const toolCalls = messageToolCalls;
            for (let idx = 0; idx < toolCalls.length; idx++) {
              const tc = toolCalls[idx];
              const name = tc.name || tc.function?.name || 'tool';
              const callTitle =
                (tc.title && tc.title.trim().length > 0
                  ? tc.title
                  : undefined) ??
                (tc.__title && tc.__title.trim().length > 0
                  ? tc.__title
                  : undefined) ??
                (tc.function?.title && tc.function.title.trim().length > 0
                  ? tc.function.title
                  : undefined) ??
                (tc.function?.__title && tc.function.__title.trim().length > 0
                  ? tc.function.__title
                  : undefined);
              let matched = consumeToolResultById(tc.id);
              if (!matched) {
                matched = followingTools.find(
                  (tm) => getMessageString(tm.message, 'toolCallId') === tc.id,
                );
                if (matched) {
                  markToolCallConsumed(
                    tc.id || getMessageString(matched.message, 'toolCallId'),
                  );
                  markToolMessageConsumed(matched);
                }
              }
              const resultContent = matched?.message?.content;
              const toolArgs = tc.function?.arguments ?? tc.args;
              const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
              const resultObj = isPlainObject(resultContent)
                ? (resultContent as ShellResult)
                : null;
              const shellCommand = shellCmdFromArgs || resultObj?.command;
              const isShell = (name || '').toLowerCase() === 'shell';
              const toolOptions = argsToObject(toolArgs);
              const matchedTitle = getMessageTitle(matched?.message);
              const effectiveTitle = matchedTitle || callTitle;
              const toolCallRunId =
                getMessageRunId(m.message) ?? getMessageRunId(matched?.message);

              const matchedIsInterAgent = matched
                ? isInterAgentCommunication(matched)
                : false;
              const toolIsInterAgent = isInterAgent || matchedIsInterAgent;
              const matchedSourceAgentNodeId = matched
                ? getSourceAgentNodeId(matched)
                : undefined;
              const toolSourceAgentNodeId =
                sourceAgentNodeId || matchedSourceAgentNodeId;

              prepared.push({
                type: 'tool',
                name: name || 'tool',
                status: matched
                  ? 'executed'
                  : allowCallingIndicators && isLatestRun(toolCallRunId)
                    ? 'calling'
                    : 'stopped',
                result: resultContent,
                id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
                toolKind: isShell ? 'shell' : 'generic',
                shellCommand,
                toolOptions: toolOptions || undefined,
                tokenUsage: matched?.tokenUsage ?? m.tokenUsage,
                tokenUsageIn: m.tokenUsage,
                tokenUsageOut: matched?.tokenUsage,
                requestTokenUsage: m.requestTokenUsage,
                requestTokenUsageIn: m.requestTokenUsage,
                requestTokenUsageOut: matched?.requestTokenUsage,
                nodeId: matched?.nodeId ?? m.nodeId,
                createdAt: matched?.createdAt ?? m.createdAt,
                roleLabel: effectiveTitle || name || 'tool',
                title: effectiveTitle,
                inCommunicationExec: toolIsInterAgent,
                sourceAgentNodeId: toolSourceAgentNodeId,
              });
            }

            i = i + 1 + followingTools.length;
            continue;
          }

          if (isToolLikeRole(role)) {
            const toolCallId = getMessageString(m.message, 'toolCallId');
            const messageKey = getToolMessageKey(m);
            if (
              (toolCallId && consumedToolCallIds.has(toolCallId)) ||
              (messageKey && consumedToolMessageKeys.has(messageKey))
            ) {
              i++;
              continue;
            }

            const name = getMessageString(m.message, 'name') || 'tool';

            // Skip communication_exec outputs that don't have their input in the current message set
            // This happens when messages are paginated and the tool call is in an unloaded chunk
            if (
              name === 'communication_exec' &&
              toolCallId &&
              !existingToolCallIds.has(toolCallId)
            ) {
              i++;
              continue;
            }

            const title = getMessageTitle(m.message);
            const resultContent = m.message?.content;
            const resultObj = isPlainObject(resultContent)
              ? (resultContent as ShellResult)
              : null;
            const shellCommand = resultObj?.command;
            const isShell = (name || '').toLowerCase() === 'shell';
            const toolOptions = undefined;

            prepared.push({
              type: 'tool',
              name,
              status: 'executed',
              result: resultContent,
              id: `tool-standalone-${m.id || m.createdAt}`,
              toolKind: isShell ? 'shell' : 'generic',
              shellCommand,
              toolOptions,
              tokenUsage: m.tokenUsage,
              tokenUsageOut: m.tokenUsage,
              requestTokenUsage: m.requestTokenUsage,
              requestTokenUsageOut: m.requestTokenUsage,
              nodeId: m.nodeId,
              createdAt: m.createdAt,
              roleLabel: title || name || 'tool',
              title,
              inCommunicationExec: isInterAgent,
              sourceAgentNodeId,
            });
            i++;
            continue;
          }

          if (!isBlankContent(m.message?.content)) {
            prepared.push({
              type: 'chat',
              message: m,
              id: `chat-${m.id || m.createdAt}`,
              nodeId: m.nodeId,
              createdAt: m.createdAt,
              inCommunicationExec: isInterAgent,
              sourceAgentNodeId,
            });
          }
          i++;
        }

        return prepared;
      },
      [
        argsToObject,
        buildToolCallResultIndex,
        extractShellCommandFromArgs,
        isNodeRunning,
        isThreadStopped,
        currentThreadLastRunId,
      ],
    );

    // eslint-disable-next-line react-hooks/exhaustive-deps
    const preparedMessages = useMemo(() => {
      return prepareReadyMessages(messages);
    }, [messages, prepareReadyMessages]);
    const isThinkingVisible = isNodeRunning && isAgentNode;

    const renderFullHeightState = (content: React.ReactNode) => (
      <div style={fullHeightColumnStyle}>
        <div style={centeredStateStyle}>{content}</div>
      </div>
    );

    const renderSystemGroup = (
      systemMessages: ThreadMessageDto[],
      count: number,
    ) => {
      const firstMessage = systemMessages[0];
      const content = formatMessageContent(firstMessage.message?.content);
      const countSuffix = count > 1 ? ` (${count} system messages)` : '';
      const fullText = `${content}${countSuffix}`;

      const textContainerStyle: React.CSSProperties = {
        fontSize: '12px',
        color: '#afafaf',
        textAlign: 'center',
      };

      return (
        <div style={{ width: '100%' }}>
          <div style={textContainerStyle}>
            <MarkdownContent content={fullText} allowHorizontalScroll={true} />
          </div>
        </div>
      );
    };

    const renderFinishTool = (
      status: ToolRenderStatus,
      resultContent?: unknown,
      tokenUsage?: ThreadMessageDtoTokenUsage | null,
      requestTokenUsage?: ThreadMessageDtoRequestTokenUsage | null,
      metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string },
      borderColor?: string,
    ) => {
      if (status !== 'executed') {
        return undefined;
      }

      let finishMessage = 'Task completed.';
      let needsMoreInfo = false;
      if (resultContent) {
        if (typeof resultContent === 'string') {
          finishMessage = resultContent;
        } else if (isPlainObject(resultContent)) {
          const obj = resultContent as Record<string, unknown>;
          finishMessage =
            (typeof obj.message === 'string' ? obj.message : '') ||
            (typeof obj.content === 'string' ? obj.content : '') ||
            (typeof obj.result === 'string' ? obj.result : '') ||
            'Task completed.';
          needsMoreInfo = Boolean(obj.needsMoreInfo);
        }
      }

      const messageColor = needsMoreInfo ? '#faad14' : '#52c41a';
      const statusTag = needsMoreInfo ? '⚠ Need more info' : '✓ Finished';
      const avatarSrc = metadata?.nodeId
        ? getAgentAvatarDataUri(metadata.nodeId)
        : undefined;

      const finishAgentName =
        (metadata?.nodeId && nodeDisplayNames?.[metadata.nodeId]) ||
        (metadata?.nodeId ? `Node ${metadata.nodeId.slice(-6)}` : 'Agent');

      const bubbleStyle: React.CSSProperties = {
        backgroundColor: '#f3f3f3',
        borderLeft: `3px solid ${messageColor}`,
      };

      if (borderColor) {
        bubbleStyle.borderLeft = `3px solid ${borderColor}`;
      }

      return (
        <ChatBubble
          isHuman={false}
          avatarLabel="AI"
          avatarColor={messageColor}
          avatarSrc={avatarSrc}
          avatarTooltip={finishAgentName}
          containerStyle={{ marginBottom: '8px' }}
          bubbleStyle={bubbleStyle}
          footer={
            <Text
              type="secondary"
              style={{
                fontSize: '11px',
                marginTop: '4px',
                color: '#8c8c8c',
                display: 'block',
              }}>
              {renderFooterLineWithUsage(
                formatMetadataLine(
                  metadata?.createdAt,
                  metadata?.roleLabel,
                  metadata?.nodeId,
                ) ?? '',
                tokenUsage,
                requestTokenUsage,
              )}
            </Text>
          }>
          <Text
            type="secondary"
            style={{
              fontSize: '11px',
              marginBottom: '5px',
              display: 'block',
              color: messageColor,
              fontWeight: 'bold',
            }}>
            {statusTag}
          </Text>

          <MarkdownContent
            content={finishMessage}
            style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
          />
        </ChatBubble>
      );
    };

    const renderToolStatusLine = (
      name: string,
      status: ToolRenderStatus,
      resultContent?: unknown,
      toolOptions?: Record<string, JsonValue>,
      titleText?: string,
      align: 'left' | 'center' = 'center',
    ) => {
      const isClickable = status === 'executed' && resultContent !== undefined;
      const isCalling = status === 'calling';
      const errorText =
        status === 'executed' ? extractToolErrorText(resultContent) : undefined;
      const hasError = Boolean(errorText);
      const statusText =
        status === 'calling'
          ? 'calling...'
          : status === 'stopped'
            ? 'stopped'
            : 'executed';
      const displayTitleBase =
        (titleText && titleText.trim().length > 0 ? titleText : undefined) ??
        (toolOptions?.purpose
          ? `${name} | ${String(toolOptions.purpose)}`
          : `tool ${name} is ${statusText}`);
      const displayTitle = hasError
        ? `${displayTitleBase} - ${errorText}`
        : displayTitleBase;
      const accessibleName = displayTitle || name;
      const line = (
        <div
          className="hoverable-chat-message"
          style={{
            cursor: isClickable ? 'pointer' : 'default',
            animation: isCalling
              ? 'messages-tab-thinking-pulse 1.6s ease-in-out infinite'
              : undefined,
            textAlign: align,
            ...(hasError ? { color: '#ff4d4f' } : null),
          }}
          aria-label={
            status === 'executed'
              ? `View tool result for ${accessibleName}`
              : status === 'stopped'
                ? `Tool ${accessibleName} is stopped`
                : `Tool ${accessibleName} is calling`
          }
          tabIndex={isClickable ? 0 : -1}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: align === 'left' ? 'flex-start' : 'center',
            }}>
            <Text
              type="secondary"
              className="tool-status-line__text"
              style={{
                fontSize: '12px',
                color: 'inherit',
                fontWeight: hasError ? 600 : undefined,
              }}>
              {displayTitle}
            </Text>
          </div>
        </div>
      );

      let baseLine: React.ReactNode = line;
      if (isClickable) {
        const contentNode = renderToolPopoverContent(
          resultContent,
          toolOptions,
          name,
        );
        baseLine = (
          <Popover
            content={contentNode}
            trigger={['click']}
            placement="topLeft">
            {line}
          </Popover>
        );
      }

      return baseLine;
    };

    const renderShellStatusLine = (
      name: string,
      status: ToolRenderStatus,
      resultContent?: unknown,
      shellCommand?: string,
      toolOptions?: Record<string, JsonValue>,
      metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string },
      titleText?: string,
      tokenUsageIn?: ThreadMessageDtoTokenUsage | null,
      tokenUsageOut?: ThreadMessageDtoTokenUsage | null,
      requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null,
      borderColor?: string,
    ) => {
      return (
        <ShellToolDisplay
          name={name}
          status={status}
          resultContent={resultContent}
          shellCommand={shellCommand}
          toolOptions={toolOptions}
          title={titleText}
          metadata={metadata}
          tokenUsageIn={tokenUsageIn}
          tokenUsageOut={tokenUsageOut}
          {...({ requestTokenUsageIn } as unknown as Record<string, unknown>)}
          borderColor={borderColor}
        />
      );
    };

    const renderNonAgentNodeInfo = () => {
      if (isAgentNode) return null;

      return (
        <div style={{ padding: '16px', textAlign: 'center' }}>
          <Space direction="vertical" size="large">
            <ToolOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
            <div>
              <Text strong style={{ fontSize: '16px' }}>
                {nodeTemplateKind || 'Tool'} Node
              </Text>
              <br />
              <Text type="secondary" style={{ fontSize: '14px' }}>
                This node executes tool calls and doesn't participate in
                conversations.
              </Text>
            </div>
            <div
              style={{
                backgroundColor: '#f8f9fa',
                border: '1px solid #e9ecef',
                borderRadius: '8px',
                padding: '12px',
                textAlign: 'left',
              }}>
              <Text strong style={{ fontSize: '13px', color: '#495057' }}>
                Tool Call Information:
              </Text>
              <br />
              <Text type="secondary" style={{ fontSize: '12px' }}>
                • Tool calls are executed when this node is triggered
                <br />
                • Results are passed to connected nodes
                <br />• Check the execution logs for detailed information
              </Text>
            </div>
          </Space>
        </div>
      );
    };

    const renderMessage = (message: ThreadMessageDto, borderColor?: string) => {
      const role = (message.message?.role as string) || '';
      const content = formatMessageContent(message.message?.content);
      const metadataText =
        formatMetadataLine(message.createdAt, role, message.nodeId) ||
        (role ? `from ${role}` : undefined);

      if (isToolLikeRole(role)) {
        const name = getMessageString(message.message, 'name') || 'tool';
        const title = getMessageTitle(message.message);
        const resultContent = message.message?.content;
        return renderToolStatusLine(
          name,
          'executed',
          resultContent,
          undefined,
          title,
        );
      }

      if (isBlankContent(message.message?.content)) return null;

      // Check if this is an agent instruction message
      const record = getMessageRecord(message.message);
      const additional =
        (record?.additionalKwargs as Record<string, unknown> | undefined) ??
        (record?.additional_kwargs as Record<string, unknown> | undefined);
      const normalizedAdditional = isPlainObject(additional)
        ? (additional as Record<string, unknown>)
        : undefined;
      const isAgentInstruction = Boolean(
        normalizedAdditional?.__isAgentInstructionMessage ??
          normalizedAdditional?.isAgentInstructionMessage,
      );

      const isHuman = role === 'human';
      const avatarSeedNodeId = message.nodeId || nodeId;
      const avatarSrc =
        !isHuman && avatarSeedNodeId
          ? getAgentAvatarDataUri(avatarSeedNodeId)
          : undefined;
      const avatarColor = isHuman
        ? '#1890ff'
        : role === 'ai'
          ? '#52c41a'
          : role === 'system'
            ? '#722ed1'
            : '#d9d9d9';

      // Get agent name for tooltip
      const agentName =
        (message.nodeId && nodeDisplayNames?.[message.nodeId]) ||
        (message.nodeId ? `Node ${message.nodeId.slice(-6)}` : 'Agent');

      const avatarTooltip = isHuman ? 'You' : agentName;

      // Apply border if borderColor is provided
      const bubbleBorderStyle = borderColor
        ? { borderLeft: `3px solid ${borderColor}` }
        : undefined;

      // Special rendering for agent instruction messages
      if (isAgentInstruction) {
        // For agent instruction messages, show only date (no "from ..." part)
        const dateOnlyText = message.createdAt
          ? new Date(message.createdAt).toLocaleString()
          : undefined;

        return (
          <ChatBubble
            isHuman={isHuman}
            avatarLabel={isHuman ? 'ME' : 'AI'}
            avatarColor="#722ed1"
            avatarSrc={avatarSrc}
            avatarTooltip={avatarTooltip}
            bubbleStyle={{
              backgroundColor: '#f9f0ff',
              border: '2px solid #d3adf7',
              borderRadius: '8px',
              padding: '12px 16px',
              ...bubbleBorderStyle,
            }}
            footer={
              dateOnlyText ? (
                <Text
                  type="secondary"
                  style={{
                    fontSize: '11px',
                    marginTop: '4px',
                    color: '#8c8c8c',
                  }}>
                  {renderFooterLineWithUsage(
                    dateOnlyText,
                    message.tokenUsage,
                    message.requestTokenUsage,
                  )}
                </Text>
              ) : undefined
            }>
            <div>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  marginBottom: '8px',
                  paddingBottom: '8px',
                  borderBottom: '1px solid #d3adf7',
                }}>
                <span
                  style={{
                    fontSize: '12px',
                    fontWeight: 600,
                    color: '#722ed1',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px',
                  }}>
                  Providing Instructions for {agentName}
                </span>
              </div>
              <MarkdownContent
                content={content}
                style={{
                  fontSize: '14px',
                  lineHeight: '1.4',
                  color: '#000000',
                }}
              />
            </div>
          </ChatBubble>
        );
      }

      return (
        <ChatBubble
          isHuman={isHuman}
          avatarLabel={isHuman ? 'ME' : 'AI'}
          avatarColor={avatarColor}
          avatarSrc={avatarSrc}
          avatarTooltip={avatarTooltip}
          bubbleStyle={bubbleBorderStyle}
          footer={
            metadataText ? (
              <Text
                type="secondary"
                style={{
                  fontSize: '11px',
                  marginTop: '4px',
                  color: '#8c8c8c',
                }}>
                {renderFooterLineWithUsage(
                  metadataText,
                  message.tokenUsage,
                  message.requestTokenUsage,
                )}
              </Text>
            ) : undefined
          }>
          <MarkdownContent
            content={content}
            style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
          />
        </ChatBubble>
      );
    };

    const renderPendingMessage = (message: PendingMessage) => {
      const isHuman = message.role === 'human';
      const content = message.content;
      const avatarSrc =
        !isHuman && nodeId ? getAgentAvatarDataUri(nodeId) : undefined;

      const sendTimeText =
        newMessageMode === 'inject_after_tool_call'
          ? 'Will be sent after next tool execution'
          : newMessageMode === 'wait_for_completion'
            ? 'Will be sent after agent completes current task'
            : 'Pending';

      const pendingAgentName =
        (nodeId && nodeDisplayNames?.[nodeId]) ||
        (nodeId ? `Node ${nodeId.slice(-6)}` : 'Agent');
      const pendingAvatarTooltip = isHuman ? 'You' : pendingAgentName;

      return (
        <ChatBubble
          isHuman={isHuman}
          avatarLabel={isHuman ? 'ME' : 'AI'}
          avatarColor={isHuman ? '#1890ff' : '#52c41a'}
          avatarSrc={avatarSrc}
          avatarTooltip={pendingAvatarTooltip}
          containerStyle={{ opacity: 0.6 }}
          bubbleStyle={{ border: '2px dashed #d9d9d9' }}
          footer={
            <Text
              type="secondary"
              style={{
                fontSize: '11px',
                marginTop: '4px',
                color: '#8c8c8c',
                fontStyle: 'italic',
              }}>
              {sendTimeText}
            </Text>
          }>
          <MarkdownContent
            content={content}
            style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
          />
        </ChatBubble>
      );
    };

    const formatNodeLabel = (nodeIdentifier?: string): string | undefined => {
      if (!nodeIdentifier) {
        return undefined;
      }
      const mapped = nodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) {
        return mapped;
      }
      if (nodeIdentifier.length <= 10) {
        return nodeIdentifier;
      }
      return `Node ${nodeIdentifier.slice(-6)}`;
    };

    const resolveSenderLabel = (
      roleLabel?: string,
      sourceNodeId?: string,
    ): string | undefined => {
      if (roleLabel === 'human') {
        return 'Human';
      }
      if (showNodeHeadings) {
        const label = formatNodeLabel(sourceNodeId || nodeId);
        if (label) {
          return label;
        }
      }
      return roleLabel;
    };

    const formatMetadataLine = (
      createdAt?: string,
      roleLabel?: string,
      sourceNodeId?: string,
    ): string | undefined => {
      const datePart = createdAt
        ? new Date(createdAt).toLocaleString()
        : undefined;
      const descriptorParts: string[] = [];
      const senderLabel = resolveSenderLabel(roleLabel, sourceNodeId);
      if (senderLabel) {
        descriptorParts.push(`from ${senderLabel}`);
      }
      const descriptor = descriptorParts.join(' ');
      const parts = [datePart, descriptor].filter(
        (part) => part && part.length,
      );
      if (!parts.length) {
        return undefined;
      }
      return parts.join(' | ');
    };

    const renderMetadataText = (
      createdAt?: string,
      roleLabel?: string,
      sourceNodeId?: string,
    ): React.ReactNode => {
      const text = formatMetadataLine(createdAt, roleLabel, sourceNodeId);
      if (!text) {
        return null;
      }
      return (
        <Text
          type="secondary"
          style={{
            fontSize: '11px',
            marginTop: '4px',
            color: '#8c8c8c',
            display: 'block',
          }}>
          {text}
        </Text>
      );
    };

    const renderPreparedMessages = () => {
      const rows: React.ReactNode[] = [];
      let i = 0;

      const pushRow = (
        key: React.Key,
        content: React.ReactNode,
        extraStyle?: React.CSSProperties,
      ) => {
        rows.push(
          <div key={key} style={{ ...messageBlockStyle, ...extraStyle }}>
            {content}
          </div>,
        );
      };

      const isWorkGroupItem = (item: PreparedMessage): boolean => {
        if (item.type === 'reasoning') return true;
        if (item.type === 'tool') {
          return (item.name || '').toLowerCase() !== 'finish';
        }
        return false;
      };

      const getAvatarInitials = (label?: string): string => {
        if (!label) return 'AI';
        const trimmed = label.trim();
        if (!trimmed) return 'AI';
        const words = trimmed.split(/\s+/).filter(Boolean);
        if (words.length === 1) {
          return words[0].slice(0, 2).toUpperCase();
        }
        return words
          .slice(0, 2)
          .map((w) => w[0])
          .join('')
          .toUpperCase();
      };

      const renderWorkingBlock = (
        items: PreparedMessage[],
        borderColor?: string,
      ) => {
        const avatarSeedNodeId =
          items.find((it) => it.nodeId)?.nodeId ?? nodeId ?? undefined;
        const avatarLabel = getAvatarInitials(
          formatNodeLabel(avatarSeedNodeId) ?? undefined,
        );
        const avatarSrc = avatarSeedNodeId
          ? getAgentAvatarDataUri(avatarSeedNodeId)
          : undefined;

        const workingAgentName =
          (avatarSeedNodeId && nodeDisplayNames?.[avatarSeedNodeId]) ||
          (avatarSeedNodeId ? `Node ${avatarSeedNodeId.slice(-6)}` : 'Agent');

        const bubbleStyle: React.CSSProperties = {
          backgroundColor: '#ffffff',
          border: '1px solid #e5e7eb',
          borderRadius: 8,
          padding: '10px 12px',
        };

        if (borderColor) {
          bubbleStyle.borderLeft = `3px solid ${borderColor}`;
        }

        return (
          <ChatBubble
            isHuman={false}
            avatarLabel={avatarLabel}
            avatarColor="#8c8c8c"
            avatarSrc={avatarSrc}
            avatarTooltip={workingAgentName}
            containerStyle={{ marginBottom: '8px' }}
            bubbleStyle={bubbleStyle}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 10 }}>
              <Text
                type="secondary"
                style={{
                  fontSize: 12,
                  fontWeight: 600,
                  color: '#8c8c8c',
                  textAlign: 'left',
                }}>
                Working...
              </Text>

              <div style={{ display: 'flex', flexDirection: 'column', gap: 5 }}>
                {items.map((it, idx) => {
                  if (it.type === 'reasoning') {
                    const reasoningId =
                      getReasoningIdentifier(it.message) ?? it.message.id;
                    return (
                      <div key={`work-reasoning-${it.id}-${idx}`}>
                        <ReasoningMessage
                          message={it.message}
                          isExpanded={expandedReasoningIds.has(reasoningId)}
                          onToggle={toggleReasoningMessage}
                          align="left"
                        />
                      </div>
                    );
                  }

                  if (it.type === 'tool') {
                    if (it.toolKind === 'shell') {
                      return (
                        <div key={`work-shell-${it.id}-${idx}`}>
                          {renderShellStatusLine(
                            it.name,
                            it.status,
                            it.result,
                            it.shellCommand,
                            it.toolOptions,
                            {
                              nodeId: it.nodeId,
                              createdAt: it.createdAt,
                              roleLabel: it.roleLabel ?? it.name,
                            },
                            it.title,
                            it.tokenUsageIn,
                            it.tokenUsageOut,
                            it.requestTokenUsageIn,
                          )}
                        </div>
                      );
                    }

                    return (
                      <div key={`work-tool-${it.id}-${idx}`}>
                        {renderToolStatusLine(
                          it.name,
                          it.status,
                          it.result,
                          it.toolOptions,
                          it.title,
                          'left',
                        )}
                      </div>
                    );
                  }

                  return null;
                })}
              </div>
            </div>
          </ChatBubble>
        );
      };

      while (i < preparedMessages.length) {
        const item = preparedMessages[i];

        // Generate border color if inter-agent communication
        const borderColor =
          item.inCommunicationExec && item.sourceAgentNodeId
            ? generateColorFromNodeId(item.sourceAgentNodeId)
            : undefined;

        if (item.type === 'system') {
          pushRow(
            item.id,
            renderSystemGroup(item.messages, item.messages.length),
          );
          i++;
          continue;
        }

        if (item.type === 'reasoning') {
          if (isWorkGroupItem(item)) {
            const group: PreparedMessage[] = [item];
            let j = i + 1;
            while (
              j < preparedMessages.length &&
              isWorkGroupItem(preparedMessages[j])
            ) {
              group.push(preparedMessages[j]);
              j++;
            }
            const groupSourceNodeId = group.find(
              (g) => g.sourceAgentNodeId,
            )?.sourceAgentNodeId;
            const hasCommExec =
              group.length > 0 && group.every((g) => g.inCommunicationExec);
            const groupBorderColor =
              hasCommExec && groupSourceNodeId
                ? generateColorFromNodeId(groupSourceNodeId)
                : undefined;
            pushRow(
              `working-${item.id}`,
              renderWorkingBlock(group, groupBorderColor),
            );
            i = j;
            continue;
          }

          const reasoningId =
            getReasoningIdentifier(item.message) ?? item.message.id;
          pushRow(
            item.id,
            <ReasoningMessage
              message={item.message}
              isExpanded={expandedReasoningIds.has(reasoningId)}
              onToggle={toggleReasoningMessage}
            />,
          );
          i++;
          continue;
        }

        if (item.type === 'chat') {
          pushRow(item.id, renderMessage(item.message, borderColor));
          i++;
          continue;
        }

        if (item.type === 'tool') {
          if (isWorkGroupItem(item)) {
            const group: PreparedMessage[] = [item];
            let j = i + 1;
            while (
              j < preparedMessages.length &&
              isWorkGroupItem(preparedMessages[j])
            ) {
              group.push(preparedMessages[j]);
              j++;
            }
            const groupSourceNodeId = group.find(
              (g) => g.sourceAgentNodeId,
            )?.sourceAgentNodeId;
            const hasCommExec =
              group.length > 0 && group.every((g) => g.inCommunicationExec);
            const groupBorderColor =
              hasCommExec && groupSourceNodeId
                ? generateColorFromNodeId(groupSourceNodeId)
                : undefined;
            pushRow(
              `working-${item.id}`,
              renderWorkingBlock(group, groupBorderColor),
            );
            i = j;
            continue;
          }
          if (item.name && item.name.toLowerCase() === 'finish') {
            pushRow(
              item.id || `finish-${i}`,
              renderFinishTool(
                item.status,
                item.result,
                item.tokenUsage,
                item.requestTokenUsage,
                {
                  nodeId: item.nodeId,
                  createdAt: item.createdAt,
                  roleLabel: 'ai',
                },
                borderColor,
              ),
            );
            i++;
            continue;
          }

          if (item.toolKind === 'shell') {
            pushRow(
              item.id || `shell-${i}`,
              renderShellStatusLine(
                item.name,
                item.status,
                item.result,
                item.shellCommand,
                item.toolOptions,
                {
                  nodeId: item.nodeId,
                  createdAt: item.createdAt,
                  roleLabel: item.roleLabel ?? item.name,
                },
                item.title,
                item.tokenUsageIn,
                item.tokenUsageOut,
                item.requestTokenUsageIn,
                borderColor,
              ),
            );
            i++;
            continue;
          }

          pushRow(
            item.id || `generic-tool-${i}`,
            renderToolStatusLine(
              item.name,
              item.status,
              item.result,
              item.toolOptions,
              item.title,
            ),
          );
          i++;
          continue;
        }

        i++;
      }

      return rows;
    };

    if (!selectedThreadId) {
      return renderFullHeightState(
        <Text type="secondary">
          Select a thread from the header to view messages.
        </Text>,
      );
    }

    if (!isAgentNode) {
      return (
        <div style={fullHeightColumnStyle}>
          <div
            style={{
              ...scrollContainerStyle,
              overflowX: 'auto',
            }}>
            {renderNonAgentNodeInfo()}
          </div>
        </div>
      );
    }

    if (messagesLoading) {
      return renderFullHeightState(
        <Space direction="vertical" align="center" size="small">
          <Spin />
          <Text type="secondary">Loading messages...</Text>
        </Space>,
      );
    }

    if (messages.length === 0) {
      return renderFullHeightState(
        <Text type="secondary">No messages found for this thread.</Text>,
      );
    }

    return (
      <div style={fullHeightColumnStyle}>
        <div
          ref={scrollContainerRef}
          onScroll={handleScroll}
          style={scrollContainerStyle}>
          {loadingMore && (
            <div
              style={{
                padding: '8px 12px',
                textAlign: 'center',
                fontSize: '12px',
                color: '#8c8c8c',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '8px',
              }}>
              <Spin size="small" />
              <Text
                type="secondary"
                style={{ fontSize: '12px', color: '#8c8c8c' }}>
                Loading more messages...
              </Text>
            </div>
          )}

          {renderPreparedMessages()}
          {isThinkingVisible && !messagesLoading && (
            <div
              style={{
                textAlign: 'center',
                animation:
                  'messages-tab-thinking-pulse 1.6s ease-in-out infinite',
              }}>
              <div
                style={{
                  fontSize: '12px',
                  color: '#8c8c8c',
                  textAlign: 'center',
                  cursor: 'pointer',
                  display: '-webkit-box',
                  WebkitLineClamp: 3,
                  WebkitBoxOrient: 'vertical',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  lineHeight: '1.5',
                  wordBreak: 'break-word',
                  width: '100%',
                }}>
                Agent is thinking...
              </div>
            </div>
          )}
          {pendingMessages && pendingMessages.length > 0 && (
            <div
              style={{
                borderTop: '1px solid #ebebeb',
                paddingTop: '10px',
                marginTop: '8px',
              }}>
              {pendingMessages.map((msg, idx) => (
                <div
                  key={`pending-${msg.content}-${idx}`}
                  style={messageBlockStyle}>
                  {renderPendingMessage(msg)}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    );
  },
  (prevProps, nextProps) => {
    const messagesEqual =
      prevProps.messages === nextProps.messages ||
      (prevProps.messages.length === nextProps.messages.length &&
        prevProps.messages.every(
          (msg, idx) => msg.id === nextProps.messages[idx]?.id,
        ));

    const pendingMessagesEqual =
      prevProps.pendingMessages === nextProps.pendingMessages ||
      (prevProps.pendingMessages?.length ===
        nextProps.pendingMessages?.length &&
        (prevProps.pendingMessages?.every(
          (msg, idx) =>
            msg.content === nextProps.pendingMessages?.[idx]?.content &&
            msg.role === nextProps.pendingMessages?.[idx]?.role,
        ) ??
          false));

    return (
      messagesEqual &&
      prevProps.messagesLoading === nextProps.messagesLoading &&
      prevProps.selectedThreadId === nextProps.selectedThreadId &&
      prevProps.nodeId === nextProps.nodeId &&
      prevProps.isAgentNode === nextProps.isAgentNode &&
      prevProps.hasMoreMessages === nextProps.hasMoreMessages &&
      prevProps.loadingMore === nextProps.loadingMore &&
      prevProps.isNodeRunning === nextProps.isNodeRunning &&
      pendingMessagesEqual &&
      prevProps.newMessageMode === nextProps.newMessageMode &&
      prevProps.onLoadMoreMessages === nextProps.onLoadMoreMessages
    );
  },
);

export default ThreadMessagesView;
