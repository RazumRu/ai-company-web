import 'diff2html/bundles/css/diff2html.min.css';

import {
  CheckOutlined,
  CloseOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  ExpandOutlined,
  FileTextOutlined,
  InfoCircleOutlined,
  PlayCircleOutlined,
} from '@ant-design/icons';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import {
  Alert,
  Avatar,
  Button,
  Form,
  Input,
  InputNumber,
  Layout,
  message,
  Modal,
  Popover,
  Select,
  Space,
  Switch,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { createTwoFilesPatch } from 'diff';
import { html as diff2html } from 'diff2html';
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

import { graphsApi, litellmApi } from '../../../api';
import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  LiteLlmModelDto,
  TemplateDto,
  ThreadDtoStatusEnum,
  ThreadMessageDto,
} from '../../../autogenerated';
import { getAgentAvatarDataUri } from '../../../utils/agentAvatars';
import { extractApiErrorMessage } from '../../../utils/errors';
import type {
  FormField,
  GraphNode,
  GraphNodeData,
  SchemaProperty,
} from '../types';
import type { PendingMessage } from '../types/messages';
import { KeyValuePairsInput } from './KeyValuePairsInput';
import { NodeMessagesPanel } from './NodeMessagesPanel';

const DIFF_NO_LINE_NUMBERS_CSS = `
.diff2html-wrapper .d2h-code-linenumber,
.diff2html-wrapper .d2h-code-side-linenumber {
  display: none !important;
}
.diff2html-wrapper .d2h-code-line {
  padding-left: 12px !important;
}
.diff2html-wrapper .d2h-file-header {
  display: none;
}
.diff2html-wrapper .d2h-ins,
.diff2html-wrapper .d2h-del {
  padding-left: 12px !important;
}
.diff2html-wrapper .d2h-code-line-ctn {
  white-space: pre-wrap !important;
  word-break: break-word !important;
}
.diff2html-wrapper .d2h-file-wrapper {
  width: 100% !important;
  overflow-x: auto !important;
}
`;

const { Sider } = Layout;
const { Title, Text } = Typography;

interface NodeEditSidebarProps {
  node: GraphNode | null;
  visible: boolean;
  onClose: () => void;
  /**
   * Called whenever the user makes a real change to the node form.
   * GraphPage should use this to update draftGraph immediately.
   */
  onNodeDraftChange: (
    nodeId: string,
    updates: { name?: string; config?: Record<string, unknown> },
  ) => void;
  templates: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  /**
   * Global graph-level unsaved changes flag, computed in GraphPage.
   * NodeEditSidebar should NOT modify this.
   */
  hasGlobalUnsavedChanges?: boolean;
  onTriggerClick?: (nodeId: string) => void;
  selectedThreadId?: string;
  selectedThreadStatus?: ThreadDtoStatusEnum;
  selectedThreadLastRunId?: string | null;
  compiledNode?: GraphNodeWithStatusDto;
  compiledNodesLoading?: boolean;
  messages?: ThreadMessageDto[];
  messagesLoading?: boolean;
  hasMoreMessages?: boolean;
  loadingMoreMessages?: boolean;
  pendingMessages?: PendingMessage[];
  onLoadMoreMessages?: () => void;
  onRefreshMessages?: () => void;
  graphId?: string;
  /**
   * Snapshot version of the node config from draftGraph.
   * Used to reset initialFormValues when the parent updates draftGraph externally.
   */
  draftNodeConfigVersion?: number;
  /**
   * True when the currently opened node in the draft differs from the server baseline.
   * This should be computed in GraphPage (single source of truth).
   */
  hasNodeUnsavedChangesFromServer?: boolean;
}

type AiSuggestionMode = 'agent' | 'knowledge';

export type AiSuggestionState = {
  fieldKey: string;
  fieldLabel: string;
  mode: AiSuggestionMode;
  initialInstructions: string;
  currentInstructions: string;
  suggestedInstructions?: string;
  lastSuggestedInstructions?: string;
  manualSuggestedOverride?: string;
  isEditingSuggestion?: boolean;
  editSuggestionDraft?: string;
  userRequest: string;
  threadId?: string;
  loading: boolean;
};

export const NodeEditSidebar = React.memo(
  ({
    node,
    visible,
    onClose,
    onNodeDraftChange,
    templates,
    graphStatus,
    hasGlobalUnsavedChanges = false,
    onTriggerClick,
    selectedThreadId,
    selectedThreadStatus,
    selectedThreadLastRunId,
    compiledNode,
    compiledNodesLoading,
    messages = [],
    messagesLoading = false,
    hasMoreMessages = true,
    loadingMoreMessages = false,
    pendingMessages = [],
    onLoadMoreMessages,
    onRefreshMessages,
    graphId,
    draftNodeConfigVersion,
    hasNodeUnsavedChangesFromServer,
  }: NodeEditSidebarProps) => {
    const [form] = Form.useForm();
    const isHydratingRef = useRef(false);
    const nodeRef = useRef<GraphNode | null>(null);
    const [nodeName, setNodeName] = useState('');
    const [isEditingName, setIsEditingName] = useState(false);
    const [editingName, setEditingName] = useState('');
    const [formFields, setFormFields] = useState<FormField[]>([]);
    const [expandedTextarea, setExpandedTextarea] = useState<{
      fieldKey: string;
      value: string;
    } | null>(null);
    const [initialFormValues, setInitialFormValues] = useState<
      Record<string, unknown>
    >({});
    const [hasLocalUnsavedChanges, setHasLocalUnsavedChanges] = useState(false);
    const [activeTab, setActiveTab] = useState('options');
    const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
    const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);
    const [aiSuggestionState, setAiSuggestionState] =
      useState<AiSuggestionState | null>(null);

    const deepSortKeys = useCallback((obj: unknown): unknown => {
      if (obj === null || obj === undefined) return obj;
      if (typeof obj !== 'object') return obj;
      if (Array.isArray(obj)) return obj.map(deepSortKeys);

      const sorted: Record<string, unknown> = {};
      Object.keys(obj as Record<string, unknown>)
        .sort()
        .forEach((key) => {
          sorted[key] = deepSortKeys((obj as Record<string, unknown>)[key]);
        });
      return sorted;
    }, []);

    const deepEqual = useCallback(
      (a: unknown, b: unknown) => {
        // Sort keys before comparing to handle key ordering differences
        const sortedA = deepSortKeys(a);
        const sortedB = deepSortKeys(b);
        return JSON.stringify(sortedA) === JSON.stringify(sortedB);
      },
      [deepSortKeys],
    );

    const computeHasLocalUnsavedChanges = useCallback(() => {
      const currentValues = form.getFieldsValue(true) as Record<
        string,
        unknown
      >;
      const keys = new Set([
        ...Object.keys(initialFormValues),
        ...Object.keys(currentValues),
      ]);

      const formChanged = Array.from(keys).some((key) => {
        return !deepEqual(currentValues[key], initialFormValues[key]);
      });

      const expandedChanged = expandedTextarea
        ? !deepEqual(
            expandedTextarea.value,
            initialFormValues[expandedTextarea.fieldKey],
          )
        : false;

      return formChanged || expandedChanged;
    }, [deepEqual, expandedTextarea, form, initialFormValues]);

    // Local unsaved warning: ONLY based on actual local form changes.
    // (Do NOT compare draft config to compiled/runtime config; that can differ even
    // without user edits and causes false warnings.)
    // Also do NOT include server/draft diffs here - local is strictly uiForm vs baseline.
    const shouldShowUnsavedWarning = hasLocalUnsavedChanges;

    // For AI suggestion modal, we need to warn if there are unsaved changes that AI won't see
    const nodeDirtyWarning = useMemo(() => {
      // Show warning if there are local form changes OR the node differs from the
      // server baseline (draft != server). The parent owns this comparison.
      return (
        shouldShowUnsavedWarning || Boolean(hasNodeUnsavedChangesFromServer)
      );
    }, [shouldShowUnsavedWarning, hasNodeUnsavedChangesFromServer]);

    // Track the previous node ID to detect node switches
    const prevNodeIdRef = useRef<string | undefined>(undefined);

    const selectedNodeId = node?.id;
    const selectedNodeTemplateId = (node?.data as unknown as GraphNodeData)
      ?.template;

    useEffect(() => {
      // Keep a stable snapshot for form hydration to avoid re-hydrating
      // on every node prop reference change (e.g. when draftGraph updates).
      nodeRef.current = node;
    }, [node, selectedNodeId]);

    // Reset local unsaved changes when the parent signals that the graph was saved
    // (draftNodeConfigVersion increments after save)
    useEffect(() => {
      if (!hasGlobalUnsavedChanges && !isHydratingRef.current) {
        // Graph was saved - reset local form baseline
        const currentValues = form.getFieldsValue(true) as Record<
          string,
          unknown
        >;
        setInitialFormValues(currentValues);
        setHasLocalUnsavedChanges(false);
      }
    }, [form, hasGlobalUnsavedChanges]);

    // Update initialFormValues when the draftNodeConfigVersion changes (after parent save)
    useEffect(() => {
      if (draftNodeConfigVersion !== undefined && !isHydratingRef.current) {
        const currentValues = form.getFieldsValue(true) as Record<
          string,
          unknown
        >;
        setInitialFormValues(currentValues);
        setHasLocalUnsavedChanges(false);
      }
    }, [draftNodeConfigVersion, form]);

    useEffect(() => {
      if (expandedTextarea) {
        const hasChanges = computeHasLocalUnsavedChanges();
        if (hasChanges) {
          setHasLocalUnsavedChanges(true);
        }
      }
    }, [
      computeHasLocalUnsavedChanges,
      expandedTextarea,
      expandedTextarea?.value,
    ]);

    const AiSuggestionLink: React.FC<{
      onClick: () => void;
      style?: React.CSSProperties;
      label?: string;
      disabled?: boolean;
    }> = ({ onClick, style, label = 'Improve with AI', disabled }) => (
      <Button
        type="link"
        size="small"
        style={{ padding: 0, height: 'auto', fontSize: 12, ...style }}
        onClick={onClick}
        disabled={disabled}>
        {label}
      </Button>
    );

    const hasLiteLlmSelectField = useMemo(
      () =>
        formFields.some(
          (field) => field['x-ui:litellm-models-list-select'] === true,
        ),
      [formFields],
    );

    const nodeData = node?.data as unknown as GraphNodeData;
    const templateKindLower = (nodeData?.templateKind || '').toLowerCase();
    const isAgentNode = templateKindLower === 'simpleagent';
    const isKnowledgeNode = templateKindLower === 'knowledge';
    const aiSuggestionMode: AiSuggestionMode = isKnowledgeNode
      ? 'knowledge'
      : 'agent';
    const isGraphRunning = graphStatus === GraphDtoStatusEnum.Running;
    const isThreadStopped =
      selectedThreadStatus === ThreadDtoStatusEnum.Stopped;
    const showNodeStatus = ['runtime', 'simpleagent', 'trigger'].includes(
      templateKindLower,
    );
    const [instructionsVisible, setInstructionsVisible] = useState(false);
    const agentInstructionsText = useMemo(() => {
      const instructions = (
        compiledNode?.additionalNodeMetadata as unknown as {
          instructions?: unknown;
        }
      )?.instructions;
      if (instructions === undefined || instructions === null) {
        return '';
      }
      if (typeof instructions === 'string') {
        return instructions;
      }
      if (Array.isArray(instructions)) {
        return instructions.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(instructions, null, 2);
      } catch {
        return String(instructions);
      }
    }, [compiledNode?.additionalNodeMetadata]);
    const instructionsAvailable = Boolean(agentInstructionsText);
    const instructionsButtonDisabled =
      !isGraphRunning || compiledNodesLoading || !instructionsAvailable;
    const instructionsTooltip = !isGraphRunning
      ? 'Start the graph to view live instructions'
      : compiledNodesLoading
        ? 'Loading instructions...'
        : instructionsAvailable
          ? 'View current agent instructions'
          : 'Instructions are not available for this node yet';

    const expandedTextareaField = useMemo(
      () =>
        expandedTextarea
          ? formFields.find((field) => field.key === expandedTextarea.fieldKey)
          : undefined,
      [expandedTextarea, formFields],
    );

    const formatInstructionsValue = useCallback((value: unknown) => {
      if (value === undefined || value === null) {
        return '';
      }
      if (typeof value === 'string') {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }, []);

    const aiInitialInstructions = aiSuggestionState?.initialInstructions ?? '';
    const aiLastSuggestedInstructions =
      aiSuggestionState?.lastSuggestedInstructions;
    const aiManualSuggestedOverride =
      aiSuggestionState?.manualSuggestedOverride;

    const suggestionDiffHtml = useMemo(() => {
      if (!aiLastSuggestedInstructions && !aiManualSuggestedOverride) {
        return null;
      }

      const suggested =
        aiManualSuggestedOverride ?? aiLastSuggestedInstructions ?? '';
      const diffString = createTwoFilesPatch(
        'AI Suggestion',
        'AI Suggestion',
        aiInitialInstructions,
        suggested,
        '',
        '',
        { context: Number.MAX_SAFE_INTEGER },
      );

      return diff2html(diffString, {
        drawFileList: false,
        matching: 'lines',
        outputFormat: 'line-by-line',
      });
    }, [
      aiInitialInstructions,
      aiLastSuggestedInstructions,
      aiManualSuggestedOverride,
    ]);

    const openAiSuggestionModal = useCallback(
      (
        fieldKey: string,
        fieldLabel: string,
        initialValue?: unknown,
        modeOverride?: AiSuggestionMode,
      ) => {
        const modeToUse = modeOverride ?? aiSuggestionMode;
        if (!isGraphRunning) {
          message.warning('Start the graph to use AI suggestions');
          return;
        }

        const valueToUse: unknown =
          initialValue !== undefined
            ? initialValue
            : ((form.getFieldValue(fieldKey) as unknown) ?? '');
        const formattedValue = formatInstructionsValue(valueToUse);
        setAiSuggestionState({
          fieldKey,
          fieldLabel,
          mode: modeToUse,
          initialInstructions: formattedValue,
          currentInstructions: formattedValue,
          suggestedInstructions: undefined,
          lastSuggestedInstructions: undefined,
          manualSuggestedOverride: undefined,
          isEditingSuggestion: false,
          editSuggestionDraft: undefined,
          userRequest: '',
          threadId: undefined,
          loading: false,
        });
      },
      [aiSuggestionMode, form, formatInstructionsValue, isGraphRunning],
    );

    const closeAiSuggestionModal = useCallback(() => {
      setAiSuggestionState(null);
    }, []);

    const statusTagColorMap: Record<string, string> = {
      running: 'green',
      idle: 'blue',
      starting: 'geekblue',
      stopped: 'red',
    };

    const rawStatus = compiledNode?.status;

    const statusLabel = !isGraphRunning
      ? 'Not running'
      : compiledNodesLoading
        ? 'Loading...'
        : rawStatus
          ? `${rawStatus.charAt(0).toUpperCase()}${rawStatus.slice(1)}`
          : 'Unknown';

    const statusTagColor = !isGraphRunning
      ? 'default'
      : compiledNodesLoading
        ? 'geekblue'
        : statusTagColorMap[rawStatus ?? ''] || 'default';

    const normalizeJsonViewValue = (value: unknown): object | undefined => {
      if (value === undefined) {
        return undefined;
      }
      if (value !== null && typeof value === 'object') {
        return value as object;
      }
      return { value } as Record<string, unknown>;
    };

    const metadataJsonValue = normalizeJsonViewValue(compiledNode?.metadata);
    const configJsonValue = normalizeJsonViewValue(compiledNode?.config);
    const hasInfoData = Boolean(metadataJsonValue || configJsonValue);

    const infoContent = (
      <div style={{ maxWidth: 360 }}>
        {compiledNodesLoading && (
          <Text
            type="secondary"
            style={{
              display: 'block',
              marginBottom: hasInfoData ? 8 : 0,
            }}>
            Loading latest node information...
          </Text>
        )}
        {metadataJsonValue && (
          <div style={{ marginBottom: configJsonValue ? 16 : 0 }}>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Metadata
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView
                value={metadataJsonValue as object}
                style={lightTheme}
              />
            </div>
          </div>
        )}
        {configJsonValue && (
          <div>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Configuration
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView value={configJsonValue as object} style={lightTheme} />
            </div>
          </div>
        )}
        {!compiledNodesLoading && !hasInfoData && (
          <Text type="secondary">No metadata or configuration available.</Text>
        )}
      </div>
    );

    useEffect(() => {
      if (!visible) {
        setAiSuggestionState(null);
      }
    }, [visible]);

    useEffect(() => {
      setAiSuggestionState(null);
    }, [node?.id]);

    useEffect(() => {
      if (!hasLiteLlmSelectField) {
        return;
      }
      if (liteLlmModels.length > 0) {
        return;
      }

      let isActive = true;

      const fetchLiteLlmModels = async () => {
        try {
          setLitellmModelsLoading(true);
          const response = await litellmApi.listModels();
          if (!isActive) {
            return;
          }
          setLiteLlmModels(response.data ?? []);
        } catch (error) {
          if (!isActive) {
            return;
          }
          console.error('Failed to load LiteLLM models:', error);
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load LiteLLM models',
          );
          message.error(errorMessage);
        } finally {
          if (isActive) {
            setLitellmModelsLoading(false);
          }
        }
      };

      fetchLiteLlmModels();

      return () => {
        isActive = false;
      };
    }, [hasLiteLlmSelectField, liteLlmModels.length]);

    // Keep active tab valid for the currently selected node (does NOT touch form state).
    useEffect(() => {
      const nodeForTabs = node;
      if (!nodeForTabs) return;
      const currentNodeData = nodeForTabs.data as unknown as GraphNodeData;
      const currentNodeIsAgent =
        currentNodeData?.templateKind === 'simpleAgent';
      const availableTabs = ['options'];
      if (currentNodeIsAgent) {
        availableTabs.push('messages');
      }
      if (!availableTabs.includes(activeTab)) {
        setActiveTab('options');
      }
    }, [activeTab, node]);

    // Hydrate form ONLY when switching nodes or switching templates.
    // Critically, do NOT re-run on every `node` object reference change, otherwise
    // typing (which updates draftGraph) will rehydrate and steal focus.
    useEffect(() => {
      const nodeForInit = nodeRef.current;
      if (!nodeForInit) {
        form.resetFields();
        setFormFields([]);
        setInitialFormValues({});
        setHasLocalUnsavedChanges(false);
        prevNodeIdRef.current = undefined;
        return;
      }

      const currentNodeData = nodeForInit.data as unknown as GraphNodeData;
      const template = templates.find((t) => t.id === currentNodeData.template);

      isHydratingRef.current = true;

      if (template?.schema?.properties) {
        const fields: FormField[] = [];
        Object.entries(template.schema.properties).forEach(([key, prop]) => {
          const typedProp = prop as SchemaProperty;
          const isConst = typedProp.const !== undefined;
          const isObject =
            typedProp.type === 'object' && typedProp.additionalProperties;

          fields.push({
            ...typedProp,
            key,
            name: typedProp.title || key,
            description: typedProp.description,
            type: isObject ? 'object' : typedProp.type || 'string',
            required:
              (template.schema.required as unknown[] | undefined)?.includes(
                key,
              ) || false,
            default: typedProp.default,
            const: typedProp.const,
            enum: typedProp.enum,
            isConst,
            isObject,
          });
        });

        setFormFields(fields);

        const initialValues: Record<string, unknown> = {};
        fields.forEach((field) => {
          if (field.isConst) {
            initialValues[field.key] = field.const;
          } else {
            initialValues[field.key] =
              (currentNodeData.config as Record<string, unknown>)?.[
                field.key
              ] ??
              field.default ??
              '';
          }
        });

        form.resetFields();
        form.setFieldsValue(initialValues);

        const currentValuesNow = form.getFieldsValue(true) as Record<
          string,
          unknown
        >;
        setInitialFormValues(currentValuesNow);
        setHasLocalUnsavedChanges(false);

        requestAnimationFrame(() => {
          isHydratingRef.current = false;
        });
      } else {
        setFormFields([]);
        form.resetFields();
        setInitialFormValues({});
        setHasLocalUnsavedChanges(false);
        requestAnimationFrame(() => {
          isHydratingRef.current = false;
        });
      }

      const label = (currentNodeData.label as string) || '';
      setNodeName(label);
      setEditingName(label);
      prevNodeIdRef.current = nodeForInit.id;
    }, [form, selectedNodeId, selectedNodeTemplateId, templates]);

    /**
     * Build the processed config from current form values.
     * This is used for both immediate draft updates and final saves.
     */
    const buildProcessedConfig = useCallback((): Record<string, unknown> => {
      const currentConfig: Record<string, unknown> =
        (node?.data as unknown as GraphNodeData | undefined)?.config ?? {};

      // Start with keys that are NOT in formFields (to preserve them)
      const formFieldKeys = new Set(formFields.map((f) => f.key));
      const configValues: Record<string, unknown> = {};
      Object.keys(currentConfig).forEach((key) => {
        if (!formFieldKeys.has(key)) {
          configValues[key] = currentConfig[key];
        }
      });

      // Process all form fields and include them in the config (even if they have default values)
      // This ensures the server always has the full config
      formFields.forEach((field) => {
        const key = field.key;

        if (field.isConst) {
          configValues[key] = field.const as unknown;
          return;
        }

        const rawValue: unknown = form.getFieldValue(key);
        const effectiveValue: unknown =
          rawValue === undefined
            ? (currentConfig as Record<string, unknown>)[key]
            : rawValue;

        const isEmptyString =
          typeof effectiveValue === 'string' && effectiveValue.trim() === '';
        const isEmptyArray =
          Array.isArray(effectiveValue) && effectiveValue.length === 0;
        const isEmptyObject =
          field.type === 'object' &&
          effectiveValue !== null &&
          typeof effectiveValue === 'object' &&
          !Array.isArray(effectiveValue) &&
          Object.keys(effectiveValue as Record<string, unknown>).length === 0;

        const isTrulyEmpty: boolean =
          effectiveValue === null ||
          effectiveValue === undefined ||
          isEmptyString ||
          isEmptyArray ||
          isEmptyObject;

        // Skip truly empty values (but not booleans)
        if (isTrulyEmpty && field.type !== 'boolean') {
          return;
        }

        let processedValue: unknown = effectiveValue;

        switch (field.type) {
          case 'number':
          case 'integer': {
            if (typeof effectiveValue === 'string') {
              const num = Number(effectiveValue);
              if (Number.isNaN(num)) {
                return;
              }
              processedValue = field.type === 'integer' ? Math.trunc(num) : num;
            } else if (typeof effectiveValue === 'number') {
              processedValue =
                field.type === 'integer'
                  ? Math.trunc(effectiveValue)
                  : effectiveValue;
            } else {
              return;
            }
            break;
          }
          case 'array': {
            if (typeof effectiveValue === 'string') {
              processedValue = effectiveValue
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line !== '');
            } else if (Array.isArray(effectiveValue)) {
              processedValue = effectiveValue;
            } else if (effectiveValue == null) {
              return;
            }
            break;
          }
          case 'object': {
            if (typeof effectiveValue === 'string') {
              try {
                const parsed: unknown = JSON.parse(effectiveValue as string);
                processedValue = parsed;
              } catch {
                return;
              }
            } else if (
              effectiveValue &&
              typeof effectiveValue === 'object' &&
              !Array.isArray(effectiveValue)
            ) {
              processedValue = effectiveValue;
            } else if (effectiveValue == null) {
              return;
            }
            break;
          }
          case 'boolean': {
            processedValue = Boolean(effectiveValue);
            break;
          }
          case 'string':
          default: {
            if (typeof effectiveValue === 'string') {
              const trimmed = effectiveValue.trim();
              if (trimmed === '') {
                return;
              }
              processedValue = trimmed;
            } else {
              processedValue = effectiveValue;
            }
          }
        }

        configValues[key] = processedValue;
      });

      return configValues;
    }, [node?.data, formFields, form]);

    /**
     * Push draft changes to the parent (GraphPage).
     * This is called immediately on every meaningful form change.
     * The parent will update draftGraph and persist the diff.
     */
    const pushDraftChange = useCallback(() => {
      if (!node) return;
      if (isHydratingRef.current) return; // Don't push during hydration

      const configValues = buildProcessedConfig();
      const currentConfig: Record<string, unknown> =
        (node.data as unknown as GraphNodeData | undefined)?.config ?? {};
      const currentLabel = (node.data as unknown as GraphNodeData | undefined)
        ?.label;

      const labelUnchanged = nodeName === currentLabel;
      const configUnchanged = deepEqual(configValues, currentConfig);

      if (labelUnchanged && configUnchanged) {
        return;
      }

      onNodeDraftChange(node.id, {
        name: nodeName,
        config: configValues,
      });
    }, [node, nodeName, buildProcessedConfig, deepEqual, onNodeDraftChange]);

    // Cleanup effect: push any pending draft changes when unmounting
    // Note: This is a safety net, but ideally changes should be pushed immediately
    useEffect(() => {
      return () => {
        // The effect cleanup runs on unmount, but we can't reliably
        // push changes here since the refs and state may be stale.
        // The handleClose function should handle this case.
      };
    }, []);

    const handleExpandedTextareaSave = useCallback(() => {
      if (expandedTextarea) {
        form.setFieldValue(expandedTextarea.fieldKey, expandedTextarea.value);
        // Compute hasChanges and push draft
        const hasChanges = computeHasLocalUnsavedChanges();
        setHasLocalUnsavedChanges(hasChanges);
        if (hasChanges) {
          pushDraftChange();
        }
      }
      setExpandedTextarea(null);
    }, [
      expandedTextarea,
      form,
      computeHasLocalUnsavedChanges,
      pushDraftChange,
    ]);

    const handleFormChange = useCallback(
      (
        _changedValues: Record<string, unknown>,
        _allValues: Record<string, unknown>,
      ) => {
        void _changedValues;
        void _allValues;

        // Ignore changes during form hydration (initial mount / node switch)
        if (isHydratingRef.current) {
          return;
        }

        // Always push changes to draft state
        // The draft state layer will determine if there are unsaved changes vs server baseline
        pushDraftChange();

        // Compute whether the form has actually changed from the initial values
        const hasChanges = computeHasLocalUnsavedChanges();

        // Update local unsaved state - this can go from true to false
        // if the user reverts their changes back to the initial values
        setHasLocalUnsavedChanges(hasChanges);
      },
      [computeHasLocalUnsavedChanges, pushDraftChange],
    );

    const handleClose = useCallback(() => {
      // Push any remaining draft changes before closing
      if (hasLocalUnsavedChanges) {
        pushDraftChange();
      }
      onClose();
    }, [hasLocalUnsavedChanges, pushDraftChange, onClose]);

    const handleStartEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) => {
        if (!prev) return prev;
        const currentDraft =
          prev.manualSuggestedOverride ??
          prev.lastSuggestedInstructions ??
          prev.currentInstructions ??
          '';
        return {
          ...prev,
          isEditingSuggestion: true,
          editSuggestionDraft: currentDraft,
        };
      });
    }, []);

    const handleCancelEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) =>
        prev
          ? {
              ...prev,
              isEditingSuggestion: false,
              editSuggestionDraft: undefined,
            }
          : prev,
      );
    }, []);

    const handleApplyEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) =>
        prev && prev.editSuggestionDraft !== undefined
          ? {
              ...prev,
              manualSuggestedOverride: prev.editSuggestionDraft,
              suggestedInstructions: prev.editSuggestionDraft,
              isEditingSuggestion: false,
            }
          : prev,
      );
    }, []);

    const handleNameEdit = () => {
      setIsEditingName(true);
      setEditingName(nodeName);
    };

    const handleNameSave = () => {
      if (editingName !== nodeName) {
        setNodeName(editingName);
        if (node) {
          // Use onNodeDraftChange for immediate draft update
          onNodeDraftChange(node.id, {
            name: editingName,
          });
          setHasLocalUnsavedChanges(true);
        }
      }
      setIsEditingName(false);
    };

    const handleNameCancel = () => {
      setEditingName(nodeName);
      setIsEditingName(false);
    };

    const handleAiSuggestionSubmit = useCallback(async () => {
      if (!aiSuggestionState) return;

      const isAgentSuggestion = aiSuggestionState.mode === 'agent';

      if (!isGraphRunning) {
        message.warning('Start the graph to use AI suggestions');
        return;
      }

      const userRequest = aiSuggestionState.userRequest.trim();
      if (!userRequest) {
        message.warning('Enter a request for the AI suggestion');
        return;
      }

      if (!graphId || !node?.id) {
        message.error('Graph or node is missing for suggestions');
        return;
      }

      setAiSuggestionState((prev) =>
        prev ? { ...prev, loading: true } : prev,
      );

      try {
        if (isAgentSuggestion) {
          const response = await graphsApi.suggestAgentInstructions(
            graphId ?? '',
            node?.id ?? '',
            {
              userRequest,
              threadId: aiSuggestionState.threadId,
            },
          );

          setAiSuggestionState((prev) =>
            prev
              ? {
                  ...prev,
                  loading: false,
                  suggestedInstructions:
                    response.data?.instructions ?? prev.suggestedInstructions,
                  lastSuggestedInstructions:
                    response.data?.instructions ??
                    prev.lastSuggestedInstructions,
                  manualSuggestedOverride: undefined,
                  isEditingSuggestion: false,
                  editSuggestionDraft: undefined,
                  threadId: response.data?.threadId ?? prev.threadId,
                  userRequest: '',
                }
              : prev,
          );
        } else {
          const response = await graphsApi.suggestKnowledgeContent(
            graphId,
            node.id,
            {
              userRequest,
              threadId: aiSuggestionState.threadId,
            },
          );

          setAiSuggestionState((prev) =>
            prev
              ? {
                  ...prev,
                  loading: false,
                  suggestedInstructions:
                    response.data?.content ?? prev.suggestedInstructions,
                  lastSuggestedInstructions:
                    response.data?.content ?? prev.lastSuggestedInstructions,
                  manualSuggestedOverride: undefined,
                  isEditingSuggestion: false,
                  editSuggestionDraft: undefined,
                  threadId: response.data?.threadId ?? prev.threadId,
                  userRequest: '',
                }
              : prev,
          );
        }
      } catch (error) {
        setAiSuggestionState((prev) =>
          prev ? { ...prev, loading: false } : prev,
        );
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to fetch AI suggestion',
        );
        message.error(errorMessage);
      }
    }, [aiSuggestionState, graphId, isGraphRunning, node?.id]);

    const handleApplyAiSuggestion = useCallback(() => {
      if (
        !aiSuggestionState?.suggestedInstructions &&
        !aiSuggestionState?.manualSuggestedOverride
      )
        return;

      const suggestedInstructions =
        aiSuggestionState.manualSuggestedOverride ??
        aiSuggestionState.suggestedInstructions ??
        '';

      form.setFieldValue(aiSuggestionState.fieldKey, suggestedInstructions);

      if (
        expandedTextarea?.fieldKey &&
        expandedTextarea.fieldKey === aiSuggestionState.fieldKey
      ) {
        setExpandedTextarea((prev) =>
          prev ? { ...prev, value: suggestedInstructions } : prev,
        );
      }

      setAiSuggestionState(null);

      // Push the AI suggestion as a draft change
      setHasLocalUnsavedChanges(true);
      pushDraftChange();
    }, [aiSuggestionState, expandedTextarea?.fieldKey, form, pushDraftChange]);

    const renderFormField = (field: FormField) => {
      const {
        key,
        name,
        description,
        type,
        required,
        isConst,
        const: constValue,
        enum: enumValues,
      } = field;

      const rules = required
        ? [{ required: true, message: `${name} is required` }]
        : undefined;

      const descriptionNode = description ? (
        <Text
          type="secondary"
          style={{
            fontSize: 12,
            fontWeight: 'normal',
          }}>
          {description}
        </Text>
      ) : undefined;

      const supportsAiSuggestions =
        (field as SchemaProperty)['x-ui:ai-suggestions'] === true;

      const aiSuggestionLabel =
        aiSuggestionMode === 'knowledge'
          ? 'Generate with AI'
          : 'Improve with AI';

      const aiSuggestionLink = supportsAiSuggestions ? (
        <AiSuggestionLink
          onClick={() =>
            openAiSuggestionModal(key, name, undefined, aiSuggestionMode)
          }
          disabled={!isGraphRunning || !graphId || !node?.id}
          label={aiSuggestionLabel}
        />
      ) : null;

      const extraContent =
        descriptionNode || aiSuggestionLink ? (
          <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
            {descriptionNode}
            {aiSuggestionLink}
          </div>
        ) : undefined;

      const commonProps = {
        name: key,
        label: name,
        required,
        rules,
        extra: extraContent,
        style: {
          marginBottom: '10px',
        },
      } as const;

      if (isConst) {
        return (
          <Form.Item key={key} {...commonProps} initialValue={constValue}>
            <Input disabled size="middle" value={String(constValue)} />
          </Form.Item>
        );
      }

      const shouldUseLiteLlmModelsSelect =
        (field as SchemaProperty)['x-ui:litellm-models-list-select'] === true;

      if (shouldUseLiteLlmModelsSelect) {
        return (
          <Form.Item key={key} {...commonProps}>
            <Select
              placeholder={`Select ${name.toLowerCase()}`}
              size="middle"
              allowClear={!required}
              showSearch
              loading={litellmModelsLoading}
              notFoundContent={
                litellmModelsLoading
                  ? 'Loading models...'
                  : 'No models available'
              }
              filterOption={(input, option) =>
                (option?.label ?? '')
                  .toString()
                  .toLowerCase()
                  .includes(input.toLowerCase())
              }
              options={liteLlmModels.map((model) => ({
                label: model.ownedBy
                  ? `${model.id} (${model.ownedBy})`
                  : model.id,
                value: model.id,
              }))}
            />
          </Form.Item>
        );
      }

      if (enumValues && Array.isArray(enumValues) && enumValues.length > 0) {
        return (
          <Form.Item key={key} {...commonProps}>
            <Select
              placeholder={`Select ${name.toLowerCase()}`}
              size="middle"
              allowClear={!required}
              showSearch
              filterOption={(input, option) =>
                (option?.label ?? '')
                  .toString()
                  .toLowerCase()
                  .includes(input.toLowerCase())
              }
              options={enumValues.map((value) => ({
                label: String(value),
                value: value,
              }))}
            />
          </Form.Item>
        );
      }

      const shouldUseTextarea =
        (field as SchemaProperty)['x-ui:textarea'] === true;

      switch (type) {
        case 'string':
          if (shouldUseTextarea) {
            return (
              <Form.Item
                key={key}
                label={name}
                required={required}
                rules={rules}
                extra={descriptionNode}
                style={{ marginBottom: '10px' }}>
                <div style={{ position: 'relative' }}>
                  <Form.Item name={key} noStyle>
                    <Input.TextArea
                      placeholder={`Enter ${name.toLowerCase()}`}
                      rows={4}
                      size="middle"
                      style={{ paddingRight: '32px' }}
                    />
                  </Form.Item>
                  <Button
                    type="text"
                    icon={<ExpandOutlined />}
                    size="small"
                    style={{
                      position: 'absolute',
                      right: '4px',
                      top: '4px',
                      zIndex: 1,
                    }}
                    onClick={() => {
                      const fieldValue: unknown = form.getFieldValue(key);
                      const safeValue =
                        fieldValue === undefined || fieldValue === null
                          ? ''
                          : String(fieldValue);
                      setExpandedTextarea({
                        fieldKey: key,
                        value: safeValue,
                      });
                    }}
                  />
                </div>
                {supportsAiSuggestions && (
                  <AiSuggestionLink
                    onClick={() =>
                      openAiSuggestionModal(
                        key,
                        name,
                        undefined,
                        aiSuggestionMode,
                      )
                    }
                    disabled={!isGraphRunning}
                    label={
                      aiSuggestionMode === 'knowledge'
                        ? 'Generate with AI'
                        : 'Improve with AI'
                    }
                  />
                )}
              </Form.Item>
            );
          }

          return (
            <Form.Item key={key} {...commonProps}>
              <Input
                placeholder={`Enter ${name.toLowerCase()}`}
                size="middle"
              />
            </Form.Item>
          );

        case 'number':
          return (
            <Form.Item key={key} {...commonProps}>
              <InputNumber
                style={{ width: '100%' }}
                placeholder={`Enter ${name.toLowerCase()}`}
                size="middle"
              />
            </Form.Item>
          );

        case 'boolean':
          return (
            <Form.Item key={key} {...commonProps} valuePropName="checked">
              <Switch />
            </Form.Item>
          );

        case 'array':
          return (
            <Form.Item key={key} {...commonProps}>
              <Input.TextArea
                placeholder={`Enter ${name.toLowerCase()} (one per line)`}
                rows={3}
                size="middle"
              />
            </Form.Item>
          );

        case 'object':
          return (
            <Form.Item key={key} {...commonProps}>
              <KeyValuePairsInput />
            </Form.Item>
          );

        default:
          return (
            <Form.Item key={key} {...commonProps}>
              <Input
                placeholder={`Enter ${name.toLowerCase()}`}
                size="middle"
              />
            </Form.Item>
          );
      }
    };

    const isTriggerNode = nodeData?.templateKind === 'trigger';
    const canTrigger = isTriggerNode && isGraphRunning;

    const renderOptionsTabContent = () => {
      return (
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
          }}>
          <div
            style={{
              flexShrink: 0,
              padding: '8px 4px 0 4px',
            }}>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: 8,
              }}>
              <Title level={5} style={{ margin: 0 }}>
                Configuration
              </Title>
            </div>
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'auto',
              padding: '0 4px 8px 4px',
            }}>
            {formFields.length > 0 ? (
              <Form
                form={form}
                layout="vertical"
                size="small"
                style={{ marginTop: 0 }}
                labelCol={{ style: { paddingBottom: 4 } }}
                onValuesChange={handleFormChange}>
                {formFields.map(renderFormField)}
              </Form>
            ) : (
              <Text type="secondary">
                No configuration options available for this template.
              </Text>
            )}
          </div>
        </div>
      );
    };

    const newMessageMode = useMemo(() => {
      return (compiledNode?.config as Record<string, unknown>)
        ?.newMessageMode as
        | 'inject_after_tool_call'
        | 'wait_for_completion'
        | undefined;
    }, [compiledNode?.config]);

    const renderMessagesTabContent = useCallback(() => {
      const isNodeRunning =
        !isThreadStopped &&
        isGraphRunning &&
        (typeof compiledNode?.status === 'string'
          ? compiledNode.status.toLowerCase() === 'running'
          : true);

      return (
        <NodeMessagesPanel
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={selectedThreadId}
          nodeId={node?.id}
          nodeTemplateKind={nodeData?.templateKind}
          onLoadMoreMessages={onLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMoreMessages={loadingMoreMessages}
          isNodeRunning={isNodeRunning}
          isThreadStopped={isThreadStopped}
          currentThreadLastRunId={selectedThreadLastRunId}
          pendingMessages={pendingMessages}
          newMessageMode={newMessageMode}
          onRefreshMessages={onRefreshMessages}
        />
      );
    }, [
      compiledNode?.status,
      hasMoreMessages,
      isGraphRunning,
      isThreadStopped,
      loadingMoreMessages,
      messages,
      messagesLoading,
      newMessageMode,
      node?.id,
      nodeData?.templateKind,
      onLoadMoreMessages,
      onRefreshMessages,
      pendingMessages,
      selectedThreadId,
      selectedThreadLastRunId,
    ]);

    const tabItems = isAgentNode
      ? [
          { key: 'options', label: 'Options' },
          { key: 'messages', label: 'Messages' },
        ]
      : [{ key: 'options', label: 'Options' }];

    if (!visible) {
      // Keep the form instance connected to a Form element to avoid antd warnings
      return <Form form={form} style={{ display: 'none' }} />;
    }

    const isKnowledgeSuggestion = aiSuggestionState?.mode === 'knowledge';
    const suggestionModalTitle = aiSuggestionState?.fieldLabel
      ? `${isKnowledgeSuggestion ? 'Generate' : 'Improve'} ${aiSuggestionState.fieldLabel} with AI`
      : isKnowledgeSuggestion
        ? 'Generate knowledge with AI'
        : 'Improve instructions with AI';
    const currentContentLabel = isKnowledgeSuggestion
      ? 'Current content'
      : 'Current instructions';
    const suggestionSectionLabel = isKnowledgeSuggestion
      ? 'Suggested content'
      : 'Suggested instructions';
    const requestPromptLabel = isKnowledgeSuggestion
      ? 'What should be generated?'
      : 'What should be improved?';
    const requestPlaceholder = isKnowledgeSuggestion
      ? 'Describe the knowledge you want to generate or refine'
      : 'Describe what you want to change or add';
    const sendButtonLabel = isKnowledgeSuggestion ? 'Generate' : 'Send';
    const suggestionText =
      aiSuggestionState?.manualSuggestedOverride ??
      aiSuggestionState?.lastSuggestedInstructions ??
      aiSuggestionState?.suggestedInstructions ??
      '';
    const hasSuggestedContent = Boolean(suggestionText);
    const shouldShowDiffOnly =
      isKnowledgeSuggestion &&
      hasSuggestedContent &&
      Boolean(suggestionDiffHtml);

    return (
      <Sider
        width={400}
        style={{
          background: '#fff',
          borderLeft: '1px solid #f0f0f0',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
        }}>
        <div
          style={{
            padding: '16px',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            minHeight: 0,
          }}>
          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: 16,
              paddingBottom: 16,
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <Title level={4} style={{ margin: 0 }}>
              Edit Node
            </Title>
            <Space>
              {isTriggerNode && (
                <Button
                  type="primary"
                  icon={<PlayCircleOutlined />}
                  disabled={!canTrigger}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onTriggerClick?.(node?.id || '');
                  }}
                  size="small">
                  Trigger
                </Button>
              )}
              <Button
                onClick={handleClose}
                icon={<CloseOutlined />}
                size="small"></Button>
            </Space>
          </div>

          <div style={{ flexShrink: 0, marginBottom: 16 }}>
            {isEditingName ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Input
                  value={editingName}
                  onChange={(e) => setEditingName(e.target.value)}
                  onPressEnter={handleNameSave}
                  onBlur={handleNameSave}
                  autoFocus
                  style={{ flex: 1 }}
                />
                <Button
                  type="text"
                  icon={<CheckOutlined />}
                  onClick={handleNameSave}
                  size="small"
                />
                <Button
                  type="text"
                  icon={<CloseOutlined />}
                  onClick={handleNameCancel}
                  size="small"
                />
              </div>
            ) : (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 4,
                }}>
                {isAgentNode && node?.id && (
                  <Avatar
                    size={30}
                    src={getAgentAvatarDataUri(node.id, 64)}
                    style={{ flexShrink: 0 }}
                  />
                )}
                <Text
                  strong
                  style={{
                    flex: 1,
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    display: 'block',
                  }}>
                  {nodeName}
                </Text>
                {isAgentNode && (
                  <Tooltip title={instructionsTooltip} placement="bottom">
                    <Button
                      type="text"
                      size="small"
                      icon={<FileTextOutlined />}
                      disabled={instructionsButtonDisabled}
                      onClick={() => setInstructionsVisible(true)}
                      aria-label="View agent instructions"
                    />
                  </Tooltip>
                )}
                <Popover
                  content={infoContent}
                  trigger="click"
                  placement="bottomRight">
                  <Button
                    type="text"
                    size="small"
                    icon={<InfoCircleOutlined />}
                    aria-label="View node metadata and configuration"
                  />
                </Popover>
                <Button
                  type="text"
                  icon={<EditOutlined />}
                  onClick={handleNameEdit}
                  size="small"
                />
              </div>
            )}

            <div
              style={{
                fontSize: '11px',
                color: '#bfbfbf',
              }}>
              {nodeData?.template} ({nodeData?.templateKind})
            </div>
            {showNodeStatus && (
              <div
                style={{
                  marginTop: 8,
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                  flexWrap: 'wrap',
                }}>
                <Space size={2} wrap align="center">
                  <Tag
                    color={statusTagColor}
                    style={{ margin: 0, fontSize: 12 }}
                    bordered={statusTagColor === 'default'}>
                    {statusLabel}
                  </Tag>
                  {compiledNode?.error && (
                    <Tooltip title={compiledNode.error} placement="top">
                      <ExclamationCircleOutlined
                        style={{ color: '#ff4d4f', fontSize: 14 }}
                      />
                    </Tooltip>
                  )}
                </Space>
              </div>
            )}
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'hidden',
              display: 'flex',
              flexDirection: 'column',
            }}>
            {tabItems.length > 1 && (
              <div
                style={{
                  flexShrink: 0,
                  display: 'flex',
                }}>
                <div
                  role="tablist"
                  aria-label="Node editor tabs"
                  style={{
                    background: '#f2f2f7',
                    borderRadius: 999,
                    padding: 4,
                    display: 'flex',
                    gap: 6,
                    width: '100%',
                  }}>
                  {tabItems.map((tab, index) => {
                    const isActive = activeTab === tab.key;
                    return (
                      <button
                        key={tab.key}
                        role="tab"
                        aria-selected={isActive}
                        onClick={() => setActiveTab(tab.key)}
                        onKeyDown={(event) => {
                          if (event.key === 'ArrowRight') {
                            event.preventDefault();
                            const nextKey =
                              tabItems[(index + 1) % tabItems.length]?.key ??
                              tab.key;
                            setActiveTab(nextKey);
                          } else if (event.key === 'ArrowLeft') {
                            event.preventDefault();
                            const prevKey =
                              tabItems[
                                (index - 1 + tabItems.length) % tabItems.length
                              ]?.key ?? tab.key;
                            setActiveTab(prevKey);
                          }
                        }}
                        style={{
                          border: 'none',
                          background: isActive ? '#ffffff' : 'transparent',
                          padding: '4px 0',
                          borderRadius: 999,
                          fontWeight: 600,
                          fontSize: 13,
                          color: isActive ? '#111' : '#555',
                          cursor: 'pointer',
                          transition: 'all 0.2s ease',
                          flex: 1,
                        }}>
                        {tab.label}
                      </button>
                    );
                  })}
                </div>
              </div>
            )}

            <div
              style={{
                flex: 1,
                minHeight: 0,
                overflow: 'hidden',
                display: 'flex',
                flexDirection: 'column',
              }}>
              {activeTab === 'options'
                ? renderOptionsTabContent()
                : renderMessagesTabContent()}
            </div>
          </div>
        </div>

        <Modal
          title={suggestionModalTitle}
          open={!!aiSuggestionState}
          footer={null}
          onCancel={closeAiSuggestionModal}
          destroyOnClose
          width={720}>
          {aiSuggestionState && (
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              {nodeDirtyWarning && (
                <Alert
                  type="warning"
                  showIcon
                  message="Unsaved changes for this node"
                  description="AI suggestions use the current value from the database. Save this node first if you want your latest edits included."
                />
              )}
              {!shouldShowDiffOnly && (
                <div>
                  <Text strong style={{ display: 'block', marginBottom: 6 }}>
                    {currentContentLabel}
                  </Text>
                  {aiSuggestionState.lastSuggestedInstructions &&
                  (aiSuggestionState.manualSuggestedOverride ||
                    suggestionDiffHtml) ? (
                    aiSuggestionState.isEditingSuggestion ? (
                      <Space direction="vertical" style={{ width: '100%' }}>
                        <Input.TextArea
                          value={
                            aiSuggestionState.editSuggestionDraft ??
                            aiSuggestionState.manualSuggestedOverride ??
                            aiSuggestionState.lastSuggestedInstructions
                          }
                          onChange={(e) =>
                            setAiSuggestionState((prev) =>
                              prev
                                ? {
                                    ...prev,
                                    editSuggestionDraft: e.target.value,
                                  }
                                : prev,
                            )
                          }
                          autoSize={{ minRows: 6, maxRows: 14 }}
                          style={{ fontFamily: 'monospace' }}
                        />
                        <Space>
                          <Button
                            onClick={handleCancelEditSuggested}
                            size="small">
                            Cancel
                          </Button>
                          <Button
                            type="primary"
                            size="small"
                            onClick={handleApplyEditSuggested}>
                            Apply
                          </Button>
                        </Space>
                      </Space>
                    ) : (
                      <>
                        <div
                          style={{
                            display: 'flex',
                            justifyContent: 'flex-end',
                            marginBottom: 8,
                          }}>
                          <AiSuggestionLink
                            onClick={handleStartEditSuggested}
                            label="Edit"
                            disabled={!isGraphRunning}
                          />
                        </div>
                        <style>{DIFF_NO_LINE_NUMBERS_CSS}</style>
                        <div
                          className="diff2html-wrapper"
                          style={{
                            maxHeight: 360,
                            overflowY: 'auto',
                            overflowX: 'auto',
                            border: '1px solid #f0f0f0',
                            borderRadius: 6,
                          }}
                          dangerouslySetInnerHTML={{
                            __html: suggestionDiffHtml ?? '',
                          }}
                        />
                      </>
                    )
                  ) : aiSuggestionState.currentInstructions.trim() ? (
                    <div
                      style={{
                        maxHeight: 280,
                        overflowY: 'auto',
                      }}>
                      <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={{
                          p: (props) => (
                            <Typography.Paragraph
                              style={{ marginBottom: 8 }}
                              {...props}
                            />
                          ),
                          ul: (props) => (
                            <ul
                              style={{ paddingLeft: 20, marginBottom: 8 }}
                              {...props}
                            />
                          ),
                          ol: (props) => (
                            <ol
                              style={{ paddingLeft: 20, marginBottom: 8 }}
                              {...props}
                            />
                          ),
                          code: (props) => (
                            <Typography.Text
                              code
                              style={{
                                background: '#f5f5f5',
                                padding: '2px 4px',
                                borderRadius: 4,
                                fontSize: 12,
                              }}
                              {...props}
                            />
                          ),
                        }}>
                        {aiSuggestionState.currentInstructions}
                      </ReactMarkdown>
                    </div>
                  ) : (
                    <Text type="secondary">No content available.</Text>
                  )}
                </div>
              )}

              {shouldShowDiffOnly && (
                <div>
                  <Text strong style={{ display: 'block', marginBottom: 6 }}>
                    Suggested content
                  </Text>
                  {aiSuggestionState.isEditingSuggestion ? (
                    <Space direction="vertical" style={{ width: '100%' }}>
                      <Input.TextArea
                        value={
                          aiSuggestionState.editSuggestionDraft ??
                          aiSuggestionState.manualSuggestedOverride ??
                          aiSuggestionState.lastSuggestedInstructions ??
                          ''
                        }
                        onChange={(e) =>
                          setAiSuggestionState((prev) =>
                            prev
                              ? {
                                  ...prev,
                                  editSuggestionDraft: e.target.value,
                                }
                              : prev,
                          )
                        }
                        autoSize={{ minRows: 6, maxRows: 14 }}
                        style={{ fontFamily: 'monospace' }}
                      />
                      <Space>
                        <Button
                          onClick={handleCancelEditSuggested}
                          size="small">
                          Cancel
                        </Button>
                        <Button
                          type="primary"
                          size="small"
                          onClick={handleApplyEditSuggested}>
                          Apply
                        </Button>
                      </Space>
                    </Space>
                  ) : (
                    <>
                      <div
                        style={{
                          display: 'flex',
                          justifyContent: 'flex-end',
                          marginBottom: 8,
                        }}>
                        <AiSuggestionLink
                          onClick={handleStartEditSuggested}
                          label="Edit"
                          disabled={!isGraphRunning}
                        />
                      </div>
                      <style>{DIFF_NO_LINE_NUMBERS_CSS}</style>
                      <div
                        className="diff2html-wrapper"
                        style={{
                          maxHeight: 360,
                          overflowY: 'auto',
                          overflowX: 'auto',
                          border: '1px solid #f0f0f0',
                          borderRadius: 6,
                        }}
                        dangerouslySetInnerHTML={{
                          __html: suggestionDiffHtml ?? '',
                        }}
                      />
                    </>
                  )}
                </div>
              )}

              {isKnowledgeSuggestion && suggestionText ? (
                <div>
                  <Text strong style={{ display: 'block', marginBottom: 6 }}>
                    {suggestionSectionLabel}
                  </Text>
                  {aiSuggestionState.isEditingSuggestion ? (
                    <Space direction="vertical" style={{ width: '100%' }}>
                      <Input.TextArea
                        value={
                          aiSuggestionState.editSuggestionDraft ??
                          aiSuggestionState.manualSuggestedOverride ??
                          aiSuggestionState.lastSuggestedInstructions ??
                          ''
                        }
                        onChange={(e) =>
                          setAiSuggestionState((prev) =>
                            prev
                              ? {
                                  ...prev,
                                  editSuggestionDraft: e.target.value,
                                }
                              : prev,
                          )
                        }
                        autoSize={{ minRows: 6, maxRows: 14 }}
                        style={{ fontFamily: 'monospace' }}
                      />
                      <Space>
                        <Button
                          onClick={handleCancelEditSuggested}
                          size="small">
                          Cancel
                        </Button>
                        <Button
                          type="primary"
                          size="small"
                          onClick={handleApplyEditSuggested}>
                          Apply
                        </Button>
                      </Space>
                    </Space>
                  ) : (
                    <>
                      <div
                        style={{
                          display: 'flex',
                          justifyContent: 'flex-end',
                          marginBottom: 8,
                        }}>
                        <AiSuggestionLink
                          onClick={handleStartEditSuggested}
                          label="Edit"
                        />
                      </div>
                      <div
                        style={{
                          maxHeight: 360,
                          overflowY: 'auto',
                        }}>
                        <ReactMarkdown
                          remarkPlugins={[remarkGfm]}
                          components={{
                            p: (props) => (
                              <Typography.Paragraph
                                style={{ marginBottom: 8 }}
                                {...props}
                              />
                            ),
                            ul: (props) => (
                              <ul
                                style={{ paddingLeft: 20, marginBottom: 8 }}
                                {...props}
                              />
                            ),
                            ol: (props) => (
                              <ol
                                style={{ paddingLeft: 20, marginBottom: 8 }}
                                {...props}
                              />
                            ),
                            code: (props) => (
                              <Typography.Text
                                code
                                style={{
                                  background: '#f5f5f5',
                                  padding: '2px 4px',
                                  borderRadius: 4,
                                  fontSize: 12,
                                }}
                                {...props}
                              />
                            ),
                          }}>
                          {suggestionText}
                        </ReactMarkdown>
                      </div>
                    </>
                  )}
                </div>
              ) : null}

              <div>
                <Text strong style={{ display: 'block', marginBottom: 6 }}>
                  {requestPromptLabel}
                </Text>
                <Input.TextArea
                  value={aiSuggestionState.userRequest}
                  onChange={(e) =>
                    setAiSuggestionState((prev) =>
                      prev ? { ...prev, userRequest: e.target.value } : prev,
                    )
                  }
                  placeholder={requestPlaceholder}
                  autoSize={{ minRows: 3, maxRows: 6 }}
                />
                <div
                  style={{
                    marginTop: 8,
                    display: 'flex',
                    justifyContent: 'flex-end',
                  }}>
                  <Button
                    type="primary"
                    onClick={handleAiSuggestionSubmit}
                    loading={aiSuggestionState.loading}
                    disabled={
                      !isGraphRunning ||
                      aiSuggestionState.loading ||
                      !aiSuggestionState.userRequest.trim() ||
                      !graphId ||
                      !node?.id
                    }>
                    {sendButtonLabel}
                  </Button>
                </div>
              </div>

              {aiSuggestionState.suggestedInstructions && (
                <div
                  style={{
                    marginTop: 12,
                    display: 'flex',
                    justifyContent: 'flex-end',
                  }}>
                  <Space>
                    <Button onClick={closeAiSuggestionModal}>Close</Button>
                    <Button type="primary" onClick={handleApplyAiSuggestion}>
                      Apply to field
                    </Button>
                  </Space>
                </div>
              )}
            </Space>
          )}
        </Modal>

        <Modal
          open={instructionsVisible}
          title="Agent instructions"
          footer={null}
          onCancel={() => setInstructionsVisible(false)}
          destroyOnClose
          width={520}
          bodyStyle={{ maxHeight: 420, overflowY: 'auto' }}>
          {agentInstructionsText ? (
            <div
              style={{
                margin: 0,
                wordBreak: 'break-word',
                fontSize: 13,
                lineHeight: 1.6,
              }}>
              <ReactMarkdown
                remarkPlugins={[remarkGfm]}
                components={{
                  p: (props) => (
                    <Typography.Paragraph
                      style={{ marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  ul: (props) => (
                    <ul
                      style={{ paddingLeft: 20, marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  ol: (props) => (
                    <ol
                      style={{ paddingLeft: 20, marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  code: (props) => (
                    <Typography.Text
                      code
                      style={{
                        background: '#f5f5f5',
                        padding: '2px 4px',
                        borderRadius: 4,
                        fontSize: 12,
                      }}
                      {...props}
                    />
                  ),
                }}>
                {agentInstructionsText}
              </ReactMarkdown>
            </div>
          ) : (
            <Text type="secondary">No instructions available.</Text>
          )}
        </Modal>

        <Modal
          title="Edit Text"
          open={!!expandedTextarea}
          onCancel={handleExpandedTextareaSave}
          width={800}
          footer={[
            <Button key="cancel" onClick={handleExpandedTextareaSave}>
              Close
            </Button>,
            <Button
              key="save"
              type="primary"
              onClick={handleExpandedTextareaSave}>
              Save
            </Button>,
          ]}>
          {expandedTextarea && (
            <>
              <Input.TextArea
                value={expandedTextarea.value}
                onChange={(e) =>
                  setExpandedTextarea({
                    ...expandedTextarea,
                    value: e.target.value,
                  })
                }
                rows={20}
                style={{ fontFamily: 'monospace' }}
                placeholder="Enter your text here..."
              />
              {expandedTextareaField?.['x-ui:ai-suggestions'] === true && (
                <AiSuggestionLink
                  onClick={() =>
                    openAiSuggestionModal(
                      expandedTextarea.fieldKey,
                      expandedTextareaField?.name || expandedTextarea.fieldKey,
                      expandedTextarea.value,
                      aiSuggestionMode,
                    )
                  }
                  disabled={!isGraphRunning}
                  label={
                    aiSuggestionMode === 'knowledge'
                      ? 'Generate with AI'
                      : 'Improve with AI'
                  }
                />
              )}
            </>
          )}
        </Modal>
      </Sider>
    );
  },
  (prevProps, nextProps) => {
    const prevNodeData = prevProps.node?.data as unknown as GraphNodeData;
    const nextNodeData = nextProps.node?.data as unknown as GraphNodeData;

    const prevConfig = prevNodeData?.config;
    const nextConfig = nextNodeData?.config;
    const configEqual =
      JSON.stringify(prevConfig) === JSON.stringify(nextConfig);

    const messagesEqual =
      prevProps.messages === nextProps.messages &&
      prevProps.messages?.length === nextProps.messages?.length;
    const pendingEqual =
      prevProps.pendingMessages === nextProps.pendingMessages &&
      prevProps.pendingMessages?.length === nextProps.pendingMessages?.length;

    return (
      prevProps.visible === nextProps.visible &&
      prevProps.node?.id === nextProps.node?.id &&
      prevNodeData?.label === nextNodeData?.label &&
      prevNodeData?.template === nextNodeData?.template &&
      configEqual &&
      prevProps.graphStatus === nextProps.graphStatus &&
      prevProps.hasGlobalUnsavedChanges === nextProps.hasGlobalUnsavedChanges &&
      prevProps.selectedThreadId === nextProps.selectedThreadId &&
      prevProps.graphId === nextProps.graphId &&
      prevProps.compiledNodesLoading === nextProps.compiledNodesLoading &&
      prevProps.compiledNode?.status === nextProps.compiledNode?.status &&
      prevProps.compiledNode?.error === nextProps.compiledNode?.error &&
      prevProps.templates?.length === nextProps.templates?.length &&
      messagesEqual &&
      pendingEqual &&
      prevProps.messagesLoading === nextProps.messagesLoading &&
      prevProps.hasMoreMessages === nextProps.hasMoreMessages &&
      prevProps.loadingMoreMessages === nextProps.loadingMoreMessages &&
      prevProps.onLoadMoreMessages === nextProps.onLoadMoreMessages &&
      prevProps.onRefreshMessages === nextProps.onRefreshMessages &&
      prevProps.draftNodeConfigVersion === nextProps.draftNodeConfigVersion
    );
  },
);
