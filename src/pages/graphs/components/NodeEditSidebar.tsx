import React, {
  useEffect,
  useMemo,
  useState,
  useCallback,
  useRef,
} from 'react';
import {
  Button,
  Form,
  Input,
  InputNumber,
  Layout,
  message,
  Modal,
  Popover,
  Select,
  Space,
  Switch,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  CheckOutlined,
  CloseOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  ExpandOutlined,
  FileTextOutlined,
  InfoCircleOutlined,
  PlayCircleOutlined,
} from '@ant-design/icons';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import type {
  GraphNode,
  GraphNodeData,
  FormField,
  SchemaProperty,
} from '../types';
import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  LiteLlmModelDto,
  TemplateDto,
  ThreadMessageDto,
} from '../../../autogenerated';
import { litellmApi } from '../../../api';
import type { PendingMessage } from '../types/messages';
import { KeyValuePairsInput } from './KeyValuePairsInput';
import { NodeMessagesPanel } from './NodeMessagesPanel';
import { extractApiErrorMessage } from '../../../utils/errors';

const { Sider } = Layout;
const { Title, Text } = Typography;

interface NodeEditSidebarProps {
  node: GraphNode | null;
  visible: boolean;
  onClose: () => void;
  onSave: (
    nodeId: string,
    updates: { name?: string; config?: Record<string, unknown> },
  ) => void;
  templates: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  onTriggerClick?: (nodeId: string) => void;
  selectedThreadId?: string;
  compiledNode?: GraphNodeWithStatusDto;
  compiledNodesLoading?: boolean;
  messages?: ThreadMessageDto[];
  messagesLoading?: boolean;
  hasMoreMessages?: boolean;
  loadingMoreMessages?: boolean;
  pendingMessages?: PendingMessage[];
  onLoadMoreMessages?: () => void;
  onRefreshMessages?: () => void;
}

export const NodeEditSidebar = React.memo(
  ({
    node,
    visible,
    onClose,
    onSave,
    templates,
    graphStatus,
    onTriggerClick,
    selectedThreadId,
    compiledNode,
    compiledNodesLoading,
    messages = [],
    messagesLoading = false,
    hasMoreMessages = true,
    loadingMoreMessages = false,
    pendingMessages = [],
    onLoadMoreMessages,
    onRefreshMessages,
  }: NodeEditSidebarProps) => {
    const [form] = Form.useForm();
    const [nodeName, setNodeName] = useState('');
    const [isEditingName, setIsEditingName] = useState(false);
    const [editingName, setEditingName] = useState('');
    const [formFields, setFormFields] = useState<FormField[]>([]);
    const [expandedTextarea, setExpandedTextarea] = useState<{
      fieldKey: string;
      value: string;
    } | null>(null);
    const [initialFormValues, setInitialFormValues] = useState<
      Record<string, unknown>
    >({});
    const [activeTab, setActiveTab] = useState('options');
    const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
    const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);
    const saveTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

    const hasLiteLlmSelectField = useMemo(
      () =>
        formFields.some(
          (field) => field['x-ui:litellm-models-list-select'] === true,
        ),
      [formFields],
    );

    const nodeData = node?.data as unknown as GraphNodeData;
    const templateKindLower = (nodeData?.templateKind || '').toLowerCase();
    const isAgentNode = templateKindLower === 'simpleagent';
    const isGraphRunning = graphStatus === GraphDtoStatusEnum.Running;
    const showNodeStatus = ['runtime', 'simpleagent', 'trigger'].includes(
      templateKindLower,
    );
    const [instructionsVisible, setInstructionsVisible] = useState(false);
    const agentInstructionsText = useMemo(() => {
      const instructions = compiledNode?.additionalNodeMetadata?.instructions;
      if (instructions === undefined || instructions === null) {
        return '';
      }
      if (typeof instructions === 'string') {
        return instructions;
      }
      if (Array.isArray(instructions)) {
        return instructions.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(instructions, null, 2);
      } catch {
        return String(instructions);
      }
    }, [compiledNode?.additionalNodeMetadata?.instructions]);
    const instructionsAvailable = Boolean(agentInstructionsText);
    const instructionsButtonDisabled =
      !isGraphRunning || compiledNodesLoading || !instructionsAvailable;
    const instructionsTooltip = !isGraphRunning
      ? 'Start the graph to view live instructions'
      : compiledNodesLoading
        ? 'Loading instructions...'
        : instructionsAvailable
          ? 'View current agent instructions'
          : 'Instructions are not available for this node yet';

    const statusTagColorMap: Record<string, string> = {
      running: 'green',
      idle: 'blue',
      starting: 'geekblue',
      stopped: 'red',
    };

    const rawStatus = compiledNode?.status;

    const statusLabel = !isGraphRunning
      ? 'Not running'
      : compiledNodesLoading
        ? 'Loading...'
        : rawStatus
          ? `${rawStatus.charAt(0).toUpperCase()}${rawStatus.slice(1)}`
          : 'Unknown';

    const statusTagColor = !isGraphRunning
      ? 'default'
      : compiledNodesLoading
        ? 'geekblue'
        : statusTagColorMap[rawStatus ?? ''] || 'default';

    const normalizeJsonViewValue = (value: unknown): object | undefined => {
      if (value === undefined) {
        return undefined;
      }
      if (value !== null && typeof value === 'object') {
        return value as object;
      }
      return { value } as Record<string, unknown>;
    };

    const metadataJsonValue = normalizeJsonViewValue(compiledNode?.metadata);
    const configJsonValue = normalizeJsonViewValue(compiledNode?.config);
    const hasInfoData = Boolean(metadataJsonValue || configJsonValue);

    const infoContent = (
      <div style={{ maxWidth: 360 }}>
        {compiledNodesLoading && (
          <Text
            type="secondary"
            style={{
              display: 'block',
              marginBottom: hasInfoData ? 8 : 0,
            }}>
            Loading latest node information...
          </Text>
        )}
        {metadataJsonValue && (
          <div style={{ marginBottom: configJsonValue ? 16 : 0 }}>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Metadata
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView
                value={metadataJsonValue as object}
                style={lightTheme}
              />
            </div>
          </div>
        )}
        {configJsonValue && (
          <div>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Configuration
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView value={configJsonValue as object} style={lightTheme} />
            </div>
          </div>
        )}
        {!compiledNodesLoading && !hasInfoData && (
          <Text type="secondary">No metadata or configuration available.</Text>
        )}
      </div>
    );

    useEffect(() => {
      return () => {
        if (saveTimeoutRef.current) {
          clearTimeout(saveTimeoutRef.current);
        }
      };
    }, []);

    useEffect(() => {
      if (!hasLiteLlmSelectField) {
        return;
      }
      if (liteLlmModels.length > 0) {
        return;
      }

      let isActive = true;

      const fetchLiteLlmModels = async () => {
        try {
          setLitellmModelsLoading(true);
          const response = await litellmApi.listModels();
          if (!isActive) {
            return;
          }
          setLiteLlmModels(response.data ?? []);
        } catch (error) {
          if (!isActive) {
            return;
          }
          console.error('Failed to load LiteLLM models:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load LiteLLM models',
        );
        message.error(errorMessage);
        } finally {
          if (isActive) {
            setLitellmModelsLoading(false);
          }
        }
      };

      fetchLiteLlmModels();

      return () => {
        isActive = false;
      };
    }, [hasLiteLlmSelectField, liteLlmModels.length]);

    useEffect(() => {
      if (!node) {
        form.resetFields();
        setFormFields([]);
        setInitialFormValues({});
        return;
      }

      const currentNodeData = node.data as unknown as GraphNodeData;
      const currentNodeIsAgent =
        currentNodeData?.templateKind === 'simpleAgent';
      const availableTabs = ['options'];
      if (currentNodeIsAgent) {
        availableTabs.push('messages');
      }

      if (!availableTabs.includes(activeTab)) {
        setActiveTab('options');
      }

      const template = templates.find((t) => t.id === currentNodeData.template);

      if (template?.schema?.properties) {
        const fields: FormField[] = [];
        Object.entries(template.schema.properties).forEach(([key, prop]) => {
          const typedProp = prop as SchemaProperty;
          const isConst = typedProp.const !== undefined;
          const isObject =
            typedProp.type === 'object' && typedProp.additionalProperties;

          fields.push({
            ...typedProp,
            key,
            name: typedProp.title || key,
            description: typedProp.description,
            type: isObject ? 'object' : typedProp.type || 'string',
            required: template.schema.required?.includes(key) || false,
            default: typedProp.default,
            const: typedProp.const,
            enum: typedProp.enum,
            isConst,
            isObject,
          });
        });

        setFormFields(fields);

        const initialValues: Record<string, unknown> = {};
        fields.forEach((field) => {
          if (field.isConst) {
            initialValues[field.key] = field.const;
          } else {
            initialValues[field.key] =
              (currentNodeData.config as Record<string, unknown>)?.[
                field.key
              ] ??
              field.default ??
              '';
          }
        });

        form.resetFields();
        form.setFieldsValue(initialValues);
        const currentValuesNow = form.getFieldsValue(true);
        setInitialFormValues(currentValuesNow);
      } else {
        setFormFields([]);
        form.resetFields();
        setInitialFormValues({});
      }

      const label = (currentNodeData.label as string) || '';
      setNodeName(label);
      setEditingName(label);
    }, [node?.id, templates, form, node, activeTab]);

    const autoSaveNodeChanges = useCallback(async () => {
      if (!node) return;

      try {
        const configValues: Record<string, unknown> = {};

        formFields.forEach((field) => {
          const key = field.key;

          if (field.isConst) {
            configValues[key] = field.const as unknown;
            return;
          }

          const rawValue = form.getFieldValue(key);

          const isEmptyString =
            typeof rawValue === 'string' && rawValue.trim() === '';
          const isEmptyArray = Array.isArray(rawValue) && rawValue.length === 0;
          const isEmptyObject =
            field.type === 'object' &&
            rawValue &&
            typeof rawValue === 'object' &&
            !Array.isArray(rawValue) &&
            Object.keys(rawValue as object).length === 0;

          const isTrulyEmpty =
            rawValue === null ||
            rawValue === undefined ||
            isEmptyString ||
            isEmptyArray ||
            isEmptyObject;

          if (isTrulyEmpty && field.type !== 'boolean') {
            return;
          }

          let processedValue: unknown = rawValue;

          switch (field.type) {
            case 'number':
            case 'integer': {
              if (typeof rawValue === 'string') {
                const num = Number(rawValue);
                if (Number.isNaN(num)) {
                  return;
                }
                processedValue =
                  field.type === 'integer' ? Math.trunc(num) : num;
              } else if (typeof rawValue === 'number') {
                processedValue =
                  field.type === 'integer' ? Math.trunc(rawValue) : rawValue;
              } else {
                return;
              }
              break;
            }
            case 'array': {
              if (typeof rawValue === 'string') {
                processedValue = rawValue
                  .split('\n')
                  .map((line) => line.trim())
                  .filter((line) => line !== '');
              } else if (Array.isArray(rawValue)) {
                processedValue = rawValue;
              } else if (rawValue == null) {
                return;
              }
              break;
            }
            case 'object': {
              if (typeof rawValue === 'string') {
                try {
                  const parsed = JSON.parse(rawValue);
                  processedValue = parsed;
                } catch {
                  return;
                }
              } else if (
                rawValue &&
                typeof rawValue === 'object' &&
                !Array.isArray(rawValue)
              ) {
                processedValue = rawValue;
              } else if (rawValue == null) {
                return;
              }
              break;
            }
            case 'boolean': {
              processedValue = Boolean(rawValue);
              break;
            }
            case 'string':
            default: {
              if (typeof rawValue === 'string') {
                const trimmed = rawValue.trim();
                if (trimmed === '') {
                  return;
                }
                processedValue = trimmed;
              } else {
                processedValue = rawValue;
              }
            }
          }

          configValues[key] = processedValue;
        });

        onSave(node.id, {
          name: nodeName,
          config: configValues,
        });

        const currentValues = form.getFieldsValue(true);
        setInitialFormValues(currentValues);
      } catch (error) {
        console.error('Auto-save failed:', error);
      }
    }, [node, nodeName, formFields, form, onSave]);

    const handleFormChange = useCallback(
      (
        changedValues: Record<string, unknown>,
        allValues: Record<string, unknown>,
      ) => {
        const hasRealChanges = Object.keys(changedValues).some((key) => {
          const currentValue = allValues[key];
          const initialValue = initialFormValues[key];
          return JSON.stringify(currentValue) !== JSON.stringify(initialValue);
        });

        if (!hasRealChanges) {
          return;
        }

        if (saveTimeoutRef.current) {
          clearTimeout(saveTimeoutRef.current);
        }

        saveTimeoutRef.current = setTimeout(() => {
          autoSaveNodeChanges();
        }, 500);
      },
      [initialFormValues, autoSaveNodeChanges],
    );

    const handleClose = useCallback(() => {
      onClose();
    }, [onClose]);

    const handleNameEdit = () => {
      setIsEditingName(true);
      setEditingName(nodeName);
    };

    const handleNameSave = () => {
      if (editingName !== nodeName) {
        setNodeName(editingName);
        if (node) {
          onSave(node.id, {
            name: editingName,
          });
        }
      }
      setIsEditingName(false);
    };

    const handleNameCancel = () => {
      setEditingName(nodeName);
      setIsEditingName(false);
    };

    const renderFormField = (field: FormField) => {
      const {
        key,
        name,
        description,
        type,
        required,
        isConst,
        const: constValue,
        enum: enumValues,
      } = field;

      const rules = required
        ? [{ required: true, message: `${name} is required` }]
        : undefined;

      const descriptionNode = description ? (
        <Text
          type="secondary"
          style={{
            fontSize: 12,
            fontWeight: 'normal',
          }}>
          {description}
        </Text>
      ) : undefined;

      const commonProps = {
        name: key,
        label: name,
        required,
        rules,
        extra: descriptionNode,
        style: {
          marginBottom: '10px',
        },
      } as const;

      if (isConst) {
        return (
          <Form.Item key={key} {...commonProps} initialValue={constValue}>
            <Input disabled size="middle" value={String(constValue)} />
          </Form.Item>
        );
      }

      const shouldUseLiteLlmModelsSelect =
        (field as SchemaProperty)['x-ui:litellm-models-list-select'] === true;

      if (shouldUseLiteLlmModelsSelect) {
        return (
          <Form.Item key={key} {...commonProps}>
            <Select
              placeholder={`Select ${name.toLowerCase()}`}
              size="middle"
              allowClear={!required}
              showSearch
              loading={litellmModelsLoading}
              notFoundContent={
                litellmModelsLoading
                  ? 'Loading models...'
                  : 'No models available'
              }
              filterOption={(input, option) =>
                (option?.label ?? '')
                  .toString()
                  .toLowerCase()
                  .includes(input.toLowerCase())
              }
              options={liteLlmModels.map((model) => ({
                label: model.ownedBy
                  ? `${model.id} (${model.ownedBy})`
                  : model.id,
                value: model.id,
              }))}
            />
          </Form.Item>
        );
      }

      if (enumValues && Array.isArray(enumValues) && enumValues.length > 0) {
        return (
          <Form.Item key={key} {...commonProps}>
            <Select
              placeholder={`Select ${name.toLowerCase()}`}
              size="middle"
              allowClear={!required}
              showSearch
              filterOption={(input, option) =>
                (option?.label ?? '')
                  .toString()
                  .toLowerCase()
                  .includes(input.toLowerCase())
              }
              options={enumValues.map((value) => ({
                label: String(value),
                value: value,
              }))}
            />
          </Form.Item>
        );
      }

      const shouldUseTextarea =
        (field as SchemaProperty)['x-ui:textarea'] === true;

      switch (type) {
        case 'string':
          if (shouldUseTextarea) {
            return (
              <Form.Item
                key={key}
                label={name}
                required={required}
                rules={rules}
                extra={descriptionNode}
                style={{ marginBottom: '10px' }}>
                <div style={{ position: 'relative' }}>
                  <Form.Item name={key} noStyle>
                    <Input.TextArea
                      placeholder={`Enter ${name.toLowerCase()}`}
                      rows={4}
                      size="middle"
                      style={{ paddingRight: '32px' }}
                    />
                  </Form.Item>
                  <Button
                    type="text"
                    icon={<ExpandOutlined />}
                    size="small"
                    style={{
                      position: 'absolute',
                      right: '4px',
                      top: '4px',
                      zIndex: 1,
                    }}
                    onClick={() => {
                      const currentValue = form.getFieldValue(key) || '';
                      setExpandedTextarea({
                        fieldKey: key,
                        value: currentValue,
                      });
                    }}
                  />
                </div>
              </Form.Item>
            );
          }

          return (
            <Form.Item key={key} {...commonProps}>
              <Input
                placeholder={`Enter ${name.toLowerCase()}`}
                size="middle"
              />
            </Form.Item>
          );

        case 'number':
          return (
            <Form.Item key={key} {...commonProps}>
              <InputNumber
                style={{ width: '100%' }}
                placeholder={`Enter ${name.toLowerCase()}`}
                size="middle"
              />
            </Form.Item>
          );

        case 'boolean':
          return (
            <Form.Item key={key} {...commonProps} valuePropName="checked">
              <Switch />
            </Form.Item>
          );

        case 'array':
          return (
            <Form.Item key={key} {...commonProps}>
              <Input.TextArea
                placeholder={`Enter ${name.toLowerCase()} (one per line)`}
                rows={3}
                size="middle"
              />
            </Form.Item>
          );

        case 'object':
          return (
            <Form.Item key={key} {...commonProps}>
              <KeyValuePairsInput />
            </Form.Item>
          );

        default:
          return (
            <Form.Item key={key} {...commonProps}>
              <Input
                placeholder={`Enter ${name.toLowerCase()}`}
                size="middle"
              />
            </Form.Item>
          );
      }
    };

    const isTriggerNode = nodeData?.templateKind === 'trigger';
    const canTrigger = isTriggerNode && isGraphRunning;

    const renderOptionsTabContent = () => {
      return (
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
          }}>
          <div
            style={{
              flexShrink: 0,
              padding: '8px 4px 0 4px',
            }}>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: 8,
              }}>
              <Title level={5} style={{ margin: 0 }}>
                Configuration
              </Title>
            </div>
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'auto',
              padding: '0 4px 8px 4px',
            }}>
            {formFields.length > 0 ? (
              <Form
                form={form}
                layout="vertical"
                size="small"
                style={{ marginTop: 0 }}
                labelCol={{ style: { paddingBottom: 4 } }}
                onValuesChange={handleFormChange}>
                {formFields.map(renderFormField)}
              </Form>
            ) : (
              <Text type="secondary">
                No configuration options available for this template.
              </Text>
            )}
          </div>
        </div>
      );
    };

    const newMessageMode = useMemo(() => {
      return (compiledNode?.config as Record<string, unknown>)
        ?.newMessageMode as
        | 'inject_after_tool_call'
        | 'wait_for_completion'
        | undefined;
    }, [compiledNode?.config]);

    const renderMessagesTabContent = useCallback(() => {
      const isNodeRunning =
        isGraphRunning &&
        (typeof compiledNode?.status === 'string'
          ? compiledNode.status.toLowerCase() === 'running'
          : true);

      return (
        <NodeMessagesPanel
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={selectedThreadId}
          nodeId={node?.id}
          nodeTemplateKind={nodeData?.templateKind}
          onLoadMoreMessages={onLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMoreMessages={loadingMoreMessages}
          isNodeRunning={isNodeRunning}
          pendingMessages={pendingMessages}
          newMessageMode={newMessageMode}
          onRefreshMessages={onRefreshMessages}
        />
      );
    }, [
      compiledNode?.status,
      hasMoreMessages,
      isGraphRunning,
      loadingMoreMessages,
      messages,
      messagesLoading,
      newMessageMode,
      node?.id,
      nodeData?.templateKind,
      onLoadMoreMessages,
      onRefreshMessages,
      pendingMessages,
      selectedThreadId,
    ]);

    const tabItems = isAgentNode
      ? [
          { key: 'options', label: 'Options' },
          { key: 'messages', label: 'Messages' },
        ]
      : [{ key: 'options', label: 'Options' }];

    if (!visible) {
      // Keep the form instance connected to a Form element to avoid antd warnings
      return <Form form={form} style={{ display: 'none' }} />;
    }

    return (
      <Sider
        width={400}
        style={{
          background: '#fff',
          borderLeft: '1px solid #f0f0f0',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
        }}>
        <div
          style={{
            padding: '16px',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            minHeight: 0,
          }}>
          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: 16,
              paddingBottom: 16,
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <Title level={4} style={{ margin: 0 }}>
              Edit Node
            </Title>
            <Space>
              {isTriggerNode && (
                <Button
                  type="primary"
                  icon={<PlayCircleOutlined />}
                  disabled={!canTrigger}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onTriggerClick?.(node?.id || '');
                  }}
                  size="small">
                  Trigger
                </Button>
              )}
              <Button
                onClick={handleClose}
                icon={<CloseOutlined />}
                size="small"></Button>
            </Space>
          </div>

          <div style={{ flexShrink: 0, marginBottom: 16 }}>
            {isEditingName ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Input
                  value={editingName}
                  onChange={(e) => setEditingName(e.target.value)}
                  onPressEnter={handleNameSave}
                  onBlur={handleNameSave}
                  autoFocus
                  style={{ flex: 1 }}
                />
                <Button
                  type="text"
                  icon={<CheckOutlined />}
                  onClick={handleNameSave}
                  size="small"
                />
                <Button
                  type="text"
                  icon={<CloseOutlined />}
                  onClick={handleNameCancel}
                  size="small"
                />
              </div>
            ) : (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 4,
                }}>
                <Text
                  strong
                  style={{
                    flex: 1,
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    display: 'block',
                  }}>
                  {nodeName}
                </Text>
                {isAgentNode && (
                  <Tooltip title={instructionsTooltip} placement="bottom">
                    <Button
                      type="text"
                      size="small"
                      icon={<FileTextOutlined />}
                      disabled={instructionsButtonDisabled}
                      onClick={() => setInstructionsVisible(true)}
                      aria-label="View agent instructions"
                    />
                  </Tooltip>
                )}
                <Popover
                  content={infoContent}
                  trigger="click"
                  placement="bottomRight">
                  <Button
                    type="text"
                    size="small"
                    icon={<InfoCircleOutlined />}
                    aria-label="View node metadata and configuration"
                  />
                </Popover>
                <Button
                  type="text"
                  icon={<EditOutlined />}
                  onClick={handleNameEdit}
                  size="small"
                />
              </div>
            )}

            <div
              style={{
                fontSize: '11px',
                color: '#bfbfbf',
              }}>
              {nodeData?.template} ({nodeData?.templateKind})
            </div>
            {showNodeStatus && (
              <div
                style={{
                  marginTop: 8,
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                  flexWrap: 'wrap',
                }}>
                <Space size={2} wrap align="center">
                  <Tag
                    color={statusTagColor}
                    style={{ margin: 0, fontSize: 12 }}
                    bordered={statusTagColor === 'default'}>
                    {statusLabel}
                  </Tag>
                  {compiledNode?.error && (
                    <Tooltip title={compiledNode.error} placement="top">
                      <ExclamationCircleOutlined
                        style={{ color: '#ff4d4f', fontSize: 14 }}
                      />
                    </Tooltip>
                  )}
                </Space>
              </div>
            )}
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'hidden',
              display: 'flex',
              flexDirection: 'column',
            }}>
            {tabItems.length > 1 && (
              <div
                style={{
                  flexShrink: 0,
                  display: 'flex',
                }}>
                <div
                  role="tablist"
                  aria-label="Node editor tabs"
                  style={{
                    background: '#f2f2f7',
                    borderRadius: 999,
                    padding: 4,
                    display: 'flex',
                    gap: 6,
                    width: '100%',
                  }}>
                  {tabItems.map((tab, index) => {
                    const isActive = activeTab === tab.key;
                    return (
                      <button
                        key={tab.key}
                        role="tab"
                        aria-selected={isActive}
                        onClick={() => setActiveTab(tab.key)}
                        onKeyDown={(event) => {
                          if (event.key === 'ArrowRight') {
                            event.preventDefault();
                            const nextKey =
                              tabItems[(index + 1) % tabItems.length]?.key ??
                              tab.key;
                            setActiveTab(nextKey);
                          } else if (event.key === 'ArrowLeft') {
                            event.preventDefault();
                            const prevKey =
                              tabItems[
                                (index - 1 + tabItems.length) % tabItems.length
                              ]?.key ?? tab.key;
                            setActiveTab(prevKey);
                          }
                        }}
                        style={{
                          border: 'none',
                          background: isActive ? '#ffffff' : 'transparent',
                          padding: '4px 0',
                          borderRadius: 999,
                          fontWeight: 600,
                          fontSize: 13,
                          color: isActive ? '#111' : '#555',
                          cursor: 'pointer',
                          transition: 'all 0.2s ease',
                          flex: 1,
                        }}>
                        {tab.label}
                      </button>
                    );
                  })}
                </div>
              </div>
            )}

            <div
              style={{
                flex: 1,
                minHeight: 0,
                overflow: 'hidden',
                display: 'flex',
                flexDirection: 'column',
              }}>
              {activeTab === 'options'
                ? renderOptionsTabContent()
                : renderMessagesTabContent()}
            </div>
          </div>
        </div>

        <Modal
          open={instructionsVisible}
          title="Agent instructions"
          footer={null}
          onCancel={() => setInstructionsVisible(false)}
          destroyOnClose
          width={520}
          bodyStyle={{ maxHeight: 420, overflowY: 'auto' }}>
          {agentInstructionsText ? (
            <div
              style={{
                margin: 0,
                wordBreak: 'break-word',
                fontSize: 13,
                lineHeight: 1.6,
              }}>
              <ReactMarkdown
                remarkPlugins={[remarkGfm]}
                components={{
                  p: (props) => (
                    <Typography.Paragraph
                      style={{ marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  ul: (props) => (
                    <ul
                      style={{ paddingLeft: 20, marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  ol: (props) => (
                    <ol
                      style={{ paddingLeft: 20, marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  code: (props) => (
                    <Typography.Text
                      code
                      style={{
                        background: '#f5f5f5',
                        padding: '2px 4px',
                        borderRadius: 4,
                        fontSize: 12,
                      }}
                      {...props}
                    />
                  ),
                }}>
                {agentInstructionsText}
              </ReactMarkdown>
            </div>
          ) : (
            <Text type="secondary">No instructions available.</Text>
          )}
        </Modal>

        <Modal
          title="Edit Text"
          open={!!expandedTextarea}
          onCancel={() => setExpandedTextarea(null)}
          width={800}
          footer={[
            <Button key="cancel" onClick={() => setExpandedTextarea(null)}>
              Cancel
            </Button>,
            <Button
              key="save"
              type="primary"
              onClick={() => {
                if (expandedTextarea) {
                  form.setFieldValue(
                    expandedTextarea.fieldKey,
                    expandedTextarea.value,
                  );
                  autoSaveNodeChanges();
                  setExpandedTextarea(null);
                }
              }}>
              Save
            </Button>,
          ]}>
          {expandedTextarea && (
            <Input.TextArea
              value={expandedTextarea.value}
              onChange={(e) =>
                setExpandedTextarea({
                  ...expandedTextarea,
                  value: e.target.value,
                })
              }
              rows={20}
              style={{ fontFamily: 'monospace' }}
              placeholder="Enter your text here..."
            />
          )}
        </Modal>
      </Sider>
    );
  },
  (prevProps, nextProps) => {
    const prevNodeData = prevProps.node?.data as unknown as GraphNodeData;
    const nextNodeData = nextProps.node?.data as unknown as GraphNodeData;

    const prevConfig = prevNodeData?.config;
    const nextConfig = nextNodeData?.config;
    const configEqual =
      JSON.stringify(prevConfig) === JSON.stringify(nextConfig);

    const messagesEqual =
      prevProps.messages === nextProps.messages &&
      prevProps.messages?.length === nextProps.messages?.length;
    const pendingEqual =
      prevProps.pendingMessages === nextProps.pendingMessages &&
      prevProps.pendingMessages?.length ===
        nextProps.pendingMessages?.length;

    return (
      prevProps.visible === nextProps.visible &&
      prevProps.node?.id === nextProps.node?.id &&
      prevNodeData?.label === nextNodeData?.label &&
      prevNodeData?.template === nextNodeData?.template &&
      configEqual &&
      prevProps.graphStatus === nextProps.graphStatus &&
      prevProps.selectedThreadId === nextProps.selectedThreadId &&
      prevProps.compiledNodesLoading === nextProps.compiledNodesLoading &&
      prevProps.compiledNode?.status === nextProps.compiledNode?.status &&
      prevProps.compiledNode?.error === nextProps.compiledNode?.error &&
      prevProps.templates?.length === nextProps.templates?.length &&
      messagesEqual &&
      pendingEqual &&
      prevProps.messagesLoading === nextProps.messagesLoading &&
      prevProps.hasMoreMessages === nextProps.hasMoreMessages &&
      prevProps.loadingMoreMessages === nextProps.loadingMoreMessages &&
      prevProps.onLoadMoreMessages === nextProps.onLoadMoreMessages &&
      prevProps.onRefreshMessages === nextProps.onRefreshMessages
    );
  },
);
