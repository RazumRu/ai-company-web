import { useEffect, useState } from 'react';
import {
  Button,
  Card,
  Divider,
  Form,
  Input,
  InputNumber,
  Layout,
  message,
  Modal,
  Space,
  Switch,
  Typography,
} from 'antd';
import {
  CheckOutlined,
  CloseOutlined,
  DeleteOutlined,
  EditOutlined,
  ExpandOutlined,
  PlusOutlined,
  SaveOutlined,
} from '@ant-design/icons';
import type {
  GraphNode,
  GraphNodeData,
  FormField,
  KeyValuePair,
  SchemaProperty,
} from '../types';
import type { TemplateDto } from '../../../autogenerated';

const { Sider } = Layout;
const { Title, Text } = Typography;

interface NodeEditSidebarProps {
  node: GraphNode | null;
  visible: boolean;
  onClose: () => void;
  onSave: (
    nodeId: string,
    updates: { name?: string; config?: Record<string, unknown> },
  ) => void;
  templates: TemplateDto[];
}

const KeyValuePairsInput = ({
  value,
  onChange,
}: {
  value?: KeyValuePair[];
  onChange?: (value: KeyValuePair[]) => void;
}) => {
  const [pairs, setPairs] = useState<KeyValuePair[]>(value || []);

  useEffect(() => {
    if (value) {
      setPairs(value);
    }
  }, [value]);

  const addPair = () => {
    const newPairs = [...pairs, { key: '', value: '' }];
    setPairs(newPairs);
    onChange?.(newPairs);
  };

  const removePair = (index: number) => {
    const newPairs = pairs.filter((_, i) => i !== index);
    setPairs(newPairs);
    onChange?.(newPairs);
  };

  const updatePair = (
    index: number,
    field: 'key' | 'value',
    newValue: string,
  ) => {
    const newPairs = pairs.map((pair, i) =>
      i === index ? { ...pair, [field]: newValue } : pair,
    );
    setPairs(newPairs);
    onChange?.(newPairs);
  };

  return (
    <div>
      {pairs.map((pair, index) => (
        <Card
          key={index}
          size="small"
          style={{
            marginBottom: 8,
            border: '1px solid #d9d9d9',
            borderRadius: 6,
          }}
          styles={{ body: { padding: 8 } }}>
          <Space.Compact style={{ width: '100%' }}>
            <Input
              placeholder="Key"
              value={pair.key}
              onChange={(e) => updatePair(index, 'key', e.target.value)}
              style={{ flex: 1 }}
            />
            <Input
              placeholder="Value"
              value={pair.value}
              onChange={(e) => updatePair(index, 'value', e.target.value)}
              style={{ flex: 1 }}
            />
            <Button
              type="text"
              danger
              icon={<DeleteOutlined />}
              onClick={() => removePair(index)}
            />
          </Space.Compact>
        </Card>
      ))}
      <Button
        type="dashed"
        onClick={addPair}
        icon={<PlusOutlined />}
        style={{
          width: '100%',
          borderStyle: 'dashed',
          borderColor: '#d9d9d9',
          color: '#666',
        }}
        size="middle">
        Add Key-Value Pair
      </Button>
    </div>
  );
};

export const NodeEditSidebar = ({
  node,
  visible,
  onClose,
  onSave,
  templates,
}: NodeEditSidebarProps) => {
  const [form] = Form.useForm();
  const [nodeName, setNodeName] = useState('');
  const [isEditingName, setIsEditingName] = useState(false);
  const [editingName, setEditingName] = useState('');
  const [formFields, setFormFields] = useState<FormField[]>([]);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [showCloseConfirm, setShowCloseConfirm] = useState(false);
  const [expandedTextarea, setExpandedTextarea] = useState<{
    fieldKey: string;
    value: string;
  } | null>(null);
  const [initialFormValues, setInitialFormValues] = useState<
    Record<string, unknown>
  >({});

  useEffect(() => {
    if (node) {
      const nodeData = node.data;
      setNodeName((nodeData.label as string) || '');
      setEditingName((nodeData.label as string) || '');

      // Find template from passed templates
      const template = templates.find((t) => t.name === nodeData.template);

      if (template?.schema?.properties) {
        const fields: FormField[] = [];
        Object.entries(template.schema.properties).forEach(([key, prop]) => {
          const typedProp = prop as SchemaProperty;
          const isConst = typedProp.const !== undefined;
          const isObject =
            typedProp.type === 'object' && typedProp.additionalProperties;

          fields.push({
            ...typedProp,
            key,
            name: typedProp.title || key,
            description: typedProp.description,
            type: isObject ? 'object' : typedProp.type || 'string',
            required: template.schema.required?.includes(key) || false,
            default: typedProp.default,
            const: typedProp.const,
            isConst,
            isObject,
          });
        });

        setFormFields(fields);

        // Set initial form values
        const initialValues: Record<string, unknown> = {};
        fields.forEach((field) => {
          if (field.isConst) {
            initialValues[field.key] = field.const;
          } else {
            initialValues[field.key] =
              (nodeData.config as Record<string, unknown>)?.[field.key] ??
              field.default ??
              '';
          }
        });

        // Reset form and set values
        form.resetFields();
        form.setFieldsValue(initialValues);
      } else {
        setFormFields([]);
      }

      // Store initial form values for comparison
      const initialValues = form.getFieldsValue(true);
      setInitialFormValues(initialValues);

      // Reset unsaved changes when node changes
      setHasUnsavedChanges(false);
    }
  }, [node, form, templates]);

  // Track form changes to detect unsaved changes
  const handleFormChange = (
    changedValues: Record<string, unknown>,
    allValues: Record<string, unknown>,
  ) => {
    // Compare current values with initial values to detect real changes
    const hasRealChanges = Object.keys(changedValues).some((key) => {
      const currentValue = allValues[key];
      const initialValue = initialFormValues[key];
      return JSON.stringify(currentValue) !== JSON.stringify(initialValue);
    });

    if (hasRealChanges) {
      setHasUnsavedChanges(true);
    }
  };

  const handleSave = async () => {
    try {
      await form.validateFields();
      const values = form.getFieldsValue(true);

      if (node) {
        const configValues: Record<string, unknown> = {};
        Object.entries(values).forEach(([key, value]) => {
          const field = formFields.find((f) => f.key === key);
          if (!field?.isConst) {
            configValues[key] = value;
          }
        });

        onSave(node.id, {
          name: nodeName,
          config: configValues,
        });

        // Update initial values to current values after successful save
        const currentValues = form.getFieldsValue(true);
        setInitialFormValues(currentValues);
        setHasUnsavedChanges(false);
        message.success('Node updated successfully');
      }
    } catch (error) {
      console.error('Form validation failed:', error);
    }
  };

  const handleClose = () => {
    if (hasUnsavedChanges) {
      setShowCloseConfirm(true);
    } else {
      onClose();
    }
  };

  const handleCloseConfirm = () => {
    setShowCloseConfirm(false);
    setHasUnsavedChanges(false);
    onClose();
  };

  const handleSaveAndClose = async () => {
    try {
      await handleSave();
      setShowCloseConfirm(false);
      onClose();
    } catch (error) {
      console.error('Failed to save before closing:', error);
    }
  };

  const handleCloseCancel = () => {
    setShowCloseConfirm(false);
  };

  const handleNameEdit = () => {
    setIsEditingName(true);
    setEditingName(nodeName);
  };

  const handleNameSave = () => {
    if (editingName !== nodeName) {
      setHasUnsavedChanges(true);
    }
    setNodeName(editingName);
    setIsEditingName(false);
  };

  const handleNameCancel = () => {
    setEditingName(nodeName);
    setIsEditingName(false);
  };

  const renderFormField = (field: FormField) => {
    const {
      key,
      name,
      description,
      type,
      required,
      isConst,
      const: constValue,
    } = field;

    const rules = required
      ? [{ required: true, message: `${name} is required` }]
      : undefined;

    const descriptionNode = description ? (
      <Text
        type="secondary"
        style={{
          fontSize: 12,
          fontWeight: 'normal',
        }}>
        {description}
      </Text>
    ) : undefined;

    const commonProps = {
      name: key,
      label: name,
      required,
      rules,
      extra: descriptionNode,
      style: {
        marginBottom: '20px',
      },
    } as const;

    if (isConst) {
      return (
        <Form.Item key={key} {...commonProps} initialValue={constValue}>
          <Input disabled size="middle" value={String(constValue)} />
        </Form.Item>
      );
    }

    const shouldUseTextarea =
      (field as SchemaProperty)['x-ui:textarea'] === true;

    switch (type) {
      case 'string':
        if (shouldUseTextarea) {
          return (
            <Form.Item
              key={key}
              label={name}
              required={required}
              rules={rules}
              extra={descriptionNode}
              style={{ marginBottom: '20px' }}>
              <div style={{ position: 'relative' }}>
                <Form.Item name={key} noStyle>
                  <Input.TextArea
                    placeholder={`Enter ${name.toLowerCase()}`}
                    rows={4}
                    size="middle"
                    style={{ paddingRight: '32px' }}
                  />
                </Form.Item>
                <Button
                  type="text"
                  icon={<ExpandOutlined />}
                  size="small"
                  style={{
                    position: 'absolute',
                    right: '4px',
                    top: '4px',
                    zIndex: 1,
                  }}
                  onClick={() => {
                    const currentValue = form.getFieldValue(key) || '';
                    setExpandedTextarea({ fieldKey: key, value: currentValue });
                  }}
                />
              </div>
            </Form.Item>
          );
        }

        return (
          <Form.Item key={key} {...commonProps}>
            <Input placeholder={`Enter ${name.toLowerCase()}`} size="middle" />
          </Form.Item>
        );

      case 'number':
        return (
          <Form.Item key={key} {...commonProps}>
            <InputNumber
              style={{ width: '100%' }}
              placeholder={`Enter ${name.toLowerCase()}`}
              size="middle"
            />
          </Form.Item>
        );

      case 'boolean':
        return (
          <Form.Item key={key} {...commonProps} valuePropName="checked">
            <Switch />
          </Form.Item>
        );

      case 'array':
        return (
          <Form.Item key={key} {...commonProps}>
            <Input.TextArea
              placeholder={`Enter ${name.toLowerCase()} (one per line)`}
              rows={3}
              size="middle"
            />
          </Form.Item>
        );

      case 'object':
        return (
          <Form.Item key={key} {...commonProps}>
            <KeyValuePairsInput />
          </Form.Item>
        );

      default:
        return (
          <Form.Item key={key} {...commonProps}>
            <Input placeholder={`Enter ${name.toLowerCase()}`} size="middle" />
          </Form.Item>
        );
    }
  };

  if (!visible || !node) return null;

  const nodeData = node.data as unknown as GraphNodeData;
  const templateSchema = nodeData.templateSchema;

  return (
    <Sider
      width={400}
      style={{
        background: '#fff',
        borderLeft: '1px solid #f0f0f0',
        overflow: 'auto',
        height: '100%',
      }}>
      <div
        style={{
          padding: '16px',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
        }}>
        {/* Header */}
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 16,
            paddingBottom: 16,
            borderBottom: '1px solid #f0f0f0',
          }}>
          <Title level={4} style={{ margin: 0 }}>
            Edit Node
          </Title>
          <Space>
            <Button
              type="primary"
              onClick={handleSave}
              icon={<SaveOutlined />}
              size="small">
              Save
            </Button>
            <Button
              onClick={handleClose}
              icon={<CloseOutlined />}
              size="small"></Button>
          </Space>
        </div>

        {/* Content */}
        <div style={{ flex: 1, overflow: 'auto' }}>
          <Space direction="vertical" size="small" style={{ width: '100%' }}>
            {/* Node Name */}
            <div>
              {isEditingName ? (
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <Input
                    value={editingName}
                    onChange={(e) => setEditingName(e.target.value)}
                    onPressEnter={handleNameSave}
                    onBlur={handleNameSave}
                    autoFocus
                    style={{ flex: 1 }}
                  />
                  <Button
                    type="text"
                    icon={<CheckOutlined />}
                    onClick={handleNameSave}
                    size="small"
                  />
                  <Button
                    type="text"
                    icon={<CloseOutlined />}
                    onClick={handleNameCancel}
                    size="small"
                  />
                </div>
              ) : (
                <div style={{ display: 'flex', alignItems: 'center', gap: 15 }}>
                  <Text
                    strong
                    style={{
                      flex: 1,
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                      display: 'block',
                    }}>
                    {nodeName}
                  </Text>
                  <Button
                    type="text"
                    icon={<EditOutlined />}
                    onClick={handleNameEdit}
                    size="small"
                  />
                </div>
              )}

              <div>
                <Text strong>Template:</Text> {nodeData.template}
              </div>
              <div>
                <Text strong>Kind:</Text> {nodeData.templateKind}
              </div>
            </div>

            <Divider />

            {/* Dynamic Form Fields */}
            {formFields.length > 0 ? (
              <div>
                <Title level={5}>Configuration</Title>
                <Form
                  form={form}
                  layout="vertical"
                  size="small"
                  style={{ marginTop: 8 }}
                  labelCol={{ style: { paddingBottom: 4 } }}
                  preserve={false}
                  onValuesChange={handleFormChange}>
                  {formFields.map(renderFormField)}
                </Form>
              </div>
            ) : (
              <div>
                <Title level={5}>Configuration</Title>
                <Text type="secondary">
                  No configuration options available for this template.
                </Text>
              </div>
            )}
          </Space>
        </div>
      </div>

      {/* Confirmation Modal */}
      <Modal
        title="Unsaved Changes"
        open={showCloseConfirm}
        onCancel={handleCloseCancel}
        footer={[
          <Button key="cancel" onClick={handleCloseCancel}>
            Keep Editing
          </Button>,
          <Button key="discard" danger onClick={handleCloseConfirm}>
            Discard Changes
          </Button>,
          <Button key="save" type="primary" onClick={handleSaveAndClose}>
            Save and Close
          </Button>,
        ]}>
        <p>You have unsaved changes. What would you like to do?</p>
      </Modal>

      {/* Expanded Textarea Modal */}
      <Modal
        title="Edit Text"
        open={!!expandedTextarea}
        onCancel={() => setExpandedTextarea(null)}
        width={800}
        footer={[
          <Button key="cancel" onClick={() => setExpandedTextarea(null)}>
            Cancel
          </Button>,
          <Button
            key="save"
            type="primary"
            onClick={() => {
              if (expandedTextarea) {
                form.setFieldValue(
                  expandedTextarea.fieldKey,
                  expandedTextarea.value,
                );
                setExpandedTextarea(null);
                setHasUnsavedChanges(true);
              }
            }}>
            Save
          </Button>,
        ]}>
        {expandedTextarea && (
          <Input.TextArea
            value={expandedTextarea.value}
            onChange={(e) =>
              setExpandedTextarea({
                ...expandedTextarea,
                value: e.target.value,
              })
            }
            rows={20}
            style={{ fontFamily: 'monospace' }}
            placeholder="Enter your text here..."
          />
        )}
      </Modal>
    </Sider>
  );
};
