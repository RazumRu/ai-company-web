import {
  CheckOutlined,
  CloseOutlined,
  EditOutlined,
  ExclamationCircleOutlined,
  FileTextOutlined,
  InfoCircleOutlined,
  PlayCircleOutlined,
  ToolOutlined,
} from '@ant-design/icons';
import $RefParser from '@apidevtools/json-schema-ref-parser';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import {
  Alert,
  Avatar,
  Button,
  Input,
  Layout,
  message,
  Modal,
  Popover,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { createTwoFilesPatch } from 'diff';
import { isEqual } from 'lodash';
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

import { graphsApi, litellmApi } from '../../../api';
import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  LiteLlmModelDto,
  TemplateDto,
  ThreadDtoStatusEnum,
  ThreadMessageDto,
} from '../../../autogenerated';
import { MarkdownSplitEditor } from '../../../components/markdown/MarkdownSplitEditor';
import { getAgentAvatarDataUri } from '../../../utils/agentAvatars';
import { extractApiErrorMessage } from '../../../utils/errors';
import type { GraphNode, SchemaProperty } from '../types';
import type { PendingMessage } from '../types/messages';
import {
  flattenAllOfInSchema,
  getDefaultEmptyValue,
  getNodeData,
  getSchemaTypeName,
  isTrulyEmptyValue,
  processValueByType,
} from '../utils/schemaUtils';
import { NodeMessagesPanel } from './NodeMessagesPanel';
import { TemplateConfigForm } from './TemplateConfigForm';

const { Sider } = Layout;
const { Title, Text } = Typography;

interface NodeEditSidebarProps {
  node: GraphNode | null;
  visible: boolean;
  onClose: () => void;
  /**
   * Called whenever the user makes a real change to the node form.
   * GraphPage should use this to update draftGraph immediately.
   */
  onNodeDraftChange: (
    nodeId: string,
    updates: { name?: string; config?: Record<string, unknown> },
  ) => void;
  templates: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  /**
   * Global graph-level unsaved changes flag, computed in GraphPage.
   * NodeEditSidebar should NOT modify this.
   */
  hasGlobalUnsavedChanges?: boolean;
  onTriggerClick?: (nodeId: string) => void;
  selectedThreadId?: string;
  selectedThreadStatus?: ThreadDtoStatusEnum;
  selectedThreadLastRunId?: string | null;
  compiledNode?: GraphNodeWithStatusDto;
  compiledNodesLoading?: boolean;
  messages?: ThreadMessageDto[];
  messagesLoading?: boolean;
  hasMoreMessages?: boolean;
  loadingMoreMessages?: boolean;
  pendingMessages?: PendingMessage[];
  nodeDisplayNames?: Record<string, string>;
  onLoadMoreMessages?: () => void;
  graphId?: string;
  /**
   * Snapshot version of the node config from draftGraph.
   * Used to reset the local config form baseline when the parent saves/updates draftGraph externally.
   */
  draftNodeConfigVersion?: number;
  /**
   * True when the currently opened node in the draft differs from the server baseline.
   * This should be computed in GraphPage (single source of truth).
   */
  hasNodeUnsavedChangesFromServer?: boolean;
}

export type AiSuggestionState = {
  fieldKey: string;
  fieldLabel: string;
  initialInstructions: string;
  currentInstructions: string;
  suggestedInstructions?: string;
  lastSuggestedInstructions?: string;
  manualSuggestedOverride?: string;
  isEditingSuggestion?: boolean;
  editSuggestionDraft?: string;
  userRequest: string;
  threadId?: string;
  loading: boolean;
};

export const NodeEditSidebar = React.memo(
  ({
    node,
    visible,
    onClose,
    onNodeDraftChange,
    templates,
    graphStatus,
    hasGlobalUnsavedChanges = false,
    onTriggerClick,
    selectedThreadId,
    selectedThreadStatus,
    selectedThreadLastRunId,
    compiledNode,
    compiledNodesLoading,
    messages = [],
    messagesLoading = false,
    hasMoreMessages = true,
    loadingMoreMessages = false,
    pendingMessages = [],
    nodeDisplayNames,
    onLoadMoreMessages,
    graphId,
    draftNodeConfigVersion,
    hasNodeUnsavedChangesFromServer,
  }: NodeEditSidebarProps) => {
    const isHydratingRef = useRef(false);
    const nodeRef = useRef<GraphNode | null>(null);
    const [nodeName, setNodeName] = useState('');
    const [isEditingName, setIsEditingName] = useState(false);
    const [editingName, setEditingName] = useState('');
    const [templateSchema, setTemplateSchema] = useState<Record<
      string,
      unknown
    > | null>(null);
    const [configFormData, setConfigFormData] = useState<
      Record<string, unknown>
    >({});
    const [expandedTextarea, setExpandedTextarea] = useState<{
      fieldKey: string;
      value: string;
    } | null>(null);
    const [initialConfigFormData, setInitialConfigFormData] = useState<
      Record<string, unknown>
    >({});
    const [hasLocalUnsavedChanges, setHasLocalUnsavedChanges] = useState(false);
    const [activeTab, setActiveTab] = useState('options');
    const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
    const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);
    const [aiSuggestionState, setAiSuggestionState] =
      useState<AiSuggestionState | null>(null);

    const computeHasLocalUnsavedChanges = useCallback(
      (nextData?: Record<string, unknown>) => {
        const currentValues = nextData ?? configFormData;
        const keys = new Set([
          ...Object.keys(initialConfigFormData),
          ...Object.keys(currentValues),
        ]);

        const formChanged = Array.from(keys).some((key) => {
          return !isEqual(currentValues[key], initialConfigFormData[key]);
        });

        const expandedChanged = expandedTextarea
          ? !isEqual(
              expandedTextarea.value,
              initialConfigFormData[expandedTextarea.fieldKey],
            )
          : false;

        return formChanged || expandedChanged;
      },
      [configFormData, expandedTextarea, initialConfigFormData],
    );

    // Local unsaved warning: ONLY based on actual local form changes.
    // (Do NOT compare draft config to compiled/runtime config; that can differ even
    // without user edits and causes false warnings.)
    // Also do NOT include server/draft diffs here - local is strictly uiForm vs baseline.
    const shouldShowUnsavedWarning = hasLocalUnsavedChanges;

    // For AI suggestion modal, we need to warn if there are unsaved changes that AI won't see
    const nodeDirtyWarning = useMemo(() => {
      // Show warning if there are local form changes OR the node differs from the
      // server baseline (draft != server). The parent owns this comparison.
      return (
        shouldShowUnsavedWarning || Boolean(hasNodeUnsavedChangesFromServer)
      );
    }, [shouldShowUnsavedWarning, hasNodeUnsavedChangesFromServer]);

    // Track the previous node ID to detect node switches
    const prevNodeIdRef = useRef<string | undefined>(undefined);

    const selectedNodeId = node?.id;
    const selectedNodeTemplateId = getNodeData(node)?.template;

    useEffect(() => {
      // Keep a stable snapshot for form hydration to avoid re-hydrating
      // on every node prop reference change (e.g. when draftGraph updates).
      nodeRef.current = node;
    }, [node, selectedNodeId]);

    // Reset local unsaved changes when the parent signals that the graph was saved
    // (draftNodeConfigVersion increments after save)
    useEffect(() => {
      if (!hasGlobalUnsavedChanges && !isHydratingRef.current) {
        // Graph was saved - reset local form baseline
        setInitialConfigFormData(configFormData);
        setHasLocalUnsavedChanges(false);
      }
    }, [configFormData, hasGlobalUnsavedChanges]);

    // Update baseline when the draftNodeConfigVersion changes (after parent save)
    useEffect(() => {
      if (draftNodeConfigVersion !== undefined && !isHydratingRef.current) {
        setInitialConfigFormData(configFormData);
        setHasLocalUnsavedChanges(false);
      }
    }, [configFormData, draftNodeConfigVersion]);

    useEffect(() => {
      if (expandedTextarea) {
        const hasChanges = computeHasLocalUnsavedChanges();
        if (hasChanges) {
          setHasLocalUnsavedChanges(true);
        }
      }
    }, [
      computeHasLocalUnsavedChanges,
      expandedTextarea,
      expandedTextarea?.value,
    ]);

    const AiSuggestionLink: React.FC<{
      onClick: () => void;
      style?: React.CSSProperties;
      label?: string;
      disabled?: boolean;
    }> = ({ onClick, style, label = 'Improve with AI', disabled }) => (
      <Button
        type="link"
        size="small"
        style={{ padding: 0, height: 'auto', fontSize: 12, ...style }}
        onClick={onClick}
        disabled={disabled}>
        {label}
      </Button>
    );

    const schemaProperties = useMemo(() => {
      const propsUnknown = (templateSchema as { properties?: unknown } | null)
        ?.properties;
      if (!propsUnknown || typeof propsUnknown !== 'object') {
        return {} as Record<string, SchemaProperty>;
      }
      return propsUnknown as Record<string, SchemaProperty>;
    }, [templateSchema]);

    const schemaPropertyKeys = useMemo(
      () => Object.keys(schemaProperties),
      [schemaProperties],
    );

    const hasLiteLlmSelectField = useMemo(
      () =>
        Object.values(schemaProperties).some(
          (field) => field['x-ui:litellm-models-list-select'] === true,
        ),
      [schemaProperties],
    );

    const nodeData = getNodeData(node);
    const nodeTemplate = templates.find((t) => t.id === nodeData?.template);
    const templateKind = nodeTemplate?.kind ?? nodeData?.templateKind;
    const templateKindLower = (templateKind || '').toLowerCase();
    const isAgentNode = templateKindLower === 'simpleagent';
    const isGraphRunning = graphStatus === GraphDtoStatusEnum.Running;
    const isThreadStopped =
      selectedThreadStatus === ThreadDtoStatusEnum.Stopped;
    const showNodeStatus = ['runtime', 'simpleagent', 'trigger'].includes(
      templateKindLower,
    );
    const [instructionsVisible, setInstructionsVisible] = useState(false);
    const [toolsVisible, setToolsVisible] = useState(false);
    const agentInstructionsText = useMemo(() => {
      const instructions = (
        compiledNode?.additionalNodeMetadata as unknown as {
          instructions?: unknown;
        }
      )?.instructions;
      if (instructions === undefined || instructions === null) {
        return '';
      }
      if (typeof instructions === 'string') {
        return instructions;
      }
      if (Array.isArray(instructions)) {
        return instructions.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(instructions, null, 2);
      } catch {
        return String(instructions);
      }
    }, [compiledNode?.additionalNodeMetadata]);

    const connectedTools = useMemo(() => {
      return (
        (
          compiledNode?.additionalNodeMetadata as unknown as {
            connectedTools?: {
              name: string;
              description: string;
              schema: Record<string, unknown>;
            }[];
          }
        )?.connectedTools || []
      );
    }, [compiledNode?.additionalNodeMetadata]);
    const instructionsAvailable = Boolean(agentInstructionsText);
    const instructionsButtonDisabled =
      !isGraphRunning || compiledNodesLoading || !instructionsAvailable;
    const instructionsTooltip = !isGraphRunning
      ? 'Start the graph to view live instructions'
      : compiledNodesLoading
        ? 'Loading instructions...'
        : instructionsAvailable
          ? 'View current agent instructions'
          : 'Instructions are not available for this node yet';

    const toolsAvailable = connectedTools.length > 0;
    const toolsButtonDisabled =
      !isGraphRunning || compiledNodesLoading || !toolsAvailable;
    const toolsTooltip = !isGraphRunning
      ? 'Start the graph to view connected tools'
      : compiledNodesLoading
        ? 'Loading tools...'
        : toolsAvailable
          ? 'View connected agent tools'
          : 'No tools are connected to this node';

    const expandedTextareaField = useMemo(() => {
      if (!expandedTextarea) return undefined;
      const prop = schemaProperties[expandedTextarea.fieldKey];
      if (!prop) return undefined;
      const label =
        (typeof prop['x-ui:label'] === 'string'
          ? prop['x-ui:label']
          : undefined) ??
        prop.title ??
        expandedTextarea.fieldKey;
      return { prop, label };
    }, [expandedTextarea, schemaProperties]);

    const formatInstructionsValue = useCallback((value: unknown) => {
      if (value === undefined || value === null) {
        return '';
      }
      if (typeof value === 'string') {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((item) => String(item)).join('\n\n');
      }
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }, []);

    const aiInitialInstructions = aiSuggestionState?.initialInstructions ?? '';
    const aiLastSuggestedInstructions =
      aiSuggestionState?.lastSuggestedInstructions;
    const aiManualSuggestedOverride =
      aiSuggestionState?.manualSuggestedOverride;

    const suggestionDiffMarkdown = useMemo(() => {
      if (!aiLastSuggestedInstructions && !aiManualSuggestedOverride) {
        return null;
      }

      const suggested =
        aiManualSuggestedOverride ?? aiLastSuggestedInstructions ?? '';
      const diffString = createTwoFilesPatch(
        'AI Suggestion',
        'AI Suggestion',
        aiInitialInstructions,
        suggested,
        '',
        '',
        { context: Number.MAX_SAFE_INTEGER },
      );

      const trimmed = diffString.trimEnd();
      return `\`\`\`diff\n${trimmed}\n\`\`\``;
    }, [
      aiInitialInstructions,
      aiLastSuggestedInstructions,
      aiManualSuggestedOverride,
    ]);

    const openAiSuggestionModal = useCallback(
      (fieldKey: string, fieldLabel: string, initialValue?: unknown) => {
        if (!isGraphRunning) {
          message.warning('Start the graph to use AI suggestions');
          return;
        }

        const valueToUse: unknown =
          initialValue !== undefined
            ? initialValue
            : (configFormData[fieldKey] ?? '');
        const formattedValue = formatInstructionsValue(valueToUse);
        setAiSuggestionState({
          fieldKey,
          fieldLabel,
          initialInstructions: formattedValue,
          currentInstructions: formattedValue,
          suggestedInstructions: undefined,
          lastSuggestedInstructions: undefined,
          manualSuggestedOverride: undefined,
          isEditingSuggestion: false,
          editSuggestionDraft: undefined,
          userRequest: '',
          threadId: undefined,
          loading: false,
        });
      },
      [configFormData, formatInstructionsValue, isGraphRunning],
    );

    const closeAiSuggestionModal = useCallback(() => {
      setAiSuggestionState(null);
    }, []);

    const statusTagColorMap: Record<string, string> = {
      running: 'green',
      idle: 'blue',
      starting: 'geekblue',
      stopped: 'red',
    };

    const rawStatus = compiledNode?.status;

    const statusLabel = !isGraphRunning
      ? 'Not running'
      : compiledNodesLoading
        ? 'Loading...'
        : rawStatus
          ? `${rawStatus.charAt(0).toUpperCase()}${rawStatus.slice(1)}`
          : 'Unknown';

    const statusTagColor = !isGraphRunning
      ? 'default'
      : compiledNodesLoading
        ? 'geekblue'
        : statusTagColorMap[rawStatus ?? ''] || 'default';

    const normalizeJsonViewValue = (value: unknown): object | undefined => {
      if (value === undefined) {
        return undefined;
      }
      if (value !== null && typeof value === 'object') {
        return value as object;
      }
      return { value } as Record<string, unknown>;
    };

    const metadataJsonValue = normalizeJsonViewValue(compiledNode?.metadata);
    const configJsonValue = normalizeJsonViewValue(compiledNode?.config);
    const hasInfoData = Boolean(metadataJsonValue || configJsonValue);

    const infoContent = (
      <div style={{ maxWidth: 360 }}>
        {compiledNodesLoading && (
          <Text
            type="secondary"
            style={{
              display: 'block',
              marginBottom: hasInfoData ? 8 : 0,
            }}>
            Loading latest node information...
          </Text>
        )}
        {metadataJsonValue && (
          <div style={{ marginBottom: configJsonValue ? 16 : 0 }}>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Metadata
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView
                value={metadataJsonValue as object}
                style={lightTheme}
              />
            </div>
          </div>
        )}
        {configJsonValue && (
          <div>
            <Text strong style={{ display: 'block', marginBottom: 8 }}>
              Configuration
            </Text>
            <div
              style={{
                maxHeight: 240,
                overflow: 'auto',
                border: '1px solid #f0f0f0',
                borderRadius: 6,
                padding: 8,
                background: '#fafafa',
              }}>
              <JsonView value={configJsonValue as object} style={lightTheme} />
            </div>
          </div>
        )}
        {!compiledNodesLoading && !hasInfoData && (
          <Text type="secondary">No metadata or configuration available.</Text>
        )}
      </div>
    );

    useEffect(() => {
      if (!visible) {
        setAiSuggestionState(null);
      }
    }, [visible]);

    useEffect(() => {
      setAiSuggestionState(null);
    }, [node?.id]);

    useEffect(() => {
      if (!hasLiteLlmSelectField) {
        return;
      }
      if (liteLlmModels.length > 0) {
        return;
      }

      let isActive = true;

      const fetchLiteLlmModels = async () => {
        try {
          setLitellmModelsLoading(true);
          const response = await litellmApi.listModels();
          if (!isActive) {
            return;
          }
          setLiteLlmModels(response.data ?? []);
        } catch (error) {
          if (!isActive) {
            return;
          }
          console.error('Failed to load LiteLLM models:', error);
          const errorMessage = extractApiErrorMessage(
            error,
            'Failed to load LiteLLM models',
          );
          message.error(errorMessage);
        } finally {
          if (isActive) {
            setLitellmModelsLoading(false);
          }
        }
      };

      fetchLiteLlmModels();

      return () => {
        isActive = false;
      };
    }, [hasLiteLlmSelectField, liteLlmModels.length]);

    // Keep active tab valid for the currently selected node (does NOT touch form state).
    useEffect(() => {
      const nodeForTabs = node;
      if (!nodeForTabs) return;
      const currentNodeData = getNodeData(nodeForTabs);
      const currentNodeTemplate = templates.find(
        (template) => template.id === currentNodeData?.template,
      );
      const currentTemplateKind =
        currentNodeTemplate?.kind ?? currentNodeData?.templateKind;
      const currentNodeIsAgent =
        (currentTemplateKind || '').toLowerCase() === 'simpleagent';
      const availableTabs = ['options'];
      if (currentNodeIsAgent) {
        availableTabs.push('messages');
      }
      if (!availableTabs.includes(activeTab)) {
        setActiveTab('options');
      }
    }, [activeTab, node]);

    // Hydrate form ONLY when switching nodes or switching templates.
    // Critically, do NOT re-run on every `node` object reference change, otherwise
    // typing (which updates draftGraph) will rehydrate and steal focus.
    useEffect(() => {
      const nodeForInit = nodeRef.current;
      if (!nodeForInit) {
        setTemplateSchema(null);
        setConfigFormData({});
        setInitialConfigFormData({});
        setHasLocalUnsavedChanges(false);
        prevNodeIdRef.current = undefined;
        return;
      }

      const currentNodeData = getNodeData(nodeForInit);
      if (!currentNodeData) {
        setTemplateSchema(null);
        setConfigFormData({});
        setInitialConfigFormData({});
        setHasLocalUnsavedChanges(false);
        prevNodeIdRef.current = undefined;
        return;
      }

      const template = templates.find((t) => t.id === currentNodeData.template);

      isHydratingRef.current = true;

      let didCancel = false;

      const hydrateForm = async () => {
        const rawSchema = template?.schema as unknown;
        if (!rawSchema) {
          setTemplateSchema(null);
          setConfigFormData({});
          setInitialConfigFormData({});
          setHasLocalUnsavedChanges(false);
          requestAnimationFrame(() => {
            isHydratingRef.current = false;
          });
          return;
        }

        let schema: unknown = rawSchema;
        try {
          schema = await $RefParser.dereference(rawSchema, {
            mutateInputSchema: false,
          });
          // Flatten allOf structures to help RJSF understand enum fields
          if (schema && typeof schema === 'object') {
            schema = flattenAllOfInSchema(schema as Record<string, unknown>);
          }
        } catch (error) {
          console.error('Failed to dereference template schema:', error);
          schema = rawSchema;
        }

        if (didCancel) return;

        const schemaPropertiesUnknown = (schema as { properties?: unknown })
          ?.properties;
        if (
          !schemaPropertiesUnknown ||
          typeof schemaPropertiesUnknown !== 'object'
        ) {
          setTemplateSchema(null);
          setConfigFormData({});
          setInitialConfigFormData({});
          setHasLocalUnsavedChanges(false);
          requestAnimationFrame(() => {
            isHydratingRef.current = false;
          });
          return;
        }

        const schemaProperties = schemaPropertiesUnknown as Record<
          string,
          SchemaProperty
        >;
        const initialValues: Record<string, unknown> = {};
        for (const [key, prop] of Object.entries(schemaProperties)) {
          if (prop.const !== undefined) {
            initialValues[key] = prop.const;
            continue;
          }

          const resolvedType = getSchemaTypeName(prop);
          const fallbackEmptyValue = getDefaultEmptyValue(resolvedType);

          initialValues[key] =
            (currentNodeData.config as Record<string, unknown>)?.[key] ??
            prop.default ??
            fallbackEmptyValue;
        }

        setTemplateSchema(schema as Record<string, unknown>);
        setConfigFormData(initialValues);
        setInitialConfigFormData(initialValues);
        setHasLocalUnsavedChanges(false);

        requestAnimationFrame(() => {
          isHydratingRef.current = false;
        });
      };

      void hydrateForm();

      const label = (currentNodeData.label as string) || '';
      setNodeName(label);
      setEditingName(label);
      prevNodeIdRef.current = nodeForInit.id;

      return () => {
        didCancel = true;
      };
    }, [selectedNodeId, selectedNodeTemplateId, templates]);

    /**
     * Build the processed config from current form values.
     * This is used for both immediate draft updates and final saves.
     */
    const buildProcessedConfig = useCallback(
      (overrideFormData?: Record<string, unknown>): Record<string, unknown> => {
        const currentConfig: Record<string, unknown> =
          getNodeData(node)?.config ?? {};
        const effectiveFormData = overrideFormData ?? configFormData;

        // Preserve keys that are NOT in the current template schema (backward/forward compat).
        const schemaKeys = new Set(schemaPropertyKeys);
        const configValues: Record<string, unknown> = {};
        Object.keys(currentConfig).forEach((key) => {
          if (!schemaKeys.has(key)) {
            configValues[key] = currentConfig[key];
          }
        });

        for (const key of schemaPropertyKeys) {
          const prop = schemaProperties[key];
          if (!prop) continue;

          // Handle const values - they override everything
          if (prop.const !== undefined) {
            configValues[key] = prop.const as unknown;
            continue;
          }

          const rawValue: unknown = effectiveFormData[key];
          const effectiveValue: unknown =
            rawValue === undefined ? currentConfig[key] : rawValue;

          const typeName = getSchemaTypeName(prop);

          // Skip truly empty values (but not booleans)
          if (isTrulyEmptyValue(effectiveValue, typeName)) {
            continue;
          }

          const processedValue = processValueByType(effectiveValue, typeName);

          // Only add the value if processing succeeded
          if (processedValue !== undefined) {
            configValues[key] = processedValue;
          }
        }

        return configValues;
      },
      [configFormData, node, schemaProperties, schemaPropertyKeys],
    );

    /**
     * Push draft changes to the parent (GraphPage).
     * This is called immediately on every meaningful form change.
     * The parent will update draftGraph and persist the diff.
     */
    const pushDraftChange = useCallback(
      (overrideFormData?: Record<string, unknown>) => {
        if (!node) return;
        if (isHydratingRef.current) return; // Don't push during hydration

        const configValues = buildProcessedConfig(overrideFormData);
        const nodeData = getNodeData(node);
        const currentConfig: Record<string, unknown> = nodeData?.config ?? {};
        const currentLabel = nodeData?.label;

        const labelUnchanged = nodeName === currentLabel;
        const configUnchanged = isEqual(configValues, currentConfig);

        if (labelUnchanged && configUnchanged) {
          return;
        }

        onNodeDraftChange(node.id, {
          name: nodeName,
          config: configValues,
        });
      },
      [node, nodeName, buildProcessedConfig, onNodeDraftChange],
    );

    // Cleanup effect: push any pending draft changes when unmounting
    // Note: This is a safety net, but ideally changes should be pushed immediately
    useEffect(() => {
      return () => {
        // The effect cleanup runs on unmount, but we can't reliably
        // push changes here since the refs and state may be stale.
        // The handleClose function should handle this case.
      };
    }, []);

    const handleExpandedTextareaSave = useCallback(() => {
      if (expandedTextarea) {
        const nextFormData: Record<string, unknown> = {
          ...configFormData,
          [expandedTextarea.fieldKey]: expandedTextarea.value,
        };
        setConfigFormData(nextFormData);
        // Compute hasChanges and push draft
        const hasChanges = computeHasLocalUnsavedChanges(nextFormData);
        setHasLocalUnsavedChanges(hasChanges);
        if (hasChanges) {
          pushDraftChange(nextFormData);
        }
      }
      setExpandedTextarea(null);
    }, [
      expandedTextarea,
      configFormData,
      computeHasLocalUnsavedChanges,
      pushDraftChange,
    ]);

    const handleConfigFormChange = useCallback(
      (nextFormData: Record<string, unknown>) => {
        // Ignore changes during hydration (initial mount / node switch)
        if (isHydratingRef.current) {
          return;
        }

        setConfigFormData(nextFormData);

        // Always push changes to draft state
        // The draft state layer will determine if there are unsaved changes vs server baseline
        pushDraftChange(nextFormData);

        // Compute whether the form has actually changed from the initial values
        const hasChanges = computeHasLocalUnsavedChanges(nextFormData);

        // Update local unsaved state - this can go from true to false
        // if the user reverts their changes back to the initial values
        setHasLocalUnsavedChanges(hasChanges);
      },
      [computeHasLocalUnsavedChanges, pushDraftChange],
    );

    const handleClose = useCallback(() => {
      // Push any remaining draft changes before closing
      if (hasLocalUnsavedChanges) {
        pushDraftChange();
      }
      onClose();
    }, [hasLocalUnsavedChanges, pushDraftChange, onClose]);

    const handleStartEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) => {
        if (!prev) return prev;
        const currentDraft =
          prev.manualSuggestedOverride ??
          prev.lastSuggestedInstructions ??
          prev.currentInstructions ??
          '';
        return {
          ...prev,
          isEditingSuggestion: true,
          editSuggestionDraft: currentDraft,
        };
      });
    }, []);

    const handleCancelEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) =>
        prev
          ? {
              ...prev,
              isEditingSuggestion: false,
              editSuggestionDraft: undefined,
            }
          : prev,
      );
    }, []);

    const handleApplyEditSuggested = useCallback(() => {
      setAiSuggestionState((prev) =>
        prev && prev.editSuggestionDraft !== undefined
          ? {
              ...prev,
              manualSuggestedOverride: prev.editSuggestionDraft,
              suggestedInstructions: prev.editSuggestionDraft,
              isEditingSuggestion: false,
            }
          : prev,
      );
    }, []);

    const handleNameEdit = () => {
      setIsEditingName(true);
      setEditingName(nodeName);
    };

    const handleNameSave = () => {
      if (editingName !== nodeName) {
        setNodeName(editingName);
        if (node) {
          // Use onNodeDraftChange for immediate draft update
          onNodeDraftChange(node.id, {
            name: editingName,
          });
          setHasLocalUnsavedChanges(true);
        }
      }
      setIsEditingName(false);
    };

    const handleNameCancel = () => {
      setEditingName(nodeName);
      setIsEditingName(false);
    };

    const handleAiSuggestionSubmit = useCallback(async () => {
      if (!aiSuggestionState) return;

      if (!isGraphRunning) {
        message.warning('Start the graph to use AI suggestions');
        return;
      }

      const userRequest = aiSuggestionState.userRequest.trim();
      if (!userRequest) {
        message.warning('Enter a request for the AI suggestion');
        return;
      }

      if (!graphId || !node?.id) {
        message.error('Graph or node is missing for suggestions');
        return;
      }

      setAiSuggestionState((prev) =>
        prev ? { ...prev, loading: true } : prev,
      );

      try {
        const response = await graphsApi.suggestAgentInstructions(
          graphId ?? '',
          node?.id ?? '',
          {
            userRequest,
            threadId: aiSuggestionState.threadId,
          },
        );

        setAiSuggestionState((prev) =>
          prev
            ? {
                ...prev,
                loading: false,
                suggestedInstructions:
                  response.data?.instructions ?? prev.suggestedInstructions,
                lastSuggestedInstructions:
                  response.data?.instructions ?? prev.lastSuggestedInstructions,
                manualSuggestedOverride: undefined,
                isEditingSuggestion: false,
                editSuggestionDraft: undefined,
                threadId: response.data?.threadId ?? prev.threadId,
                userRequest: '',
              }
            : prev,
        );
      } catch (error) {
        setAiSuggestionState((prev) =>
          prev ? { ...prev, loading: false } : prev,
        );
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to fetch AI suggestion',
        );
        message.error(errorMessage);
      }
    }, [aiSuggestionState, graphId, isGraphRunning, node?.id]);

    const handleApplyAiSuggestion = useCallback(() => {
      if (
        !aiSuggestionState?.suggestedInstructions &&
        !aiSuggestionState?.manualSuggestedOverride
      )
        return;

      const suggestedInstructions =
        aiSuggestionState.manualSuggestedOverride ??
        aiSuggestionState.suggestedInstructions ??
        '';

      const nextFormData: Record<string, unknown> = {
        ...configFormData,
        [aiSuggestionState.fieldKey]: suggestedInstructions,
      };
      setConfigFormData(nextFormData);

      if (
        expandedTextarea?.fieldKey &&
        expandedTextarea.fieldKey === aiSuggestionState.fieldKey
      ) {
        setExpandedTextarea((prev) =>
          prev ? { ...prev, value: suggestedInstructions } : prev,
        );
      }

      setAiSuggestionState(null);

      // Push the AI suggestion as a draft change
      const hasChanges = computeHasLocalUnsavedChanges(nextFormData);
      setHasLocalUnsavedChanges(hasChanges);
      pushDraftChange(nextFormData);
    }, [
      aiSuggestionState,
      computeHasLocalUnsavedChanges,
      configFormData,
      expandedTextarea?.fieldKey,
      pushDraftChange,
    ]);

    const isTriggerNode = templateKindLower === 'trigger';
    const canTrigger = isTriggerNode && isGraphRunning;

    const renderOptionsTabContent = () => {
      return (
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
          }}>
          <div
            style={{
              flexShrink: 0,
              padding: '8px 4px 0 4px',
            }}>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                gap: 8,
              }}>
              <Title level={5} style={{ margin: 0 }}>
                Configuration
              </Title>
            </div>
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'auto',
              padding: '0 4px 8px 4px',
            }}>
            {templateSchema && schemaPropertyKeys.length > 0 ? (
              <TemplateConfigForm
                schema={templateSchema}
                formData={configFormData}
                onChange={handleConfigFormChange}
                liteLlmModels={liteLlmModels}
                litellmModelsLoading={litellmModelsLoading}
                onOpenExpandedTextarea={(fieldKey, value) =>
                  setExpandedTextarea({ fieldKey, value })
                }
                onOpenAiSuggestion={(fieldKey, fieldLabel, value) =>
                  openAiSuggestionModal(fieldKey, fieldLabel, value)
                }
                aiSuggestionEnabled={Boolean(
                  isGraphRunning && graphId && node?.id,
                )}
              />
            ) : (
              <Text type="secondary">
                No configuration options available for this template.
              </Text>
            )}
          </div>
        </div>
      );
    };

    const newMessageMode = useMemo(() => {
      return (compiledNode?.config as Record<string, unknown>)
        ?.newMessageMode as
        | 'inject_after_tool_call'
        | 'wait_for_completion'
        | undefined;
    }, [compiledNode?.config]);

    const renderMessagesTabContent = useCallback(() => {
      const isNodeRunning =
        !isThreadStopped &&
        isGraphRunning &&
        (typeof compiledNode?.status === 'string'
          ? compiledNode.status.toLowerCase() === 'running'
          : true);

      return (
        <NodeMessagesPanel
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={selectedThreadId}
          nodeId={node?.id}
          nodeDisplayNames={nodeDisplayNames}
          nodeTemplateKind={templateKind}
          onLoadMoreMessages={onLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMoreMessages={loadingMoreMessages}
          isNodeRunning={isNodeRunning}
          isThreadStopped={isThreadStopped}
          currentThreadLastRunId={selectedThreadLastRunId}
          pendingMessages={pendingMessages}
          newMessageMode={newMessageMode}
        />
      );
    }, [
      compiledNode?.status,
      hasMoreMessages,
      isGraphRunning,
      isThreadStopped,
      loadingMoreMessages,
      messages,
      messagesLoading,
      newMessageMode,
      node?.id,
      templateKind,
      nodeDisplayNames,
      onLoadMoreMessages,
      pendingMessages,
      selectedThreadId,
      selectedThreadLastRunId,
    ]);

    const tabItems = isAgentNode
      ? [
          { key: 'options', label: 'Options' },
          { key: 'messages', label: 'Messages' },
        ]
      : [{ key: 'options', label: 'Options' }];

    if (!visible) {
      return null;
    }

    const suggestionModalTitle = aiSuggestionState?.fieldLabel
      ? `Improve ${aiSuggestionState.fieldLabel} with AI`
      : 'Improve instructions with AI';
    const currentContentLabel = 'Current instructions';
    const requestPromptLabel = 'What should be improved?';
    const requestPlaceholder = 'Describe what you want to change or add';
    const sendButtonLabel = 'Send';
    return (
      <Sider
        width={400}
        style={{
          background: '#fff',
          borderLeft: '1px solid #f0f0f0',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
        }}>
        <div
          style={{
            padding: '16px',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            minHeight: 0,
          }}>
          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: 16,
              paddingBottom: 16,
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <Title level={4} style={{ margin: 0 }}>
              Edit Node
            </Title>
            <Space>
              {isTriggerNode && (
                <Button
                  type="primary"
                  icon={<PlayCircleOutlined />}
                  disabled={!canTrigger}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onTriggerClick?.(node?.id || '');
                  }}
                  size="small">
                  Trigger
                </Button>
              )}
              <Button
                onClick={handleClose}
                icon={<CloseOutlined />}
                size="small"></Button>
            </Space>
          </div>

          <div style={{ flexShrink: 0, marginBottom: 16 }}>
            {isEditingName ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <Input
                  value={editingName}
                  onChange={(e) => setEditingName(e.target.value)}
                  onPressEnter={handleNameSave}
                  onBlur={handleNameSave}
                  autoFocus
                  style={{ flex: 1 }}
                />
                <Button
                  type="text"
                  icon={<CheckOutlined />}
                  onClick={handleNameSave}
                  size="small"
                />
                <Button
                  type="text"
                  icon={<CloseOutlined />}
                  onClick={handleNameCancel}
                  size="small"
                />
              </div>
            ) : (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 4,
                }}>
                {isAgentNode && node?.id && (
                  <Avatar
                    size={30}
                    src={getAgentAvatarDataUri(node.id, 64)}
                    style={{ flexShrink: 0 }}
                  />
                )}
                <Text
                  strong
                  style={{
                    flex: 1,
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    display: 'block',
                  }}>
                  {nodeName}
                </Text>
                {isAgentNode && (
                  <>
                    <Tooltip title={instructionsTooltip} placement="bottom">
                      <Button
                        type="text"
                        size="small"
                        icon={<FileTextOutlined />}
                        disabled={instructionsButtonDisabled}
                        onClick={() => setInstructionsVisible(true)}
                        aria-label="View agent instructions"
                      />
                    </Tooltip>
                    <Tooltip title={toolsTooltip} placement="bottom">
                      <Button
                        type="text"
                        size="small"
                        icon={<ToolOutlined />}
                        disabled={toolsButtonDisabled}
                        onClick={() => setToolsVisible(true)}
                        aria-label="View connected tools"
                      />
                    </Tooltip>
                  </>
                )}
                <Popover
                  content={infoContent}
                  trigger="click"
                  placement="bottomRight">
                  <Button
                    type="text"
                    size="small"
                    icon={<InfoCircleOutlined />}
                    aria-label="View node metadata and configuration"
                  />
                </Popover>
                <Button
                  type="text"
                  icon={<EditOutlined />}
                  onClick={handleNameEdit}
                  size="small"
                />
              </div>
            )}

            <div
              style={{
                fontSize: '11px',
                color: '#bfbfbf',
              }}>
              {nodeData?.template} ({templateKind})
            </div>
            {showNodeStatus && (
              <div
                style={{
                  marginTop: 8,
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                  flexWrap: 'wrap',
                }}>
                <Space size={2} wrap align="center">
                  <Tag
                    color={statusTagColor}
                    style={{ margin: 0, fontSize: 12 }}
                    bordered={statusTagColor === 'default'}>
                    {statusLabel}
                  </Tag>
                  {compiledNode?.error && (
                    <Tooltip title={compiledNode.error} placement="top">
                      <ExclamationCircleOutlined
                        style={{ color: '#ff4d4f', fontSize: 14 }}
                      />
                    </Tooltip>
                  )}
                </Space>
              </div>
            )}
          </div>

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'hidden',
              display: 'flex',
              flexDirection: 'column',
            }}>
            {tabItems.length > 1 && (
              <div
                style={{
                  flexShrink: 0,
                  display: 'flex',
                }}>
                <div
                  role="tablist"
                  aria-label="Node editor tabs"
                  style={{
                    background: '#f2f2f7',
                    borderRadius: 999,
                    padding: 4,
                    display: 'flex',
                    gap: 6,
                    width: '100%',
                  }}>
                  {tabItems.map((tab, index) => {
                    const isActive = activeTab === tab.key;
                    return (
                      <button
                        key={tab.key}
                        role="tab"
                        aria-selected={isActive}
                        onClick={() => setActiveTab(tab.key)}
                        onKeyDown={(event) => {
                          if (event.key === 'ArrowRight') {
                            event.preventDefault();
                            const nextKey =
                              tabItems[(index + 1) % tabItems.length]?.key ??
                              tab.key;
                            setActiveTab(nextKey);
                          } else if (event.key === 'ArrowLeft') {
                            event.preventDefault();
                            const prevKey =
                              tabItems[
                                (index - 1 + tabItems.length) % tabItems.length
                              ]?.key ?? tab.key;
                            setActiveTab(prevKey);
                          }
                        }}
                        style={{
                          border: 'none',
                          background: isActive ? '#ffffff' : 'transparent',
                          padding: '4px 0',
                          borderRadius: 999,
                          fontWeight: 600,
                          fontSize: 13,
                          color: isActive ? '#111' : '#555',
                          cursor: 'pointer',
                          transition: 'all 0.2s ease',
                          flex: 1,
                        }}>
                        {tab.label}
                      </button>
                    );
                  })}
                </div>
              </div>
            )}

            <div
              style={{
                flex: 1,
                minHeight: 0,
                overflow: 'hidden',
                display: 'flex',
                flexDirection: 'column',
              }}>
              {activeTab === 'options'
                ? renderOptionsTabContent()
                : renderMessagesTabContent()}
            </div>
          </div>
        </div>

        <Modal
          title={suggestionModalTitle}
          open={!!aiSuggestionState}
          footer={null}
          onCancel={closeAiSuggestionModal}
          destroyOnClose
          width={1100}>
          {aiSuggestionState && (
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              {nodeDirtyWarning && (
                <Alert
                  type="warning"
                  showIcon
                  message="Unsaved changes for this node"
                  description="AI suggestions use the current value from the database. Save this node first if you want your latest edits included."
                />
              )}
              <div>
                <Text strong style={{ display: 'block', marginBottom: 6 }}>
                  {currentContentLabel}
                </Text>
                {aiSuggestionState.lastSuggestedInstructions &&
                (aiSuggestionState.manualSuggestedOverride ||
                  suggestionDiffMarkdown) ? (
                  aiSuggestionState.isEditingSuggestion ? (
                    <Space direction="vertical" style={{ width: '100%' }}>
                      <MarkdownSplitEditor
                        value={
                          aiSuggestionState.editSuggestionDraft ??
                          aiSuggestionState.manualSuggestedOverride ??
                          aiSuggestionState.lastSuggestedInstructions
                        }
                        onChange={(nextValue) =>
                          setAiSuggestionState((prev) =>
                            prev
                              ? { ...prev, editSuggestionDraft: nextValue }
                              : prev,
                          )
                        }
                        height={360}
                        placeholder="Edit suggested contentâ€¦"
                        initialMode="split"
                      />
                      <Space>
                        <Button
                          onClick={handleCancelEditSuggested}
                          size="small">
                          Cancel
                        </Button>
                        <Button
                          type="primary"
                          size="small"
                          onClick={handleApplyEditSuggested}>
                          Apply
                        </Button>
                      </Space>
                    </Space>
                  ) : (
                    <Space direction="vertical" style={{ width: '100%' }}>
                      <MarkdownSplitEditor
                        value={suggestionDiffMarkdown ?? ''}
                        readOnly
                        height={360}
                        initialMode="split"
                        previewValue={
                          aiSuggestionState.manualSuggestedOverride ??
                          aiSuggestionState.lastSuggestedInstructions ??
                          ''
                        }
                        onModeChange={(nextMode) => {
                          if (nextMode === 'edit') {
                            handleStartEditSuggested();
                          }
                        }}
                        shouldChangeMode={(nextMode) => nextMode !== 'edit'}
                      />
                    </Space>
                  )
                ) : aiSuggestionState.currentInstructions.trim() ? (
                  <div
                    style={{
                      maxHeight: 280,
                      overflowY: 'auto',
                    }}>
                    <ReactMarkdown
                      remarkPlugins={[remarkGfm]}
                      components={{
                        p: (props) => (
                          <Typography.Paragraph
                            style={{ marginBottom: 8 }}
                            {...props}
                          />
                        ),
                        ul: (props) => (
                          <ul
                            style={{ paddingLeft: 20, marginBottom: 8 }}
                            {...props}
                          />
                        ),
                        ol: (props) => (
                          <ol
                            style={{ paddingLeft: 20, marginBottom: 8 }}
                            {...props}
                          />
                        ),
                        code: (props) => (
                          <Typography.Text
                            code
                            style={{
                              background: '#f5f5f5',
                              padding: '2px 4px',
                              borderRadius: 4,
                              fontSize: 12,
                            }}
                            {...props}
                          />
                        ),
                      }}>
                      {aiSuggestionState.currentInstructions}
                    </ReactMarkdown>
                  </div>
                ) : (
                  <Text type="secondary">No content available.</Text>
                )}
              </div>

              <div>
                <Text strong style={{ display: 'block', marginBottom: 6 }}>
                  {requestPromptLabel}
                </Text>
                <Input.TextArea
                  value={aiSuggestionState.userRequest}
                  onChange={(e) =>
                    setAiSuggestionState((prev) =>
                      prev ? { ...prev, userRequest: e.target.value } : prev,
                    )
                  }
                  placeholder={requestPlaceholder}
                  autoSize={{ minRows: 3, maxRows: 6 }}
                />
                <div
                  style={{
                    marginTop: 8,
                    display: 'flex',
                    justifyContent: 'flex-end',
                  }}>
                  <Button
                    type="primary"
                    onClick={handleAiSuggestionSubmit}
                    loading={aiSuggestionState.loading}
                    disabled={
                      !isGraphRunning ||
                      aiSuggestionState.loading ||
                      !aiSuggestionState.userRequest.trim() ||
                      !graphId ||
                      !node?.id
                    }>
                    {sendButtonLabel}
                  </Button>
                </div>
              </div>

              {aiSuggestionState.suggestedInstructions && (
                <div
                  style={{
                    marginTop: 12,
                    display: 'flex',
                    justifyContent: 'flex-end',
                  }}>
                  <Space>
                    <Button onClick={closeAiSuggestionModal}>Close</Button>
                    <Button type="primary" onClick={handleApplyAiSuggestion}>
                      Apply to field
                    </Button>
                  </Space>
                </div>
              )}
            </Space>
          )}
        </Modal>

        <Modal
          open={instructionsVisible}
          title="Agent instructions"
          footer={null}
          onCancel={() => setInstructionsVisible(false)}
          destroyOnClose
          width={520}
          bodyStyle={{ maxHeight: 420, overflowY: 'auto' }}>
          {agentInstructionsText ? (
            <div
              style={{
                margin: 0,
                wordBreak: 'break-word',
                fontSize: 13,
                lineHeight: 1.6,
              }}>
              <ReactMarkdown
                remarkPlugins={[remarkGfm]}
                components={{
                  p: (props) => (
                    <Typography.Paragraph
                      style={{ marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  ul: (props) => (
                    <ul
                      style={{ paddingLeft: 20, marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  ol: (props) => (
                    <ol
                      style={{ paddingLeft: 20, marginBottom: 8 }}
                      {...props}
                    />
                  ),
                  code: (props) => (
                    <Typography.Text
                      code
                      style={{
                        background: '#f5f5f5',
                        padding: '2px 4px',
                        borderRadius: 4,
                        fontSize: 12,
                      }}
                      {...props}
                    />
                  ),
                }}>
                {agentInstructionsText}
              </ReactMarkdown>
            </div>
          ) : (
            <Text type="secondary">No instructions available.</Text>
          )}
        </Modal>

        <Modal
          open={toolsVisible}
          title={`Connected Tools (${connectedTools.length})`}
          footer={null}
          onCancel={() => setToolsVisible(false)}
          destroyOnClose
          width={720}
          bodyStyle={{ maxHeight: 560, overflowY: 'auto' }}>
          {connectedTools.length > 0 ? (
            <Space direction="vertical" size="middle" style={{ width: '100%' }}>
              {connectedTools.map((tool) => (
                <div
                  key={tool.name}
                  style={{
                    border: '1px solid #f0f0f0',
                    borderRadius: 8,
                    padding: 16,
                    background: '#fafafa',
                  }}>
                  <div style={{ marginBottom: 12 }}>
                    <Text
                      strong
                      style={{
                        fontSize: 15,
                        display: 'block',
                        marginBottom: 8,
                      }}>
                      {tool.name}
                    </Text>
                    <Text
                      type="secondary"
                      style={{
                        fontSize: 13,
                        display: 'block',
                        wordBreak: 'break-word',
                      }}>
                      {tool.description}
                    </Text>
                  </div>
                  <div
                    style={{
                      padding: 12,
                      background: '#ffffff',
                      borderRadius: 6,
                      border: '1px solid #e8e8e8',
                      maxHeight: 320,
                      overflow: 'auto',
                    }}>
                    <JsonView
                      value={tool.schema as object}
                      style={lightTheme}
                      collapsed={1}
                    />
                  </div>
                </div>
              ))}
            </Space>
          ) : (
            <Text type="secondary">No connected tools available.</Text>
          )}
        </Modal>

        <Modal
          title="Edit Text"
          open={!!expandedTextarea}
          onCancel={handleExpandedTextareaSave}
          width={1200}
          footer={[
            <Button key="cancel" onClick={handleExpandedTextareaSave}>
              Close
            </Button>,
            <Button
              key="save"
              type="primary"
              onClick={handleExpandedTextareaSave}>
              Save
            </Button>,
          ]}>
          {expandedTextarea && (
            <>
              <MarkdownSplitEditor
                value={expandedTextarea.value}
                onChange={(nextValue) =>
                  setExpandedTextarea({
                    ...expandedTextarea,
                    value: nextValue,
                  })
                }
                height={520}
                placeholder="Enter markdownâ€¦"
                initialMode="split"
              />
              {expandedTextareaField?.prop['x-ui:ai-suggestions'] === true && (
                <AiSuggestionLink
                  onClick={() =>
                    openAiSuggestionModal(
                      expandedTextarea.fieldKey,
                      expandedTextareaField?.label || expandedTextarea.fieldKey,
                      expandedTextarea.value,
                    )
                  }
                  disabled={!isGraphRunning}
                  label="Improve with AI"
                />
              )}
            </>
          )}
        </Modal>
      </Sider>
    );
  },
  (prevProps, nextProps) => {
    const prevNodeData = getNodeData(prevProps.node);
    const nextNodeData = getNodeData(nextProps.node);

    const prevConfig = prevNodeData?.config;
    const nextConfig = nextNodeData?.config;
    const configEqual =
      JSON.stringify(prevConfig) === JSON.stringify(nextConfig);

    const messagesEqual =
      prevProps.messages === nextProps.messages &&
      prevProps.messages?.length === nextProps.messages?.length;
    const pendingEqual =
      prevProps.pendingMessages === nextProps.pendingMessages &&
      prevProps.pendingMessages?.length === nextProps.pendingMessages?.length;

    return (
      prevProps.visible === nextProps.visible &&
      prevProps.node?.id === nextProps.node?.id &&
      prevNodeData?.label === nextNodeData?.label &&
      prevNodeData?.template === nextNodeData?.template &&
      configEqual &&
      prevProps.graphStatus === nextProps.graphStatus &&
      prevProps.hasGlobalUnsavedChanges === nextProps.hasGlobalUnsavedChanges &&
      prevProps.selectedThreadId === nextProps.selectedThreadId &&
      prevProps.graphId === nextProps.graphId &&
      prevProps.compiledNodesLoading === nextProps.compiledNodesLoading &&
      prevProps.compiledNode?.status === nextProps.compiledNode?.status &&
      prevProps.compiledNode?.error === nextProps.compiledNode?.error &&
      prevProps.templates?.length === nextProps.templates?.length &&
      messagesEqual &&
      pendingEqual &&
      prevProps.messagesLoading === nextProps.messagesLoading &&
      prevProps.hasMoreMessages === nextProps.hasMoreMessages &&
      prevProps.loadingMoreMessages === nextProps.loadingMoreMessages &&
      prevProps.onLoadMoreMessages === nextProps.onLoadMoreMessages &&
      prevProps.draftNodeConfigVersion === nextProps.draftNodeConfigVersion
    );
  },
);
