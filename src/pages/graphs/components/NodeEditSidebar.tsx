// NodeEditSidebar.tsx
import { useEffect, useState } from 'react';
import {
  Button,
  Card,
  Form,
  Input,
  InputNumber,
  Layout,
  message,
  Modal,
  Space,
  Switch,
  Typography,
  Tabs,
} from 'antd';
import {
  CheckOutlined,
  CloseOutlined,
  DeleteOutlined,
  EditOutlined,
  ExpandOutlined,
  PlayCircleOutlined,
  PlusOutlined,
  SettingOutlined,
  MessageOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import type {
  GraphNode,
  GraphNodeData,
  FormField,
  KeyValuePair,
  SchemaProperty,
} from '../types';
import {
  GraphDtoStatusEnum,
  TemplateDto,
  ThreadMessageDto,
} from '../../../autogenerated';
import { threadsApi } from '../../../api';
import MessagesTab from './MessagesTab';

const { Sider } = Layout;
const { Title, Text } = Typography;

interface NodeEditSidebarProps {
  node: GraphNode | null;
  visible: boolean;
  onClose: () => void;
  onSave: (
    nodeId: string,
    updates: { name?: string; config?: Record<string, unknown> },
  ) => void;
  templates: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  onTriggerClick?: (nodeId: string) => void;
  selectedThreadId?: string;
  graphId?: string;
}

const KeyValuePairsInput = ({
  value,
  onChange,
}: {
  value?: KeyValuePair[];
  onChange?: (value: KeyValuePair[]) => void;
}) => {
  const [pairs, setPairs] = useState<KeyValuePair[]>(value || []);

  useEffect(() => {
    if (value) {
      setPairs(value);
    }
  }, [value]);

  const addPair = () => {
    const newPairs = [...pairs, { key: '', value: '' }];
    setPairs(newPairs);
    onChange?.(newPairs);
  };

  const removePair = (index: number) => {
    const newPairs = pairs.filter((_, i) => i !== index);
    setPairs(newPairs);
    onChange?.(newPairs);
  };

  const updatePair = (
    index: number,
    field: 'key' | 'value',
    newValue: string,
  ) => {
    const newPairs = pairs.map((pair, i) =>
      i === index ? { ...pair, [field]: newValue } : pair,
    );
    setPairs(newPairs);
    onChange?.(newPairs);
  };

  return (
    <div>
      {pairs.map((pair, index) => (
        <Card
          key={index}
          size="small"
          style={{
            marginBottom: 8,
            border: '1px solid #d9d9d9',
            borderRadius: 6,
          }}
          styles={{ body: { padding: 8 } }}>
          <Space.Compact style={{ width: '100%' }}>
            <Input
              placeholder="Key"
              value={pair.key}
              onChange={(e) => updatePair(index, 'key', e.target.value)}
              style={{ flex: 1 }}
            />
            <Input
              placeholder="Value"
              value={pair.value}
              onChange={(e) => updatePair(index, 'value', e.target.value)}
              style={{ flex: 1 }}
            />
            <Button
              type="text"
              danger
              icon={<DeleteOutlined />}
              onClick={() => removePair(index)}
            />
          </Space.Compact>
        </Card>
      ))}
      <Button
        type="dashed"
        onClick={addPair}
        icon={<PlusOutlined />}
        style={{
          width: '100%',
          borderStyle: 'dashed',
          borderColor: '#d9d9d9',
          color: '#666',
        }}
        size="middle">
        Add Key-Value Pair
      </Button>
    </div>
  );
};

export const NodeEditSidebar = ({
  node,
  visible,
  onClose,
  onSave,
  templates,
  graphStatus,
  onTriggerClick,
  selectedThreadId,
  graphId,
}: NodeEditSidebarProps) => {
  const [form] = Form.useForm();
  const [nodeName, setNodeName] = useState('');
  const [isEditingName, setIsEditingName] = useState(false);
  const [editingName, setEditingName] = useState('');
  const [formFields, setFormFields] = useState<FormField[]>([]);
  const [expandedTextarea, setExpandedTextarea] = useState<{
    fieldKey: string;
    value: string;
  } | null>(null);
  const [initialFormValues, setInitialFormValues] = useState<
    Record<string, unknown>
  >({});
  const [activeTab, setActiveTab] = useState('options');
  const [messages, setMessages] = useState<ThreadMessageDto[]>([]);
  const [messagesLoading, setMessagesLoading] = useState(false);
  const [hasMoreMessages, setHasMoreMessages] = useState(true);
  const [loadingMoreMessages, setLoadingMoreMessages] = useState(false);
  const [currentOffset, setCurrentOffset] = useState(0);

  const nodeData = node?.data as unknown as GraphNodeData;
  const templateSchema = nodeData?.templateSchema;
  const isAgentNode = nodeData?.templateKind === 'simpleAgent';

  useEffect(() => {
    if (node) {
      const nodeData = node.data;
      setNodeName((nodeData.label as string) || '');
      setEditingName((nodeData.label as string) || '');

      const currentNodeIsAgent = nodeData?.templateKind === 'simpleAgent';
      const availableTabs = ['options'];
      if (currentNodeIsAgent) {
        availableTabs.push('messages');
      }

      if (!availableTabs.includes(activeTab)) {
        setActiveTab('options');
      }

      const template = templates.find((t) => t.name === nodeData.template);

      if (template?.schema?.properties) {
        const fields: FormField[] = [];
        Object.entries(template.schema.properties).forEach(([key, prop]) => {
          const typedProp = prop as SchemaProperty;
          const isConst = typedProp.const !== undefined;
          const isObject =
            typedProp.type === 'object' && typedProp.additionalProperties;

          fields.push({
            ...typedProp,
            key,
            name: typedProp.title || key,
            description: typedProp.description,
            type: isObject ? 'object' : typedProp.type || 'string',
            required: template.schema.required?.includes(key) || false,
            default: typedProp.default,
            const: typedProp.const,
            isConst,
            isObject,
          });
        });

        setFormFields(fields);

        const initialValues: Record<string, unknown> = {};
        fields.forEach((field) => {
          if (field.isConst) {
            initialValues[field.key] = field.const;
          } else {
            initialValues[field.key] =
              (nodeData.config as Record<string, unknown>)?.[field.key] ??
              field.default ??
              '';
          }
        });

        form.resetFields();
        form.setFieldsValue(initialValues);
      } else {
        setFormFields([]);
      }

      const currentValuesNow = form.getFieldsValue(true);
      setInitialFormValues(currentValuesNow);
    }
  }, [node, form, templates]);

  useEffect(() => {
    const loadMessages = async () => {
      if (!selectedThreadId || !node?.id || !isAgentNode) {
        setMessages([]);
        setHasMoreMessages(true);
        setCurrentOffset(0);
        return;
      }

      try {
        setMessagesLoading(true);
        const response = await threadsApi.getThreadMessages(
          selectedThreadId,
          node.id,
          50,
          0,
        );
        const newMessages = response.data?.reverse() || [];
        setMessages(newMessages);
        setHasMoreMessages(newMessages.length === 50);
        setCurrentOffset(50);
      } catch (error) {
        console.error('Error loading messages:', error);
        message.error('Failed to load messages');
        setMessages([]);
        setHasMoreMessages(false);
      } finally {
        setMessagesLoading(false);
      }
    };

    loadMessages();
  }, [selectedThreadId, node?.id, isAgentNode]);

  const loadMoreMessages = async () => {
    if (
      !selectedThreadId ||
      !node?.id ||
      !isAgentNode ||
      loadingMoreMessages ||
      !hasMoreMessages
    ) {
      return;
    }

    try {
      setLoadingMoreMessages(true);
      const response = await threadsApi.getThreadMessages(
        selectedThreadId,
        node.id,
        50,
        currentOffset,
      );
      const newMessages = response.data?.reverse() || [];

      if (newMessages.length > 0) {
        setMessages((prev) => [...newMessages, ...prev]);
        setCurrentOffset((prev) => prev + newMessages.length);
        setHasMoreMessages(newMessages.length === 50);
      } else {
        setHasMoreMessages(false);
      }
    } catch (error) {
      console.error('Error loading more messages:', error);
      message.error('Failed to load more messages');
    } finally {
      setLoadingMoreMessages(false);
    }
  };

  const refreshMessages = async () => {
    if (!selectedThreadId || !node?.id || !isAgentNode) {
      return;
    }
    try {
      setMessagesLoading(true);
      const response = await threadsApi.getThreadMessages(
        selectedThreadId,
        node.id,
        50,
        0,
      );
      const newMessages = response.data?.reverse() || [];
      setMessages(newMessages);
      setHasMoreMessages(newMessages.length === 50);
      setCurrentOffset(50);
    } catch (error) {
      console.error('Error refreshing messages:', error);
      message.error('Failed to refresh messages');
    } finally {
      setMessagesLoading(false);
    }
  };

  const autoSaveNodeChanges = async () => {
    if (!node) return;

    try {
      const configValues: Record<string, unknown> = {};

      formFields.forEach((field) => {
        const key = field.key;

        // Always include constant values
        if (field.isConst) {
          configValues[key] = field.const as unknown;
          return;
        }

        const rawValue = form.getFieldValue(key);

        // For non-constant fields, determine emptiness precisely
        const isEmptyString =
          typeof rawValue === 'string' && rawValue.trim() === '';
        const isEmptyArray = Array.isArray(rawValue) && rawValue.length === 0;
        const isEmptyObject =
          field.type === 'object' &&
          rawValue &&
          typeof rawValue === 'object' &&
          !Array.isArray(rawValue) &&
          Object.keys(rawValue as object).length === 0;

        const isTrulyEmpty =
          rawValue === null ||
          rawValue === undefined ||
          isEmptyString ||
          isEmptyArray ||
          isEmptyObject;

        // For booleans, false is a valid value and should not be treated as empty
        if (isTrulyEmpty && field.type !== 'boolean') {
          return;
        }

        let processedValue: unknown = rawValue;

        switch (field.type) {
          case 'number':
          case 'integer': {
            if (typeof rawValue === 'string') {
              const num = Number(rawValue);
              if (Number.isNaN(num)) {
                return; // skip invalid number
              }
              processedValue = field.type === 'integer' ? Math.trunc(num) : num;
            } else if (typeof rawValue === 'number') {
              processedValue =
                field.type === 'integer' ? Math.trunc(rawValue) : rawValue;
            } else {
              return; // unsupported type for number
            }
            break;
          }
          case 'array': {
            if (typeof rawValue === 'string') {
              processedValue = rawValue
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line !== '');
            } else if (Array.isArray(rawValue)) {
              processedValue = rawValue;
            } else if (rawValue == null) {
              return;
            }
            break;
          }
          case 'object': {
            if (typeof rawValue === 'string') {
              try {
                const parsed = JSON.parse(rawValue);
                processedValue = parsed;
              } catch {
                // If JSON is invalid, skip saving this field
                return;
              }
            } else if (
              rawValue &&
              typeof rawValue === 'object' &&
              !Array.isArray(rawValue)
            ) {
              processedValue = rawValue;
            } else if (rawValue == null) {
              return;
            }
            break;
          }
          case 'boolean': {
            // Preserve exact boolean value including false
            processedValue = Boolean(rawValue);
            break;
          }
          case 'string':
          default: {
            if (typeof rawValue === 'string') {
              const trimmed = rawValue.trim();
              if (trimmed === '') {
                return;
              }
              processedValue = trimmed;
            } else {
              processedValue = rawValue;
            }
          }
        }

        configValues[key] = processedValue;
      });

      onSave(node.id, {
        name: nodeName,
        config: configValues,
      });

      const currentValues = form.getFieldsValue(true);
      setInitialFormValues(currentValues);
    } catch (error) {
      console.error('Auto-save failed:', error);
    }
  };

  const handleFormChange = (
    changedValues: Record<string, unknown>,
    allValues: Record<string, unknown>,
  ) => {
    const hasRealChanges = Object.keys(changedValues).some((key) => {
      const currentValue = allValues[key];
      const initialValue = initialFormValues[key];
      return JSON.stringify(currentValue) !== JSON.stringify(initialValue);
    });

    if (hasRealChanges) {
      // Auto-save changes immediately
      autoSaveNodeChanges();
    }
  };

  const handleClose = () => {
    onClose();
  };

  const handleNameEdit = () => {
    setIsEditingName(true);
    setEditingName(nodeName);
  };

  const handleNameSave = () => {
    if (editingName !== nodeName) {
      setNodeName(editingName);
      // Auto-save name changes immediately
      if (node) {
        onSave(node.id, {
          name: editingName,
        });
      }
    }
    setIsEditingName(false);
  };

  const handleNameCancel = () => {
    setEditingName(nodeName);
    setIsEditingName(false);
  };

  const renderFormField = (field: FormField) => {
    const {
      key,
      name,
      description,
      type,
      required,
      isConst,
      const: constValue,
    } = field;

    const rules = required
      ? [{ required: true, message: `${name} is required` }]
      : undefined;

    const descriptionNode = description ? (
      <Text
        type="secondary"
        style={{
          fontSize: 12,
          fontWeight: 'normal',
        }}>
        {description}
      </Text>
    ) : undefined;

    const commonProps = {
      name: key,
      label: name,
      required,
      rules,
      extra: descriptionNode,
      style: {
        marginBottom: '20px',
      },
    } as const;

    if (isConst) {
      return (
        <Form.Item key={key} {...commonProps} initialValue={constValue}>
          <Input disabled size="middle" value={String(constValue)} />
        </Form.Item>
      );
    }

    const shouldUseTextarea =
      (field as SchemaProperty)['x-ui:textarea'] === true;

    switch (type) {
      case 'string':
        if (shouldUseTextarea) {
          return (
            <Form.Item
              key={key}
              label={name}
              required={required}
              rules={rules}
              extra={descriptionNode}
              style={{ marginBottom: '20px' }}>
              <div style={{ position: 'relative' }}>
                <Form.Item name={key} noStyle>
                  <Input.TextArea
                    placeholder={`Enter ${name.toLowerCase()}`}
                    rows={4}
                    size="middle"
                    style={{ paddingRight: '32px' }}
                  />
                </Form.Item>
                <Button
                  type="text"
                  icon={<ExpandOutlined />}
                  size="small"
                  style={{
                    position: 'absolute',
                    right: '4px',
                    top: '4px',
                    zIndex: 1,
                  }}
                  onClick={() => {
                    const currentValue = form.getFieldValue(key) || '';
                    setExpandedTextarea({ fieldKey: key, value: currentValue });
                  }}
                />
              </div>
            </Form.Item>
          );
        }

        return (
          <Form.Item key={key} {...commonProps}>
            <Input placeholder={`Enter ${name.toLowerCase()}`} size="middle" />
          </Form.Item>
        );

      case 'number':
        return (
          <Form.Item key={key} {...commonProps}>
            <InputNumber
              style={{ width: '100%' }}
              placeholder={`Enter ${name.toLowerCase()}`}
              size="middle"
            />
          </Form.Item>
        );

      case 'boolean':
        return (
          <Form.Item key={key} {...commonProps} valuePropName="checked">
            <Switch />
          </Form.Item>
        );

      case 'array':
        return (
          <Form.Item key={key} {...commonProps}>
            <Input.TextArea
              placeholder={`Enter ${name.toLowerCase()} (one per line)`}
              rows={3}
              size="middle"
            />
          </Form.Item>
        );

      case 'object':
        return (
          <Form.Item key={key} {...commonProps}>
            <KeyValuePairsInput />
          </Form.Item>
        );

      default:
        return (
          <Form.Item key={key} {...commonProps}>
            <Input placeholder={`Enter ${name.toLowerCase()}`} size="middle" />
          </Form.Item>
        );
    }
  };

  const isTriggerNode = nodeData?.templateKind === 'trigger';
  const isGraphRunning = graphStatus === GraphDtoStatusEnum.Running;
  const canTrigger = isTriggerNode && isGraphRunning;

  const renderOptionsTabContent = () => {
    return (
      <div
        style={{
          flex: 1,
          minHeight: 0,
          display: 'flex',
          flexDirection: 'column',
        }}>
        <div
          style={{
            flexShrink: 0,
            padding: '8px 4px 0 4px',
          }}>
          <Title level={5} style={{ marginBottom: 8 }}>
            Configuration
          </Title>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            overflow: 'auto',
            padding: '0 4px 8px 4px',
          }}>
          {formFields.length > 0 ? (
            <Form
              form={form}
              layout="vertical"
              size="small"
              style={{ marginTop: 0 }}
              labelCol={{ style: { paddingBottom: 4 } }}
              preserve={false}
              onValuesChange={handleFormChange}>
              {formFields.map(renderFormField)}
            </Form>
          ) : (
            <Text type="secondary">
              No configuration options available for this template.
            </Text>
          )}
        </div>
      </div>
    );
  };

  const renderMessagesTabContent = () => {
    return (
      <div
        style={{
          flex: 1,
          minHeight: 0,
          display: 'flex',
          flexDirection: 'column',
        }}>
        <div
          style={{
            flexShrink: 0,
            padding: '8px 0 8px 0',
            marginBottom: 0,
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            gap: 8,
          }}>
          <Title level={5} style={{ margin: 0 }}>
            Messages
          </Title>
          <Button
            size="small"
            icon={<ReloadOutlined />}
            onClick={refreshMessages}
            loading={messagesLoading}
            disabled={!selectedThreadId || !node?.id || !isAgentNode}></Button>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            overflow: 'hidden',
          }}>
          <MessagesTab
            messages={messages}
            messagesLoading={messagesLoading}
            selectedThreadId={selectedThreadId}
            nodeId={node?.id}
            isAgentNode={isAgentNode}
            nodeTemplateKind={nodeData?.templateKind}
            onLoadMoreMessages={loadMoreMessages}
            hasMoreMessages={hasMoreMessages}
            loadingMore={loadingMoreMessages}
          />
        </div>
      </div>
    );
  };

  const tabHeaders = [
    {
      key: 'options',
      label: (
        <span>
          <SettingOutlined style={{ marginRight: 8 }} />
          Options
        </span>
      ),
    },
    ...(isAgentNode
      ? [
          {
            key: 'messages',
            label: (
              <span>
                <MessageOutlined style={{ marginRight: 8 }} />
                Messages
              </span>
            ),
          },
        ]
      : []),
  ];

  if (!visible) {
    return null;
  }

  return (
    <Sider
      width={400}
      style={{
        background: '#fff',
        borderLeft: '1px solid #f0f0f0',
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
      }}>
      <div
        style={{
          padding: '16px',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 16,
            paddingBottom: 16,
            borderBottom: '1px solid #f0f0f0',
            flexShrink: 0,
          }}>
          <Title level={4} style={{ margin: 0 }}>
            Edit Node
          </Title>
          <Space>
            {isTriggerNode && (
              <Button
                type="primary"
                icon={<PlayCircleOutlined />}
                disabled={!canTrigger}
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  onTriggerClick?.(node?.id || '');
                }}
                size="small">
                Trigger
              </Button>
            )}
            <Button
              onClick={handleClose}
              icon={<CloseOutlined />}
              size="small"></Button>
          </Space>
        </div>

        <div style={{ flexShrink: 0, marginBottom: 16 }}>
          {isEditingName ? (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <Input
                value={editingName}
                onChange={(e) => setEditingName(e.target.value)}
                onPressEnter={handleNameSave}
                onBlur={handleNameSave}
                autoFocus
                style={{ flex: 1 }}
              />
              <Button
                type="text"
                icon={<CheckOutlined />}
                onClick={handleNameSave}
                size="small"
              />
              <Button
                type="text"
                icon={<CloseOutlined />}
                onClick={handleNameCancel}
                size="small"
              />
            </div>
          ) : (
            <div style={{ display: 'flex', alignItems: 'center', gap: 15 }}>
              <Text
                strong
                style={{
                  flex: 1,
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  display: 'block',
                }}>
                {nodeName}
              </Text>
              <Button
                type="text"
                icon={<EditOutlined />}
                onClick={handleNameEdit}
                size="small"
              />
            </div>
          )}

          <div>
            <Text strong>Template:</Text> {nodeData?.template}
          </div>
          <div>
            <Text strong>Kind:</Text> {nodeData?.templateKind}
          </div>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            overflow: 'hidden',
            display: 'flex',
            flexDirection: 'column',
          }}>
          <Tabs
            activeKey={activeTab}
            onChange={setActiveTab}
            items={tabHeaders}
            tabBarStyle={{ marginBottom: 0, flexShrink: 0 }}
            style={{
              flexShrink: 0,
              display: 'flex',
              flexDirection: 'column',
            }}
          />

          <div
            style={{
              flex: 1,
              minHeight: 0,
              overflow: 'hidden',
              display: 'flex',
              flexDirection: 'column',
            }}>
            {activeTab === 'options'
              ? renderOptionsTabContent()
              : renderMessagesTabContent()}
          </div>
        </div>
      </div>

      <Modal
        title="Edit Text"
        open={!!expandedTextarea}
        onCancel={() => setExpandedTextarea(null)}
        width={800}
        footer={[
          <Button key="cancel" onClick={() => setExpandedTextarea(null)}>
            Cancel
          </Button>,
          <Button
            key="save"
            type="primary"
            onClick={() => {
              if (expandedTextarea) {
                form.setFieldValue(
                  expandedTextarea.fieldKey,
                  expandedTextarea.value,
                );
                setExpandedTextarea(null);
              }
            }}>
            Save
          </Button>,
        ]}>
        {expandedTextarea && (
          <Input.TextArea
            value={expandedTextarea.value}
            onChange={(e) =>
              setExpandedTextarea({
                ...expandedTextarea,
                value: e.target.value,
              })
            }
            rows={20}
            style={{ fontFamily: 'monospace' }}
            placeholder="Enter your text here..."
          />
        )}
      </Modal>
    </Sider>
  );
};
