import React, { useEffect, useMemo, useRef } from 'react';
import type { CSSProperties } from 'react';
import { Handle, NodeProps, Position, useStore } from '@xyflow/react';
import { Button, Card, Space, Tag, Tooltip, Typography } from 'antd';
import {
  DeleteOutlined,
  ExclamationCircleOutlined,
  PlayCircleOutlined,
} from '@ant-design/icons';
import type { GraphEdge, GraphNode, GraphNodeData } from '../types';
import { makeHandleId } from './GraphCanvas';
import { GraphValidationService } from '../../../services/GraphValidationService';
import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  TemplateDto,
} from '../../../autogenerated';

const ensureNodeStatusPulseStyle = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') {
      return;
    }
    if (document.getElementById('graph-node-status-pulse-style')) {
      injected = true;
      return;
    }
    const styleEl = document.createElement('style');
    styleEl.id = 'graph-node-status-pulse-style';
    styleEl.textContent = `
      @keyframes graph-node-status-pulse {
        0% { box-shadow: 0 0 0 0 rgba(82, 196, 26, 0.6); }
        70% { box-shadow: 0 0 0 8px rgba(82, 196, 26, 0); }
        100% { box-shadow: 0 0 0 0 rgba(82, 196, 26, 0); }
      }
    `;
    document.head.appendChild(styleEl);
    injected = true;
  };
})();

const { Text } = Typography;

interface CustomNodeProps extends NodeProps {
  templates?: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  onTriggerClick?: (nodeId: string) => void;
  compiledNode?: GraphNodeWithStatusDto;
  compiledNodesLoading?: boolean;
}

export const CustomNode = React.memo(
  ({
    id: nodeId,
    data,
    selected,
    templates = [],
    isConnectable = true,
    graphStatus,
    onTriggerClick,
    compiledNode,
    compiledNodesLoading,
  }: CustomNodeProps) => {
    const nodeData = data as unknown as GraphNodeData;
    const allNodes = useStore((s) => s.nodes) as GraphNode[];
    const allEdges = useStore((s) => s.edges) as GraphEdge[];
    const nodeTemplate = templates?.find((t) => t.id === nodeData.template);

    useEffect(() => {
      ensureNodeStatusPulseStyle();
    }, []);

    const getKindColor = (kind?: string) => {
      const map: Record<string, string> = {
        runtime: 'blue',
        tool: 'green',
        simpleagent: 'orange',
        trigger: 'red',
        resource: 'purple',
        default: 'gray',
      };
      return map[kind?.toLowerCase() || 'default'] || 'gray';
    };

    const getMetadataProperties = () => {
      if (!nodeData.templateSchema?.properties)
        return [] as { key: string; value: unknown; title: string }[];
      return Object.entries(nodeData.templateSchema.properties)
        .filter(([, prop]) => prop['x-ui:show-on-node'] === true)
        .map(([key, prop]) => ({
          key,
          value: nodeData.config[key] ?? prop.const ?? prop.default ?? '',
          title: prop['x-ui:label'] ?? prop.title ?? key,
        }))
        .filter(
          (x) => x.value !== undefined && x.value !== null && x.value !== '',
        );
    };

    const metadataProperties = getMetadataProperties();

    const validationErrors = useMemo(
      () =>
        templates.length > 0 && allNodes.length > 0 && allEdges.length > 0
          ? GraphValidationService.getNodeValidationErrors(
              nodeId,
              allNodes,
              allEdges,
              templates,
            )
          : [],
      [allEdges, allNodes, nodeId, templates],
    );
    const hasValidationErrors = validationErrors.length > 0;

    const inputRules = useMemo(
      () =>
        templates.length > 0 && nodeId
          ? GraphValidationService.getAvailableConnectionTypes(
              {
                id: nodeId,
                data: nodeData as unknown as Record<string, unknown>,
                position: { x: 0, y: 0 },
                type: 'custom',
              } satisfies GraphNode,
              templates,
            )
          : [],
      [nodeData, nodeId, templates],
    );

    const contentRef = useRef<HTMLDivElement | null>(null);

    const targets = useMemo(() => inputRules, [inputRules]);

    const outMissing =
      inputRules.some((r) => r.required) &&
      !allEdges.some((e) => e.source === nodeId);

    // Check if this is a trigger node and if graph is running
    const isTriggerNode = nodeTemplate?.kind === 'trigger';
    const isGraphRunning = graphStatus === GraphDtoStatusEnum.Running;
    const isGraphCompiling = graphStatus === GraphDtoStatusEnum.Compiling;
    const isGraphActive = isGraphRunning || isGraphCompiling;
    const canTrigger = isTriggerNode && isGraphRunning;
    const color = (
      role: 'target' | 'source',
      _required: boolean,
      missing: boolean,
    ) => {
      if (missing) {
        return {
          bg: '#ff4d4f',
          br: '2px solid white',
          sh: '0 0 0 1px rgba(255,77,79,0.5)',
        };
      }
      if (role === 'source') {
        return {
          bg: '#52c41a',
          br: '2px solid white',
          sh: '0 0 0 1px rgba(82,196,26,0.5)',
        };
      }
      return {
        bg: '#1890ff',
        br: '2px solid white',
        sh: '0 0 0 1px rgba(24,144,255,0.5)',
      };
    };

    const statusDotColorMap: Record<string, string> = {
      running: '#52c41a',
      idle: '#1890ff',
      starting: '#2f54eb',
      stopped: '#ff4d4f',
    };

    const templateKindLower = (nodeTemplate?.kind || '').toLowerCase();
    const showNodeStatus = ['runtime', 'simpleagent', 'trigger'].includes(
      templateKindLower,
    );

    const formattedStatus = compiledNode?.status
      ? `${compiledNode.status.charAt(0).toUpperCase()}${compiledNode.status.slice(1)}`
      : isGraphCompiling
        ? 'Compiling'
        : 'Unknown';

    const statusTooltip = !isGraphActive
      ? 'Not running'
      : compiledNodesLoading
        ? 'Loading status...'
        : formattedStatus;

    const statusDotColor = !isGraphActive
      ? '#d9d9d9'
      : compiledNodesLoading
        ? '#1890ff'
        : compiledNode?.status
          ? (statusDotColorMap[compiledNode.status] ?? '#d9d9d9')
          : '#d9d9d9';

    const isStatusRunning =
      isGraphActive &&
      !compiledNodesLoading &&
      compiledNode?.status === 'running';

    const statusDotStyle: CSSProperties = {
      width: 8,
      height: 8,
      borderRadius: '50%',
      backgroundColor: statusDotColor,
      display: 'inline-block',
      cursor: 'help',
      boxShadow: isStatusRunning ? '0 0 0 0 rgba(82, 196, 26, 0.6)' : 'none',
      animation: isStatusRunning
        ? 'graph-node-status-pulse 1.5s ease-out infinite'
        : undefined,
    };

    const statusDot = showNodeStatus ? (
      <Tooltip title={statusTooltip} placement="top">
        <span style={statusDotStyle} />
      </Tooltip>
    ) : null;

    return (
      <Card
        size="small"
        style={{
          minWidth: 300,
          position: 'relative',
          zIndex: 1,
          border: hasValidationErrors
            ? '2px solid #ff4d4f'
            : selected
              ? '1px solid #1890ff'
              : '1px solid #d9d9d9',
          borderRadius: 8,
          boxShadow: hasValidationErrors
            ? '0 4px 12px rgba(255, 77, 79, 0.3)'
            : selected
              ? '0 4px 12px rgba(24, 144, 255, 0.3)'
              : '0 2px 8px rgba(0, 0, 0, 0.1)',
        }}
        styles={{
          body: {
            padding: 0,
            position: 'relative',
          },
        }}>
        <div
          style={{
            background: '#F3F6FF',
            padding: 12,
            borderBottom: '1px solid #dfdfdf',
            borderRadius: '8px 8px 0 0',
          }}>
          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              gap: 15,
            }}>
            <Space size="small" align="center">
              <Space size={8} align="center">
                {statusDot}
                <Text
                  strong
                  style={{
                    fontSize: 14,
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    maxWidth: 260,
                    display: 'block',
                  }}>
                  {nodeData.label}
                </Text>
              </Space>
              <Tag
                color={getKindColor(nodeData.templateKind)}
                style={{ margin: 0, fontSize: 10 }}>
                {nodeData.templateKind}
              </Tag>
              <Tag color="geekblue" style={{ margin: 0, fontSize: 10 }}>
                {nodeData.template}
              </Tag>
              {compiledNode?.error && (
                <Tooltip title={compiledNode.error} placement="top">
                  <ExclamationCircleOutlined
                    style={{ color: '#ff4d4f', fontSize: 14 }}
                  />
                </Tooltip>
              )}
            </Space>
            <Space size="small">
              {hasValidationErrors && (
                <Tooltip
                  title={
                    <div>
                      <div style={{ fontWeight: 'bold', marginBottom: 4 }}>
                        Validation Errors:
                      </div>
                      {validationErrors.map((e, i) => (
                        <div key={i} style={{ fontSize: 12 }}>
                          • {e.message}
                        </div>
                      ))}
                    </div>
                  }
                  placement="top">
                  <ExclamationCircleOutlined
                    style={{ color: '#ff4d4f', fontSize: 16, cursor: 'help' }}
                  />
                </Tooltip>
              )}
              {nodeData.onDelete && (
                <Button
                  type="text"
                  size="small"
                  danger
                  icon={<DeleteOutlined />}
                  onClick={(e) => {
                    e.stopPropagation();
                    nodeData.onDelete?.();
                  }}
                />
              )}
            </Space>
          </div>

          <div ref={contentRef} style={{ position: 'relative', marginTop: 8 }}>
            {metadataProperties.length > 0 && (
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: 4 }}>
                {metadataProperties.map(({ key, value, title }) => (
                  <Tag
                    key={key}
                    color="default"
                    bordered={false}
                    style={{ fontSize: 10, margin: 0, background: '#dee6ff' }}>
                    {title}: {String(value)}
                  </Tag>
                ))}
              </div>
            )}

            <Text
              type="secondary"
              style={{
                fontSize: 12,
                display: 'block',
                marginTop: 5,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
              }}>
              {nodeTemplate?.description}
            </Text>
          </div>
        </div>

        <div
          style={{
            display: 'flex',
            gap: 16,
            padding: 12,
          }}>
          <div
            style={{
              flex: 1,
              display: 'flex',
              flexDirection: 'column',
              gap: 6,
            }}>
            {targets.map((t) => {
              const id = makeHandleId('target', t);
              const miss =
                t.required && !allEdges.some((e) => e.target === nodeId);
              const c = color('target', t.required, miss);
              return (
                <div
                  key={id}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    position: 'relative',
                    minHeight: 18,
                  }}>
                  <Handle
                    type="target"
                    id={id}
                    isConnectable={isConnectable}
                    position={Position.Left}
                    style={{
                      width: '12px',
                      height: '12px',
                      position: 'absolute',
                      left: '-12px',
                      background: miss ? '#ff5d5d' : c.bg,
                      border: c.br,
                      boxShadow: c.sh,
                    }}
                  />
                  <span
                    style={{
                      fontSize: 11,
                      color: miss ? '#ff4d4f' : 'white',
                      marginLeft: 3,
                      whiteSpace: 'nowrap',
                      background: miss ? '#ff5d5d' : c.bg,
                      padding: '2px 10px',
                      borderRadius: '10px',
                    }}>
                    {t.value}
                    {t.required ? ' • required' : ''}
                    {t.multiple ? ' • multiple' : ''}
                  </span>
                </div>
              );
            })}
          </div>

          <div
            style={{
              flex: 1,
              display: 'flex',
              flexDirection: 'column',
              gap: 6,
            }}>
            {nodeTemplate?.outputs?.map((output) => {
              const outRule: {
                type: 'kind' | 'template';
                value: string;
                required?: boolean;
                multiple?: boolean;
              } = {
                type: output.type as 'kind' | 'template',
                value: String(output.value),
                required: output.required,
                multiple: output.multiple,
              };
              const id = makeHandleId('source', outRule);
              const miss =
                output.required && !allEdges.some((e) => e.target === nodeId);
              const c = color('source', output.required || false, false);
              return (
                <div
                  key={id}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'flex-end',
                    position: 'relative',
                    minHeight: 18,
                  }}>
                  <span
                    style={{
                      fontSize: 11,
                      marginRight: 3,
                      whiteSpace: 'nowrap',
                      background: miss ? '#ff5d5d' : c.bg,
                      padding: '2px 10px',
                      borderRadius: '10px',
                      color: 'white',
                    }}>
                    {output.value}
                    {output.required ? ' • required' : ''}
                    {output.multiple ? ' • multiple' : ''}
                  </span>
                  <Handle
                    type="source"
                    id={id}
                    isConnectable={isConnectable}
                    position={Position.Right}
                    style={{
                      background: miss ? '#ff5d5d' : c.bg,
                      border: c.br,
                      boxShadow: c.sh,
                      width: '12px',
                      height: '12px',
                      position: 'absolute',
                      right: '-12px',
                    }}
                  />
                </div>
              );
            })}
            {nodeTemplate?.outputs === undefined && (
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'flex-end',
                  position: 'relative',
                  minHeight: 18,
                  paddingRight: 6,
                }}>
                <span
                  style={{
                    fontSize: 11,
                    color: '#595959',
                    marginRight: 8,
                    whiteSpace: 'nowrap',
                  }}>
                  output
                </span>
                <Handle
                  type="source"
                  id="source-out"
                  isConnectable={isConnectable}
                  position={Position.Right}
                  style={{
                    background: color('source', false, outMissing).bg,
                    border: color('source', false, outMissing).br,
                    boxShadow: color('source', false, outMissing).sh,
                    width: '12px',
                    height: '12px',
                    position: 'absolute',
                    right: '-12px',
                  }}
                />
              </div>
            )}
          </div>
        </div>

        {/* Actions row */}
        {isTriggerNode && (
          <div
            style={{
              display: 'flex',
              justifyContent: 'center',
              padding: 12,
              borderTop: '1px solid #dfdfdf',
            }}>
            <Button
              type="primary"
              size="small"
              icon={<PlayCircleOutlined />}
              disabled={!canTrigger}
              onClick={() => onTriggerClick?.(nodeId)}
              style={{
                fontSize: '11px',
                padding: '0 20px',
              }}>
              Trigger
            </Button>
          </div>
        )}
      </Card>
    );
  },
  (prevProps, nextProps) => {
    // Custom comparison function to prevent unnecessary rerenders
    // Only rerender if relevant props change
    // Note: We compare data.label and data.template instead of the whole data object
    // since the data object reference changes frequently but content may not
    const prevData = prevProps.data as unknown as GraphNodeData;
    const nextData = nextProps.data as unknown as GraphNodeData;

    return (
      prevProps.id === nextProps.id &&
      prevProps.selected === nextProps.selected &&
      prevData?.label === nextData?.label &&
      prevData?.template === nextData?.template &&
      prevProps.graphStatus === nextProps.graphStatus &&
      prevProps.compiledNodesLoading === nextProps.compiledNodesLoading &&
      prevProps.compiledNode?.status === nextProps.compiledNode?.status &&
      prevProps.compiledNode?.error === nextProps.compiledNode?.error &&
      prevProps.templates?.length === nextProps.templates?.length
    );
  },
);
