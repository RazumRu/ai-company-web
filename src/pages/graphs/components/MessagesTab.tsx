// MessagesTab.tsx
import React, { useEffect, useRef, useCallback, useState } from 'react';
import { Avatar, Typography, Space, Spin, Popover, message } from 'antd';
import { ToolOutlined, CopyOutlined } from '@ant-design/icons';
import type { ThreadMessageDto } from '../../../autogenerated';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';

interface ToolCallFunction {
  name?: string;
  arguments?: string | Record<string, unknown>;
}

interface ToolCall {
  id?: string;
  name?: string;
  function?: ToolCallFunction;
  args?: string | Record<string, unknown>;
}

interface ShellResult {
  command?: string;
  exitCode?: number;
  output?: string;
  stdout?: string;
  stderr?: string;
  [key: string]: unknown;
}

interface PendingMessage {
  content: string;
  role: 'human' | 'ai';
  additionalKwargs?: {
    run_id?: string;
    created_at?: string;
    [key: string]: unknown;
  };
  createdAt?: string;
}

type JsonValue =
  | string
  | number
  | boolean
  | null
  | JsonValue[]
  | { [key: string]: JsonValue };

const { Text } = Typography;

interface MessagesTabProps {
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  selectedThreadId?: string;
  nodeId?: string;
  isAgentNode?: boolean;
  nodeTemplateKind?: string;
  onLoadMoreMessages?: () => void;
  hasMoreMessages?: boolean;
  loadingMore?: boolean;
  isNodeRunning?: boolean;
  pendingMessages?: PendingMessage[];
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

const ensureThinkingIndicatorStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-thinking-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-thinking-style';
    style.textContent = `
      @keyframes messages-tab-thinking-pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const MessagesTab: React.FC<MessagesTabProps> = ({
  messages,
  messagesLoading,
  selectedThreadId,
  nodeId,
  isAgentNode = true,
  nodeTemplateKind,
  onLoadMoreMessages,
  hasMoreMessages,
  loadingMore,
  isNodeRunning = false,
  pendingMessages = [],
  newMessageMode,
}) => {
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const prevScrollHeightRef = useRef<number>(0);
  const isPrependingRef = useRef<boolean>(false);
  const pendingAutoScrollRef = useRef<boolean>(false);
  const autoScrollDisabledRef = useRef<boolean>(false);
  const lastMessageCountRef = useRef<number>(0);

  useEffect(() => {
    ensureThinkingIndicatorStyles();
  }, []);

  useEffect(() => {
    pendingAutoScrollRef.current = true;
  }, [selectedThreadId, nodeId]);

  useEffect(() => {
    if (!isPrependingRef.current) return;
    const el = scrollContainerRef.current;
    if (el) {
      const diff = el.scrollHeight - prevScrollHeightRef.current;
      el.scrollTop = diff + el.scrollTop;
    }
    isPrependingRef.current = false;
  }, [messages.length]);

  useEffect(() => {
    if (messagesLoading) return;
    const el = scrollContainerRef.current;
    if (!el) return;

    const isInitiallyEmpty = lastMessageCountRef.current === 0;
    const shouldAutoScroll =
      pendingAutoScrollRef.current ||
      isInitiallyEmpty ||
      !autoScrollDisabledRef.current;

    if (shouldAutoScroll) {
      el.scrollTop = el.scrollHeight;
    }

    pendingAutoScrollRef.current = false;
    lastMessageCountRef.current = messages.length;
  }, [messagesLoading, messages.length]);

  useEffect(() => {
    // Inject scrollbar styles for webkit browsers
    const styleId = 'shell-scrollbar-styles';
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      .shell-output-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .shell-output-container::-webkit-scrollbar-track {
        background: #2a2a2a;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb:hover {
        background: #666;
      }
    `;
    document.head.appendChild(style);

    return () => {
      const existingStyle = document.getElementById(styleId);
      if (existingStyle) {
        existingStyle.remove();
      }
    };
  }, []);

  const handleScroll = useCallback(() => {
    const el = scrollContainerRef.current;
    if (!el) return;
    const nearTop = el.scrollTop <= 100;
    if (
      nearTop &&
      hasMoreMessages &&
      !loadingMore &&
      typeof onLoadMoreMessages === 'function'
    ) {
      prevScrollHeightRef.current = el.scrollHeight;
      isPrependingRef.current = true;
      onLoadMoreMessages();
    }
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight <= 48;
    autoScrollDisabledRef.current = !nearBottom;
  }, [hasMoreMessages, loadingMore, onLoadMoreMessages]);

  const formatMessageContent = (content: unknown): string => {
    if (typeof content === 'string') return content;
    if (typeof content === 'object' && content !== null)
      return JSON.stringify(content, null, 2);
    return String(content ?? '');
  };

  const isBlankContent = (content: unknown): boolean => {
    if (content === null || content === undefined) return true;
    if (typeof content === 'string') {
      const trimmed = content.trim();
      // Check if it's empty or an empty array/object string
      return trimmed.length === 0 || trimmed === '[]' || trimmed === '{}';
    }
    return false;
  };

  const parseJsonSafe = (value: string): JsonValue | null => {
    try {
      return JSON.parse(value) as JsonValue;
    } catch {
      return null;
    }
  };

  const isToolLikeRole = (role?: string): boolean => {
    if (!role) return false;
    return role === 'tool' || role === 'tool-shell';
  };

  const argsToObject = (
    args?: string | Record<string, unknown>,
  ): Record<string, JsonValue> | null => {
    if (!args) return null;
    if (typeof args === 'string') {
      const parsed = parseJsonSafe(args);
      return parsed && typeof parsed === 'object' && !Array.isArray(parsed)
        ? (parsed as Record<string, JsonValue>)
        : null;
    }
    if (typeof args === 'object' && !Array.isArray(args)) {
      return args as Record<string, JsonValue>;
    }
    return null;
  };

  const extractShellCommandFromArgs = (
    args?: string | Record<string, unknown>,
  ): string | undefined => {
    const obj = argsToObject(args);
    if (!obj) return undefined;
    if (typeof obj.command === 'string') return obj.command;
    if (typeof obj.cmd === 'string') return obj.cmd;
    return undefined;
  };

  const renderToolPopoverContent = (
    value: unknown,
    toolOptions?: Record<string, JsonValue>,
  ): React.ReactNode => {
    let parsed: JsonValue | null = null;
    if (typeof value === 'string') {
      parsed = parseJsonSafe(value);
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      parsed = value as JsonValue;
    }

    const containerStyle: React.CSSProperties = { maxWidth: 520 };
    const innerStyle: React.CSSProperties = {
      maxHeight: 300,
      overflow: 'auto',
      background: '#f5f5f5',
      border: '1px solid #eee',
      borderRadius: 6,
      padding: 12,
      fontFamily:
        'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
      fontSize: 12,
      whiteSpace: 'pre-wrap',
    };

    const sectionStyle: React.CSSProperties = {
      marginBottom: 16,
    };

    const sectionTitleStyle: React.CSSProperties = {
      fontWeight: 'bold',
      fontSize: 13,
      marginBottom: 8,
      color: '#333',
      borderBottom: '1px solid #ddd',
      paddingBottom: 4,
    };

    return (
      <div style={containerStyle}>
        {toolOptions && Object.keys(toolOptions).length > 0 && (
          <div style={sectionStyle}>
            <div style={sectionTitleStyle}>Tool Options:</div>
            <div style={innerStyle}>
              <JsonView value={toolOptions} style={lightTheme} />
            </div>
          </div>
        )}

        <div style={sectionStyle}>
          <div style={sectionTitleStyle}>Output:</div>
          <div style={innerStyle}>
            {parsed ? (
              <JsonView value={parsed as object} style={lightTheme} />
            ) : (
              <pre
                style={{
                  margin: 0,
                  whiteSpace: 'pre-wrap',
                  wordBreak: 'break-word',
                }}>
                {String(value ?? '')}
              </pre>
            )}
          </div>
        </div>
      </div>
    );
  };

  type PreparedMessage =
    | { type: 'system'; messages: ThreadMessageDto[]; id: string }
    | { type: 'chat'; message: ThreadMessageDto; id: string }
    | {
        type: 'tool';
        name: string;
        status: 'calling' | 'executed';
        result?: unknown;
        id: string;
        toolKind?: 'generic' | 'shell';
        shellCommand?: string;
        toolOptions?: Record<string, JsonValue>;
      };

  const prepareReadyMessages = (
    msgs: ThreadMessageDto[],
  ): PreparedMessage[] => {
    const prepared: PreparedMessage[] = [];
    let i = 0;

    while (i < msgs.length) {
      const m = msgs[i];
      const role = (m.message?.role as string) || '';

      if (role === 'system') {
        const sys: ThreadMessageDto[] = [m];
        let j = i + 1;
        while (
          j < msgs.length &&
          (msgs[j].message?.role as string) === 'system'
        ) {
          sys.push(msgs[j]);
          j++;
        }
        prepared.push({
          type: 'system',
          messages: sys,
          id: `system-${sys[0].id || sys[0].createdAt}`,
        });
        i = j;
        continue;
      }

      if (
        role === 'ai' &&
        Array.isArray(m.message?.toolCalls) &&
        m.message!.toolCalls.length > 0
      ) {
        // Check if we need to display the message content
        // Display it if content is not blank OR if toolCalls have meaningful data
        const hasNonBlankContent = !isBlankContent(m.message?.content);

        if (hasNonBlankContent) {
          prepared.push({
            type: 'chat',
            message: m,
            id: `chat-${m.id || m.createdAt}`,
          });
        }

        const followingTools: ThreadMessageDto[] = [];
        let j = i + 1;
        while (
          j < msgs.length &&
          isToolLikeRole(msgs[j].message?.role as string)
        ) {
          followingTools.push(msgs[j]);
          j++;
        }

        const toolCalls = m.message!.toolCalls as unknown as ToolCall[];
        for (let idx = 0; idx < toolCalls.length; idx++) {
          const tc = toolCalls[idx];
          const name = tc.name || tc.function?.name || 'tool';
          const matched = followingTools.find(
            (tm) => tm.message?.toolCallId === tc.id,
          );
          const resultContent = matched?.message?.content;
          const toolArgs = tc.function?.arguments ?? tc.args;
          const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
          const resultObj =
            typeof resultContent === 'object' &&
            resultContent !== null &&
            !Array.isArray(resultContent)
              ? (resultContent as ShellResult)
              : null;
          const shellCommand = shellCmdFromArgs || resultObj?.command;
          const isShell = (name || '').toLowerCase() === 'shell';
          const toolOptions = argsToObject(toolArgs);

          prepared.push({
            type: 'tool',
            name: name || 'tool',
            status: matched ? 'executed' : 'calling',
            result: resultContent,
            id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
            toolKind: isShell ? 'shell' : 'generic',
            shellCommand,
            toolOptions: toolOptions || undefined,
          });
        }

        i = i + 1 + followingTools.length;
        continue;
      }

      if (isToolLikeRole(role)) {
        const name = m.message?.name || 'tool';
        const resultContent = m.message?.content;
        const resultObj =
          typeof resultContent === 'object' &&
          resultContent !== null &&
          !Array.isArray(resultContent)
            ? (resultContent as ShellResult)
            : null;
        const shellCommand = resultObj?.command;
        const isShell = (name || '').toLowerCase() === 'shell';
        // For standalone tools, we don't have access to the original arguments
        // so we'll leave toolOptions as undefined
        const toolOptions = undefined;

        prepared.push({
          type: 'tool',
          name,
          status: 'executed',
          result: resultContent,
          id: `tool-standalone-${m.id || m.createdAt}`,
          toolKind: isShell ? 'shell' : 'generic',
          shellCommand,
          toolOptions,
        });
        i++;
        continue;
      }

      if (!isBlankContent(m.message?.content)) {
        prepared.push({
          type: 'chat',
          message: m,
          id: `chat-${m.id || m.createdAt}`,
        });
      }
      i++;
    }

    return prepared;
  };

  const preparedMessages = prepareReadyMessages(messages);
  const isThinkingVisible = isNodeRunning && isAgentNode;

  const renderSystemGroup = (
    systemMessages: ThreadMessageDto[],
    count: number,
  ) => {
    const firstMessage = systemMessages[0];
    const content = formatMessageContent(firstMessage.message?.content);
    const countSuffix = count > 1 ? ` (${count} system messages)` : '';
    const fullText = `${content}${countSuffix}`;

    const textContent = (
      <div
        style={{
          fontSize: '12px',
          color: '#8c8c8c',
          textAlign: 'center',
          cursor: 'pointer',
          display: '-webkit-box',
          WebkitLineClamp: 3,
          WebkitBoxOrient: 'vertical',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          lineHeight: '1.5',
          wordBreak: 'break-word',
          width: '100%',
        }}>
        {fullText}
      </div>
    );

    return (
      <div style={{ padding: '4px 12px', marginBottom: '4px' }}>
        <Popover
          content={
            <div
              style={{
                maxWidth: '500px',
                maxHeight: '400px',
                overflow: 'auto',
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-word',
                fontSize: '12px',
              }}>
              {fullText}
            </div>
          }
          trigger={['click']}
          placement="topLeft">
          {textContent}
        </Popover>
      </div>
    );
  };

  const renderFinishTool = (
    status: 'calling' | 'executed',
    resultContent?: unknown,
  ) => {
    if (status === 'calling') {
      return undefined;
    }

    // Extract message and needsMoreInfo flag from result content
    let finishMessage = 'Task completed.';
    let needsMoreInfo = false;
    if (resultContent) {
      if (typeof resultContent === 'string') {
        finishMessage = resultContent;
      } else if (typeof resultContent === 'object' && resultContent !== null) {
        const obj = resultContent as Record<string, unknown>;
        finishMessage =
          (typeof obj.message === 'string' ? obj.message : '') ||
          (typeof obj.content === 'string' ? obj.content : '') ||
          (typeof obj.result === 'string' ? obj.result : '') ||
          'Task completed.';
        needsMoreInfo = Boolean(obj.needsMoreInfo);
      }
    }

    const messageColor = needsMoreInfo ? '#faad14' : '#52c41a';
    const statusTag = needsMoreInfo ? '⚠ Need more info' : '✓ Finished';

    return (
      <div
        style={{
          padding: '8px 12px',
          marginBottom: '8px',
          display: 'flex',
          justifyContent: 'flex-start',
          alignItems: 'flex-start',
          gap: '8px',
        }}>
        <Avatar
          style={{
            backgroundColor: messageColor,
            flexShrink: 0,
          }}
          size="small">
          AI
        </Avatar>
        <div
          style={{
            maxWidth: '90%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'flex-start',
          }}>
          <div
            style={{
              backgroundColor: '#f3f3f3',
              borderRadius: '5px',
              padding: '8px 12px',
              wordBreak: 'break-word',
              minWidth: '100px',
              borderLeft: `3px solid ${messageColor}`,
            }}>
            <Text
              type="secondary"
              style={{
                fontSize: '11px',
                marginBottom: '5px',
                display: 'block',
                color: messageColor,
                fontWeight: 'bold',
              }}>
              {statusTag}
            </Text>

            <div
              style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}>
              {finishMessage}
            </div>
          </div>
        </div>
      </div>
    );
  };

  const renderToolStatusLine = (
    name: string,
    status: 'calling' | 'executed',
    resultContent?: unknown,
    toolOptions?: Record<string, JsonValue>,
  ) => {
    const line = (
      <div
        style={{
          cursor:
            status === 'executed' && resultContent !== undefined
              ? 'pointer'
              : 'default',
        }}
        aria-label={
          status === 'executed'
            ? `View tool result for ${name}`
            : `Tool ${name} is calling`
        }
        tabIndex={
          status === 'executed' && resultContent !== undefined ? 0 : -1
        }>
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '8px',
          }}>
          {status === 'calling' && <Spin size="small" />}
          <Text type="secondary" style={{ fontSize: '12px', color: '#8c8c8c' }}>
            {toolOptions?.purpose
              ? `${name} | ${String(toolOptions.purpose)}`
              : `tool ${name} is ${status === 'calling' ? 'calling...' : 'executed'}`}
          </Text>
        </div>
      </div>
    );

    if (status === 'executed' && resultContent !== undefined) {
      const contentNode = renderToolPopoverContent(resultContent, toolOptions);
      return (
        <Popover content={contentNode} trigger={['click']} placement="topLeft">
          {line}
        </Popover>
      );
    }

    return line;
  };

  const truncateToLines = (
    text: string,
    maxLines: number,
  ): { truncated: string; full: string; isTruncated: boolean } => {
    const lines = text.split('\n');
    const isTruncated = lines.length > maxLines;
    const truncated = lines.slice(0, maxLines).join('\n');
    return { truncated, full: text, isTruncated };
  };

  const ShellToolDisplay: React.FC<{
    name: string;
    status: 'calling' | 'executed';
    resultContent?: unknown;
    shellCommand?: string;
    toolOptions?: Record<string, JsonValue>;
  }> = ({ name, status, resultContent, shellCommand, toolOptions }) => {
    const [commandExpanded, setCommandExpanded] = useState(false);
    const [outputExpanded, setOutputExpanded] = useState(false);

    const resultObj =
      typeof resultContent === 'object' &&
      resultContent !== null &&
      !Array.isArray(resultContent)
        ? (resultContent as ShellResult)
        : null;
    const exitCode = resultObj?.exitCode;
    const exitCodeStatus = exitCode !== undefined ? exitCode : null;
    const exitCodeColor =
      exitCodeStatus === null
        ? '#c4c4c4'
        : exitCodeStatus === 0
          ? '#c4c4c4'
          : '#ff4d4f'; // Red for non-zero exit codes
    const tint =
      exitCodeStatus === null
        ? '#2b2b2b'
        : exitCodeStatus === 0
          ? '#1d2b1f'
          : '#2b1d1d';

    const toolNameElement = (
      <div
        style={{
          cursor:
            status === 'executed' && resultContent !== undefined
              ? 'pointer'
              : 'default',
        }}
        aria-label={
          status === 'executed'
            ? `View shell result for ${name}`
            : `Shell ${name} is calling`
        }>
        {name}
      </div>
    );

    // Get output text
    const getOutputText = (): string | null => {
      if (
        resultObj?.output !== undefined &&
        typeof resultObj.output === 'string'
      ) {
        return resultObj.output;
      }
      if (typeof resultContent === 'string') {
        return resultContent;
      }
      if (resultObj && typeof resultObj === 'object') {
        const displayText =
          resultObj.output || resultObj.stdout || resultObj.stderr;
        if (typeof displayText === 'string') {
          return displayText;
        }
      }
      return null;
    };

    const outputText = getOutputText();
    const commandTruncated = shellCommand
      ? truncateToLines(shellCommand, 3)
      : null;
    const outputTruncated = outputText ? truncateToLines(outputText, 3) : null;

    return (
      <div style={{ marginBottom: `12px` }}>
        {toolOptions?.purpose && (
          <Text
            type="secondary"
            style={{
              fontSize: '12px',
              color: '#8c8c8c',
              lineHeight: '15px',
              display: 'block',
              marginBottom: '10px',
            }}>
            {String(toolOptions.purpose)}
          </Text>
        )}
        <div
          style={{
            background: '#1e1e1e',
            borderRadius: 6,
            border: '1px solid #333',
            color: '#e8e8e8',
            fontFamily:
              'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
            fontSize: 12,
            display: 'flex',
            flexDirection: 'column',
            gap: 6,
            boxShadow: 'inset 0 0 0 1px rgba(255,255,255,0.02)',
            backgroundImage: `linear-gradient(${tint}, ${tint})`,
            backgroundBlendMode: 'soft-light',
          }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              gap: 8,
              padding: '5px 10px',
              background: '#1a1a1a',
            }}>
            {status === 'executed' && resultContent !== undefined ? (
              <Popover
                content={renderToolPopoverContent(resultContent, toolOptions)}
                trigger={['click']}
                placement="topLeft">
                {toolNameElement}
              </Popover>
            ) : (
              toolNameElement
            )}

            {status === 'calling' ? (
              <>
                <Spin size="small" />
                <span style={{ color: '#c4c4c4' }}>executing…</span>
              </>
            ) : (
              <span
                style={{
                  color: exitCodeColor,
                }}>
                executed
                {exitCodeStatus !== null ? ` | exit ${exitCodeStatus}` : ''}
              </span>
            )}
          </div>

          {shellCommand && (
            <div style={{ padding: '5px 10px' }}>
              <div style={{ display: 'flex', alignItems: 'flex-start' }}>
                <span
                  style={{
                    color: '#a0a0a0',
                    paddingRight: '10px',
                    flexShrink: 0,
                  }}>
                  $
                </span>
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div
                    style={{
                      maxHeight:
                        commandExpanded || !commandTruncated?.isTruncated
                          ? 'none'
                          : '4.5em',
                      overflow:
                        commandExpanded || !commandTruncated?.isTruncated
                          ? 'visible'
                          : 'hidden',
                      position: 'relative',
                    }}>
                    <SyntaxHighlighter
                      language="bash"
                      style={vscDarkPlus}
                      customStyle={{
                        margin: 0,
                        padding: 0,
                        background: 'transparent',
                        fontSize: '12px',
                        whiteSpace: 'pre-wrap',
                        wordBreak: 'break-word',
                        lineHeight: '1.5',
                      }}
                      PreTag="div"
                      codeTagProps={{
                        style: {
                          fontFamily: 'inherit',
                          whiteSpace: 'pre-wrap',
                          wordBreak: 'break-word',
                          margin: 0,
                          padding: 0,
                          lineHeight: '1.5',
                        },
                      }}>
                      {shellCommand}
                    </SyntaxHighlighter>
                    {commandTruncated?.isTruncated && !commandExpanded && (
                      <div
                        style={{
                          position: 'absolute',
                          bottom: 0,
                          left: 0,
                          right: 0,
                          height: '1.5em',
                          background:
                            'linear-gradient(to bottom, transparent, #1e1e1e)',
                          pointerEvents: 'none',
                        }}
                      />
                    )}
                  </div>
                  {commandTruncated?.isTruncated && (
                    <div
                      style={{
                        color: '#1890ff',
                        cursor: 'pointer',
                        fontSize: '11px',
                        marginTop: '4px',
                        textDecoration: 'underline',
                      }}
                      onClick={() => setCommandExpanded(!commandExpanded)}>
                      {commandExpanded ? 'Show less' : 'Show more...'}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {status === 'executed' && outputText && (
            <div
              style={{
                borderTop: '1px solid #333',
              }}>
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  padding: '5px 10px',
                  borderBottom: '1px solid #333',
                  background: '#1a1a1a',
                }}>
                <span style={{ fontSize: '11px', color: '#c4c4c4' }}>
                  Output
                </span>
                <CopyOutlined
                  style={{
                    color: '#c4c4c4',
                    cursor: 'pointer',
                    fontSize: '14px',
                  }}
                  onClick={async () => {
                    try {
                      await navigator.clipboard.writeText(outputText);
                      message.success('Copied to clipboard');
                    } catch (err) {
                      message.error('Failed to copy to clipboard');
                    }
                  }}
                />
              </div>
              <div
                style={{
                  padding: '5px 10px',
                  maxHeight: outputExpanded ? '200px' : 'none',
                  overflowY: outputExpanded ? 'scroll' : 'visible',
                  overflowX: 'hidden',
                  scrollbarWidth: 'thin',
                  scrollbarColor: '#555 #2a2a2a',
                }}
                className="shell-output-container">
                <SyntaxHighlighter
                  language="bash"
                  style={vscDarkPlus}
                  customStyle={{
                    margin: 0,
                    padding: 0,
                    background: 'transparent',
                    fontSize: '12px',
                  }}
                  PreTag="div"
                  codeTagProps={{ style: { fontFamily: 'inherit' } }}>
                  {outputExpanded || !outputTruncated?.isTruncated
                    ? outputText
                    : outputTruncated.truncated}
                </SyntaxHighlighter>
                {outputTruncated?.isTruncated && (
                  <div
                    style={{
                      color: '#1890ff',
                      cursor: 'pointer',
                      fontSize: '11px',
                      marginTop: '4px',
                      textDecoration: 'underline',
                    }}
                    onClick={() => setOutputExpanded(!outputExpanded)}>
                    {outputExpanded ? 'Show less' : 'Show more...'}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  const renderShellStatusLine = (
    name: string,
    status: 'calling' | 'executed',
    resultContent?: unknown,
    shellCommand?: string,
    toolOptions?: Record<string, JsonValue>,
  ) => {
    return (
      <ShellToolDisplay
        name={name}
        status={status}
        resultContent={resultContent}
        shellCommand={shellCommand}
        toolOptions={toolOptions}
      />
    );
  };

  const renderNonAgentNodeInfo = () => {
    if (isAgentNode) return null;

    return (
      <div style={{ padding: '16px', textAlign: 'center' }}>
        <Space direction="vertical" size="large">
          <ToolOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
          <div>
            <Text strong style={{ fontSize: '16px' }}>
              {nodeTemplateKind || 'Tool'} Node
            </Text>
            <br />
            <Text type="secondary" style={{ fontSize: '14px' }}>
              This node executes tool calls and doesn't participate in
              conversations.
            </Text>
          </div>
          <div
            style={{
              backgroundColor: '#f8f9fa',
              border: '1px solid #e9ecef',
              borderRadius: '8px',
              padding: '12px',
              textAlign: 'left',
            }}>
            <Text strong style={{ fontSize: '13px', color: '#495057' }}>
              Tool Call Information:
            </Text>
            <br />
            <Text type="secondary" style={{ fontSize: '12px' }}>
              • Tool calls are executed when this node is triggered
              <br />
              • Results are passed to connected nodes
              <br />• Check the execution logs for detailed information
            </Text>
          </div>
        </Space>
      </div>
    );
  };

  const renderMessage = (message: ThreadMessageDto) => {
    const role = (message.message?.role as string) || '';
    const content = formatMessageContent(message.message?.content);
    const createdAt = new Date(message.createdAt).toLocaleString();

    if (isToolLikeRole(role)) {
      const name = message.message?.name || 'tool';
      const resultContent = message.message?.content;
      // For standalone tools, we don't have access to the original arguments
      return renderToolStatusLine(name, 'executed', resultContent, undefined);
    }

    if (isBlankContent(message.message?.content)) return null;

    const isHuman = role === 'human';

    return (
      <div
        style={{
          padding: '8px 12px',
          marginBottom: '8px',
          display: 'flex',
          justifyContent: isHuman ? 'flex-end' : 'flex-start',
          alignItems: 'flex-start',
          gap: '8px',
        }}>
        {!isHuman && (
          <Avatar
            style={{
              backgroundColor:
                role === 'ai'
                  ? '#52c41a'
                  : role === 'system'
                    ? '#722ed1'
                    : '#d9d9d9',
              flexShrink: 0,
            }}
            size="small">
            AI
          </Avatar>
        )}

        <div
          style={{
            maxWidth: '90%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: isHuman ? 'flex-end' : 'flex-start',
          }}>
          <div
            style={{
              backgroundColor: isHuman ? '#f0f8ff' : '#f3f3f3',
              borderRadius: '5px',
              padding: '8px 12px',
              wordBreak: 'break-word',
              minWidth: '100px',
            }}>
            <div
              style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}>
              {content}
            </div>
          </div>

          <Text
            type="secondary"
            style={{ fontSize: '11px', marginTop: '4px', color: '#8c8c8c' }}>
            {`${createdAt} | ${role}`}
          </Text>
        </div>

        {isHuman && (
          <Avatar
            style={{ backgroundColor: '#1890ff', flexShrink: 0 }}
            size="small">
            ME
          </Avatar>
        )}
      </div>
    );
  };

  const renderPendingMessage = (message: PendingMessage, index: number) => {
    const isHuman = message.role === 'human';
    const content = message.content;

    // Determine when the message will be sent
    const sendTimeText =
      newMessageMode === 'inject_after_tool_call'
        ? 'Will be sent after next tool execution'
        : newMessageMode === 'wait_for_completion'
          ? 'Will be sent after agent completes current task'
          : 'Pending';

    return (
      <div
        key={`pending-${index}`}
        style={{
          padding: '8px 12px',
          marginBottom: '8px',
          display: 'flex',
          justifyContent: isHuman ? 'flex-end' : 'flex-start',
          alignItems: 'flex-start',
          gap: '8px',
          opacity: 0.6,
        }}>
        {!isHuman && (
          <Avatar
            style={{
              backgroundColor: '#52c41a',
              flexShrink: 0,
            }}
            size="small">
            AI
          </Avatar>
        )}

        <div
          style={{
            maxWidth: '90%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: isHuman ? 'flex-end' : 'flex-start',
          }}>
          <div
            style={{
              backgroundColor: isHuman ? '#f0f8ff' : '#f3f3f3',
              borderRadius: '5px',
              padding: '8px 12px',
              wordBreak: 'break-word',
              minWidth: '100px',
              border: '2px dashed #d9d9d9',
            }}>
            <div
              style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}>
              {content}
            </div>
          </div>

          <Text
            type="secondary"
            style={{
              fontSize: '11px',
              marginTop: '4px',
              color: '#8c8c8c',
              fontStyle: 'italic',
            }}>
            {sendTimeText}
          </Text>
        </div>

        {isHuman && (
          <Avatar
            style={{ backgroundColor: '#1890ff', flexShrink: 0 }}
            size="small">
            ME
          </Avatar>
        )}
      </div>
    );
  };

  if (!selectedThreadId) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Text type="secondary">
            Select a thread from the header to view messages.
          </Text>
        </div>
      </div>
    );
  }

  if (!isAgentNode) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div style={{ flex: 1, minHeight: 0, overflow: 'auto' }}>
          {renderNonAgentNodeInfo()}
        </div>
      </div>
    );
  }

  if (messagesLoading) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Spin />
          <div style={{ marginTop: 8 }}>
            <Text type="secondary">Loading messages...</Text>
          </div>
        </div>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Text type="secondary">
            No messages found for this thread and node.
          </Text>
        </div>
      </div>
    );
  }

  return (
    <div
      style={{
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        minHeight: 0,
      }}>
      <div
        ref={scrollContainerRef}
        onScroll={handleScroll}
        style={{ flex: 1, minHeight: 0, overflow: 'auto', padding: 0 }}>
        {loadingMore && (
          <div
            style={{
              padding: '8px 12px',
              textAlign: 'center',
              fontSize: '12px',
              color: '#8c8c8c',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '8px',
            }}>
            <Spin size="small" />
            <Text
              type="secondary"
              style={{ fontSize: '12px', color: '#8c8c8c' }}>
              Loading more messages...
            </Text>
          </div>
        )}

        {(() => {
          const prepared = prepareReadyMessages(messages);
          const rows: React.ReactNode[] = [];

          let i = 0;
          while (i < prepared.length) {
            const item = prepared[i];

            if (item.type === 'system') {
              rows.push(
                <div key={item.id}>
                  {renderSystemGroup(item.messages, item.messages.length)}
                </div>,
              );
              i++;
              continue;
            }

            if (item.type === 'chat') {
              rows.push(<div key={item.id}>{renderMessage(item.message)}</div>);
              i++;
              continue;
            }

            if (item.type === 'tool') {
              const group: Array<Extract<PreparedMessage, { type: 'tool' }>> = [
                item,
              ];
              let j = i + 1;
              while (j < prepared.length && prepared[j].type === 'tool') {
                group.push(
                  prepared[j] as Extract<PreparedMessage, { type: 'tool' }>,
                );
                j++;
              }

              rows.push(
                <div
                  key={`tool-stack-${i}`}
                  style={{
                    padding: '0 12px',
                    display: 'flex',
                    flexDirection: 'column',
                    rowGap: 2,
                    marginBottom: 6,
                  }}>
                  {group.map((t, idx) => {
                    const isFinish = (t.name || '').toLowerCase() === 'finish';
                    return (
                      <div key={t.id || `tool-${i}-${idx}`}>
                        {isFinish
                          ? renderFinishTool(t.status, t.result)
                          : t.toolKind === 'shell'
                            ? renderShellStatusLine(
                                t.name,
                                t.status,
                                t.result,
                                t.shellCommand,
                                t.toolOptions,
                              )
                            : renderToolStatusLine(
                                t.name,
                                t.status,
                                t.result,
                                t.toolOptions,
                              )}
                      </div>
                    );
                  })}
                </div>,
              );

              i = j;
              continue;
            }

            i++;
          }

          return rows;
        })()}
        {isThinkingVisible && !messagesLoading && (
          <div
            style={{
              textAlign: 'center',
              animation:
                'messages-tab-thinking-pulse 1.6s ease-in-out infinite',
            }}>
            <div
              style={{
                fontSize: '12px',
                color: '#8c8c8c',
                textAlign: 'center',
                cursor: 'pointer',
                display: '-webkit-box',
                WebkitLineClamp: 3,
                WebkitBoxOrient: 'vertical',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                lineHeight: '1.5',
                wordBreak: 'break-word',
                width: '100%',
              }}>
              Agent is thinking...
            </div>
          </div>
        )}
        {pendingMessages && pendingMessages.length > 0 && (
          <div
            style={{
              borderTop: '1px solid #ebebeb',
              paddingTop: '10px',
              marginTop: '8px',
            }}>
            {pendingMessages.map((msg, idx) => renderPendingMessage(msg, idx))}
          </div>
        )}
      </div>
    </div>
  );
};

export default MessagesTab;
