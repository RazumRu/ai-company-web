// MessagesTab.tsx
import React, {
  useEffect,
  useRef,
  useCallback,
  useMemo,
  useState,
  type ReactNode,
} from 'react';
import { Avatar, Typography, Space, Spin, Popover, message } from 'antd';
import { ToolOutlined, CopyOutlined } from '@ant-design/icons';
import type { ThreadMessageDto } from '../../../autogenerated';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import ReactMarkdown from 'react-markdown';
import type { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';

interface ToolCallFunction {
  name?: string;
  arguments?: string | Record<string, unknown>;
}

interface ToolCall {
  id?: string;
  name?: string;
  function?: ToolCallFunction;
  args?: string | Record<string, unknown>;
}

interface ShellResult {
  command?: string;
  exitCode?: number;
  output?: string;
  stdout?: string;
  stderr?: string;
  [key: string]: unknown;
}

interface PendingMessage {
  content: string;
  role: 'human' | 'ai';
  additionalKwargs?: {
    run_id?: string;
    created_at?: string;
    [key: string]: unknown;
  };
  createdAt?: string;
}

type JsonValue =
  | string
  | number
  | boolean
  | null
  | JsonValue[]
  | { [key: string]: JsonValue };

const { Text } = Typography;

interface MessagesTabProps {
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  selectedThreadId?: string;
  nodeId?: string;
  isAgentNode?: boolean;
  nodeTemplateKind?: string;
  onLoadMoreMessages?: () => void;
  hasMoreMessages?: boolean;
  loadingMore?: boolean;
  isNodeRunning?: boolean;
  pendingMessages?: PendingMessage[];
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

const ensureThinkingIndicatorStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-thinking-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-thinking-style';
    style.textContent = `
      @keyframes messages-tab-thinking-pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

const ensureReasoningAnimationStyles = (() => {
  let injected = false;
  return () => {
    if (injected || typeof document === 'undefined') return;
    if (document.getElementById('messages-tab-reasoning-style')) {
      injected = true;
      return;
    }
    const style = document.createElement('style');
    style.id = 'messages-tab-reasoning-style';
    style.textContent = `
      @keyframes messages-tab-reasoning-appear {
        0% {
          opacity: 0;
          transform: translateY(6px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes messages-tab-reasoning-streaming {
        0% {
          color: rgba(0, 0, 0, 0.4);
        }
        50% {
          color: rgba(0, 0, 0, 0.75);
        }
        100% {
          color: rgba(0, 0, 0, 0.4);
        }
      }
    `;
    document.head.appendChild(style);
    injected = true;
  };
})();

type MarkdownElementProps<T> = React.HTMLAttributes<T> & {
  children?: ReactNode;
};

type MarkdownCodeProps = React.HTMLAttributes<HTMLElement> & {
  inline?: boolean;
  className?: string;
  children?: ReactNode[];
};

const renderMarkdownCode = ({
  inline,
  className,
  children,
}: MarkdownCodeProps) => {
  const match = /language-(\w+)/.exec(className || '');
  const codeContent = String(children ?? '').replace(/\n$/, '');
  if (!inline && match) {
    return (
      <div
        style={{
          margin: '8px 0',
          borderRadius: 6,
          overflow: 'hidden',
        }}>
        <SyntaxHighlighter
          style={vscDarkPlus}
          language={match[1]}
          PreTag="div"
          codeTagProps={{ style: { fontSize: 12 } }}>
          {codeContent}
        </SyntaxHighlighter>
      </div>
    );
  }
  return (
    <code
      className={className}
      style={{
        backgroundColor: 'rgba(0, 0, 0, 0.04)',
        padding: '0 4px',
        borderRadius: 4,
        fontSize: '12px',
      }}>
      {children}
    </code>
  );
};

const markdownComponents: Components = {
  p: ({ children }: MarkdownElementProps<HTMLParagraphElement>) => (
    <p
      style={{
        margin: 0,
        lineHeight: '1.5',
        whiteSpace: 'pre-wrap',
        wordBreak: 'break-word',
      }}>
      {children}
    </p>
  ),
  a: ({
    children,
    ...props
  }: React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a
      {...props}
      target="_blank"
      rel="noopener noreferrer"
      style={{ color: '#1677ff' }}>
      {children}
    </a>
  ),
  ul: ({ children }: MarkdownElementProps<HTMLUListElement>) => (
    <ul style={{ margin: '0 0 8px 20px', padding: 0 }}>{children}</ul>
  ),
  ol: ({ children }: MarkdownElementProps<HTMLOListElement>) => (
    <ol style={{ margin: '0 0 8px 20px', padding: 0 }}>{children}</ol>
  ),
  li: ({ children }: MarkdownElementProps<HTMLLIElement>) => (
    <li style={{ marginBottom: 4, lineHeight: '1.5' }}>{children}</li>
  ),
  blockquote: ({ children }: MarkdownElementProps<HTMLQuoteElement>) => (
    <blockquote
      style={{
        margin: '0 0 8px',
        paddingLeft: 12,
        borderLeft: '3px solid #d9d9d9',
        color: '#595959',
      }}>
      {children}
    </blockquote>
  ),
  table: ({ children }: MarkdownElementProps<HTMLTableElement>) => (
    <table
      style={{
        borderCollapse: 'collapse',
        width: '100%',
        marginBottom: 12,
      }}>
      {children}
    </table>
  ),
  thead: ({ children }: MarkdownElementProps<HTMLTableSectionElement>) => (
    <thead style={{ background: '#f5f5f5' }}>{children}</thead>
  ),
  tbody: ({ children }: MarkdownElementProps<HTMLTableSectionElement>) => (
    <tbody>{children}</tbody>
  ),
  th: ({ children }: MarkdownElementProps<HTMLTableCellElement>) => (
    <th
      style={{
        border: '1px solid #d9d9d9',
        padding: '4px 8px',
        textAlign: 'left',
        fontWeight: 600,
      }}>
      {children}
    </th>
  ),
  td: ({ children }: MarkdownElementProps<HTMLTableCellElement>) => (
    <td
      style={{
        border: '1px solid #d9d9d9',
        padding: '4px 8px',
        verticalAlign: 'top',
      }}>
      {children}
    </td>
  ),
  code: renderMarkdownCode as Components['code'],
};

const MarkdownContent: React.FC<{
  content: string;
  style?: React.CSSProperties;
  className?: string;
  allowHorizontalScroll?: boolean;
}> = ({ content, style, className, allowHorizontalScroll = true }) => {
  if (!content || content.trim().length === 0) {
    return null;
  }

  const combinedStyle: React.CSSProperties = {
    maxWidth: '100%',
    overflowX: allowHorizontalScroll ? 'auto' : 'hidden',
    wordBreak: 'break-word',
    display: 'flex',
    flexDirection: 'column',
    gap: '8px',
    ...style,
  };

  return (
    <div style={combinedStyle} className={className}>
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={markdownComponents}>
        {content}
      </ReactMarkdown>
    </div>
  );
};

const fullHeightColumnStyle: React.CSSProperties = {
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  minHeight: 0,
};

const centeredStateStyle: React.CSSProperties = {
  flex: 1,
  minHeight: 0,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
};

const scrollContainerStyle: React.CSSProperties = {
  flex: 1,
  minHeight: 0,
  overflowY: 'auto',
  overflowX: 'hidden',
  padding: 0,
};

const messageBlockStyle: React.CSSProperties = {
  padding: '8px 12px',
  marginBottom: '8px',
};

const collapsedGradientStyle: React.CSSProperties = {
  position: 'absolute',
  bottom: 0,
  left: 0,
  right: 0,
  height: '24px',
  background: 'linear-gradient(180deg, rgba(255,255,255,0) 0%, #fff 100%)',
  pointerEvents: 'none',
};

const MessagesTab: React.FC<MessagesTabProps> = ({
  messages,
  messagesLoading,
  selectedThreadId,
  nodeId,
  isAgentNode = true,
  nodeTemplateKind,
  onLoadMoreMessages,
  hasMoreMessages,
  loadingMore,
  isNodeRunning = false,
  pendingMessages = [],
  newMessageMode,
}) => {
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const prevScrollHeightRef = useRef<number>(0);
  const isPrependingRef = useRef<boolean>(false);
  const pendingAutoScrollRef = useRef<boolean>(false);
  const autoScrollDisabledRef = useRef<boolean>(false);
  const lastMessageCountRef = useRef<number>(0);
  const [expandedSystemIds, setExpandedSystemIds] = useState<Set<string>>(
    () => new Set(),
  );
  const toggleSystemMessage = useCallback((id: string) => {
    setExpandedSystemIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  }, []);

  useEffect(() => {
    ensureThinkingIndicatorStyles();
    ensureReasoningAnimationStyles();
  }, []);

  useEffect(() => {
    pendingAutoScrollRef.current = true;
  }, [selectedThreadId, nodeId]);

  useEffect(() => {
    if (!isPrependingRef.current) return;
    const el = scrollContainerRef.current;
    if (el) {
      const diff = el.scrollHeight - prevScrollHeightRef.current;
      el.scrollTop = diff + el.scrollTop;
    }
    isPrependingRef.current = false;
  }, [messages.length]);

  useEffect(() => {
    if (messagesLoading) return;
    const el = scrollContainerRef.current;
    if (!el) return;

    const isInitiallyEmpty = lastMessageCountRef.current === 0;
    const shouldAutoScroll =
      pendingAutoScrollRef.current ||
      isInitiallyEmpty ||
      !autoScrollDisabledRef.current;

    if (shouldAutoScroll) {
      el.scrollTop = el.scrollHeight;
    }

    pendingAutoScrollRef.current = false;
    lastMessageCountRef.current = messages.length;
  }, [messagesLoading, messages.length]);

  useEffect(() => {
    // Inject scrollbar styles for webkit browsers
    const styleId = 'shell-scrollbar-styles';
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      .shell-output-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .shell-output-container::-webkit-scrollbar-track {
        background: #2a2a2a;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .shell-output-container::-webkit-scrollbar-thumb:hover {
        background: #666;
      }
    `;
    document.head.appendChild(style);

    return () => {
      const existingStyle = document.getElementById(styleId);
      if (existingStyle) {
        existingStyle.remove();
      }
    };
  }, []);

  const handleScroll = useCallback(() => {
    const el = scrollContainerRef.current;
    if (!el) return;
    const nearTop = el.scrollTop <= 100;
    if (
      nearTop &&
      hasMoreMessages &&
      !loadingMore &&
      typeof onLoadMoreMessages === 'function'
    ) {
      prevScrollHeightRef.current = el.scrollHeight;
      isPrependingRef.current = true;
      onLoadMoreMessages();
    }
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight <= 48;
    autoScrollDisabledRef.current = !nearBottom;
  }, [hasMoreMessages, loadingMore, onLoadMoreMessages]);

  const formatMessageContent = (content: unknown): string => {
    if (typeof content === 'string') return content;
    if (typeof content === 'object' && content !== null)
      return JSON.stringify(content, null, 2);
    return String(content ?? '');
  };

  const isBlankContent = (content: unknown): boolean => {
    if (content === null || content === undefined) return true;
    if (typeof content === 'string') {
      const trimmed = content.trim();
      // Check if it's empty or an empty array/object string
      return trimmed.length === 0 || trimmed === '[]' || trimmed === '{}';
    }
    return false;
  };

  const limitConsecutiveNewlines = (value: string): string =>
    value.replace(/(\r?\n){2,}/g, '\n');

  const createReasoningPreview = (
    value: string,
    maxLines = 6,
  ): { text: string; isTruncated: boolean } => {
    if (!value) {
      return { text: '', isTruncated: false };
    }

    const lines = value.split('\n');
    const normalized: string[] = [];

    for (const line of lines) {
      if (
        line.trim().length === 0 &&
        normalized.length > 0 &&
        normalized[normalized.length - 1].trim().length === 0
      ) {
        continue;
      }
      normalized.push(line);
    }

    const isTruncated = normalized.length > maxLines;
    const truncated = normalized.slice(0, maxLines).join('\n').trim();

    return {
      text: truncated.length > 0 ? truncated : 'Reasoning hidden.',
      isTruncated,
    };
  };

  const parseJsonSafe = (value: string): JsonValue | null => {
    try {
      return JSON.parse(value) as JsonValue;
    } catch {
      return null;
    }
  };

  const isToolLikeRole = (role?: string): boolean => {
    if (!role) return false;
    return role === 'tool' || role === 'tool-shell';
  };

  const argsToObject = (
    args?: string | Record<string, unknown>,
  ): Record<string, JsonValue> | null => {
    if (!args) return null;
    if (typeof args === 'string') {
      const parsed = parseJsonSafe(args);
      return parsed && typeof parsed === 'object' && !Array.isArray(parsed)
        ? (parsed as Record<string, JsonValue>)
        : null;
    }
    if (typeof args === 'object' && !Array.isArray(args)) {
      return args as Record<string, JsonValue>;
    }
    return null;
  };

  const extractShellCommandFromArgs = (
    args?: string | Record<string, unknown>,
  ): string | undefined => {
    const obj = argsToObject(args);
    if (!obj) return undefined;
    if (typeof obj.command === 'string') return obj.command;
    if (typeof obj.cmd === 'string') return obj.cmd;
    return undefined;
  };

  const renderToolPopoverContent = (
    value: unknown,
    toolOptions?: Record<string, JsonValue>,
  ): React.ReactNode => {
    let parsed: JsonValue | null = null;
    if (typeof value === 'string') {
      parsed = parseJsonSafe(value);
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      parsed = value as JsonValue;
    }

    const containerStyle: React.CSSProperties = { maxWidth: 520 };
    const innerStyle: React.CSSProperties = {
      maxHeight: 300,
      overflow: 'auto',
      background: '#f5f5f5',
      border: '1px solid #eee',
      borderRadius: 6,
      padding: 12,
      fontFamily:
        'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
      fontSize: 12,
      whiteSpace: 'pre-wrap',
    };

    const sectionStyle: React.CSSProperties = {
      marginBottom: 16,
    };

    const sectionTitleStyle: React.CSSProperties = {
      fontWeight: 'bold',
      fontSize: 13,
      marginBottom: 8,
      color: '#333',
      borderBottom: '1px solid #ddd',
      paddingBottom: 4,
    };

    return (
      <div style={containerStyle}>
        {toolOptions && Object.keys(toolOptions).length > 0 && (
          <div style={sectionStyle}>
            <div style={sectionTitleStyle}>Tool Options:</div>
            <div style={innerStyle}>
              <JsonView value={toolOptions} style={lightTheme} />
            </div>
          </div>
        )}

        <div style={sectionStyle}>
          <div style={sectionTitleStyle}>Output:</div>
          <div style={innerStyle}>
            {parsed ? (
              <JsonView value={parsed as object} style={lightTheme} />
            ) : (
              <pre
                style={{
                  margin: 0,
                  whiteSpace: 'pre-wrap',
                  wordBreak: 'break-word',
                }}>
                {String(value ?? '')}
              </pre>
            )}
          </div>
        </div>
      </div>
    );
  };

  type PreparedMessage =
    | { type: 'system'; messages: ThreadMessageDto[]; id: string }
    | { type: 'reasoning'; message: ThreadMessageDto; id: string }
    | { type: 'chat'; message: ThreadMessageDto; id: string }
    | {
        type: 'tool';
        name: string;
        status: 'calling' | 'executed';
        result?: unknown;
        id: string;
        toolKind?: 'generic' | 'shell';
        shellCommand?: string;
        toolOptions?: Record<string, JsonValue>;
      };

  const prepareReadyMessages = (
    msgs: ThreadMessageDto[],
  ): PreparedMessage[] => {
    const prepared: PreparedMessage[] = [];
    let i = 0;

    while (i < msgs.length) {
      const m = msgs[i];
      const role = (m.message?.role as string) || '';

      if (role === 'reasoning') {
        if (!isBlankContent(m.message?.content)) {
          prepared.push({
            type: 'reasoning',
            message: m,
            id: `reasoning-${m.id || m.createdAt}`,
          });
        }
        i++;
        continue;
      }

      if (role === 'system') {
        const sys: ThreadMessageDto[] = [m];
        let j = i + 1;
        while (
          j < msgs.length &&
          (msgs[j].message?.role as string) === 'system'
        ) {
          sys.push(msgs[j]);
          j++;
        }
        prepared.push({
          type: 'system',
          messages: sys,
          id: `system-${sys[0].id || sys[0].createdAt}`,
        });
        i = j;
        continue;
      }

      if (
        role === 'ai' &&
        Array.isArray(m.message?.toolCalls) &&
        m.message!.toolCalls.length > 0
      ) {
        // Check if we need to display the message content
        // Display it if content is not blank OR if toolCalls have meaningful data
        const hasNonBlankContent = !isBlankContent(m.message?.content);

        if (hasNonBlankContent) {
          prepared.push({
            type: 'chat',
            message: m,
            id: `chat-${m.id || m.createdAt}`,
          });
        }

        const followingTools: ThreadMessageDto[] = [];
        let j = i + 1;
        while (
          j < msgs.length &&
          isToolLikeRole(msgs[j].message?.role as string)
        ) {
          followingTools.push(msgs[j]);
          j++;
        }

        const toolCalls = m.message!.toolCalls as unknown as ToolCall[];
        for (let idx = 0; idx < toolCalls.length; idx++) {
          const tc = toolCalls[idx];
          const name = tc.name || tc.function?.name || 'tool';
          const matched = followingTools.find(
            (tm) => tm.message?.toolCallId === tc.id,
          );
          const resultContent = matched?.message?.content;
          const toolArgs = tc.function?.arguments ?? tc.args;
          const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
          const resultObj =
            typeof resultContent === 'object' &&
            resultContent !== null &&
            !Array.isArray(resultContent)
              ? (resultContent as ShellResult)
              : null;
          const shellCommand = shellCmdFromArgs || resultObj?.command;
          const isShell = (name || '').toLowerCase() === 'shell';
          const toolOptions = argsToObject(toolArgs);

          prepared.push({
            type: 'tool',
            name: name || 'tool',
            status: matched ? 'executed' : 'calling',
            result: resultContent,
            id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
            toolKind: isShell ? 'shell' : 'generic',
            shellCommand,
            toolOptions: toolOptions || undefined,
          });
        }

        i = i + 1 + followingTools.length;
        continue;
      }

      if (isToolLikeRole(role)) {
        const name = m.message?.name || 'tool';
        const resultContent = m.message?.content;
        const resultObj =
          typeof resultContent === 'object' &&
          resultContent !== null &&
          !Array.isArray(resultContent)
            ? (resultContent as ShellResult)
            : null;
        const shellCommand = resultObj?.command;
        const isShell = (name || '').toLowerCase() === 'shell';
        // For standalone tools, we don't have access to the original arguments
        // so we'll leave toolOptions as undefined
        const toolOptions = undefined;

        prepared.push({
          type: 'tool',
          name,
          status: 'executed',
          result: resultContent,
          id: `tool-standalone-${m.id || m.createdAt}`,
          toolKind: isShell ? 'shell' : 'generic',
          shellCommand,
          toolOptions,
        });
        i++;
        continue;
      }

      if (!isBlankContent(m.message?.content)) {
        prepared.push({
          type: 'chat',
          message: m,
          id: `chat-${m.id || m.createdAt}`,
        });
      }
      i++;
    }

    return prepared;
  };

  const preparedMessages = useMemo(
    () => prepareReadyMessages(messages),
    [messages],
  );
  const isThinkingVisible = isNodeRunning && isAgentNode;

  const STREAMING_REASONING_FLAG = '__streamingReasoning';

  const renderFullHeightState = (content: React.ReactNode) => (
    <div style={fullHeightColumnStyle}>
      <div style={centeredStateStyle}>{content}</div>
    </div>
  );

  const ReasoningMessage: React.FC<{ message: ThreadMessageDto }> = ({
    message,
  }) => {
    const content = limitConsecutiveNewlines(
      formatMessageContent(message.message?.content),
    );
    const [baseContent, setBaseContent] = useState(content);
    const [animatedChunk, setAnimatedChunk] = useState('');
    const prevContentRef = useRef(content);
    const timeoutRef = useRef<number | null>(null);
    const [expanded, setExpanded] = useState(false);
    const [isHovered, setIsHovered] = useState(false);
    const preview = useMemo(
      () => createReasoningPreview(baseContent),
      [baseContent],
    );

    const additionalKwargs = (message.message?.additionalKwargs ??
      {}) as Record<string, unknown>;
    const isStreaming = Boolean(additionalKwargs?.[STREAMING_REASONING_FLAG]);

    useEffect(() => {
      const prev = prevContentRef.current;
      if (content === prev) {
        return;
      }

      if (content.startsWith(prev)) {
        const newPart = content.slice(prev.length);
        if (typeof window === 'undefined') {
          setBaseContent(content);
          setAnimatedChunk('');
        } else {
          setBaseContent(prev);
          setAnimatedChunk(newPart);
          if (timeoutRef.current !== null) {
            window.clearTimeout(timeoutRef.current);
          }
          timeoutRef.current = window.setTimeout(() => {
            setBaseContent(content);
            setAnimatedChunk('');
          }, 650);
        }
      } else {
        setBaseContent(content);
        setAnimatedChunk('');
      }

      prevContentRef.current = content;
    }, [content]);

    useEffect(() => {
      return () => {
        if (timeoutRef.current !== null) {
          if (typeof window !== 'undefined') {
            window.clearTimeout(timeoutRef.current);
          }
          timeoutRef.current = null;
        }
      };
    }, []);

    const handleToggle = () => {
      setExpanded((prev) => !prev);
    };

    const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        handleToggle();
      }
    };

    const containerStyle: React.CSSProperties = {
      fontSize: '12px',
      color: isHovered ? '#4f4f4f' : '#6b6b6b',
      textAlign: 'center',
      border: 'none',
      cursor: 'pointer',
      background: 'transparent',
      transition: 'color 0.25s ease',
      animation: isStreaming
        ? 'messages-tab-reasoning-streaming 2.8s ease-in-out infinite'
        : undefined,
      animationFillMode: isStreaming ? 'both' : undefined,
    };

    const collapsedStyle: React.CSSProperties = {
      maxHeight: '6.2em',
      overflow: 'hidden',
      position: 'relative',
      cursor: 'pointer',
      textAlign: 'left',
    };

    const expandedStyle: React.CSSProperties = {
      whiteSpace: 'pre-wrap',
      wordBreak: 'break-word',
      textAlign: 'left',
    };

    return (
      <div
        style={containerStyle}
        role="button"
        tabIndex={0}
        onClick={handleToggle}
        onKeyDown={handleKeyDown}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}>
        {expanded ? (
          <div style={expandedStyle}>
            <MarkdownContent
              content={baseContent}
              allowHorizontalScroll={expanded}
            />
            {animatedChunk && (
              <div
                style={{
                  animation: 'messages-tab-reasoning-appear 0.6s ease',
                }}>
                <MarkdownContent
                  content={animatedChunk}
                  allowHorizontalScroll={expanded}
                />
              </div>
            )}
          </div>
        ) : (
          <div style={collapsedStyle}>
            <MarkdownContent
              content={preview.text}
              allowHorizontalScroll={false}
            />
            <div style={collapsedGradientStyle} />
          </div>
        )}
        <div
          style={{
            marginTop: 2,
            fontSize: 11,
            color: '#9a9a9a',
            fontStyle: 'italic',
          }}>
          {isStreaming ? 'still thinking…' : ''}
        </div>
      </div>
    );
  };

  const ChatBubble: React.FC<{
    isHuman: boolean;
    avatarLabel: string;
    avatarColor: string;
    children: React.ReactNode;
    footer?: React.ReactNode;
    bubbleStyle?: React.CSSProperties;
    containerStyle?: React.CSSProperties;
  }> = ({
    isHuman,
    avatarLabel,
    avatarColor,
    children,
    footer,
    bubbleStyle,
    containerStyle,
  }) => {
    const baseContainer: React.CSSProperties = {
      display: 'flex',
      justifyContent: isHuman ? 'flex-end' : 'flex-start',
      alignItems: 'flex-start',
      gap: '8px',
      width: '100%',
    };

    const mergedContainer = { ...baseContainer, ...containerStyle };

    const baseBubbleStyle: React.CSSProperties = {
      backgroundColor: isHuman ? '#f0f8ff' : '#f3f3f3',
      borderRadius: '5px',
      padding: '8px 12px',
      wordBreak: 'break-word',
      minWidth: '100px',
      maxWidth: '100%',
      overflowX: 'auto',
    };

    const mergedBubbleStyle = { ...baseBubbleStyle, ...bubbleStyle };

    const ContentWrapper = (
      <div
        style={{
          maxWidth: '90%',
          width: '100%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: isHuman ? 'flex-end' : 'flex-start',
        }}>
        <div style={mergedBubbleStyle}>{children}</div>
        {footer}
      </div>
    );

    return (
      <div style={mergedContainer}>
        {!isHuman && (
          <Avatar
            style={{ backgroundColor: avatarColor, flexShrink: 0 }}
            size="small">
            {avatarLabel}
          </Avatar>
        )}
        {ContentWrapper}
        {isHuman && (
          <Avatar
            style={{ backgroundColor: avatarColor, flexShrink: 0 }}
            size="small">
            {avatarLabel}
          </Avatar>
        )}
      </div>
    );
  };

  const [hoveredSystemId, setHoveredSystemId] = useState<string | null>(null);

  const renderSystemGroup = (
    systemMessages: ThreadMessageDto[],
    count: number,
  ) => {
    const firstMessage = systemMessages[0];
    const content = formatMessageContent(firstMessage.message?.content);
    const countSuffix = count > 1 ? ` (${count} system messages)` : '';
    const fullText = `${content}${countSuffix}`;
    const groupId = `system-${firstMessage.id || firstMessage.createdAt}`;
    const expanded = expandedSystemIds.has(groupId);

    const isHovered = hoveredSystemId === groupId;
    const textContainerStyle: React.CSSProperties = expanded
      ? {
          fontSize: '12px',
          color: isHovered ? '#595959' : '#8c8c8c',
          textAlign: 'center',
        }
      : {
          fontSize: '12px',
          color: isHovered ? '#595959' : '#8c8c8c',
          textAlign: 'center',
          maxHeight: '60px',
          overflow: 'hidden',
          position: 'relative',
          cursor: 'pointer',
        };

    return (
      <div
        style={{ width: '100%' }}
        role="button"
        tabIndex={0}
        onClick={() => toggleSystemMessage(groupId)}
        onKeyDown={(event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            toggleSystemMessage(groupId);
          }
        }}
        onMouseEnter={() => setHoveredSystemId(groupId)}
        onMouseLeave={() =>
          setHoveredSystemId((prev) => (prev === groupId ? null : prev))
        }>
        <div style={textContainerStyle}>
          <MarkdownContent
            content={fullText}
            allowHorizontalScroll={expanded}
          />
          {!expanded && (
            <div style={{ ...collapsedGradientStyle, height: '18px' }} />
          )}
        </div>
      </div>
    );
  };

  const renderFinishTool = (
    status: 'calling' | 'executed',
    resultContent?: unknown,
  ) => {
    if (status === 'calling') {
      return undefined;
    }

    // Extract message and needsMoreInfo flag from result content
    let finishMessage = 'Task completed.';
    let needsMoreInfo = false;
    if (resultContent) {
      if (typeof resultContent === 'string') {
        finishMessage = resultContent;
      } else if (typeof resultContent === 'object' && resultContent !== null) {
        const obj = resultContent as Record<string, unknown>;
        finishMessage =
          (typeof obj.message === 'string' ? obj.message : '') ||
          (typeof obj.content === 'string' ? obj.content : '') ||
          (typeof obj.result === 'string' ? obj.result : '') ||
          'Task completed.';
        needsMoreInfo = Boolean(obj.needsMoreInfo);
      }
    }

    const messageColor = needsMoreInfo ? '#faad14' : '#52c41a';
    const statusTag = needsMoreInfo ? '⚠ Need more info' : '✓ Finished';

    return (
      <ChatBubble
        isHuman={false}
        avatarLabel="AI"
        avatarColor={messageColor}
        containerStyle={{ marginBottom: '8px' }}
        bubbleStyle={{
          backgroundColor: '#f3f3f3',
          borderLeft: `3px solid ${messageColor}`,
        }}>
        <Text
          type="secondary"
          style={{
            fontSize: '11px',
            marginBottom: '5px',
            display: 'block',
            color: messageColor,
            fontWeight: 'bold',
          }}>
          {statusTag}
        </Text>

        <MarkdownContent
          content={finishMessage}
          style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
        />
      </ChatBubble>
    );
  };

  const renderToolStatusLine = (
    name: string,
    status: 'calling' | 'executed',
    resultContent?: unknown,
    toolOptions?: Record<string, JsonValue>,
  ) => {
    const line = (
      <div
        style={{
          cursor:
            status === 'executed' && resultContent !== undefined
              ? 'pointer'
              : 'default',
        }}
        aria-label={
          status === 'executed'
            ? `View tool result for ${name}`
            : `Tool ${name} is calling`
        }
        tabIndex={
          status === 'executed' && resultContent !== undefined ? 0 : -1
        }>
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '8px',
          }}>
          {status === 'calling' && <Spin size="small" />}
          <Text type="secondary" style={{ fontSize: '12px', color: '#8c8c8c' }}>
            {toolOptions?.purpose
              ? `${name} | ${String(toolOptions.purpose)}`
              : `tool ${name} is ${status === 'calling' ? 'calling...' : 'executed'}`}
          </Text>
        </div>
      </div>
    );

    if (status === 'executed' && resultContent !== undefined) {
      const contentNode = renderToolPopoverContent(resultContent, toolOptions);
      return (
        <Popover content={contentNode} trigger={['click']} placement="topLeft">
          {line}
        </Popover>
      );
    }

    return line;
  };

  const truncateToLines = (
    text: string,
    maxLines: number,
  ): { truncated: string; full: string; isTruncated: boolean } => {
    const lines = text.split('\n');
    const isTruncated = lines.length > maxLines;
    const truncated = lines.slice(0, maxLines).join('\n');
    return { truncated, full: text, isTruncated };
  };

  const ShellToolDisplay: React.FC<{
    name: string;
    status: 'calling' | 'executed';
    resultContent?: unknown;
    shellCommand?: string;
    toolOptions?: Record<string, JsonValue>;
  }> = ({ name, status, resultContent, shellCommand, toolOptions }) => {
    const [commandExpanded, setCommandExpanded] = useState(false);
    const [outputExpanded, setOutputExpanded] = useState(false);

    const resultObj =
      typeof resultContent === 'object' &&
      resultContent !== null &&
      !Array.isArray(resultContent)
        ? (resultContent as ShellResult)
        : null;
    const exitCode = resultObj?.exitCode;
    const exitCodeStatus = exitCode !== undefined ? exitCode : null;
    const exitCodeColor =
      exitCodeStatus === null
        ? '#c4c4c4'
        : exitCodeStatus === 0
          ? '#c4c4c4'
          : '#ff4d4f'; // Red for non-zero exit codes
    const tint =
      exitCodeStatus === null
        ? '#2b2b2b'
        : exitCodeStatus === 0
          ? '#1d2b1f'
          : '#2b1d1d';

    const toolNameElement = (
      <div
        style={{
          cursor:
            status === 'executed' && resultContent !== undefined
              ? 'pointer'
              : 'default',
        }}
        aria-label={
          status === 'executed'
            ? `View shell result for ${name}`
            : `Shell ${name} is calling`
        }>
        {name}
      </div>
    );

    // Get output text
    const getOutputText = (): string | null => {
      if (
        resultObj?.output !== undefined &&
        typeof resultObj.output === 'string'
      ) {
        return resultObj.output;
      }
      if (typeof resultContent === 'string') {
        return resultContent;
      }
      if (resultObj && typeof resultObj === 'object') {
        const displayText =
          resultObj.output || resultObj.stdout || resultObj.stderr;
        if (typeof displayText === 'string') {
          return displayText;
        }
      }
      return null;
    };

    const outputText = getOutputText();
    const commandTruncated = shellCommand
      ? truncateToLines(shellCommand, 3)
      : null;
    const outputTruncated = outputText ? truncateToLines(outputText, 3) : null;

    return (
      <div style={{ marginBottom: `12px` }}>
        {toolOptions?.purpose && (
          <Text
            type="secondary"
            style={{
              fontSize: '12px',
              color: '#8c8c8c',
              lineHeight: '15px',
              display: 'block',
              marginBottom: '10px',
            }}>
            {String(toolOptions.purpose)}
          </Text>
        )}
        <div
          style={{
            background: '#1e1e1e',
            borderRadius: 6,
            border: '1px solid #333',
            color: '#e8e8e8',
            fontFamily:
              'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
            fontSize: 12,
            display: 'flex',
            flexDirection: 'column',
            gap: 6,
            boxShadow: 'inset 0 0 0 1px rgba(255,255,255,0.02)',
            backgroundImage: `linear-gradient(${tint}, ${tint})`,
            backgroundBlendMode: 'soft-light',
          }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              gap: 8,
              padding: '5px 10px',
              background: '#1a1a1a',
            }}>
            {status === 'executed' && resultContent !== undefined ? (
              <Popover
                content={renderToolPopoverContent(resultContent, toolOptions)}
                trigger={['click']}
                placement="topLeft">
                {toolNameElement}
              </Popover>
            ) : (
              toolNameElement
            )}

            {status === 'calling' ? (
              <>
                <Spin size="small" />
                <span style={{ color: '#c4c4c4' }}>executing…</span>
              </>
            ) : (
              <span
                style={{
                  color: exitCodeColor,
                }}>
                executed
                {exitCodeStatus !== null ? ` | exit ${exitCodeStatus}` : ''}
              </span>
            )}
          </div>

          {shellCommand && (
            <div style={{ padding: '5px 10px' }}>
              <div style={{ display: 'flex', alignItems: 'flex-start' }}>
                <span
                  style={{
                    color: '#a0a0a0',
                    paddingRight: '10px',
                    flexShrink: 0,
                  }}>
                  $
                </span>
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div
                    style={{
                      maxHeight:
                        commandExpanded || !commandTruncated?.isTruncated
                          ? 'none'
                          : '4.5em',
                      overflow:
                        commandExpanded || !commandTruncated?.isTruncated
                          ? 'visible'
                          : 'hidden',
                      position: 'relative',
                    }}>
                    <SyntaxHighlighter
                      language="bash"
                      style={vscDarkPlus}
                      customStyle={{
                        margin: 0,
                        padding: 0,
                        background: 'transparent',
                        fontSize: '12px',
                        whiteSpace: 'pre-wrap',
                        wordBreak: 'break-word',
                        lineHeight: '1.5',
                      }}
                      PreTag="div"
                      codeTagProps={{
                        style: {
                          fontFamily: 'inherit',
                          whiteSpace: 'pre-wrap',
                          wordBreak: 'break-word',
                          margin: 0,
                          padding: 0,
                          lineHeight: '1.5',
                        },
                      }}>
                      {shellCommand}
                    </SyntaxHighlighter>
                    {commandTruncated?.isTruncated && !commandExpanded && (
                      <div
                        style={{
                          position: 'absolute',
                          bottom: 0,
                          left: 0,
                          right: 0,
                          height: '1.5em',
                          background:
                            'linear-gradient(to bottom, transparent, #1e1e1e)',
                          pointerEvents: 'none',
                        }}
                      />
                    )}
                  </div>
                  {commandTruncated?.isTruncated && (
                    <div
                      style={{
                        color: '#1890ff',
                        cursor: 'pointer',
                        fontSize: '11px',
                        marginTop: '4px',
                        textDecoration: 'underline',
                      }}
                      onClick={() => setCommandExpanded(!commandExpanded)}>
                      {commandExpanded ? 'Show less' : 'Show more...'}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {status === 'executed' && outputText && (
            <div
              style={{
                borderTop: '1px solid #333',
              }}>
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  padding: '5px 10px',
                  borderBottom: '1px solid #333',
                  background: '#1a1a1a',
                }}>
                <span style={{ fontSize: '11px', color: '#c4c4c4' }}>
                  Output
                </span>
                <CopyOutlined
                  style={{
                    color: '#c4c4c4',
                    cursor: 'pointer',
                    fontSize: '14px',
                  }}
                  onClick={async () => {
                    try {
                      await navigator.clipboard.writeText(outputText);
                      message.success('Copied to clipboard');
                    } catch (err) {
                      message.error('Failed to copy to clipboard');
                    }
                  }}
                />
              </div>
              <div
                style={{
                  padding: '5px 10px',
                  maxHeight: outputExpanded ? '200px' : 'none',
                  overflowY: outputExpanded ? 'scroll' : 'visible',
                  overflowX: 'hidden',
                  scrollbarWidth: 'thin',
                  scrollbarColor: '#555 #2a2a2a',
                }}
                className="shell-output-container">
                <SyntaxHighlighter
                  language="bash"
                  style={vscDarkPlus}
                  customStyle={{
                    margin: 0,
                    padding: 0,
                    background: 'transparent',
                    fontSize: '12px',
                  }}
                  PreTag="div"
                  codeTagProps={{ style: { fontFamily: 'inherit' } }}>
                  {outputExpanded || !outputTruncated?.isTruncated
                    ? outputText
                    : outputTruncated.truncated}
                </SyntaxHighlighter>
                {outputTruncated?.isTruncated && (
                  <div
                    style={{
                      color: '#1890ff',
                      cursor: 'pointer',
                      fontSize: '11px',
                      marginTop: '4px',
                      textDecoration: 'underline',
                    }}
                    onClick={() => setOutputExpanded(!outputExpanded)}>
                    {outputExpanded ? 'Show less' : 'Show more...'}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  const renderShellStatusLine = (
    name: string,
    status: 'calling' | 'executed',
    resultContent?: unknown,
    shellCommand?: string,
    toolOptions?: Record<string, JsonValue>,
  ) => {
    return (
      <ShellToolDisplay
        name={name}
        status={status}
        resultContent={resultContent}
        shellCommand={shellCommand}
        toolOptions={toolOptions}
      />
    );
  };

  const renderNonAgentNodeInfo = () => {
    if (isAgentNode) return null;

    return (
      <div style={{ padding: '16px', textAlign: 'center' }}>
        <Space direction="vertical" size="large">
          <ToolOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
          <div>
            <Text strong style={{ fontSize: '16px' }}>
              {nodeTemplateKind || 'Tool'} Node
            </Text>
            <br />
            <Text type="secondary" style={{ fontSize: '14px' }}>
              This node executes tool calls and doesn't participate in
              conversations.
            </Text>
          </div>
          <div
            style={{
              backgroundColor: '#f8f9fa',
              border: '1px solid #e9ecef',
              borderRadius: '8px',
              padding: '12px',
              textAlign: 'left',
            }}>
            <Text strong style={{ fontSize: '13px', color: '#495057' }}>
              Tool Call Information:
            </Text>
            <br />
            <Text type="secondary" style={{ fontSize: '12px' }}>
              • Tool calls are executed when this node is triggered
              <br />
              • Results are passed to connected nodes
              <br />• Check the execution logs for detailed information
            </Text>
          </div>
        </Space>
      </div>
    );
  };

  const renderMessage = (message: ThreadMessageDto) => {
    const role = (message.message?.role as string) || '';
    const content = formatMessageContent(message.message?.content);
    const createdAt = new Date(message.createdAt).toLocaleString();

    if (isToolLikeRole(role)) {
      const name = message.message?.name || 'tool';
      const resultContent = message.message?.content;
      // For standalone tools, we don't have access to the original arguments
      return renderToolStatusLine(name, 'executed', resultContent, undefined);
    }

    if (isBlankContent(message.message?.content)) return null;

    const isHuman = role === 'human';
    const avatarColor = isHuman
      ? '#1890ff'
      : role === 'ai'
        ? '#52c41a'
        : role === 'system'
          ? '#722ed1'
          : '#d9d9d9';

    return (
      <ChatBubble
        isHuman={isHuman}
        avatarLabel={isHuman ? 'ME' : 'AI'}
        avatarColor={avatarColor}
        footer={
          <Text
            type="secondary"
            style={{ fontSize: '11px', marginTop: '4px', color: '#8c8c8c' }}>
            {`${createdAt} | ${role}`}
          </Text>
        }>
        <MarkdownContent
          content={content}
          style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
        />
      </ChatBubble>
    );
  };

  const renderPendingMessage = (message: PendingMessage) => {
    const isHuman = message.role === 'human';
    const content = message.content;

    // Determine when the message will be sent
    const sendTimeText =
      newMessageMode === 'inject_after_tool_call'
        ? 'Will be sent after next tool execution'
        : newMessageMode === 'wait_for_completion'
          ? 'Will be sent after agent completes current task'
          : 'Pending';

    return (
      <ChatBubble
        isHuman={isHuman}
        avatarLabel={isHuman ? 'ME' : 'AI'}
        avatarColor={isHuman ? '#1890ff' : '#52c41a'}
        containerStyle={{ opacity: 0.6 }}
        bubbleStyle={{ border: '2px dashed #d9d9d9' }}
        footer={
          <Text
            type="secondary"
            style={{
              fontSize: '11px',
              marginTop: '4px',
              color: '#8c8c8c',
              fontStyle: 'italic',
            }}>
            {sendTimeText}
          </Text>
        }>
        <MarkdownContent
          content={content}
          style={{ fontSize: '14px', lineHeight: '1.4', color: '#000000' }}
        />
      </ChatBubble>
    );
  };

  const renderPreparedMessages = () => {
    const rows: React.ReactNode[] = [];
    let i = 0;
    const isFinishToolMessage = (
      msg: PreparedMessage,
    ): msg is Extract<PreparedMessage, { type: 'tool' }> =>
      msg.type === 'tool' && (msg.name || '').toLowerCase() === 'finish';

    const pushRow = (
      key: React.Key,
      content: React.ReactNode,
      extraStyle?: React.CSSProperties,
    ) => {
      rows.push(
        <div key={key} style={{ ...messageBlockStyle, ...extraStyle }}>
          {content}
        </div>,
      );
    };

    while (i < preparedMessages.length) {
      const item = preparedMessages[i];

      if (item.type === 'system') {
        pushRow(
          item.id,
          renderSystemGroup(item.messages, item.messages.length),
        );
        i++;
        continue;
      }

      if (item.type === 'reasoning') {
        pushRow(item.id, <ReasoningMessage message={item.message} />);
        i++;
        continue;
      }

      if (item.type === 'chat') {
        pushRow(item.id, renderMessage(item.message));
        i++;
        continue;
      }

      if (item.type === 'tool') {
        if (isFinishToolMessage(item)) {
          pushRow(
            item.id || `finish-${i}`,
            renderFinishTool(item.status, item.result),
          );
          i++;
          continue;
        }

        const group: Array<Extract<PreparedMessage, { type: 'tool' }>> = [item];
        let j = i + 1;
        while (
          j < preparedMessages.length &&
          preparedMessages[j].type === 'tool' &&
          !isFinishToolMessage(preparedMessages[j])
        ) {
          group.push(
            preparedMessages[j] as Extract<PreparedMessage, { type: 'tool' }>,
          );
          j++;
        }

        pushRow(
          `tool-stack-${i}`,
          <div style={{ display: 'flex', flexDirection: 'column', rowGap: 2 }}>
            {group.map((t, idx) => (
              <div key={t.id || `tool-${i}-${idx}`}>
                {t.toolKind === 'shell'
                  ? renderShellStatusLine(
                      t.name,
                      t.status,
                      t.result,
                      t.shellCommand,
                      t.toolOptions,
                    )
                  : renderToolStatusLine(
                      t.name,
                      t.status,
                      t.result,
                      t.toolOptions,
                    )}
              </div>
            ))}
          </div>,
        );

        i = j;
        continue;
      }

      i++;
    }

    return rows;
  };

  if (!selectedThreadId) {
    return renderFullHeightState(
      <Text type="secondary">
        Select a thread from the header to view messages.
      </Text>,
    );
  }

  if (!isAgentNode) {
    return (
      <div style={fullHeightColumnStyle}>
        <div
          style={{
            ...scrollContainerStyle,
            overflowX: 'auto',
          }}>
          {renderNonAgentNodeInfo()}
        </div>
      </div>
    );
  }

  if (messagesLoading) {
    return renderFullHeightState(
      <Space direction="vertical" align="center" size="small">
        <Spin />
        <Text type="secondary">Loading messages...</Text>
      </Space>,
    );
  }

  if (messages.length === 0) {
    return renderFullHeightState(
      <Text type="secondary">No messages found for this thread and node.</Text>,
    );
  }

  return (
    <div style={fullHeightColumnStyle}>
      <div
        ref={scrollContainerRef}
        onScroll={handleScroll}
        style={scrollContainerStyle}>
        {loadingMore && (
          <div
            style={{
              padding: '8px 12px',
              textAlign: 'center',
              fontSize: '12px',
              color: '#8c8c8c',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '8px',
            }}>
            <Spin size="small" />
            <Text
              type="secondary"
              style={{ fontSize: '12px', color: '#8c8c8c' }}>
              Loading more messages...
            </Text>
          </div>
        )}

        {renderPreparedMessages()}
        {isThinkingVisible && !messagesLoading && (
          <div
            style={{
              textAlign: 'center',
              animation:
                'messages-tab-thinking-pulse 1.6s ease-in-out infinite',
            }}>
            <div
              style={{
                fontSize: '12px',
                color: '#8c8c8c',
                textAlign: 'center',
                cursor: 'pointer',
                display: '-webkit-box',
                WebkitLineClamp: 3,
                WebkitBoxOrient: 'vertical',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                lineHeight: '1.5',
                wordBreak: 'break-word',
                width: '100%',
              }}>
              Agent is thinking...
            </div>
          </div>
        )}
        {pendingMessages && pendingMessages.length > 0 && (
          <div
            style={{
              borderTop: '1px solid #ebebeb',
              paddingTop: '10px',
              marginTop: '8px',
            }}>
            {pendingMessages.map((msg, idx) => (
              <div key={`pending-${idx}`} style={messageBlockStyle}>
                {renderPendingMessage(msg)}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default MessagesTab;
