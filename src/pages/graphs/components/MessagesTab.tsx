// MessagesTab.tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { List, Avatar, Typography, Card, Space, Collapse, Spin, Popover } from 'antd';
import { ToolOutlined, ConsoleSqlOutlined } from '@ant-design/icons';
import type { ThreadMessageDto } from '../../../autogenerated';

interface ToolCallFunction {
  name?: string;
  arguments?: string | Record<string, unknown>;
}
interface ToolCall {
  id?: string;
  name?: string;
  function?: ToolCallFunction;
}

const { Text, Paragraph } = Typography;

interface MessagesTabProps {
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  selectedThreadId?: string;
  nodeId?: string;
  isAgentNode?: boolean;
  nodeTemplateKind?: string;
  onLoadMoreMessages?: () => void;
  hasMoreMessages?: boolean;
  loadingMore?: boolean;
}

const MessagesTab: React.FC<MessagesTabProps> = ({
  messages,
  messagesLoading,
  selectedThreadId,
  nodeId,
  isAgentNode = true,
  nodeTemplateKind,
  onLoadMoreMessages,
  hasMoreMessages,
  loadingMore,
}) => {
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const prevScrollHeightRef = useRef<number>(0);
  const isPrependingRef = useRef<boolean>(false);
  const pendingAutoScrollRef = useRef<boolean>(false);

  // Mark that we should auto-scroll after this node/thread finishes loading
  useEffect(() => {
    pendingAutoScrollRef.current = true;
  }, [selectedThreadId, nodeId]);

  // After prepending older messages, keep the user's scroll position stable
  useEffect(() => {
    if (!isPrependingRef.current) return;
    const el = scrollContainerRef.current;
    if (el) {
      const oldScrollHeight = prevScrollHeightRef.current;
      const newScrollHeight = el.scrollHeight;
      const diff = newScrollHeight - oldScrollHeight;
      el.scrollTop = diff + el.scrollTop;
    }
    isPrependingRef.current = false;
  }, [messages.length]);

  // After messages for the newly focused node/thread finish loading, snap to bottom once
  useEffect(() => {
    if (messagesLoading) {
      return;
    }
    if (!pendingAutoScrollRef.current) {
      return;
    }
    const el = scrollContainerRef.current;
    if (el) {
      el.scrollTop = el.scrollHeight;
    }
    pendingAutoScrollRef.current = false;
  }, [messagesLoading, messages.length]);

  const handleScroll = useCallback(() => {
    const el = scrollContainerRef.current;
    if (!el) return;

    const nearTop = el.scrollTop <= 100;
    if (
      nearTop &&
      hasMoreMessages &&
      !loadingMore &&
      typeof onLoadMoreMessages === 'function'
    ) {
      prevScrollHeightRef.current = el.scrollHeight;
      isPrependingRef.current = true;
      onLoadMoreMessages();
    }
  }, [hasMoreMessages, loadingMore, onLoadMoreMessages]);
  const formatMessageContent = (content: unknown): string => {
    if (typeof content === 'string') {
      return content;
    }
    if (typeof content === 'object' && content !== null) {
      return JSON.stringify(content, null, 2);
    }
    return String(content ?? '');
  };

  const isBlankContent = (content: unknown): boolean => {
    if (content === null || content === undefined) return true;
    if (typeof content === 'string') return content.trim().length === 0;
    return false; // objects/numbers considered non-blank for our purposes
  };

  const renderToolCallContent = (toolCalls: ToolCall[]) => {
    const items = toolCalls.map((toolCall, index) => {
      const funcName = toolCall.function?.name || 'Tool Call';
      const funcArgs = toolCall.function?.arguments;

      let parsedArgs: string | null = null;
      if (typeof funcArgs === 'string') {
        try {
          parsedArgs = JSON.stringify(JSON.parse(funcArgs), null, 2);
        } catch {
          parsedArgs = funcArgs;
        }
      } else if (typeof funcArgs === 'object' && funcArgs !== null) {
        parsedArgs = JSON.stringify(funcArgs, null, 2);
      }

      return {
        key: index.toString(),
        label: (
          <Space>
            <ToolOutlined />
            <Text strong>{funcName}</Text>
            <Text
              type="secondary"
              style={{ fontSize: '11px', color: '#8c8c8c' }}>
              #{index + 1}
            </Text>
          </Space>
        ),
        children: (
          <div style={{ padding: '8px 0' }}>
            {parsedArgs && (
              <div style={{ marginBottom: '8px' }}>
                <Text type="secondary" style={{ fontSize: '12px' }}>
                  Arguments:
                </Text>
                <pre
                  style={{
                    background: '#f5f5f5',
                    padding: '8px',
                    borderRadius: '4px',
                    fontSize: '12px',
                    margin: '4px 0',
                    overflow: 'auto',
                  }}>
                  {parsedArgs}
                </pre>
              </div>
            )}
            {toolCall.id && (
              <Text type="secondary" style={{ fontSize: '12px' }}>
                ID: {toolCall.id}
              </Text>
            )}
          </div>
        ),
      };
    });

    return <Collapse size="small" ghost items={items} />;
  };

  const renderShellToolCall = (message: ThreadMessageDto) => {
    const content = message.message?.content;
    if (typeof content === 'object' && content?.command) {
      return (
        <Card
          size="small"
          style={{
            backgroundColor: '#1e1e1e',
            color: '#ffffff',
            borderRadius: '8px',
            border: '1px solid #333',
            fontFamily: 'Monaco, Consolas, "Courier New", monospace',
          }}
          bodyStyle={{ padding: '12px' }}>
          <div style={{ marginBottom: '8px' }}>
            <Space>
              <ConsoleSqlOutlined style={{ color: '#52c41a' }} />
              <Text style={{ color: '#52c41a', fontSize: '12px' }}>
                Shell Command
              </Text>
            </Space>
          </div>

          <div style={{ marginBottom: '8px' }}>
            <Text style={{ color: '#ffffff', fontSize: '14px' }}>
              $ {content.command}
            </Text>
          </div>

          {content.output && (
            <div style={{ marginBottom: '8px' }}>
              <Text style={{ color: '#ffffff', fontSize: '12px' }}>
                {content.output}
              </Text>
            </div>
          )}

          {content.exitCode !== undefined && (
            <div style={{ marginBottom: '8px' }}>
              <Text
                style={{
                  color: content.exitCode === 0 ? '#52c41a' : '#ff4d4f',
                  fontSize: '12px',
                }}>
                Exit code: {content.exitCode}
              </Text>
            </div>
          )}

          {content.error && (
            <div>
              <Text style={{ color: '#ff4d4f', fontSize: '12px' }}>
                Error: {content.error}
              </Text>
            </div>
          )}
        </Card>
      );
    }
    return null;
  };

  const renderNonAgentNodeInfo = () => {
    if (isAgentNode) return null;

    return (
      <div style={{ padding: '16px', textAlign: 'center' }}>
        <Space direction="vertical" size="large">
          <ToolOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
          <div>
            <Text strong style={{ fontSize: '16px' }}>
              {nodeTemplateKind || 'Tool'} Node
            </Text>
            <br />
            <Text type="secondary" style={{ fontSize: '14px' }}>
              This node executes tool calls and doesn't participate in
              conversations.
            </Text>
          </div>
          <div
            style={{
              backgroundColor: '#f8f9fa',
              border: '1px solid #e9ecef',
              borderRadius: '8px',
              padding: '12px',
              textAlign: 'left',
            }}>
            <Text strong style={{ fontSize: '13px', color: '#495057' }}>
              Tool Call Information:
            </Text>
            <br />
            <Text type="secondary" style={{ fontSize: '12px' }}>
              • Tool calls are executed when this node is triggered
              <br />
              • Results are passed to connected nodes
              <br />• Check the execution logs for detailed information
            </Text>
          </div>
        </Space>
      </div>
    );
  };

  if (!selectedThreadId) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Text type="secondary">
            Select a thread from the header to view messages.
          </Text>
        </div>
      </div>
    );
  }

  if (!isAgentNode) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            overflow: 'auto',
          }}>
          {renderNonAgentNodeInfo()}
        </div>
      </div>
    );
  }

  if (messagesLoading) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Spin />
          <div style={{ marginTop: 8 }}>
            <Text type="secondary">Loading messages...</Text>
          </div>
        </div>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div
        style={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          minHeight: 0,
        }}>
        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}>
          <Text type="secondary">
            No messages found for this thread and node.
          </Text>
        </div>
      </div>
    );
  }

  // Prepared message model to decouple data shaping from rendering
  type PreparedMessage =
    | { type: 'system'; messages: ThreadMessageDto[]; id: string }
    | {
        type: 'chat';
        message: ThreadMessageDto; // human or ai (non-tool-only)
        id: string;
      }
    | {
        type: 'tool';
        name: string;
        status: 'calling' | 'executed';
        result?: unknown;
        id: string; // stable key (prefer toolCall.id or message.id)
      };

  const prepareReadyMessages = (msgs: ThreadMessageDto[]): PreparedMessage[] => {
    const prepared: PreparedMessage[] = [];

    let i = 0;
    while (i < msgs.length) {
      const m = msgs[i];
      const role = (m.message?.role as string) || '';

      // Collapse consecutive system messages
      if (role === 'system') {
        const sys: ThreadMessageDto[] = [m];
        let j = i + 1;
        while (j < msgs.length && (msgs[j].message?.role as string) === 'system') {
          sys.push(msgs[j]);
          j++;
        }
        prepared.push({ type: 'system', messages: sys, id: `system-${sys[0].id || sys[0].createdAt}` });
        i = j;
        continue;
      }

      // Group an AI message that might contain toolCalls
      if (role === 'ai' && Array.isArray(m.message?.toolCalls) && m.message!.toolCalls.length > 0) {
        // If AI has non-blank content, emit chat bubble
        if (!isBlankContent(m.message?.content)) {
          prepared.push({ type: 'chat', message: m, id: `chat-${m.id || m.createdAt}` });
        }

        // For each toolCall, create a tool prepared item and join with its result message if present
        const toolCalls = m.message!.toolCalls as unknown as ToolCall[];
        // Look ahead to collect following tool role messages (only contiguous tool messages)
        const followingTools: ThreadMessageDto[] = [];
        let j = i + 1;
        while (j < msgs.length && (msgs[j].message?.role as string) === 'tool') {
          followingTools.push(msgs[j]);
          j++;
        }

        for (let idx = 0; idx < toolCalls.length; idx++) {
          const tc = toolCalls[idx];
          const name = tc.name || tc.function?.name || 'tool';
          const matched = followingTools.find(
            (tm) => tm.message?.toolCallId && tm.message?.toolCallId === tc.id,
          );
          prepared.push({
            type: 'tool',
            name,
            status: matched ? 'executed' : 'calling',
            result: matched?.message?.content,
            id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
          });
        }

        // Skip over the contiguous tool messages we consumed in lookahead
        i = i + 1 + followingTools.length;
        continue;
      }

      // Standalone tool message (not tied to an earlier visible AI message)
      if (role === 'tool') {
        prepared.push({
          type: 'tool',
          name: m.message?.name || 'tool',
          status: 'executed',
          result: m.message?.content,
          id: `tool-standalone-${m.id || m.createdAt}`,
        });
        i++;
        continue;
      }

      // Human or AI without toolCalls
      if (!isBlankContent(m.message?.content)) {
        prepared.push({ type: 'chat', message: m, id: `chat-${m.id || m.createdAt}` });
      }
      i++;
    }

    return prepared;
  };

  const renderSystemGroup = (
    systemMessages: ThreadMessageDto[],
    count: number,
  ) => {
    const firstMessage = systemMessages[0];
    const content = formatMessageContent(firstMessage.message?.content);

    return (
      <div style={{ padding: '4px 12px', marginBottom: '4px' }}>
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            gap: '8px',
          }}>
          <Text
            type="secondary"
            style={{ fontSize: '12px', color: '#8c8c8c', textAlign: 'center' }}>
            {content}
            {count > 1 && ` (${count} system messages)`}
          </Text>
        </div>
      </div>
    );
  };

  const renderToolStatusLine = (
    name: string,
    status: 'calling' | 'executed',
    resultContent?: unknown,
    options?: { marginBottom?: number; paddingY?: number }
  ) => {
    const mb = options?.marginBottom ?? 4;
    const py = options?.paddingY ?? 2; // slightly tighter vertical padding by default

    const line = (
      <div
        style={{
          padding: `${py}px 12px`,
          marginBottom: `${mb}px`,
          cursor:
            status === 'executed' && resultContent !== undefined ? 'pointer' : 'default',
        }}
        aria-label={
          status === 'executed'
            ? `View tool result for ${name}`
            : `Tool ${name} is calling`
        }
        tabIndex={status === 'executed' && resultContent !== undefined ? 0 : -1}
      >
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '8px',
          }}
        >
          {status === 'calling' && <Spin size="small" />}
          <Text type="secondary" style={{ fontSize: '12px', color: '#8c8c8c' }}>
            {`tool ${name} is ${status === 'calling' ? 'calling...' : 'executed'}`}
          </Text>
        </div>
      </div>
    );

    if (status === 'executed' && resultContent !== undefined) {
      const pretty =
        typeof resultContent === 'string'
          ? resultContent
          : typeof resultContent === 'object' && resultContent !== null
            ? JSON.stringify(resultContent, null, 2)
            : String(resultContent);

      const content = (
        <div style={{ maxWidth: 520 }}>
          <div
            style={{
              maxHeight: 300,
              overflow: 'auto',
              background: '#f5f5f5',
              border: '1px solid #eee',
              borderRadius: 6,
              padding: 12,
              fontFamily:
                'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
              fontSize: 12,
              whiteSpace: 'pre-wrap',
            }}
          >
            <pre style={{ margin: 0, whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
              {pretty}
            </pre>
          </div>
        </div>
      );

      return (
        <Popover content={content} trigger={["click"]} placement="topLeft">
          {line}
        </Popover>
      );
    }

    return line;
  };

  const renderToolGroup = (toolGroup: ThreadMessageDto[]) => {
    const aiMessage = toolGroup[0];
    const toolMessages = toolGroup.slice(1);
    const createdAt = new Date(aiMessage.createdAt).toLocaleString();
    const aiContent = formatMessageContent(aiMessage.message?.content);

    const showAiBubble = !isBlankContent(aiMessage.message?.content);

    return (
      <>
        {showAiBubble && (
          <div style={{ padding: '8px 12px', marginBottom: '4px' }}>
            <Card
              size="small"
              style={{
                backgroundColor: '#f0f8ff',
                borderRadius: '8px',
                border: '1px solid #e6f7ff',
                width: '100%',
              }}
              bodyStyle={{ padding: '12px' }}>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'flex-start',
                  gap: '8px',
                }}>
                <Avatar
                  style={{
                    backgroundColor: '#52c41a',
                    flexShrink: 0,
                  }}
                  size="small">
                  AI
                </Avatar>
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'flex-end',
                      gap: '8px',
                      marginBottom: '4px',
                    }}>
                    <Text
                      type="secondary"
                      style={{ fontSize: '12px', color: '#8c8c8c' }}>
                      {`${createdAt} | ai`}
                    </Text>
                  </div>

                  {aiContent && (
                    <Paragraph
                      style={{
                        margin: 0,
                        fontSize: '14px',
                        lineHeight: '1.4',
                        wordBreak: 'break-word',
                        marginBottom: toolMessages.length > 0 ? '12px' : '0',
                      }}>
                      {aiContent}
                    </Paragraph>
                  )}

                  {/* AI bubble intentionally ends without any inline tool UI */}
                </div>
              </div>
            </Card>
          </div>
        )}

        {/* Render tool status lines as separate system-style rows under the AI message */}
        {aiMessage.message?.toolCalls && aiMessage.message.toolCalls.length > 0 && (
          <div style={{ padding: '4px 12px', marginBottom: '4px' }}>
            {aiMessage.message.toolCalls.map((toolCall: ToolCall, idx: number) => {
              const name = toolCall.name || toolCall.function?.name || 'tool';
              const matched = toolMessages.find(
                (tm) => tm.message?.toolCallId === toolCall.id,
              );
              const executed = !!matched;
              const resultContent = executed ? matched?.message?.content : undefined;
              return (
                <div key={toolCall.id || idx}>
                  {renderToolStatusLine(
                    name,
                    executed ? 'executed' : 'calling',
                    resultContent,
                  )}
                </div>
              );
            })}
          </div>
        )}
      </>
    );
  };

  const renderMessage = (message: ThreadMessageDto) => {
    const role = (message.message?.role as string) || '';
    const content = formatMessageContent(message.message?.content);
    const createdAt = new Date(message.createdAt).toLocaleString();

    // Standalone tool messages should look like system messages: plain gray line with optional popover
    if (role === 'tool') {
      const name = message.message?.name || 'tool';
      const resultContent = message.message?.content;
      return renderToolStatusLine(name, 'executed', resultContent);
    }

    // Skip rendering empty non-tool bubbles (prevents blank AI cards)
    if (isBlankContent(message.message?.content)) {
      return null;
    }

    const isShellToolCall =
      role === 'tool' &&
      typeof message.message?.content === 'object' &&
      message.message?.content?.command;

    const isHuman = role === 'human';

    return (
      <div
        style={{
          padding: '8px 12px',
          marginBottom: '8px',
          display: 'flex',
          justifyContent: isHuman ? 'flex-end' : 'flex-start',
          alignItems: 'flex-start',
          gap: '8px',
        }}>
        {!isHuman && (
          <Avatar
            style={{
              backgroundColor:
                role === 'ai'
                  ? '#52c41a'
                  : role === 'system'
                    ? '#722ed1'
                    : '#d9d9d9',
              flexShrink: 0,
            }}
            size="small">
            AI
          </Avatar>
        )}

        <div
          style={{
            maxWidth: '70%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: isHuman ? 'flex-end' : 'flex-start',
          }}>
          <div
            style={{
              backgroundColor: isHuman ? '#f0f8ff' : '#f3f3f3',
              borderRadius: '5px',
              padding: '8px 12px',
              wordBreak: 'break-word',
              minWidth: '100px',
            }}>
            {isShellToolCall ? (
              renderShellToolCall(message)
            ) : (
              <div
                style={{
                  fontSize: '14px',
                  lineHeight: '1.4',
                  color: '#000000',
                }}>
                {content}
              </div>
            )}

            {/* No inline tool UI inside the AI bubble */}
          </div>

          <Text
            type="secondary"
            style={{
              fontSize: '11px',
              marginTop: '4px',
              color: '#8c8c8c',
            }}>
            {`${createdAt} | ${role}`}
          </Text>
        </div>

        {isHuman && (
          <Avatar
            style={{
              backgroundColor: '#1890ff',
              flexShrink: 0,
            }}
            size="small">
            ME
          </Avatar>
        )}
      </div>
    );
  };

  return (
    <div
      style={{
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        minHeight: 0,
      }}>
      <div
        ref={scrollContainerRef}
        onScroll={handleScroll}
        style={{
          flex: 1,
          minHeight: 0,
          overflow: 'auto',
          padding: 0,
        }}>
        {loadingMore && (
          <div
            style={{
              padding: '8px 12px',
              textAlign: 'center',
              fontSize: '12px',
              color: '#8c8c8c',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '8px',
            }}>
            <Spin size="small" />
            <Text
              type="secondary"
              style={{ fontSize: '12px', color: '#8c8c8c' }}>
              Loading more messages...
            </Text>
          </div>
        )}

        {(() => {
          const prepared = prepareReadyMessages(messages);
          const rows: React.ReactNode[] = [];

          let i = 0;
          while (i < prepared.length) {
            const item = prepared[i];

            if (item.type === 'system') {
              rows.push(
                <div key={item.id}>{renderSystemGroup(item.messages, item.messages.length)}</div>,
              );
              i++;
              continue;
            }

            if (item.type === 'chat') {
              rows.push(<div key={item.id}>{renderMessage(item.message)}</div>);
              i++;
              continue;
            }

            // Group consecutive tool lines into a compact stack with minimal gaps
            if (item.type === 'tool') {
              const group: typeof item[] = [item];
              let j = i + 1;
              while (j < prepared.length && prepared[j].type === 'tool') {
                group.push(prepared[j] as any);
                j++;
              }

              rows.push(
                <div
                  key={`tool-stack-${i}`}
                  style={{
                    padding: '0 12px',
                    display: 'flex',
                    flexDirection: 'column',
                    rowGap: 2, // tighten spacing between tool lines
                    marginBottom: 6, // small separation after the group
                  }}
                >
                  {group.map((t, idx) =>
                    renderToolStatusLine(t.name, t.status, t.result, {
                      marginBottom: 0,
                      paddingY: 2,
                    }),
                  )}
                </div>,
              );

              i = j;
              continue;
            }

            i++;
          }

          return rows;
        })()}
      </div>
    </div>
  );
};

export default MessagesTab;
