// GraphCanvas.tsx
import '@xyflow/react/dist/style.css';

import {
  Background,
  BackgroundVariant,
  Connection,
  Controls,
  MiniMap,
  Node,
  NodeTypes,
  OnConnectStart,
  OnEdgesChange,
  OnNodesChange,
  PanOnScrollMode,
  ReactFlow,
  ReactFlowProvider,
  useReactFlow,
  Viewport,
} from '@xyflow/react';
import {
  createContext,
  memo,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';

import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  TemplateDto,
} from '../../../autogenerated';
import { GraphValidationService } from '../../../services/GraphValidationService';
import { getTemplateKindColor } from '../../../utils/templateColors';
import type { GraphEdge, GraphNode, GraphNodeData } from '../types';
import {
  type ConnectionPreview,
  type ConnectionRule,
  createEdge,
  makeHandleId,
} from '../utils/graphCanvasUtils';
import { CustomNode } from './CustomNode';

// Context for frequently-changing data that CustomNode needs, so nodeTypes
// doesn't have to be recreated (which causes ReactFlow to remount all nodes).
interface NodeDynamicContext {
  compiledNodes?: Record<string, GraphNodeWithStatusDto>;
  compiledNodesLoading?: boolean;
  connectionPreview: ConnectionPreview | null;
  onNodeEdit: (node: GraphNode) => void;
  onNodeDelete: (nodeId: string) => void;
}

const noop = () => {};
export const NodeDynamicCtx = createContext<NodeDynamicContext>({
  compiledNodes: undefined,
  compiledNodesLoading: false,
  connectionPreview: null,
  onNodeEdit: noop as (node: GraphNode) => void,
  onNodeDelete: noop as (nodeId: string) => void,
});

export const useNodeDynamicCtx = () => useContext(NodeDynamicCtx);

interface GraphCanvasProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
  onNodeAdd: (node: GraphNode) => void;
  onNodeEdit: (node: GraphNode) => void;
  onNodeDelete: (nodeId: string) => void;
  onNodeSelect?: (node: GraphNode | null) => void;
  onViewportChange?: (viewport: Viewport) => void;
  initialViewport?: Viewport;
  templates?: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  onTriggerClick?: (nodeId: string) => void;
  onValidationError?: (error: string) => void;
  compiledNodes?: Record<string, GraphNodeWithStatusDto>;
  compiledNodesLoading?: boolean;
}

const GraphCanvasInner = ({
  nodes,
  edges,
  onNodesChange,
  onEdgesChange,
  onNodeAdd,
  onNodeEdit,
  onNodeDelete,
  onNodeSelect,
  onViewportChange,
  initialViewport,
  templates = [],
  graphStatus,
  onTriggerClick,
  onValidationError,
  compiledNodes,
  compiledNodesLoading,
}: GraphCanvasProps) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const {
    screenToFlowPosition,
    setViewport: setReactFlowViewport,
    getViewport,
  } = useReactFlow();
  const [connectionPreview, setConnectionPreview] =
    useState<ConnectionPreview | null>(null);

  useEffect(() => {
    if (!initialViewport) return;

    const current = getViewport();
    const same =
      Math.abs(current.x - initialViewport.x) < 0.01 &&
      Math.abs(current.y - initialViewport.y) < 0.01 &&
      Math.abs(current.zoom - initialViewport.zoom) < 0.0001;

    if (same) return;

    setReactFlowViewport(initialViewport);
  }, [initialViewport, getViewport, setReactFlowViewport]);

  // nodeTypes is now stable — compiledNodes and connectionPreview are
  // delivered via NodeDynamicCtx so changes don't cause node remounts.
  const nodeTypes = useMemo<NodeTypes>(
    () => ({
      custom: (p) => (
        <CustomNode
          {...p}
          templates={templates}
          graphStatus={graphStatus}
          onTriggerClick={onTriggerClick}
        />
      ),
    }),
    [templates, graphStatus, onTriggerClick],
  );

  // Store stable refs so the context value doesn't change on every render.
  const onNodeEditRef = useRef(onNodeEdit);
  onNodeEditRef.current = onNodeEdit;
  const onNodeDeleteRef = useRef(onNodeDelete);
  onNodeDeleteRef.current = onNodeDelete;

  // Stable callbacks that read from refs — identity never changes.
  const stableOnNodeEdit = useCallback(
    (node: GraphNode) => onNodeEditRef.current(node),
    [],
  );
  const stableOnNodeDelete = useCallback(
    (nodeId: string) => onNodeDeleteRef.current(nodeId),
    [],
  );

  // Context value for dynamic per-frame data (compiled status, connection preview)
  // and stable edit/delete callbacks.
  const dynamicCtx = useMemo<NodeDynamicContext>(
    () => ({
      compiledNodes,
      compiledNodesLoading,
      connectionPreview,
      onNodeEdit: stableOnNodeEdit,
      onNodeDelete: stableOnNodeDelete,
    }),
    [
      compiledNodes,
      compiledNodesLoading,
      connectionPreview,
      stableOnNodeEdit,
      stableOnNodeDelete,
    ],
  );

  const normalizeRule = useCallback(
    (rule: {
      type?: unknown;
      value?: unknown;
      required?: unknown;
      multiple?: unknown;
    }): ConnectionRule => ({
      type: (rule.type as 'kind' | 'template') ?? 'kind',
      value: String(rule.value ?? ''),
      required: Boolean(rule.required),
      multiple: Boolean(rule.multiple),
    }),
    [],
  );

  const findRuleForHandle = useCallback(
    (
      nodeId: string,
      handleType: 'source' | 'target',
      handleId: string,
    ): ConnectionRule | undefined => {
      const node = nodes.find((n) => n.id === nodeId);
      if (!node) return undefined;
      const nodeTemplate = templates.find(
        (t) => t.id === (node.data as unknown as GraphNodeData).template,
      );
      if (!nodeTemplate) return undefined;

      if (handleType === 'source') {
        return (
          nodeTemplate.outputs
            ?.map(normalizeRule)
            .find((rule) => makeHandleId('source', rule) === handleId) ??
          undefined
        );
      }

      const inputRules = GraphValidationService.getAvailableConnectionTypes(
        {
          id: node.id,
          data: node.data,
          position: node.position,
          type: node.type ?? 'custom',
        } satisfies GraphNode,
        templates,
      );

      return inputRules.find(
        (rule) => makeHandleId('target', normalizeRule(rule)) === handleId,
      );
    },
    [nodes, templates, normalizeRule],
  );

  const clearConnectionPreview = useCallback(() => {
    setConnectionPreview(null);
  }, []);

  const handleConnectStart = useCallback<OnConnectStart>(
    (_event, params) => {
      if (!params.nodeId || !params.handleId || !params.handleType) {
        clearConnectionPreview();
        return;
      }

      const rule = findRuleForHandle(
        params.nodeId,
        params.handleType,
        params.handleId,
      );
      const sourceNode = nodes.find((n) => n.id === params.nodeId);
      const template = templates.find(
        (t) =>
          t.id === (sourceNode?.data as GraphNodeData | undefined)?.template,
      );

      setConnectionPreview({
        fromHandleType: params.handleType,
        handleId: params.handleId,
        rule,
        template,
      });
    },
    [clearConnectionPreview, findRuleForHandle, nodes, templates],
  );

  const onConnect = useCallback(
    (params: Connection) => {
      clearConnectionPreview();

      if (templates.length > 0) {
        const sourceNode = nodes.find((n) => n.id === params.source);
        const targetNode = nodes.find((n) => n.id === params.target);

        if (sourceNode && targetNode) {
          const validation = GraphValidationService.validateConnection(
            sourceNode,
            targetNode,
            templates,
            {
              sourceHandleId: params.sourceHandle ?? undefined,
              targetHandleId: params.targetHandle ?? undefined,
            },
          );

          if (!validation.isValid) {
            const errorMessage = validation.errors
              .map((e) => e.message)
              .join('; ');
            onValidationError?.(errorMessage);
            return;
          }
        }
      }

      const newEdge = createEdge(
        params.source || '',
        params.target || '',
        params.sourceHandle || undefined,
        params.targetHandle || undefined,
      );
      onEdgesChange([
        {
          type: 'add',
          item: newEdge,
        },
      ]);
    },
    [
      clearConnectionPreview,
      onEdgesChange,
      nodes,
      templates,
      onValidationError,
    ],
  );

  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const templateData = event.dataTransfer.getData('application/reactflow');
      if (!templateData) return;

      const template: TemplateDto = JSON.parse(templateData) as TemplateDto;

      const position = screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });

      const newNode: GraphNode = {
        id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: 'custom',
        position,
        data: {
          label: template.name,
          template: template.id,
          templateKind: template.kind,
          templateSchema: template.schema,
          config: {},
        },
      };

      onNodeAdd(newNode);
    },
    [onNodeAdd, screenToFlowPosition],
  );

  const handleNodeDoubleClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeEdit(node as GraphNode);
    },
    [onNodeEdit],
  );

  const handleNodeClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeSelect?.(node as GraphNode);
    },
    [onNodeSelect],
  );

  const handlePaneClick = useCallback(() => {
    onNodeSelect?.(null);
  }, [onNodeSelect]);

  const handleViewportChange = useCallback(
    (viewport: Viewport) => {
      onViewportChange?.(viewport);
    },
    [onViewportChange],
  );

  const miniMapNodeColor = useCallback(
    (node: Node) => {
      if (node.type === 'custom') {
        const nodeData = node.data as unknown as GraphNodeData;
        const templateKind =
          nodeData?.templateKind ??
          templates.find((t) => t.id === nodeData?.template)?.kind;
        return getTemplateKindColor(templateKind);
      }
      return '#eee';
    },
    [templates],
  );

  const miniMapStyle = useMemo(
    () => ({
      width: 140,
      height: 100,
    }),
    [],
  );

  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    // On macOS trackpads, horizontal two-finger swipes generate wheel events with deltaX.
    // If the browser treats that as "overscroll", it can trigger Back/Forward navigation.
    // Prevent the default wheel behavior while still letting ReactFlow handle panning.
    const handleWheel = (event: WheelEvent) => {
      if (Math.abs(event.deltaX) > 0) {
        event.preventDefault();
      }
    };

    const addOptions: AddEventListenerOptions = {
      passive: false,
      capture: true,
    };
    const removeOptions: EventListenerOptions = { capture: true };

    el.addEventListener('wheel', handleWheel, addOptions);
    return () => {
      el.removeEventListener('wheel', handleWheel, removeOptions);
    };
  }, []);

  return (
    <NodeDynamicCtx.Provider value={dynamicCtx}>
      <div
        ref={containerRef}
        style={{
          width: '100%',
          height: '100%',
          overscrollBehavior: 'none',
          overscrollBehaviorX: 'none',
        }}>
        <ReactFlow
          nodes={nodes as Node[]}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onConnectStart={handleConnectStart}
          onConnectEnd={clearConnectionPreview}
          onDrop={onDrop}
          onDragOver={onDragOver}
          onNodeClick={handleNodeClick}
          onNodeDoubleClick={handleNodeDoubleClick}
          onPaneClick={handlePaneClick}
          onViewportChange={handleViewportChange}
          nodeTypes={nodeTypes}
          fitView={!initialViewport}
          deleteKeyCode={['Delete', 'Backspace']}
          defaultViewport={initialViewport}
          minZoom={0.1}
          maxZoom={4}
          panOnScroll
          panOnScrollMode={PanOnScrollMode.Free}
          zoomOnScroll={false}>
          <Controls />
          <MiniMap style={miniMapStyle} nodeColor={miniMapNodeColor} />
          <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
        </ReactFlow>
      </div>
    </NodeDynamicCtx.Provider>
  );
};

// Memoize GraphCanvasInner to prevent unnecessary rerenders
const MemoizedGraphCanvasInner = memo(
  GraphCanvasInner,
  (prevProps, nextProps) => {
    return (
      prevProps.nodes === nextProps.nodes &&
      prevProps.edges === nextProps.edges &&
      prevProps.onNodesChange === nextProps.onNodesChange &&
      prevProps.onEdgesChange === nextProps.onEdgesChange &&
      prevProps.onNodeAdd === nextProps.onNodeAdd &&
      prevProps.onNodeEdit === nextProps.onNodeEdit &&
      prevProps.onNodeDelete === nextProps.onNodeDelete &&
      prevProps.onNodeSelect === nextProps.onNodeSelect &&
      prevProps.onViewportChange === nextProps.onViewportChange &&
      prevProps.initialViewport?.x === nextProps.initialViewport?.x &&
      prevProps.initialViewport?.y === nextProps.initialViewport?.y &&
      prevProps.initialViewport?.zoom === nextProps.initialViewport?.zoom &&
      prevProps.templates === nextProps.templates &&
      prevProps.graphStatus === nextProps.graphStatus &&
      prevProps.onTriggerClick === nextProps.onTriggerClick &&
      prevProps.onValidationError === nextProps.onValidationError &&
      prevProps.compiledNodes === nextProps.compiledNodes &&
      prevProps.compiledNodesLoading === nextProps.compiledNodesLoading
    );
  },
);

MemoizedGraphCanvasInner.displayName = 'GraphCanvasInner';

export const GraphCanvas = (props: GraphCanvasProps) => (
  <ReactFlowProvider>
    <MemoizedGraphCanvasInner {...props} />
  </ReactFlowProvider>
);
