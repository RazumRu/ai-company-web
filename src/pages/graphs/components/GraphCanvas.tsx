// GraphCanvas.tsx
import {
  ReactFlow,
  Controls,
  Background,
  MiniMap,
  Connection,
  Node,
  NodeTypes,
  BackgroundVariant,
  OnNodesChange,
  OnEdgesChange,
  Viewport,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { useCallback, useMemo, useRef } from 'react';
import type { ReactFlowInstance } from '@xyflow/react';
import { CustomNode } from './CustomNode';
import type { GraphNode, GraphEdge, GraphNodeData } from '../types';
import { GraphDtoStatusEnum, TemplateDto } from '../../../autogenerated';
import { GraphValidationService } from '../../../services/GraphValidationService';

const slug = (v: string | number | undefined | null): string =>
  String(v ?? '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-');

export const makeHandleId = (
  dir: 'source' | 'target',
  rule: ConnectionRule,
): string => `${dir}-${rule.type}-${slug(rule.value)}`;

export type HandleDirection = {
  sourceHandle?: string;
  targetHandle?: string;
};

export interface ConnectionRule {
  type: 'kind' | 'template';
  value: string;
  required?: boolean;
  multiple?: boolean;
}

export const createEdge = (
  source: string,
  target: string,
  sourceHandle?: string,
  targetHandle?: string,
  label?: string,
): GraphEdge => ({
  id: `edge-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`,
  source,
  target,
  sourceHandle,
  targetHandle,
  label,
});

export const resolveHandlesForNodes = (
  sourceNode: GraphNode | undefined,
  targetNode: GraphNode | undefined,
  templates: TemplateDto[],
): HandleDirection => {
  if (!sourceNode || !targetNode) {
    return {};
  }

  const sourceTemplate = templates.find(
    (t) => t.name === (sourceNode.data as unknown as GraphNodeData).template,
  );
  const targetTemplate = templates.find(
    (t) => t.name === (targetNode.data as unknown as GraphNodeData).template,
  );

  if (!sourceTemplate || !targetTemplate) {
    return {};
  }

  const isRule = (r: unknown): r is ConnectionRule =>
    (!!r &&
      typeof r === 'object' &&
      (r as { type?: unknown }).type === 'kind') ||
    (r as { type?: unknown }).type === 'template';

  const targetInputs: ConnectionRule[] = Array.isArray(targetTemplate.inputs)
    ? (targetTemplate.inputs.filter((r) => isRule(r)) as ConnectionRule[])
    : [];
  const sourceOutputs: ConnectionRule[] = Array.isArray(sourceTemplate.outputs)
    ? (sourceTemplate.outputs.filter((r) => isRule(r)) as ConnectionRule[])
    : [];

  const targetByTemplate = targetInputs.find(
    (r) => r.type === 'template' && slug(r.value) === slug(sourceTemplate.name),
  );
  const targetByKind = targetInputs.find(
    (r) =>
      r.type === 'kind' &&
      slug(r.value) ===
        slug((sourceTemplate as TemplateDto & { kind?: string }).kind),
  );
  const targetRule = targetByTemplate || targetByKind;

  const sourceByTemplate = sourceOutputs.find(
    (r) => r.type === 'template' && slug(r.value) === slug(targetTemplate.name),
  );
  const sourceByKind = sourceOutputs.find(
    (r) =>
      r.type === 'kind' &&
      slug(r.value) ===
        slug((targetTemplate as TemplateDto & { kind?: string }).kind),
  );
  const sourceRule = sourceByTemplate || sourceByKind;

  const result: HandleDirection = {};
  if (targetRule) {
    result.targetHandle = makeHandleId('target', targetRule);
  } else if (targetInputs.length > 0) {
    result.targetHandle = makeHandleId('target', targetInputs[0]);
  }
  if (sourceRule) {
    result.sourceHandle = makeHandleId('source', sourceRule);
  } else if (sourceOutputs.length > 0) {
    result.sourceHandle = makeHandleId('source', sourceOutputs[0]);
  } else {
    result.sourceHandle = 'source-out';
  }
  return result;
};

interface GraphCanvasProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
  onNodeAdd: (node: GraphNode) => void;
  onNodeEdit: (node: GraphNode) => void;
  onNodeDelete: (nodeId: string) => void;
  onNodeSelect?: (node: GraphNode | null) => void;
  onViewportChange?: (viewport: Viewport) => void;
  initialViewport?: Viewport;
  templates?: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  onTriggerClick?: (nodeId: string) => void;
  onValidationError?: (error: string) => void;
}

export const GraphCanvas = ({
  nodes,
  edges,
  onNodesChange,
  onEdgesChange,
  onNodeAdd,
  onNodeEdit,
  onNodeDelete,
  onNodeSelect,
  onViewportChange,
  initialViewport,
  templates = [],
  graphStatus,
  onTriggerClick,
  onValidationError,
}: GraphCanvasProps) => {
  const reactFlowRef = useRef<HTMLDivElement | null>(null);

  const nodeTypes = useMemo<NodeTypes>(
    () => ({
      custom: (p) => (
        <CustomNode
          {...p}
          templates={templates}
          graphStatus={graphStatus}
          onTriggerClick={onTriggerClick}
        />
      ),
    }),
    [templates, graphStatus],
  );

  const enhancedNodes = nodes.map((node) => ({
    ...node,
    data: {
      ...node.data,
      onEdit: () => onNodeEdit(node),
      onDelete: () => onNodeDelete(node.id),
    },
  }));

  const onConnect = useCallback(
    (params: Connection) => {
      if (templates.length > 0) {
        const sourceNode = nodes.find((n) => n.id === params.source);
        const targetNode = nodes.find((n) => n.id === params.target);

        if (sourceNode && targetNode) {
          const validation = GraphValidationService.validateConnection(
            sourceNode,
            targetNode,
            templates,
          );

          if (!validation.isValid) {
            const errorMessage = validation.errors
              .map((e) => e.message)
              .join('; ');
            onValidationError?.(errorMessage);
            return;
          }

          const sourceTemplate = templates.find(
            (t) => t.name === sourceNode.data.template,
          );
          const targetTemplate = templates.find(
            (t) => t.name === targetNode.data.template,
          );

          if (sourceTemplate && targetTemplate) {
            const sourceRequiredConnections =
              sourceTemplate.inputs?.filter((rule) => rule.required) || [];
            const satisfiesRequired = sourceRequiredConnections.some((rule) => {
              if (rule.type === 'kind' && targetTemplate.kind === rule.value) {
                return true;
              } else if (
                rule.type === 'template' &&
                targetTemplate.name === rule.value
              ) {
                return true;
              }
              return false;
            });

            if (satisfiesRequired) {
              console.log(
                `Required connection satisfied: ${sourceNode.data.label} -> ${targetNode.data.label}`,
              );
            }
          }
        }
      }

      const newEdge = createEdge(
        params.source || '',
        params.target || '',
        params.sourceHandle || undefined,
        params.targetHandle || undefined,
      );
      onEdgesChange([
        {
          type: 'add',
          item: newEdge,
        },
      ]);
    },
    [onEdgesChange, nodes, templates, onValidationError],
  );

  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const templateData = event.dataTransfer.getData('application/reactflow');
      if (!templateData) return;

      const template: TemplateDto = JSON.parse(templateData);

      const reactFlowBounds = (
        event.target as HTMLElement
      ).getBoundingClientRect();
      const position = {
        x: event.clientX - reactFlowBounds.left - 75,
        y: event.clientY - reactFlowBounds.top - 25,
      };

      const newNode: GraphNode = {
        id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: 'custom',
        position,
        data: {
          label: template.name,
          template: template.name,
          templateKind: template.kind,
          templateSchema: template.schema,
          config: {},
        },
      };

      onNodeAdd(newNode);
    },
    [onNodeAdd],
  );

  const handleNodeDoubleClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeEdit(node as GraphNode);
    },
    [onNodeEdit],
  );

  const handleNodeClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeSelect?.(node as GraphNode);
    },
    [onNodeSelect],
  );

  const handlePaneClick = useCallback(() => {
    onNodeSelect?.(null);
  }, [onNodeSelect]);

  const handleViewportChange = useCallback(
    (viewport: Viewport) => {
      onViewportChange?.(viewport);
    },
    [onViewportChange],
  );

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <ReactFlow
        ref={reactFlowRef}
        nodes={enhancedNodes as Node[]}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onDrop={onDrop}
        onDragOver={onDragOver}
        onNodeClick={handleNodeClick}
        onNodeDoubleClick={handleNodeDoubleClick}
        onPaneClick={handlePaneClick}
        onViewportChange={handleViewportChange}
        nodeTypes={nodeTypes}
        fitView={!initialViewport}
        deleteKeyCode={['Delete', 'Backspace']}
        defaultViewport={initialViewport}>
        <Controls />
        <MiniMap />
        <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
      </ReactFlow>
    </div>
  );
};
