/* eslint-disable react-refresh/only-export-components */
// GraphCanvas.tsx
import {
  ReactFlow,
  Controls,
  Background,
  MiniMap,
  Connection,
  Node,
  NodeTypes,
  BackgroundVariant,
  OnNodesChange,
  OnEdgesChange,
  Viewport,
  useReactFlow,
  ReactFlowProvider,
  OnConnectStart,
  PanOnScrollMode,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { useCallback, useMemo, useState } from 'react';
import { CustomNode } from './CustomNode';
import type { GraphNode, GraphEdge, GraphNodeData } from '../types';
import {
  GraphDtoStatusEnum,
  GraphNodeWithStatusDto,
  TemplateDto,
} from '../../../autogenerated';
import { GraphValidationService } from '../../../services/GraphValidationService';

const slug = (v: string | number | undefined | null): string =>
  String(v ?? '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-');

export const makeHandleId = (
  dir: 'source' | 'target',
  rule: ConnectionRule,
): string => `${dir}-${rule.type}-${slug(rule.value)}`;

export type HandleDirection = {
  sourceHandle?: string;
  targetHandle?: string;
};

export interface ConnectionPreview {
  fromHandleType: 'source' | 'target';
  handleId: string;
  rule?: ConnectionRule;
  template?: TemplateDto;
}

export interface ConnectionRule {
  type: 'kind' | 'template';
  value: string;
  required?: boolean;
  multiple?: boolean;
}

export const createEdge = (
  source: string,
  target: string,
  sourceHandle?: string,
  targetHandle?: string,
  label?: string,
): GraphEdge => ({
  id: `edge-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`,
  source,
  target,
  sourceHandle,
  targetHandle,
  label,
});

export const resolveHandlesForNodes = (
  sourceNode: GraphNode | undefined,
  targetNode: GraphNode | undefined,
  templates: TemplateDto[],
): HandleDirection => {
  if (!sourceNode || !targetNode) {
    return {};
  }

  const sourceTemplate = templates.find(
    (t) => t.id === (sourceNode.data as unknown as GraphNodeData).template,
  );
  const targetTemplate = templates.find(
    (t) => t.id === (targetNode.data as unknown as GraphNodeData).template,
  );

  if (!sourceTemplate || !targetTemplate) {
    return {};
  }

  const isRule = (r: unknown): r is ConnectionRule =>
    (!!r &&
      typeof r === 'object' &&
      (r as { type?: unknown }).type === 'kind') ||
    (r as { type?: unknown }).type === 'template';

  const targetInputs: ConnectionRule[] = Array.isArray(targetTemplate.inputs)
    ? (targetTemplate.inputs.filter((r) => isRule(r)) as ConnectionRule[])
    : [];
  const sourceOutputs: ConnectionRule[] = Array.isArray(sourceTemplate.outputs)
    ? (sourceTemplate.outputs.filter((r) => isRule(r)) as ConnectionRule[])
    : [];

  const targetByTemplate = targetInputs.find(
    (r) => r.type === 'template' && r.value === sourceTemplate.id,
  );
  const targetByKind = targetInputs.find(
    (r) =>
      r.type === 'kind' &&
      slug(r.value) ===
        slug((sourceTemplate as TemplateDto & { kind?: string }).kind),
  );
  const targetRule = targetByTemplate || targetByKind;

  const sourceByTemplate = sourceOutputs.find(
    (r) => r.type === 'template' && r.value === targetTemplate.id,
  );
  const sourceByKind = sourceOutputs.find(
    (r) =>
      r.type === 'kind' &&
      slug(r.value) ===
        slug((targetTemplate as TemplateDto & { kind?: string }).kind),
  );
  const sourceRule = sourceByTemplate || sourceByKind;

  const result: HandleDirection = {};
  if (targetRule) {
    result.targetHandle = makeHandleId('target', targetRule);
  } else if (targetInputs.length > 0) {
    result.targetHandle = makeHandleId('target', targetInputs[0]);
  }
  if (sourceRule) {
    result.sourceHandle = makeHandleId('source', sourceRule);
  } else if (sourceOutputs.length > 0) {
    result.sourceHandle = makeHandleId('source', sourceOutputs[0]);
  } else {
    result.sourceHandle = 'source-out';
  }
  return result;
};

interface GraphCanvasProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
  onNodeAdd: (node: GraphNode) => void;
  onNodeEdit: (node: GraphNode) => void;
  onNodeDelete: (nodeId: string) => void;
  onNodeSelect?: (node: GraphNode | null) => void;
  onViewportChange?: (viewport: Viewport) => void;
  initialViewport?: Viewport;
  templates?: TemplateDto[];
  graphStatus?: GraphDtoStatusEnum;
  onTriggerClick?: (nodeId: string) => void;
  onValidationError?: (error: string) => void;
  compiledNodes?: Record<string, GraphNodeWithStatusDto>;
  compiledNodesLoading?: boolean;
}

const GraphCanvasInner = ({
  nodes,
  edges,
  onNodesChange,
  onEdgesChange,
  onNodeAdd,
  onNodeEdit,
  onNodeDelete,
  onNodeSelect,
  onViewportChange,
  initialViewport,
  templates = [],
  graphStatus,
  onTriggerClick,
  onValidationError,
  compiledNodes,
  compiledNodesLoading,
}: GraphCanvasProps) => {
  const { screenToFlowPosition } = useReactFlow();
  const [connectionPreview, setConnectionPreview] =
    useState<ConnectionPreview | null>(null);

  // Memoize nodeTypes to prevent recreation on every render
  // Only recreate when templates, graphStatus, or compiledNodesLoading change
  // compiledNodes is passed per-node, so it doesn't need to be in dependencies
  const nodeTypes = useMemo<NodeTypes>(
    () => ({
      custom: (p) => (
        <CustomNode
          {...p}
          templates={templates}
          graphStatus={graphStatus}
          onTriggerClick={onTriggerClick}
          compiledNode={compiledNodes?.[p.id]}
          compiledNodesLoading={compiledNodesLoading}
          connectionPreview={connectionPreview}
        />
      ),
    }),
    [
      templates,
      graphStatus,
      compiledNodesLoading,
      onTriggerClick,
      compiledNodes,
      connectionPreview,
    ],
  );

  // Memoize enhancedNodes to prevent recreation on every render
  // Only recreate when nodes array or callbacks change
  const enhancedNodes = useMemo(() => {
    return nodes.map((node) => ({
      ...node,
      data: {
        ...node.data,
        onEdit: () => onNodeEdit(node),
        onDelete: () => onNodeDelete(node.id),
      },
    }));
  }, [nodes, onNodeEdit, onNodeDelete]);

  const normalizeRule = useCallback(
    (rule: {
      type?: unknown;
      value?: unknown;
      required?: unknown;
      multiple?: unknown;
    }): ConnectionRule => ({
      type: (rule.type as 'kind' | 'template') ?? 'kind',
      value: String(rule.value ?? ''),
      required: Boolean(rule.required),
      multiple: Boolean(rule.multiple),
    }),
    [],
  );

  const findRuleForHandle = useCallback(
    (
      nodeId: string,
      handleType: 'source' | 'target',
      handleId: string,
    ): ConnectionRule | undefined => {
      const node = nodes.find((n) => n.id === nodeId);
      if (!node) return undefined;
      const nodeTemplate = templates.find(
        (t) => t.id === (node.data as unknown as GraphNodeData).template,
      );
      if (!nodeTemplate) return undefined;

      if (handleType === 'source') {
        return (
          nodeTemplate.outputs
            ?.map(normalizeRule)
            .find((rule) => makeHandleId('source', rule) === handleId) ??
          undefined
        );
      }

      const inputRules = GraphValidationService.getAvailableConnectionTypes(
        {
          id: node.id,
          data: node.data,
          position: node.position,
          type: node.type ?? 'custom',
        } satisfies GraphNode,
        templates,
      );

      return inputRules.find(
        (rule) => makeHandleId('target', normalizeRule(rule)) === handleId,
      );
    },
    [nodes, templates, normalizeRule],
  );

  const clearConnectionPreview = useCallback(() => {
    setConnectionPreview(null);
  }, []);

  const handleConnectStart = useCallback<OnConnectStart>(
    (_event, params) => {
      if (!params.nodeId || !params.handleId || !params.handleType) {
        clearConnectionPreview();
        return;
      }

      const rule = findRuleForHandle(
        params.nodeId,
        params.handleType,
        params.handleId,
      );
      const sourceNode = nodes.find((n) => n.id === params.nodeId);
      const template = templates.find(
        (t) =>
          t.id === (sourceNode?.data as GraphNodeData | undefined)?.template,
      );

      setConnectionPreview({
        fromHandleType: params.handleType,
        handleId: params.handleId,
        rule,
        template,
      });
    },
    [clearConnectionPreview, findRuleForHandle, nodes, templates],
  );

  const onConnect = useCallback(
    (params: Connection) => {
      clearConnectionPreview();

      if (templates.length > 0) {
        const sourceNode = nodes.find((n) => n.id === params.source);
        const targetNode = nodes.find((n) => n.id === params.target);

        if (sourceNode && targetNode) {
          const validation = GraphValidationService.validateConnection(
            sourceNode,
            targetNode,
            templates,
            {
              sourceHandleId: params.sourceHandle ?? undefined,
              targetHandleId: params.targetHandle ?? undefined,
            },
          );

          if (!validation.isValid) {
            const errorMessage = validation.errors
              .map((e) => e.message)
              .join('; ');
            onValidationError?.(errorMessage);
            return;
          }

          const sourceTemplate = templates.find(
            (t) => t.id === sourceNode.data.template,
          );
          const targetTemplate = templates.find(
            (t) => t.id === targetNode.data.template,
          );

          if (sourceTemplate && targetTemplate) {
            const sourceRequiredConnections =
              sourceTemplate.inputs?.filter((rule) => rule.required) || [];
            const satisfiesRequired = sourceRequiredConnections.some((rule) => {
              if (rule.type === 'kind' && targetTemplate.kind === rule.value) {
                return true;
              } else if (
                rule.type === 'template' &&
                targetTemplate.id === rule.value
              ) {
                return true;
              }
              return false;
            });

            if (satisfiesRequired) {
              console.log(
                `Required connection satisfied: ${sourceNode.data.label} -> ${targetNode.data.label}`,
              );
            }
          }
        }
      }

      const newEdge = createEdge(
        params.source || '',
        params.target || '',
        params.sourceHandle || undefined,
        params.targetHandle || undefined,
      );
      onEdgesChange([
        {
          type: 'add',
          item: newEdge,
        },
      ]);
    },
    [
      clearConnectionPreview,
      onEdgesChange,
      nodes,
      templates,
      onValidationError,
    ],
  );

  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const templateData = event.dataTransfer.getData('application/reactflow');
      if (!templateData) return;

      const template: TemplateDto = JSON.parse(templateData);

      const position = screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });

      const newNode: GraphNode = {
        id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: 'custom',
        position,
        data: {
          label: template.name,
          template: template.id,
          templateKind: template.kind,
          templateSchema: template.schema,
          config: {},
        },
      };

      onNodeAdd(newNode);
    },
    [onNodeAdd, screenToFlowPosition],
  );

  const handleNodeDoubleClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeEdit(node as GraphNode);
    },
    [onNodeEdit],
  );

  const handleNodeClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeSelect?.(node as GraphNode);
    },
    [onNodeSelect],
  );

  const handlePaneClick = useCallback(() => {
    onNodeSelect?.(null);
  }, [onNodeSelect]);

  const handleViewportChange = useCallback(
    (viewport: Viewport) => {
      onViewportChange?.(viewport);
    },
    [onViewportChange],
  );

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <ReactFlow
        nodes={enhancedNodes as Node[]}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onConnectStart={handleConnectStart}
        onConnectEnd={clearConnectionPreview}
        onDrop={onDrop}
        onDragOver={onDragOver}
        onNodeClick={handleNodeClick}
        onNodeDoubleClick={handleNodeDoubleClick}
        onPaneClick={handlePaneClick}
        onViewportChange={handleViewportChange}
        nodeTypes={nodeTypes}
        fitView={!initialViewport}
        deleteKeyCode={['Delete', 'Backspace']}
        defaultViewport={initialViewport}
        minZoom={0.1}
        maxZoom={4}
        panOnScroll
        panOnScrollMode={PanOnScrollMode.Free}
        zoomOnScroll={false}>
        <Controls />
        <MiniMap />
        <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
      </ReactFlow>
    </div>
  );
};

export const GraphCanvas = (props: GraphCanvasProps) => (
  <ReactFlowProvider>
    <GraphCanvasInner {...props} />
  </ReactFlowProvider>
);
