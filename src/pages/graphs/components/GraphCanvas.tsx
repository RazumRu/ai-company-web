import {
  ReactFlow,
  Controls,
  Background,
  MiniMap,
  addEdge,
  Connection,
  Node,
  Edge,
  NodeTypes,
  BackgroundVariant,
  OnNodesChange,
  OnEdgesChange,
  Viewport,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { useCallback, useMemo, useRef } from 'react';
import { CustomNode } from './CustomNode';
import type { GraphNode, GraphEdge } from '../types';
import type { TemplateDto } from '../../../autogenerated';
import { GraphValidationService } from '../../../services/GraphValidationService';

interface GraphCanvasProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
  onNodeAdd: (node: GraphNode) => void;
  onNodeEdit: (node: GraphNode) => void;
  onNodeDelete: (nodeId: string) => void;
  onNodeSelect?: (node: GraphNode | null) => void;
  onViewportChange?: (viewport: Viewport) => void;
  initialViewport?: Viewport;
  templates?: TemplateDto[];
  onValidationError?: (error: string) => void;
}

export const GraphCanvas = ({
  nodes,
  edges,
  onNodesChange,
  onEdgesChange,
  onNodeAdd,
  onNodeEdit,
  onNodeDelete,
  onNodeSelect,
  onViewportChange,
  initialViewport,
  templates = [],
  onValidationError,
}: GraphCanvasProps) => {
  const reactFlowRef = useRef<any>(null);

  // Enhance nodes with callback functions and validation data
  const nodeTypes = useMemo<NodeTypes>(
    () => ({
      custom: (p) => <CustomNode {...p} templates={templates} />,
    }),
    [templates],
  );

  const enhancedNodes = nodes.map((node) => ({
    ...node,
    data: {
      ...node.data,
      onEdit: () => onNodeEdit(node),
      onDelete: () => onNodeDelete(node.id),
    },
  }));
  const onConnect = useCallback(
    (params: Connection) => {
      // Validate connection before adding
      if (templates.length > 0) {
        const sourceNode = nodes.find((n) => n.id === params.source);
        const targetNode = nodes.find((n) => n.id === params.target);

        if (sourceNode && targetNode) {
          const validation = GraphValidationService.validateConnection(
            sourceNode,
            targetNode,
            templates,
          );

          if (!validation.isValid) {
            const errorMessage = validation.errors
              .map((e) => e.message)
              .join('; ');
            onValidationError?.(errorMessage);
            return; // Don't add the edge if validation fails
          }

          // Check if this connection satisfies any required connections
          const sourceTemplate = templates.find(
            (t) => t.name === sourceNode.data.template,
          );
          const targetTemplate = templates.find(
            (t) => t.name === targetNode.data.template,
          );

          if (sourceTemplate && targetTemplate) {
            // Check if this connection satisfies any required connections for source node
            const sourceRequiredConnections =
              sourceTemplate.allowedTemplates?.filter(
                (rule) => rule.required,
              ) || [];
            const satisfiesRequired = sourceRequiredConnections.some((rule) => {
              if (rule.type === 'kind' && targetTemplate.kind === rule.value) {
                return true;
              } else if (
                rule.type === 'template' &&
                targetTemplate.name === rule.value
              ) {
                return true;
              }
              return false;
            });

            if (satisfiesRequired) {
              // Show success message for required connection
              console.log(
                `Required connection satisfied: ${sourceNode.data.label} -> ${targetNode.data.label}`,
              );
            }
          }
        }
      }

      const newEdge = {
        id: `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        source: params.source || '',
        target: params.target || '',
        sourceHandle: params.sourceHandle,
        targetHandle: params.targetHandle,
      };
      onEdgesChange([
        {
          type: 'add',
          item: newEdge,
        },
      ]);
    },
    [onEdgesChange, nodes, templates, onValidationError],
  );

  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const templateData = event.dataTransfer.getData('application/reactflow');
      if (!templateData) return;

      const template: TemplateDto = JSON.parse(templateData);

      // Get the position where the node is dropped
      const reactFlowBounds = (
        event.target as HTMLElement
      ).getBoundingClientRect();
      const position = {
        x: event.clientX - reactFlowBounds.left - 75,
        y: event.clientY - reactFlowBounds.top - 25,
      };

      const newNode: GraphNode = {
        id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: 'custom',
        position,
        data: {
          label: template.name,
          template: template.name,
          templateKind: template.kind,
          templateSchema: template.schema,
          config: {},
        },
      };

      onNodeAdd(newNode);
    },
    [onNodeAdd],
  );

  const handleNodeDoubleClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeEdit(node as GraphNode);
    },
    [onNodeEdit],
  );

  const handleNodeClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      onNodeSelect?.(node as GraphNode);
    },
    [onNodeSelect],
  );

  const handlePaneClick = useCallback(() => {
    onNodeSelect?.(null);
  }, [onNodeSelect]);

  const handleViewportChange = useCallback(
    (viewport: Viewport) => {
      onViewportChange?.(viewport);
    },
    [onViewportChange],
  );

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <ReactFlow
        ref={reactFlowRef}
        nodes={enhancedNodes as Node[]}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onDrop={onDrop}
        onDragOver={onDragOver}
        onNodeClick={handleNodeClick}
        onNodeDoubleClick={handleNodeDoubleClick}
        onPaneClick={handlePaneClick}
        onViewportChange={handleViewportChange}
        nodeTypes={nodeTypes}
        fitView={!initialViewport}
        deleteKeyCode="Delete"
        defaultViewport={initialViewport}>
        <Controls />
        <MiniMap />
        <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
      </ReactFlow>
    </div>
  );
};
