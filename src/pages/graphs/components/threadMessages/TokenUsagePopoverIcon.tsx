import { BarChartOutlined } from '@ant-design/icons';
import { Popover, Space, Typography } from 'antd';
import React from 'react';

import type { ThreadMessageDtoRequestTokenUsage } from '../../../../autogenerated';
import {
  formatDurationMs,
  formatRequestTokenCount,
  formatRequestUsdShort,
  formatTokenCount,
} from './threadMessagesViewUtils';

const { Text } = Typography;

interface TokenUsagePopoverIconProps {
  requestTokenUsage?: ThreadMessageDtoRequestTokenUsage | null;
  requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
  requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
  /** LLM request duration in milliseconds. */
  durationMs?: number;
}

/** Returns true when two token-usage objects carry identical numeric values. */
const isSameUsage = (
  a?: ThreadMessageDtoRequestTokenUsage | null,
  b?: ThreadMessageDtoRequestTokenUsage | null,
): boolean => {
  if (!a || !b) return false;
  return (
    a.totalTokens === b.totalTokens &&
    a.inputTokens === b.inputTokens &&
    a.outputTokens === b.outputTokens &&
    a.totalPrice === b.totalPrice
  );
};

export const TokenUsagePopoverIcon: React.FC<TokenUsagePopoverIconProps> = ({
  requestTokenUsage,
  requestTokenUsageIn,
  requestTokenUsageOut,
  durationMs,
}) => {
  const effectiveIn = requestTokenUsageIn || requestTokenUsage;
  // Skip the Output section when it carries the same numbers as Input
  // (happens when the backend echoes the same usage on both messages).
  const effectiveOut =
    requestTokenUsageOut && !isSameUsage(effectiveIn, requestTokenUsageOut)
      ? requestTokenUsageOut
      : null;

  if (!effectiveIn && !effectiveOut) {
    return null;
  }

  const renderSection = (
    usage: ThreadMessageDtoRequestTokenUsage,
    label: string,
  ) => (
    <>
      <Text type="secondary" style={{ fontSize: 12, fontWeight: 600 }}>
        {label}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Total: {formatRequestTokenCount(usage.totalTokens)} (
        {formatRequestUsdShort(usage.totalPrice)})
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Input tokens: {formatTokenCount(usage.inputTokens)}
      </Text>
      {typeof usage.cachedInputTokens === 'number' && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          Cached input tokens: {formatTokenCount(usage.cachedInputTokens)}
        </Text>
      )}
      <Text type="secondary" style={{ fontSize: 12 }}>
        Output tokens: {formatTokenCount(usage.outputTokens)}
      </Text>
      {typeof usage.reasoningTokens === 'number' && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          Reasoning tokens: {formatTokenCount(usage.reasoningTokens)}
        </Text>
      )}
      {typeof usage.currentContext === 'number' && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          Current context: {formatTokenCount(usage.currentContext)}
        </Text>
      )}
    </>
  );

  // When only one section is shown, use a simpler label without (Input)/(Output).
  const showBoth = !!effectiveIn && !!effectiveOut;
  const inLabel = showBoth
    ? 'Request Token Usage (Input):'
    : 'Request Token Usage:';

  const popoverContent = (
    <Space direction="vertical" size={4} style={{ maxWidth: 340 }}>
      {effectiveIn && renderSection(effectiveIn, inLabel)}
      {effectiveOut &&
        renderSection(effectiveOut, 'Request Token Usage (Output):')}
      {typeof durationMs === 'number' && durationMs > 0 && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          Duration: {formatDurationMs(durationMs)}
        </Text>
      )}
    </Space>
  );

  return (
    <Popover
      content={popoverContent}
      trigger={['hover']}
      placement="bottomLeft">
      <span
        style={{
          display: 'inline-flex',
          alignItems: 'center',
          cursor: 'help',
        }}
        aria-label="View token usage details"
        title="View token usage details">
        <BarChartOutlined style={{ fontSize: 12 }} />
      </span>
    </Popover>
  );
};
