import { CopyOutlined } from '@ant-design/icons';
import JsonView from '@uiw/react-json-view';
import { lightTheme } from '@uiw/react-json-view/light';
import { AnsiUp } from 'ansi_up';
import { message, Popover } from 'antd';
import isPlainObject from 'lodash/isPlainObject';
import React, { useMemo, useState } from 'react';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import type { JsonValue } from 'type-fest';

import type {
  ThreadMessageDtoRequestTokenUsage,
  ThreadMessageDtoTokenUsage,
} from '../../../../autogenerated';

export interface ShellToolDisplayProps {
  name: string;
  status: 'calling' | 'executed' | 'stopped';
  resultContent?: unknown;
  shellCommand?: string;
  toolOptions?: Record<string, JsonValue>;
  title?: string;
  metadata?: { nodeId?: string; createdAt?: string; roleLabel?: string };
  /**
   * Token usage for the shell request (tool call message).
   */
  tokenUsageIn?: ThreadMessageDtoTokenUsage | null;
  /**
   * Token usage for the shell response (tool result message).
   */
  tokenUsageOut?: ThreadMessageDtoTokenUsage | null;
  /**
   * Request token usage for the shell tool call (use the tool request message).
   */
  requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
  /**
   * Optional border color for inter-agent communication.
   */
  borderColor?: string;
}

const ansiUp = (() => {
  const instance = new AnsiUp();
  // Keep HTML escaping enabled (defense-in-depth).
  // Newer versions use `escape_html`, older used `escape_for_html`.
  (instance as unknown as Record<string, unknown>).escape_html = true;
  (instance as unknown as Record<string, unknown>).escape_for_html = true;
  return instance;
})();

const normalizeShellText = (text: string): string =>
  text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

const containsAnsi = (text: string): boolean => {
  // We intentionally avoid regex literals with control chars here because of
  // eslint's `no-control-regex` rule.
  return text.includes('\u001b[') || text.includes('\u009b[');
};

const stripAnsiSgr = (text: string): string => {
  const esc = '\u001b';
  const csi = '\u009b';
  const sgr = new RegExp(`(?:${esc}|${csi})\\[[0-9;]*m`, 'g');
  return text.replace(sgr, '');
};

const renderAnsiHtml = (text: string): string =>
  ansiUp.ansi_to_html(normalizeShellText(text));

const parseJsonSafe = (value: string): JsonValue | null => {
  try {
    return JSON.parse(value) as JsonValue;
  } catch {
    return null;
  }
};

const renderToolPopoverContent = (
  value: unknown,
  toolOptions?: Record<string, JsonValue>,
  toolLabel?: string,
): React.ReactNode => {
  let parsed: JsonValue | null = null;
  if (typeof value === 'string') {
    parsed = parseJsonSafe(value);
  } else if (isPlainObject(value)) {
    parsed = value as JsonValue;
  }

  const containerStyle: React.CSSProperties = { maxWidth: 520 };
  const innerStyle: React.CSSProperties = {
    maxHeight: 300,
    overflow: 'auto',
    background: '#f5f5f5',
    border: '1px solid #eee',
    borderRadius: 6,
    padding: 12,
    fontFamily:
      'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
    fontSize: 12,
    whiteSpace: 'pre-wrap',
  };

  const sectionStyle: React.CSSProperties = {
    marginBottom: 16,
  };

  const sectionTitleStyle: React.CSSProperties = {
    fontWeight: 'bold',
    fontSize: 13,
    marginBottom: 8,
    color: '#333',
    borderBottom: '1px solid #ddd',
    paddingBottom: 4,
  };

  return (
    <div style={containerStyle}>
      {toolLabel && toolLabel.trim().length > 0 && (
        <div style={{ marginBottom: 12 }}>
          <span style={{ fontWeight: 600, fontSize: 13 }}>
            Tool: {toolLabel}
          </span>
        </div>
      )}
      {toolOptions && Object.keys(toolOptions).length > 0 && (
        <div style={sectionStyle}>
          <div style={sectionTitleStyle}>Tool Options:</div>
          <div style={innerStyle}>
            <JsonView value={toolOptions} style={lightTheme} />
          </div>
        </div>
      )}

      <div style={sectionStyle}>
        <div style={sectionTitleStyle}>Output:</div>
        <div style={innerStyle}>
          {parsed ? (
            <JsonView value={parsed as object} style={lightTheme} />
          ) : (
            <pre
              style={{
                margin: 0,
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-word',
              }}>
              {typeof value === 'string' && containsAnsi(value) ? (
                <span
                  dangerouslySetInnerHTML={{ __html: renderAnsiHtml(value) }}
                />
              ) : (
                String(value ?? '')
              )}
            </pre>
          )}
        </div>
      </div>
    </div>
  );
};

const truncateToLines = (
  text: string,
  maxLines: number,
): { truncated: string; full: string; isTruncated: boolean } => {
  const lines = text.split('\n');
  const isTruncated = lines.length > maxLines;
  const truncated = lines.slice(0, maxLines).join('\n');
  return { truncated, full: text, isTruncated };
};

export const ShellToolDisplay: React.FC<ShellToolDisplayProps> = ({
  name,
  status,
  resultContent,
  shellCommand,
  toolOptions,
  title,
  tokenUsageIn,
  tokenUsageOut,
  requestTokenUsageIn,
  borderColor,
}) => {
  const [commandExpanded, setCommandExpanded] = useState(false);
  const [outputExpanded, setOutputExpanded] = useState(false);

  const resultObj = isPlainObject(resultContent)
    ? (resultContent as Record<string, unknown>)
    : null;

  const toolErrorText = useMemo(() => {
    if (!resultObj) return undefined;
    const errorValue = resultObj.error;
    if (typeof errorValue === 'string') {
      const trimmed = errorValue.trim();
      return trimmed.length > 0 ? trimmed : undefined;
    }
    if (errorValue === null || errorValue === undefined) return undefined;
    try {
      const serialized = JSON.stringify(errorValue, null, 2);
      const trimmed = serialized.trim();
      return trimmed.length > 0 ? trimmed : undefined;
    } catch {
      const asString = String(errorValue);
      const trimmed = asString.trim();
      return trimmed.length > 0 ? trimmed : undefined;
    }
  }, [resultObj]);
  const hasToolError = Boolean(toolErrorText);

  const stdoutCandidate = resultObj?.stdout;
  const stdoutText =
    typeof stdoutCandidate === 'string'
      ? normalizeShellText(stdoutCandidate)
      : null;
  const stderrCandidate = resultObj?.stderr;
  const stderrText =
    typeof stderrCandidate === 'string'
      ? normalizeShellText(stderrCandidate)
      : null;
  const rawStringResult =
    typeof resultContent === 'string'
      ? normalizeShellText(resultContent)
      : null;
  const outputCandidate = resultObj?.output;
  const outputFieldText =
    typeof outputCandidate === 'string'
      ? normalizeShellText(outputCandidate)
      : null;
  const exitCodeCandidate = resultObj?.exitCode;
  const exitCode =
    typeof exitCodeCandidate === 'number'
      ? (exitCodeCandidate as number)
      : null;
  const exitCodeColor =
    hasToolError || (exitCode !== null && exitCode !== 0)
      ? '#ff4d4f'
      : '#9d9d9d';
  const tint = hasToolError
    ? '#2b1d1d'
    : exitCode === null
      ? '#2b2b2b'
      : exitCode === 0
        ? '#1d2b1f'
        : '#2b1d1d';

  const toolNameText = useMemo(() => {
    const displayName = title && title.trim().length > 0 ? title.trim() : name;
    if (displayName !== name) {
      return displayName;
    }
    return `${displayName}${
      toolOptions?.purpose ? ` | ${String(toolOptions.purpose)}` : ''
    }`;
  }, [name, title, toolOptions?.purpose]);

  const getOutputText = (): string | null => {
    if (outputFieldText) return outputFieldText;
    if (rawStringResult) return rawStringResult;
    if (resultObj) {
      const displayText =
        resultObj.output || resultObj.stdout || resultObj.stderr;
      if (typeof displayText === 'string') {
        return normalizeShellText(displayText);
      }
    }
    return null;
  };

  const outputText = getOutputText();
  const commandTruncated = shellCommand
    ? truncateToLines(shellCommand, 3)
    : undefined;
  const stdoutTruncated = stdoutText
    ? truncateToLines(stdoutText, 3)
    : undefined;
  const stderrTruncated = stderrText
    ? truncateToLines(stderrText, 3)
    : undefined;
  const fallbackOutputTruncated =
    !stdoutText && !stderrText && outputText
      ? truncateToLines(outputText, 3)
      : undefined;
  const isAnyOutputTruncated =
    stdoutTruncated?.isTruncated ||
    stderrTruncated?.isTruncated ||
    fallbackOutputTruncated?.isTruncated;

  const outputTextForCopy = useMemo(
    () =>
      [
        stdoutText ? `STDOUT:\n${stripAnsiSgr(stdoutText)}` : null,
        stderrText ? `STDERR:\n${stripAnsiSgr(stderrText)}` : null,
        !stdoutText && !stderrText && outputText
          ? stripAnsiSgr(outputText)
          : null,
      ]
        .filter(Boolean)
        .join('\n\n'),
    [outputText, stderrText, stdoutText],
  );

  const renderPlainOutputText = (
    text: string,
    color: string,
    truncatedInfo?: ReturnType<typeof truncateToLines>,
  ) => (
    <SyntaxHighlighter
      language="bash"
      style={vscDarkPlus}
      customStyle={{
        margin: 0,
        padding: 0,
        background: 'transparent',
        fontSize: '12px',
      }}
      PreTag="div"
      codeTagProps={{
        style: { fontFamily: 'inherit', color },
      }}>
      {outputExpanded || !truncatedInfo?.isTruncated
        ? text
        : (truncatedInfo?.truncated ?? text)}
    </SyntaxHighlighter>
  );

  const renderAnsiOutputText = (
    text: string,
    color: string,
    truncatedInfo?: ReturnType<typeof truncateToLines>,
  ) => {
    const displayText =
      outputExpanded || !truncatedInfo?.isTruncated
        ? text
        : (truncatedInfo?.truncated ?? text);

    return (
      <pre
        style={{
          margin: 0,
          fontSize: '12px',
          color,
          whiteSpace: 'pre-wrap',
          wordBreak: 'break-word',
          lineHeight: '1.5',
        }}>
        <span
          dangerouslySetInnerHTML={{ __html: renderAnsiHtml(displayText) }}
        />
      </pre>
    );
  };

  const renderOutputBlock = (
    label: string,
    text: string,
    color: string,
    truncatedInfo?: ReturnType<typeof truncateToLines>,
  ) => (
    <div style={{ marginBottom: 8 }}>
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: 6,
          marginBottom: 4,
        }}>
        <span
          style={{
            fontSize: '11px',
            color: '#c4c4c4',
            letterSpacing: 0.5,
            textTransform: 'uppercase',
          }}>
          {label}
        </span>
      </div>
      {containsAnsi(text)
        ? renderAnsiOutputText(text, color, truncatedInfo)
        : renderPlainOutputText(text, color, truncatedInfo)}
    </div>
  );

  const formatUsd = (amount?: number | null): string => {
    if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
    if (amount === 0 || (amount > 0 && amount < 0.01)) return '<$0.01';
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(amount);
  };

  const formatCompactNumber = (value?: number | null): string => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return '—';
    return new Intl.NumberFormat('en-US', {
      notation: 'compact',
      compactDisplay: 'short',
      maximumFractionDigits: 0,
    }).format(value);
  };

  const formatTokenCount = (value?: number | null): string => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return '—';
    return new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(
      value,
    );
  };

  const formatRequestTokenCount = (value?: number | null): string => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return '—';
    return value < 10000 ? formatTokenCount(value) : formatCompactNumber(value);
  };

  const formatRequestTokenCountShort = (value?: number | null): string => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return '—';

    const formatTruncatedDecimal = (raw: number): string => {
      const truncated = Math.floor(raw * 10) / 10;
      const normalized = String(truncated).replace('.', ',');
      return normalized.endsWith(',0') ? normalized.slice(0, -2) : normalized;
    };

    if (value < 1000) {
      return formatTokenCount(value);
    }

    if (value < 1_000_000) {
      return `${formatTruncatedDecimal(value / 1000)}k`;
    }

    return `${formatTruncatedDecimal(value / 1_000_000)}m`;
  };

  const formatRequestUsdShort = (amount?: number | null): string => {
    if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
    const truncated = Math.floor(amount * 1000) / 1000;
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 3,
      maximumFractionDigits: 3,
    }).format(truncated);
  };

  const formatTokenUsage = (
    usage?: ThreadMessageDtoTokenUsage | null,
  ): string => {
    if (!usage) return '—';
    const tokens = formatCompactNumber(usage.totalTokens);
    const cost = formatUsd(usage.totalPrice);
    return `${tokens} (${cost})`;
  };

  const formatRequestTokenUsage = (
    usage?: ThreadMessageDtoRequestTokenUsage | null,
  ): string => {
    if (!usage) return '—';
    const tokens = formatRequestTokenCountShort(usage.totalTokens);
    const cost = formatRequestUsdShort(usage.totalPrice);
    return `${tokens} (${cost})`;
  };

  const hasTokenIn =
    tokenUsageIn && typeof tokenUsageIn.totalTokens === 'number';
  const hasTokenOut =
    tokenUsageOut && typeof tokenUsageOut.totalTokens === 'number';
  const hasRequestTokens =
    requestTokenUsageIn && typeof requestTokenUsageIn.totalTokens === 'number';

  const shouldShowTokens = Boolean(
    hasTokenIn || hasTokenOut || hasRequestTokens,
  );

  const toolHeaderSuffix = hasToolError ? toolErrorText : undefined;
  const toolHeaderTitle = toolHeaderSuffix
    ? `${toolNameText} - ${toolHeaderSuffix}`
    : toolNameText;

  const containerStyle: React.CSSProperties = {
    background: '#1e1e1e',
    borderRadius: 6,
    border: `1px solid ${hasToolError ? '#5c2c2c' : '#333'}`,
    color: '#e8e8e8',
    fontFamily:
      'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace',
    fontSize: 12,
    display: 'flex',
    flexDirection: 'column',
    gap: 6,
    boxShadow: 'inset 0 0 0 1px rgba(255,255,255,0.02)',
    backgroundImage: `linear-gradient(${tint}, ${tint})`,
    backgroundBlendMode: 'soft-light',
  };

  if (borderColor) {
    containerStyle.borderLeft = `3px solid ${borderColor}`;
  }

  return (
    <div>
      <div style={containerStyle}>
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            gap: 8,
            padding: '5px 10px',
            background: '#1a1a1a',
          }}>
          {status === 'executed' && resultContent !== undefined ? (
            <Popover
              content={renderToolPopoverContent(
                resultContent,
                toolOptions,
                name,
              )}
              trigger={['click']}
              placement="topLeft">
              <div
                style={{
                  cursor:
                    status === 'executed' && resultContent !== undefined
                      ? 'pointer'
                      : 'default',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  flex: 1,
                  minWidth: 0,
                }}
                aria-label={
                  status === 'executed'
                    ? `View shell result for ${toolHeaderTitle}`
                    : status === 'stopped'
                      ? `Shell ${toolHeaderTitle} is stopped`
                      : `Shell ${toolHeaderTitle} is calling`
                }
                title={toolHeaderTitle}>
                <span>{toolNameText}</span>
                {toolHeaderSuffix && (
                  <span style={{ color: '#ff4d4f' }}>
                    {' '}
                    - {toolHeaderSuffix}
                  </span>
                )}
              </div>
            </Popover>
          ) : (
            <div
              style={{
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                flex: 1,
                minWidth: 0,
              }}
              title={toolHeaderTitle}>
              <span>{toolNameText}</span>
              {toolHeaderSuffix && (
                <span style={{ color: '#ff4d4f' }}> - {toolHeaderSuffix}</span>
              )}
            </div>
          )}

          {status === 'calling' ? (
            <span
              style={{
                color: '#c4c4c4',
                animation:
                  'messages-tab-thinking-pulse 1.6s ease-in-out infinite',
              }}>
              executing...
            </span>
          ) : status === 'stopped' ? (
            <span style={{ color: '#ff4d4f' }}>stopped</span>
          ) : (
            <span
              style={{
                color: exitCodeColor,
                whiteSpace: 'nowrap',
                fontSize: '11px',
              }}>
              executed{exitCode !== null ? ` | exit ${exitCode}` : ''}
            </span>
          )}
        </div>

        {shellCommand && (
          <div style={{ padding: '5px 10px' }}>
            <div style={{ display: 'flex', alignItems: 'flex-start' }}>
              <span
                style={{
                  color: '#a0a0a0',
                  paddingRight: '10px',
                  flexShrink: 0,
                }}>
                $
              </span>
              <div style={{ flex: 1, minWidth: 0 }}>
                <div
                  style={{
                    maxHeight:
                      commandExpanded || !commandTruncated?.isTruncated
                        ? 'none'
                        : '4.5em',
                    overflow:
                      commandExpanded || !commandTruncated?.isTruncated
                        ? 'visible'
                        : 'hidden',
                    position: 'relative',
                  }}>
                  <SyntaxHighlighter
                    language="bash"
                    style={vscDarkPlus}
                    customStyle={{
                      margin: 0,
                      padding: 0,
                      background: 'transparent',
                      fontSize: '12px',
                      whiteSpace: 'pre-wrap',
                      wordBreak: 'break-word',
                      lineHeight: '1.5',
                    }}
                    PreTag="div"
                    codeTagProps={{
                      style: {
                        fontFamily: 'inherit',
                        whiteSpace: 'pre-wrap',
                        wordBreak: 'break-word',
                        margin: 0,
                        padding: 0,
                        lineHeight: '1.5',
                      },
                    }}>
                    {shellCommand}
                  </SyntaxHighlighter>
                  {commandTruncated?.isTruncated && !commandExpanded && (
                    <div
                      style={{
                        position: 'absolute',
                        bottom: 0,
                        left: 0,
                        right: 0,
                        height: '1.5em',
                        background:
                          'linear-gradient(to bottom, transparent, #1e1e1e)',
                        pointerEvents: 'none',
                      }}
                    />
                  )}
                </div>
                {commandTruncated?.isTruncated && (
                  <div
                    style={{
                      color: '#1890ff',
                      cursor: 'pointer',
                      fontSize: '11px',
                      marginTop: '4px',
                      textDecoration: 'underline',
                    }}
                    onClick={() => setCommandExpanded(!commandExpanded)}>
                    {commandExpanded ? 'Show less' : 'Show more...'}
                  </div>
                )}
              </div>
            </div>
          </div>
        )}

        {status === 'executed' && (stdoutText || stderrText || outputText) && (
          <div
            style={{
              borderTop: '1px solid #333',
            }}>
            <div
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: '5px 10px',
                borderBottom: '1px solid #333',
                background: '#1a1a1a',
              }}>
              <span style={{ fontSize: '11px', color: '#c4c4c4' }}>Output</span>
              <CopyOutlined
                style={{
                  color: '#c4c4c4',
                  cursor: 'pointer',
                  fontSize: '14px',
                }}
                onClick={async () => {
                  if (!outputTextForCopy) {
                    message.warning('No output to copy');
                    return;
                  }
                  try {
                    await navigator.clipboard.writeText(outputTextForCopy);
                    message.success('Copied to clipboard');
                  } catch (err) {
                    message.error('Failed to copy to clipboard');
                  }
                }}
              />
            </div>
            <div
              style={{
                padding: '5px 10px',
                maxHeight: outputExpanded ? '200px' : 'none',
                overflowY: outputExpanded ? 'scroll' : 'visible',
                overflowX: 'hidden',
                scrollbarWidth: 'thin',
                scrollbarColor: '#555 #2a2a2a',
              }}
              className="shell-output-container">
              {stdoutText &&
                renderOutputBlock(
                  'stdout',
                  stdoutText,
                  '#e8e8e8',
                  stdoutTruncated,
                )}
              {stderrText &&
                renderOutputBlock(
                  'stderr',
                  stderrText,
                  '#ff7875',
                  stderrTruncated,
                )}
              {!stdoutText &&
                !stderrText &&
                outputText &&
                renderOutputBlock(
                  'output',
                  outputText,
                  '#e8e8e8',
                  fallbackOutputTruncated,
                )}
              {isAnyOutputTruncated && (
                <div
                  style={{
                    color: '#1890ff',
                    cursor: 'pointer',
                    fontSize: '11px',
                    marginTop: '4px',
                    textDecoration: 'underline',
                  }}
                  onClick={() => setOutputExpanded(!outputExpanded)}>
                  {outputExpanded ? 'Show less' : 'Show more...'}
                </div>
              )}
            </div>
          </div>
        )}

        {shouldShowTokens && (
          <div
            style={{
              borderTop: '1px solid #333',
              padding: '6px 10px',
              background: '#1a1a1a',
              color: '#c4c4c4',
              fontSize: '11px',
              display: 'flex',
              gap: 10,
              justifyContent: 'flex-end',
              flexWrap: 'wrap',
            }}>
            <span>IN: {formatTokenUsage(tokenUsageIn)}</span>
            <span>OUT: {formatTokenUsage(tokenUsageOut)}</span>
            {hasRequestTokens && (
              <span>REQ: {formatRequestTokenUsage(requestTokenUsageIn)}</span>
            )}
          </div>
        )}
      </div>
    </div>
  );
};
