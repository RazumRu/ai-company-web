import isPlainObject from 'lodash/isPlainObject';

import type { ThreadMessageDto } from '../../../../autogenerated';
import { STREAMING_REASONING_FLAG } from '../../../../utils/threadMessages';
import { isBlankContent } from './messageUtils';
import type {
  PreparedMessage,
  ShellResult,
  SubagentStatistics,
  ToolCall,
} from './threadMessagesTypes';
import {
  argsToObject,
  extractDurationMs,
  extractShellCommandFromArgs,
  getAdditionalKwargs,
  getMessageRunId,
  getMessageString,
  getMessageTitle,
  getMessageValue,
  getToolMessageKey,
  isToolLikeRole,
  parseJsonSafe,
} from './threadMessagesViewUtils';

interface PrepareReadyMessagesOptions {
  isNodeRunning: boolean;
  isThreadStopped: boolean;
  currentThreadLastRunId?: string | null;
  /** When true, suppresses synthetic communication block post-processing.
   *  Set automatically when recursing inside a communication block. */
  insideCommunicationBlock?: boolean;
  /** When true, suppresses synthetic subagent block post-processing.
   *  Set automatically when recursing inside a subagent block. */
  insideSubagentBlock?: boolean;
}

/** A PreparedMessage that has an `innerMessages` array (communication or subagent block). */
type BlockItem = PreparedMessage & { innerMessages: PreparedMessage[] };

/** Extracts the model name from the first inner message that has __model set. */
const extractSubagentModel = (
  innerMessages: ThreadMessageDto[],
): string | undefined => {
  for (const inner of innerMessages) {
    const additional = getAdditionalKwargs(inner.message);
    if (typeof additional?.__model === 'string') {
      return additional.__model;
    }
  }
  return undefined;
};

/** Accumulates token usage from **prepared** messages to provide live
 *  statistics for a subagent/communication block.  Operating on the prepared
 *  (post-grouping) messages instead of raw ThreadMessageDtos avoids
 *  double-counting: nested subagent/communication blocks contribute their own
 *  `statistics` as single items rather than having every inner message counted
 *  again at the parent level.
 *
 *  For flat message types (chat, reasoning, system) we use the original DTO's
 *  `requestTokenUsage`; for tool messages we use the directly-attached
 *  `requestTokenUsage`; for nested blocks (subagent, communication) we use
 *  the block's already-computed `statistics`. */
const accumulatePreparedStatistics = (
  prepared: PreparedMessage[],
): SubagentStatistics | undefined => {
  let totalTokens = 0;
  let totalPrice = 0;
  let durationMs = 0;
  let count = 0;

  for (const item of prepared) {
    if (item.type === 'subagent' || item.type === 'communication') {
      // Nested block — use the block's aggregated statistics so we don't
      // double-count its inner messages.
      const s = item.statistics;
      if (!s) continue;
      count++;
      const price = s.usage?.totalPrice ?? s.totalPrice;
      if (typeof price === 'number') totalPrice += price;
      if (typeof s.usage?.totalTokens === 'number')
        totalTokens += s.usage.totalTokens;
      if (typeof s.usage?.durationMs === 'number')
        durationMs += s.usage.durationMs;
    } else if (item.type === 'tool') {
      // Tool messages carry requestTokenUsage directly (no .message wrapper).
      const usage = item.requestTokenUsage;
      if (!usage) continue;
      count++;
      if (typeof usage.totalTokens === 'number')
        totalTokens += usage.totalTokens;
      if (typeof usage.totalPrice === 'number') totalPrice += usage.totalPrice;
      if (typeof item.durationMs === 'number') durationMs += item.durationMs;
    } else {
      // chat / reasoning / system — have a .message (ThreadMessageDto).
      const usage =
        item.message?.requestTokenUsage ?? item.message?.toolTokenUsage;
      if (!usage) continue;
      count++;
      if (typeof usage.totalTokens === 'number')
        totalTokens += usage.totalTokens;
      if (typeof usage.totalPrice === 'number') totalPrice += usage.totalPrice;
      // Extract durationMs from the DTO's additionalKwargs.
      const dur = extractDurationMs(item.message.message);
      if (typeof dur === 'number') durationMs += dur;
    }
  }

  if (count === 0) return undefined;

  return {
    usage: {
      totalTokens: totalTokens || undefined,
      totalPrice: totalPrice || undefined,
      durationMs: durationMs || undefined,
    },
  };
};

export const prepareReadyMessages = (
  msgs: ThreadMessageDto[],
  options: PrepareReadyMessagesOptions,
): PreparedMessage[] => {
  const { isNodeRunning, isThreadStopped, currentThreadLastRunId } = options;
  const allowCallingIndicators = isNodeRunning && !isThreadStopped;

  // Filter out messages explicitly hidden from the UI by the backend.
  msgs = msgs.filter((m) => {
    const additional = getAdditionalKwargs(m.message);
    return !additional?.__hideForUi;
  });

  const isLatestRun = (runId?: string): boolean => {
    if (!currentThreadLastRunId) return true;
    if (!runId) return false;
    return runId === currentThreadLastRunId;
  };

  const buildToolCallResultIndex = (
    allMessages: ThreadMessageDto[],
  ): Record<string, ThreadMessageDto[]> => {
    return allMessages.reduce<Record<string, ThreadMessageDto[]>>(
      (acc, msg) => {
        if (!isToolLikeRole(msg.message?.role as string)) {
          return acc;
        }
        const toolCallId = getMessageString(msg.message, 'toolCallId');
        if (!toolCallId) {
          return acc;
        }
        if (!acc[toolCallId]) {
          acc[toolCallId] = [];
        }
        acc[toolCallId].push(msg);
        return acc;
      },
      {},
    );
  };

  const toolCallResultsById = buildToolCallResultIndex(msgs);
  const consumedToolCallIds = new Set<string>();
  const consumedToolMessageKeys = new Set<string>();

  // Collect all subagents_run_task tool call IDs so only those are treated as
  // subagent parents.  Without this, the recursive call would re-scan inner
  // messages (which also carry __toolCallId) and skip them all.
  const subagentToolCallIds = new Set<string>();
  const communicationToolCallIds = new Set<string>();
  // Map communication_exec tool call ID → target agent name from args.
  // Used as a fallback to group inner messages when __toolCallId doesn't match.
  const commToolCallAgentName = new Map<string, string>();
  // Map communication_exec tool call ID → __createdAt of the parent AI message.
  // Used to temporally disambiguate when multiple calls target the same agent.
  const commToolCallCreatedAt = new Map<string, string>();
  for (const msg of msgs) {
    if ((msg.message?.role as string) !== 'ai') continue;
    const tcs = getMessageValue<ToolCall[]>(msg.message, 'toolCalls');
    if (!tcs) continue;
    for (const tc of tcs) {
      const tcName = tc.name || tc.function?.name;
      if (tcName === 'subagents_run_task' && tc.id) {
        subagentToolCallIds.add(tc.id);
      }
      if (tcName === 'communication_exec' && tc.id) {
        communicationToolCallIds.add(tc.id);
        const tcArgs = argsToObject(tc.function?.arguments ?? tc.args);
        const agentName =
          typeof tcArgs?.agent === 'string' ? tcArgs.agent : undefined;
        if (agentName) {
          commToolCallAgentName.set(tc.id, agentName);
        }
        // Store __createdAt from the AI message for temporal resolution.
        const msgAdditional = getAdditionalKwargs(msg.message);
        const createdAt =
          typeof msgAdditional?.__createdAt === 'string'
            ? msgAdditional.__createdAt
            : msg.createdAt;
        if (createdAt) {
          commToolCallCreatedAt.set(tc.id, createdAt);
        }
      }
    }
  }

  // Pre-scan: group subagent inner messages by parent tool call ID
  const subagentInnerByToolCallId = new Map<string, ThreadMessageDto[]>();
  const subagentInnerMsgIds = new Set<string>();

  // Pre-scan: group communication inner messages by parent tool call ID
  const commInnerByToolCallId = new Map<string, ThreadMessageDto[]>();
  const commInstructionByToolCallId = new Map<string, ThreadMessageDto>();
  const commInnerMsgIds = new Set<string>();

  // Reverse map: agent name → communication_exec tool call IDs targeting it.
  const commToolCallsByAgentName = new Map<string, string[]>();
  for (const [tcId, agentName] of commToolCallAgentName) {
    const list = commToolCallsByAgentName.get(agentName) ?? [];
    list.push(tcId);
    commToolCallsByAgentName.set(agentName, list);
  }

  /** Find the communication_exec call whose __createdAt is the latest one
   *  still ≤ the inner message's __createdAt.  When timestamps are unavailable,
   *  falls back to the last call in the list. */
  const resolveCommByTimestamp = (
    tcIds: string[],
    msg: ThreadMessageDto,
  ): string => {
    if (tcIds.length === 1) return tcIds[0];

    const msgAdditional = getAdditionalKwargs(msg.message);
    const msgCreatedAt =
      typeof msgAdditional?.__createdAt === 'string'
        ? msgAdditional.__createdAt
        : msg.createdAt;

    if (!msgCreatedAt) return tcIds[tcIds.length - 1];

    // Walk the list (ordered by appearance in the message stream) and pick
    // the latest comm call that was created at or before the inner message.
    let best: string | undefined;
    for (const tcId of tcIds) {
      const callCreatedAt = commToolCallCreatedAt.get(tcId);
      if (!callCreatedAt) continue;
      if (callCreatedAt <= msgCreatedAt) {
        best = tcId;
      }
    }

    return best ?? tcIds[tcIds.length - 1];
  };

  /** Try to match an inter-agent message to a communication_exec tool call ID
   *  by checking if the message's externalThreadId contains the target agent name. */
  const resolveCommToolCallId = (msg: ThreadMessageDto): string | undefined => {
    const extId = msg.externalThreadId;
    // 1. Match by externalThreadId containing the agent name.
    //    Collect ALL matching tool call IDs; when multiple calls target the
    //    same agent the externalThreadId matches them all, so we resolve
    //    via timestamp.
    if (extId) {
      const matchedByExtId: string[] = [];
      for (const [tcId, agentName] of commToolCallAgentName) {
        if (extId.includes(`__${agentName}`)) {
          matchedByExtId.push(tcId);
        }
      }
      if (matchedByExtId.length === 1) return matchedByExtId[0];
      if (matchedByExtId.length > 1) {
        return resolveCommByTimestamp(matchedByExtId, msg);
      }
    }
    // 2. Match by __sourceAgentName in kwargs → find comm call targeting that agent.
    //    When multiple calls target the same agent, use timestamps to resolve.
    const additional = getAdditionalKwargs(msg.message);
    const sourceAgent =
      typeof additional?.__sourceAgentName === 'string'
        ? additional.__sourceAgentName
        : undefined;
    if (sourceAgent) {
      const tcIds = commToolCallsByAgentName.get(sourceAgent);
      if (tcIds && tcIds.length > 0) {
        return resolveCommByTimestamp(tcIds, msg);
      }
    }
    // 3. Fallback: if there is only one communication_exec call, assign all
    //    __interAgentCommunication messages to it.
    if (communicationToolCallIds.size === 1) {
      return communicationToolCallIds.values().next().value;
    }
    return undefined;
  };

  /** Check whether a message itself CONTAINS a tool call with the given ID.
   *  This detects the case where the AI message that made the subagent/comm
   *  call carries __toolCallId equal to its own tool call.  Such a message is
   *  the *parent*, not an inner message, and must not be consumed here. */
  const msgOwnsToolCall = (
    msg: ThreadMessageDto,
    toolCallId: string,
  ): boolean => {
    if ((msg.message?.role as string) !== 'ai') return false;
    const tcs = getMessageValue<ToolCall[]>(msg.message, 'toolCalls');
    if (!tcs) return false;
    return tcs.some((tc) => tc.id === toolCallId);
  };

  for (const msg of msgs) {
    const additional = getAdditionalKwargs(msg.message);
    const parentToolCallId =
      typeof additional?.__toolCallId === 'string'
        ? additional.__toolCallId
        : undefined;
    const isInterAgent = Boolean(additional?.__interAgentCommunication);
    const isSubagentComm = Boolean(additional?.__subagentCommunication);

    // Skip messages that own the tool call — they are the parent AI message,
    // not an inner message, and must not be consumed as an inner of its own call.
    const isParentOfOwnToolCall =
      parentToolCallId != null && msgOwnsToolCall(msg, parentToolCallId);

    // Group into subagent blocks when __toolCallId matches a subagents_run_task
    // call.  Skip only when the __toolCallId also matches a communication_exec
    // call (those stay in the communication block).  Inter-agent messages whose
    // __toolCallId points to a subagent call ARE grouped — the recursive
    // prepareReadyMessages call inside communication blocks needs this to build
    // proper SubagentBlock entries.
    if (
      parentToolCallId &&
      !isParentOfOwnToolCall &&
      subagentToolCallIds.has(parentToolCallId) &&
      !communicationToolCallIds.has(parentToolCallId)
    ) {
      if (!subagentInnerByToolCallId.has(parentToolCallId)) {
        subagentInnerByToolCallId.set(parentToolCallId, []);
      }
      subagentInnerByToolCallId.get(parentToolCallId)!.push(msg);
      if (msg.id) subagentInnerMsgIds.add(msg.id);
      const key = getToolMessageKey(msg);
      if (key) subagentInnerMsgIds.add(key);
    }

    // Group communication inner messages.  The backend may set __toolCallId to
    // the communication_exec call ID, or it may only flag __interAgentCommunication
    // without a matching __toolCallId.  Handle both cases.
    //
    // Messages flagged __subagentCommunication also belong to the communication
    // block (the subagent runs inside the communication context).  They need to
    // be in commInnerByToolCallId so the recursive prepareReadyMessages call
    // inside the communication block can re-group them into a SubagentBlock.
    //
    // Guard: if a message owns a communication_exec call that matches its own
    // __toolCallId, it is the PARENT of that communication block — skip it.
    // But if it only owns a subagent call (subagents_run_task) it can still be
    // a valid inner message of a communication block, so we allow it through.
    const ownsCommToolCall =
      parentToolCallId != null &&
      communicationToolCallIds.has(parentToolCallId) &&
      msgOwnsToolCall(msg, parentToolCallId);

    let commParentId: string | undefined;
    if (
      parentToolCallId &&
      !ownsCommToolCall &&
      communicationToolCallIds.has(parentToolCallId)
    ) {
      commParentId = parentToolCallId;
    } else if ((isInterAgent || isSubagentComm) && !ownsCommToolCall) {
      commParentId = resolveCommToolCallId(msg);
    }

    if (commParentId) {
      // The "Providing Instructions" message is the instruction message
      const isInstruction = Boolean(
        additional?.__isAgentInstructionMessage ??
        additional?.isAgentInstructionMessage,
      );
      if (isInstruction && !commInstructionByToolCallId.has(commParentId)) {
        commInstructionByToolCallId.set(commParentId, msg);
      } else {
        if (!commInnerByToolCallId.has(commParentId)) {
          commInnerByToolCallId.set(commParentId, []);
        }
        commInnerByToolCallId.get(commParentId)!.push(msg);
      }
      if (msg.id) commInnerMsgIds.add(msg.id);
      const key = getToolMessageKey(msg);
      if (key) commInnerMsgIds.add(key);
    }
  }

  const markToolMessageConsumed = (msg?: ThreadMessageDto) => {
    const key = getToolMessageKey(msg);
    if (key) {
      consumedToolMessageKeys.add(key);
    }
  };

  const markToolCallConsumed = (toolCallId?: string) => {
    if (toolCallId) {
      consumedToolCallIds.add(toolCallId);
    }
  };

  const consumeToolResultById = (
    toolCallId?: string,
  ): ThreadMessageDto | undefined => {
    if (!toolCallId) return undefined;
    const queue = toolCallResultsById[toolCallId];
    if (!queue || queue.length === 0) {
      return undefined;
    }
    const next = queue.shift();
    markToolCallConsumed(toolCallId);
    markToolMessageConsumed(next);
    return next;
  };

  const isInterAgentCommunication = (msg: ThreadMessageDto): boolean => {
    const additional = getAdditionalKwargs(msg.message);
    return Boolean(additional?.__interAgentCommunication);
  };

  const isSubagentCommunication = (msg: ThreadMessageDto): boolean => {
    const additional = getAdditionalKwargs(msg.message);
    return Boolean(additional?.__subagentCommunication);
  };

  const getSourceAgentNodeId = (msg: ThreadMessageDto): string | undefined => {
    const additional = getAdditionalKwargs(msg.message);
    return typeof additional?.__sourceAgentNodeId === 'string'
      ? additional.__sourceAgentNodeId
      : undefined;
  };

  // Build a set of all tool call IDs that exist in current messages
  const existingToolCallIds = new Set<string>();
  msgs.forEach((m) => {
    const role = (m.message?.role as string) || '';
    if (role === 'ai') {
      const messageToolCalls = getMessageValue<ToolCall[]>(
        m.message,
        'toolCalls',
      );
      if (messageToolCalls && messageToolCalls.length > 0) {
        messageToolCalls.forEach((tc) => {
          if (tc.id) {
            existingToolCallIds.add(tc.id);
          }
        });
      }
    }
  });

  // First pass: mark tool results that belong to AI messages as consumed
  msgs.forEach((m) => {
    const role = (m.message?.role as string) || '';
    if (role === 'ai') {
      const messageToolCalls = getMessageValue<ToolCall[]>(
        m.message,
        'toolCalls',
      );
      if (messageToolCalls && messageToolCalls.length > 0) {
        messageToolCalls.forEach((tc) => {
          if (tc.id) {
            const queue = toolCallResultsById[tc.id];
            if (queue && queue.length > 0) {
              markToolCallConsumed(tc.id);
              markToolMessageConsumed(queue[0]);
            }
          }
        });
      }
    }
  });

  const prepared: PreparedMessage[] = [];

  let i = 0;

  while (i < msgs.length) {
    const m = msgs[i];

    // Skip subagent / communication inner messages — consumed into blocks.
    const mToolKey = getToolMessageKey(m);
    if (
      (m.id && (subagentInnerMsgIds.has(m.id) || commInnerMsgIds.has(m.id))) ||
      (mToolKey &&
        (subagentInnerMsgIds.has(mToolKey) || commInnerMsgIds.has(mToolKey)))
    ) {
      i++;
      continue;
    }

    const role = (m.message?.role as string) || '';
    const isInterAgent = isInterAgentCommunication(m);
    const isSubagent = isSubagentCommunication(m);
    const sourceAgentNodeId = getSourceAgentNodeId(m);

    if (role === 'reasoning') {
      if (!isBlankContent(m.message?.content)) {
        prepared.push({
          type: 'reasoning',
          message: m,
          id: `reasoning-${m.id || m.createdAt}`,
          nodeId: m.nodeId,
          createdAt: m.createdAt,
          inCommunicationExec: isInterAgent,
          inSubagentExec: isSubagent,
          sourceAgentNodeId,
        });
      }
      i++;
      continue;
    }

    if (role === 'system') {
      prepared.push({
        type: 'system',
        message: m,
        id: `system-${m.id || m.createdAt}`,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        inCommunicationExec: isInterAgent,
        inSubagentExec: isSubagent,
        sourceAgentNodeId,
      });
      i++;
      continue;
    }

    const messageToolCalls = getMessageValue<ToolCall[]>(
      m.message,
      'toolCalls',
    );
    if (role === 'ai' && messageToolCalls && messageToolCalls.length > 0) {
      const hasNonBlankContent = !isBlankContent(m.message?.content);

      // Check whether any tool call in this AI message is communication_exec.
      // If so, the AI text content will be folded INTO the communication block
      // instead of being emitted as a separate chat message.
      const hasCommToolCall = messageToolCalls.some(
        (tc) =>
          (tc.name || tc.function?.name) === 'communication_exec' &&
          tc.id &&
          communicationToolCallIds.has(tc.id),
      );

      if (hasNonBlankContent && !hasCommToolCall) {
        prepared.push({
          type: 'chat',
          message: m,
          id: `chat-${m.id || m.createdAt}`,
          nodeId: m.nodeId,
          createdAt: m.createdAt,
          inCommunicationExec: isInterAgent,
          inSubagentExec: isSubagent,
          sourceAgentNodeId,
          // Mark as tool-call content so it renders inside the working block
          // rather than as a standalone chat bubble.
          isToolCallContent: true,
        });
      }

      const followingTools: ThreadMessageDto[] = [];
      let j = i + 1;
      while (
        j < msgs.length &&
        isToolLikeRole(msgs[j].message?.role as string)
      ) {
        followingTools.push(msgs[j]);
        j++;
      }

      for (let idx = 0; idx < messageToolCalls.length; idx++) {
        const tc = messageToolCalls[idx];
        const name = tc.name || tc.function?.name || 'tool';
        const callTitle =
          (tc.title && tc.title.trim().length > 0 ? tc.title : undefined) ??
          (tc.__title && tc.__title.trim().length > 0
            ? tc.__title
            : undefined) ??
          (tc.function?.title && tc.function.title.trim().length > 0
            ? tc.function.title
            : undefined) ??
          (tc.function?.__title && tc.function.__title.trim().length > 0
            ? tc.function.__title
            : undefined);
        let matched = consumeToolResultById(tc.id);
        if (!matched) {
          matched = followingTools.find(
            (tm) => getMessageString(tm.message, 'toolCallId') === tc.id,
          );
          if (matched) {
            markToolCallConsumed(
              tc.id || getMessageString(matched.message, 'toolCallId'),
            );
            markToolMessageConsumed(matched);
          }
        }
        const resultContent = matched?.message?.content;
        const toolArgs = tc.function?.arguments ?? tc.args;
        const toolCallRunId =
          getMessageRunId(m.message) ?? getMessageRunId(matched?.message);

        // Subagent tool call → emit a 'subagent' prepared message
        const isSubagentTool =
          name === 'subagents_run_task' &&
          tc.id &&
          subagentInnerByToolCallId.has(tc.id);
        if (isSubagentTool) {
          const innerRawMessages = subagentInnerByToolCallId.get(tc.id!) ?? [];
          const innerPrepared = prepareReadyMessages(innerRawMessages, {
            ...options,
            insideSubagentBlock: true,
          });

          const resultObj = isPlainObject(resultContent)
            ? (resultContent as Record<string, unknown>)
            : typeof resultContent === 'string'
              ? (parseJsonSafe(resultContent) as Record<string, unknown> | null)
              : null;
          const statistics =
            (resultObj?.statistics as SubagentStatistics) ??
            accumulatePreparedStatistics(innerPrepared);
          const resultText =
            typeof resultObj?.result === 'string'
              ? resultObj.result
              : undefined;
          const errorText =
            typeof resultObj?.error === 'string' ? resultObj.error : undefined;

          const parsedArgs = argsToObject(toolArgs);
          const taskDescription =
            typeof parsedArgs?.task === 'string'
              ? parsedArgs.task
              : typeof parsedArgs?.prompt === 'string'
                ? (parsedArgs.prompt as string)
                : undefined;
          const purpose =
            typeof parsedArgs?.purpose === 'string'
              ? parsedArgs.purpose
              : undefined;
          const agentId =
            typeof parsedArgs?.agentId === 'string'
              ? parsedArgs.agentId
              : undefined;

          const model = extractSubagentModel(innerRawMessages);

          prepared.push({
            type: 'subagent',
            toolCallId: tc.id!,
            purpose,
            taskDescription,
            agentId,
            innerMessages: innerPrepared,
            statistics,
            resultText,
            errorText,
            model,
            rawToolArgs: parsedArgs ?? toolArgs,
            rawToolResult: resultContent,
            requestTokenUsageIn: m.requestTokenUsage,
            requestTokenUsageOut: matched?.requestTokenUsage,
            status: matched
              ? 'executed'
              : allowCallingIndicators && isLatestRun(toolCallRunId)
                ? 'calling'
                : 'stopped',
            id: `subagent-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
            nodeId: matched?.nodeId ?? m.nodeId,
            createdAt: m.createdAt,
            inCommunicationExec: isInterAgent,
            inSubagentExec: isSubagent,
            sourceAgentNodeId,
          });
          continue;
        }

        // Communication tool call → emit a 'communication' prepared message
        const isCommTool =
          name === 'communication_exec' &&
          tc.id &&
          communicationToolCallIds.has(tc.id);
        if (isCommTool) {
          const innerRawMessages = commInnerByToolCallId.get(tc.id!) ?? [];
          const innerPrepared = prepareReadyMessages(innerRawMessages, {
            ...options,
            insideCommunicationBlock: true,
          });
          const instructionMsg = commInstructionByToolCallId.get(tc.id!);

          const commResultObj = isPlainObject(resultContent)
            ? (resultContent as Record<string, unknown>)
            : typeof resultContent === 'string'
              ? (parseJsonSafe(resultContent) as Record<string, unknown> | null)
              : null;
          const commResultText =
            typeof commResultObj?.result === 'string'
              ? commResultObj.result
              : typeof commResultObj?.message === 'string'
                ? commResultObj.message
                : undefined;
          const commErrorText =
            typeof commResultObj?.error === 'string'
              ? commResultObj.error
              : undefined;
          const commStatistics =
            (commResultObj?.statistics as SubagentStatistics) ??
            accumulatePreparedStatistics(innerPrepared);

          const parsedArgs = argsToObject(toolArgs);
          const targetNodeId =
            typeof parsedArgs?.targetNodeId === 'string'
              ? parsedArgs.targetNodeId
              : undefined;
          const targetAgentName =
            commToolCallAgentName.get(tc.id!) ??
            (typeof parsedArgs?.agent === 'string'
              ? (parsedArgs.agent as string)
              : undefined);

          const commModel = extractSubagentModel(innerRawMessages);

          // Pass the parent AI message so its text content can be shown
          // as the first item inside the communication block.
          const parentHasContent = !isBlankContent(m.message?.content);

          // Skip redundant result-only communication blocks — these appear
          // when the backend emits a second communication_exec call that
          // carries only the final result without any inner conversation.
          // Always keep blocks that have an error so the user can see what
          // went wrong.
          const hasSubstantiveContent =
            innerPrepared.length > 0 ||
            instructionMsg ||
            parentHasContent ||
            commErrorText ||
            (!matched && allowCallingIndicators && isLatestRun(toolCallRunId));
          if (!hasSubstantiveContent) {
            continue;
          }

          prepared.push({
            type: 'communication',
            toolCallId: tc.id!,
            targetNodeId,
            targetAgentName,
            parentMessage: parentHasContent ? m : undefined,
            instructionMessage: instructionMsg,
            innerMessages: innerPrepared,
            statistics: commStatistics,
            resultText: commResultText,
            errorText: commErrorText,
            model: commModel,
            rawToolArgs: parsedArgs ?? toolArgs,
            rawToolResult: resultContent,
            requestTokenUsageIn: m.requestTokenUsage,
            requestTokenUsageOut: matched?.requestTokenUsage,
            status: matched
              ? 'executed'
              : allowCallingIndicators && isLatestRun(toolCallRunId)
                ? 'calling'
                : 'stopped',
            id: `comm-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
            nodeId: matched?.nodeId ?? m.nodeId,
            createdAt: m.createdAt,
            sourceAgentNodeId,
          });
          continue;
        }

        // Regular tool call
        const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
        const resultObj = isPlainObject(resultContent)
          ? (resultContent as ShellResult)
          : null;
        const shellCommand = shellCmdFromArgs || resultObj?.command;
        const isShell = (name || '').toLowerCase() === 'shell';
        const toolOptions = argsToObject(toolArgs) || undefined;
        const matchedTitle = getMessageTitle(matched?.message);
        const effectiveTitle = matchedTitle || callTitle;

        prepared.push({
          type: 'tool',
          name: name || 'tool',
          status: matched
            ? 'executed'
            : allowCallingIndicators && isLatestRun(toolCallRunId)
              ? 'calling'
              : 'stopped',
          result: resultContent,
          id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
          toolKind: isShell ? 'shell' : 'generic',
          shellCommand,
          toolOptions,
          requestTokenUsage: m.requestTokenUsage,
          requestTokenUsageIn: m.requestTokenUsage,
          requestTokenUsageOut: matched?.requestTokenUsage,
          durationMs: extractDurationMs(m.message),
          nodeId: matched?.nodeId ?? m.nodeId,
          createdAt: matched?.createdAt ?? m.createdAt,
          roleLabel: effectiveTitle || name || 'tool',
          title: effectiveTitle,
          inCommunicationExec: isInterAgent,
          inSubagentExec: isSubagent,
          sourceAgentNodeId,
        });
      }

      i = i + 1 + followingTools.length;
      continue;
    }

    if (isToolLikeRole(role)) {
      const toolCallId = getMessageString(m.message, 'toolCallId');
      const messageKey = getToolMessageKey(m);

      if (
        (toolCallId && consumedToolCallIds.has(toolCallId)) ||
        (messageKey && consumedToolMessageKeys.has(messageKey))
      ) {
        i++;
        continue;
      }

      const name = getMessageString(m.message, 'name') || 'tool';

      // Skip communication_exec outputs when input is not in current messages
      if (
        name === 'communication_exec' &&
        toolCallId &&
        !existingToolCallIds.has(toolCallId)
      ) {
        i++;
        continue;
      }

      const title = getMessageTitle(m.message);
      const resultContent = m.message?.content;
      const resultObj = isPlainObject(resultContent)
        ? (resultContent as ShellResult)
        : null;
      const shellCommand = resultObj?.command;
      const isShell = (name || '').toLowerCase() === 'shell';
      const toolOptions = undefined;

      prepared.push({
        type: 'tool',
        name,
        status: 'executed',
        result: resultContent,
        id: `tool-standalone-${m.id || m.createdAt}`,
        toolKind: isShell ? 'shell' : 'generic',
        shellCommand,
        toolOptions,
        requestTokenUsage: m.requestTokenUsage,
        requestTokenUsageOut: m.requestTokenUsage,
        durationMs: extractDurationMs(m.message),
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        roleLabel: title || name || 'tool',
        title,
        inCommunicationExec: isInterAgent,
        inSubagentExec: isSubagent,
        sourceAgentNodeId,
      });
      i++;
      continue;
    }

    if (!isBlankContent(m.message?.content)) {
      prepared.push({
        type: 'chat',
        message: m,
        id: `chat-${m.id || m.createdAt}`,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        inCommunicationExec: isInterAgent,
        inSubagentExec: isSubagent,
        sourceAgentNodeId,
      });
    }
    i++;
  }

  // ── Synthetic block helpers ───────────────────────────────────────────
  // When parent AI messages (communication_exec / subagents_run_task) aren't
  // loaded due to pagination, their inner messages render as standalone
  // top-level items.  The helpers below detect this and wrap them in
  // synthetic blocks so the UI shows the expected grouped layout.

  /** Extract the raw ThreadMessageDto from a PreparedMessage (if any). */
  const getRawMsg = (item: PreparedMessage): ThreadMessageDto | undefined =>
    'message' in item
      ? (item as { message?: ThreadMessageDto }).message
      : undefined;

  /**
   * Group `inSubagentExec` items into synthetic subagent blocks.
   * Items whose __toolCallId doesn't match any loaded tool call are grouped
   * by that ID; remaining items pass through unchanged.
   */
  const wrapOrphanSubagentItems = (
    items: PreparedMessage[],
  ): PreparedMessage[] => {
    const subagentGroups = new Map<string, PreparedMessage[]>();
    const ungrouped: PreparedMessage[] = [];

    for (const item of items) {
      const rawMsg = getRawMsg(item);
      const additional = rawMsg
        ? getAdditionalKwargs(rawMsg.message)
        : undefined;
      const tcId =
        typeof additional?.__toolCallId === 'string'
          ? additional.__toolCallId
          : undefined;

      if (tcId && !existingToolCallIds.has(tcId)) {
        if (!subagentGroups.has(tcId)) {
          subagentGroups.set(tcId, []);
        }
        subagentGroups.get(tcId)!.push(item);
      } else {
        ungrouped.push(item);
      }
    }

    if (subagentGroups.size === 0) return items;

    const syntheticBlocks: PreparedMessage[] = [];
    for (const [tcId, groupItems] of subagentGroups) {
      const firstRaw = getRawMsg(groupItems[0]);
      const firstAdditional = firstRaw
        ? getAdditionalKwargs(firstRaw.message)
        : undefined;
      const subModel =
        typeof firstAdditional?.__model === 'string'
          ? firstAdditional.__model
          : undefined;

      syntheticBlocks.push({
        type: 'subagent',
        toolCallId: tcId,
        innerMessages: groupItems,
        model: subModel,
        status: 'executed',
        id: `subagent-synthetic-${tcId}`,
        nodeId: 'nodeId' in groupItems[0] ? groupItems[0].nodeId : undefined,
        createdAt:
          'createdAt' in groupItems[0] ? groupItems[0].createdAt : undefined,
        inCommunicationExec:
          'inCommunicationExec' in groupItems[0]
            ? groupItems[0].inCommunicationExec
            : undefined,
        inSubagentExec: true,
        sourceAgentNodeId:
          'sourceAgentNodeId' in groupItems[0]
            ? groupItems[0].sourceAgentNodeId
            : undefined,
      });
    }

    return [...ungrouped, ...syntheticBlocks];
  };

  // ── Post-processing: synthetic communication blocks ─────────────────
  // When communication_exec parent AI messages aren't loaded (pagination),
  // inner messages render as standalone items.  Group them into synthetic
  // communication blocks by __toolCallId so each call gets its own block.
  let result = prepared;

  if (
    communicationToolCallIds.size === 0 &&
    !options.insideCommunicationBlock
  ) {
    const nonCommItems: PreparedMessage[] = [];

    // Group communication items by __toolCallId; items without one go into
    // a single fallback bucket keyed by '__unresolved'.
    const commGroups = new Map<
      string,
      { items: PreparedMessage[]; instructionMsg?: ThreadMessageDto }
    >();
    const UNRESOLVED_KEY = '__unresolved';

    const getCommGroupKey = (item: PreparedMessage): string | undefined => {
      const rawMsg = getRawMsg(item);
      if (!rawMsg) return undefined;
      const additional = getAdditionalKwargs(rawMsg.message);
      const tcId =
        typeof additional?.__toolCallId === 'string'
          ? additional.__toolCallId
          : undefined;
      return tcId ?? UNRESOLVED_KEY;
    };

    // First pass: separate communication-flagged items from the rest.
    for (const item of result) {
      if ('inCommunicationExec' in item && item.inCommunicationExec) {
        // Pull instruction message out for the block header.
        const additional = getAdditionalKwargs(getRawMsg(item)?.message);
        const isInstruction =
          item.type === 'chat' &&
          (additional?.__isAgentInstructionMessage ||
            additional?.isAgentInstructionMessage);
        const groupKey = getCommGroupKey(item) ?? UNRESOLVED_KEY;

        if (!commGroups.has(groupKey)) {
          commGroups.set(groupKey, { items: [] });
        }
        const group = commGroups.get(groupKey)!;

        if (isInstruction && !group.instructionMsg) {
          group.instructionMsg = getRawMsg(item);
        } else {
          group.items.push(item);
        }
      } else {
        nonCommItems.push(item);
      }
    }

    // Second pass: when we have communication items, pull subagent-only
    // items too (they are subagent calls inside the communication context
    // but only have __subagentCommunication, not __interAgentCommunication).
    if (commGroups.size > 0) {
      const remainingNonComm: PreparedMessage[] = [];
      for (const item of nonCommItems) {
        if ('inSubagentExec' in item && item.inSubagentExec) {
          const groupKey = getCommGroupKey(item) ?? UNRESOLVED_KEY;
          if (!commGroups.has(groupKey)) {
            commGroups.set(groupKey, { items: [] });
          }
          commGroups.get(groupKey)!.items.push(item);
        } else {
          remainingNonComm.push(item);
        }
      }
      nonCommItems.length = 0;
      nonCommItems.push(...remainingNonComm);
    }

    const syntheticBlocks: PreparedMessage[] = [];
    for (const [
      groupKey,
      { items: groupItems, instructionMsg },
    ] of commGroups) {
      if (groupItems.length === 0 && !instructionMsg) continue;

      const finalInnerMessages = wrapOrphanSubagentItems(groupItems);

      let targetAgentName: string | undefined;
      for (const item of groupItems) {
        const rawMsg = getRawMsg(item);
        if (rawMsg) {
          const additional = getAdditionalKwargs(rawMsg.message);
          if (typeof additional?.__sourceAgentName === 'string') {
            targetAgentName = additional.__sourceAgentName;
            break;
          }
        }
      }

      const commModel = (() => {
        for (const item of groupItems) {
          const rawMsg = getRawMsg(item);
          if (rawMsg) {
            const additional = getAdditionalKwargs(rawMsg.message);
            if (typeof additional?.__model === 'string') {
              return additional.__model;
            }
          }
        }
        return undefined;
      })();

      syntheticBlocks.push({
        type: 'communication',
        toolCallId: groupKey,
        targetAgentName,
        instructionMessage: instructionMsg,
        innerMessages: finalInnerMessages,
        model: commModel,
        status: 'executed',
        id: `comm-synthetic-${groupKey}-${groupItems[0]?.id ?? 'orphan'}`,
        nodeId:
          groupItems.length > 0 && 'nodeId' in groupItems[0]
            ? groupItems[0].nodeId
            : undefined,
        createdAt:
          groupItems.length > 0 && 'createdAt' in groupItems[0]
            ? groupItems[0].createdAt
            : undefined,
      });
    }

    if (syntheticBlocks.length > 0) {
      result = [...nonCommItems, ...syntheticBlocks];
    }
  }

  // ── Post-processing: synthetic subagent blocks (top-level) ──────────
  // When subagents_run_task parent AI messages aren't loaded, their inner
  // messages appear as standalone items with inSubagentExec: true.
  // Group them into synthetic subagent blocks.
  if (subagentToolCallIds.size === 0 && !options.insideSubagentBlock) {
    const subItems: PreparedMessage[] = [];
    const nonSubItems: PreparedMessage[] = [];

    for (const item of result) {
      if ('inSubagentExec' in item && item.inSubagentExec) {
        subItems.push(item);
      } else {
        nonSubItems.push(item);
      }
    }

    if (subItems.length > 0) {
      const wrapped = wrapOrphanSubagentItems(subItems);
      result = [...nonSubItems, ...wrapped];
    }
  }

  // ── Post-processing: adopt orphan streaming reasoning into active blocks ──
  // Streaming reasoning messages (from graph.node.update reasoningChunks) lack
  // __interAgentCommunication / __toolCallId context, so they appear as
  // standalone top-level items even when they belong to an active communication
  // or subagent block.  Move them into the deepest active (status === 'calling')
  // block so they render inside it.  The search recurses into nested blocks to
  // place reasoning as close to the actual agent as possible (e.g. inside a
  // subagent block nested within a communication block).
  result = adoptOrphanStreamingReasoning(result, getRawMsg);

  return result;
};

// ── Orphan streaming reasoning adoption ─────────────────────────────────────

const isStreamingReasoningOrphan = (
  item: PreparedMessage,
  getRawMsg: (item: PreparedMessage) => ThreadMessageDto | undefined,
): boolean =>
  item.type === 'reasoning' &&
  !item.inCommunicationExec &&
  !item.inSubagentExec &&
  Boolean(
    getAdditionalKwargs(getRawMsg(item)?.message)?.[STREAMING_REASONING_FLAG],
  );

/** Find the last active block in `items`, recursing into nested blocks to
 *  return the deepest one.  This ensures reasoning ends up inside the
 *  innermost subagent, not the outer communication wrapper. */
const findDeepestActiveBlock = (
  items: PreparedMessage[],
): BlockItem | undefined => {
  for (let idx = items.length - 1; idx >= 0; idx--) {
    const item = items[idx];
    if (
      (item.type === 'communication' || item.type === 'subagent') &&
      item.status === 'calling'
    ) {
      const deeper = findDeepestActiveBlock(item.innerMessages);
      return deeper ?? (item as BlockItem);
    }
  }
  return undefined;
};

/**
 * Recursively rebuilds the block tree to append `orphans` to `target`,
 * producing shallow copies of every block on the path to avoid mutation.
 */
const appendToBlock = (
  items: PreparedMessage[],
  target: BlockItem,
  orphans: PreparedMessage[],
): PreparedMessage[] =>
  items.map((item) => {
    if (item === target) {
      return {
        ...target,
        innerMessages: [...target.innerMessages, ...orphans],
      };
    }
    if (
      (item.type === 'communication' || item.type === 'subagent') &&
      item.innerMessages.length > 0
    ) {
      const updatedInner = appendToBlock(item.innerMessages, target, orphans);
      if (updatedInner !== item.innerMessages) {
        return { ...item, innerMessages: updatedInner };
      }
    }
    return item;
  });

const adoptOrphanStreamingReasoning = (
  items: PreparedMessage[],
  getRawMsg: (item: PreparedMessage) => ThreadMessageDto | undefined,
): PreparedMessage[] => {
  // Quick check: bail out early when there are no streaming reasoning orphans.
  const hasOrphans = items.some((item) =>
    isStreamingReasoningOrphan(item, getRawMsg),
  );
  if (!hasOrphans) return items;

  const deepestBlock = findDeepestActiveBlock(items);
  if (!deepestBlock) return items;

  const orphans: PreparedMessage[] = [];
  const rest: PreparedMessage[] = [];

  for (const item of items) {
    if (isStreamingReasoningOrphan(item, getRawMsg)) {
      orphans.push(item);
    } else {
      rest.push(item);
    }
  }

  if (orphans.length === 0) return items;

  return appendToBlock(rest, deepestBlock, orphans);
};
