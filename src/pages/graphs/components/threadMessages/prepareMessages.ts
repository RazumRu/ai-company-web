import isPlainObject from 'lodash/isPlainObject';

import type { ThreadMessageDto } from '../../../../autogenerated';
import { isBlankContent } from './messageUtils';
import type {
  PreparedMessage,
  ShellResult,
  ToolCall,
} from './threadMessagesTypes';
import {
  argsToObject,
  extractShellCommandFromArgs,
  getAdditionalKwargs,
  getMessageRunId,
  getMessageString,
  getMessageTitle,
  getMessageValue,
  getToolMessageKey,
  isToolLikeRole,
} from './threadMessagesViewUtils';

interface PrepareReadyMessagesOptions {
  isNodeRunning: boolean;
  isThreadStopped: boolean;
  currentThreadLastRunId?: string | null;
}

export const prepareReadyMessages = (
  msgs: ThreadMessageDto[],
  options: PrepareReadyMessagesOptions,
): PreparedMessage[] => {
  const { isNodeRunning, isThreadStopped, currentThreadLastRunId } = options;
  const allowCallingIndicators = isNodeRunning && !isThreadStopped;

  const isLatestRun = (runId?: string): boolean => {
    if (!currentThreadLastRunId) return true;
    if (!runId) return false;
    return runId === currentThreadLastRunId;
  };

  const buildToolCallResultIndex = (
    allMessages: ThreadMessageDto[],
  ): Record<string, ThreadMessageDto[]> => {
    return allMessages.reduce<Record<string, ThreadMessageDto[]>>(
      (acc, msg) => {
        if (!isToolLikeRole(msg.message?.role as string)) {
          return acc;
        }
        const toolCallId = getMessageString(msg.message, 'toolCallId');
        if (!toolCallId) {
          return acc;
        }
        if (!acc[toolCallId]) {
          acc[toolCallId] = [];
        }
        acc[toolCallId].push(msg);
        return acc;
      },
      {},
    );
  };

  const toolCallResultsById = buildToolCallResultIndex(msgs);
  const consumedToolCallIds = new Set<string>();
  const consumedToolMessageKeys = new Set<string>();

  const markToolMessageConsumed = (msg?: ThreadMessageDto) => {
    const key = getToolMessageKey(msg);
    if (key) {
      consumedToolMessageKeys.add(key);
    }
  };

  const markToolCallConsumed = (toolCallId?: string) => {
    if (toolCallId) {
      consumedToolCallIds.add(toolCallId);
    }
  };

  const consumeToolResultById = (
    toolCallId?: string,
  ): ThreadMessageDto | undefined => {
    if (!toolCallId) return undefined;
    const queue = toolCallResultsById[toolCallId];
    if (!queue || queue.length === 0) {
      return undefined;
    }
    const next = queue.shift();
    markToolCallConsumed(toolCallId);
    markToolMessageConsumed(next);
    return next;
  };

  const isInterAgentCommunication = (msg: ThreadMessageDto): boolean => {
    const additional = getAdditionalKwargs(msg.message);
    return Boolean(additional?.__interAgentCommunication);
  };

  const getSourceAgentNodeId = (msg: ThreadMessageDto): string | undefined => {
    const additional = getAdditionalKwargs(msg.message);
    return typeof additional?.__sourceAgentNodeId === 'string'
      ? additional.__sourceAgentNodeId
      : undefined;
  };

  // Build a set of all tool call IDs that exist in current messages
  const existingToolCallIds = new Set<string>();
  msgs.forEach((m) => {
    const role = (m.message?.role as string) || '';
    if (role === 'ai') {
      const messageToolCalls = getMessageValue<ToolCall[]>(
        m.message,
        'toolCalls',
      );
      if (messageToolCalls && messageToolCalls.length > 0) {
        messageToolCalls.forEach((tc) => {
          if (tc.id) {
            existingToolCallIds.add(tc.id);
          }
        });
      }
    }
  });

  // First pass: mark tool results that belong to AI messages as consumed
  msgs.forEach((m) => {
    const role = (m.message?.role as string) || '';
    if (role === 'ai') {
      const messageToolCalls = getMessageValue<ToolCall[]>(
        m.message,
        'toolCalls',
      );
      if (messageToolCalls && messageToolCalls.length > 0) {
        messageToolCalls.forEach((tc) => {
          if (tc.id) {
            const queue = toolCallResultsById[tc.id];
            if (queue && queue.length > 0) {
              markToolCallConsumed(tc.id);
              markToolMessageConsumed(queue[0]);
            }
          }
        });
      }
    }
  });

  const prepared: PreparedMessage[] = [];
  let i = 0;

  while (i < msgs.length) {
    const m = msgs[i];
    const role = (m.message?.role as string) || '';
    const isInterAgent = isInterAgentCommunication(m);
    const sourceAgentNodeId = getSourceAgentNodeId(m);

    if (role === 'reasoning') {
      if (!isBlankContent(m.message?.content)) {
        prepared.push({
          type: 'reasoning',
          message: m,
          id: `reasoning-${m.id || m.createdAt}`,
          nodeId: m.nodeId,
          createdAt: m.createdAt,
          inCommunicationExec: isInterAgent,
          sourceAgentNodeId,
        });
      }
      i++;
      continue;
    }

    if (role === 'system') {
      prepared.push({
        type: 'system',
        message: m,
        id: `system-${m.id || m.createdAt}`,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        inCommunicationExec: isInterAgent,
        sourceAgentNodeId,
      });
      i++;
      continue;
    }

    const messageToolCalls = getMessageValue<ToolCall[]>(
      m.message,
      'toolCalls',
    );
    if (role === 'ai' && messageToolCalls && messageToolCalls.length > 0) {
      const hasNonBlankContent = !isBlankContent(m.message?.content);

      if (hasNonBlankContent) {
        prepared.push({
          type: 'chat',
          message: m,
          id: `chat-${m.id || m.createdAt}`,
          nodeId: m.nodeId,
          createdAt: m.createdAt,
          inCommunicationExec: isInterAgent,
          sourceAgentNodeId,
        });
      }

      const followingTools: ThreadMessageDto[] = [];
      let j = i + 1;
      while (
        j < msgs.length &&
        isToolLikeRole(msgs[j].message?.role as string)
      ) {
        followingTools.push(msgs[j]);
        j++;
      }

      for (let idx = 0; idx < messageToolCalls.length; idx++) {
        const tc = messageToolCalls[idx];
        const name = tc.name || tc.function?.name || 'tool';
        const callTitle =
          (tc.title && tc.title.trim().length > 0 ? tc.title : undefined) ??
          (tc.__title && tc.__title.trim().length > 0
            ? tc.__title
            : undefined) ??
          (tc.function?.title && tc.function.title.trim().length > 0
            ? tc.function.title
            : undefined) ??
          (tc.function?.__title && tc.function.__title.trim().length > 0
            ? tc.function.__title
            : undefined);
        let matched = consumeToolResultById(tc.id);
        if (!matched) {
          matched = followingTools.find(
            (tm) => getMessageString(tm.message, 'toolCallId') === tc.id,
          );
          if (matched) {
            markToolCallConsumed(
              tc.id || getMessageString(matched.message, 'toolCallId'),
            );
            markToolMessageConsumed(matched);
          }
        }
        const resultContent = matched?.message?.content;
        const toolArgs = tc.function?.arguments ?? tc.args;
        const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
        const resultObj = isPlainObject(resultContent)
          ? (resultContent as ShellResult)
          : null;
        const shellCommand = shellCmdFromArgs || resultObj?.command;
        const isShell = (name || '').toLowerCase() === 'shell';
        const toolOptions = argsToObject(toolArgs) || undefined;
        const matchedTitle = getMessageTitle(matched?.message);
        const effectiveTitle = matchedTitle || callTitle;
        const toolCallRunId =
          getMessageRunId(m.message) ?? getMessageRunId(matched?.message);

        const toolIsInterAgent = isInterAgent;
        const toolSourceAgentNodeId = sourceAgentNodeId;

        prepared.push({
          type: 'tool',
          name: name || 'tool',
          status: matched
            ? 'executed'
            : allowCallingIndicators && isLatestRun(toolCallRunId)
              ? 'calling'
              : 'stopped',
          result: resultContent,
          id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
          toolKind: isShell ? 'shell' : 'generic',
          shellCommand,
          toolOptions,
          requestTokenUsage: m.requestTokenUsage,
          requestTokenUsageIn: m.requestTokenUsage,
          requestTokenUsageOut: matched?.requestTokenUsage,
          nodeId: matched?.nodeId ?? m.nodeId,
          createdAt: matched?.createdAt ?? m.createdAt,
          roleLabel: effectiveTitle || name || 'tool',
          title: effectiveTitle,
          inCommunicationExec: toolIsInterAgent,
          sourceAgentNodeId: toolSourceAgentNodeId,
        });
      }

      i = i + 1 + followingTools.length;
      continue;
    }

    if (isToolLikeRole(role)) {
      const toolCallId = getMessageString(m.message, 'toolCallId');
      const messageKey = getToolMessageKey(m);

      if (
        (toolCallId && consumedToolCallIds.has(toolCallId)) ||
        (messageKey && consumedToolMessageKeys.has(messageKey))
      ) {
        i++;
        continue;
      }

      const name = getMessageString(m.message, 'name') || 'tool';

      // Skip communication_exec outputs when input is not in current messages
      if (
        name === 'communication_exec' &&
        toolCallId &&
        !existingToolCallIds.has(toolCallId)
      ) {
        i++;
        continue;
      }

      const title = getMessageTitle(m.message);
      const resultContent = m.message?.content;
      const resultObj = isPlainObject(resultContent)
        ? (resultContent as ShellResult)
        : null;
      const shellCommand = resultObj?.command;
      const isShell = (name || '').toLowerCase() === 'shell';
      const toolOptions = undefined;

      prepared.push({
        type: 'tool',
        name,
        status: 'executed',
        result: resultContent,
        id: `tool-standalone-${m.id || m.createdAt}`,
        toolKind: isShell ? 'shell' : 'generic',
        shellCommand,
        toolOptions,
        requestTokenUsage: m.requestTokenUsage,
        requestTokenUsageOut: m.requestTokenUsage,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        roleLabel: title || name || 'tool',
        title,
        inCommunicationExec: isInterAgent,
        sourceAgentNodeId,
      });
      i++;
      continue;
    }

    if (!isBlankContent(m.message?.content)) {
      prepared.push({
        type: 'chat',
        message: m,
        id: `chat-${m.id || m.createdAt}`,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        inCommunicationExec: isInterAgent,
        sourceAgentNodeId,
      });
    }
    i++;
  }

  return prepared;
};
