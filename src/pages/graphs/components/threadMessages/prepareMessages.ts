import isPlainObject from 'lodash/isPlainObject';

import type { ThreadMessageDto } from '../../../../autogenerated';
import { isBlankContent } from './messageUtils';
import type {
  PreparedMessage,
  ShellResult,
  SubagentStatistics,
  ToolCall,
} from './threadMessagesTypes';
import {
  argsToObject,
  extractShellCommandFromArgs,
  getAdditionalKwargs,
  getMessageRunId,
  getMessageString,
  getMessageTitle,
  getMessageValue,
  getToolMessageKey,
  isToolLikeRole,
  parseJsonSafe,
} from './threadMessagesViewUtils';

interface PrepareReadyMessagesOptions {
  isNodeRunning: boolean;
  isThreadStopped: boolean;
  currentThreadLastRunId?: string | null;
}

/** Extracts the model name from the first inner message that has __model set. */
const extractSubagentModel = (
  innerMessages: ThreadMessageDto[],
): string | undefined => {
  for (const inner of innerMessages) {
    const additional = getAdditionalKwargs(inner.message);
    if (typeof additional?.__model === 'string') {
      return additional.__model;
    }
  }
  return undefined;
};

export const prepareReadyMessages = (
  msgs: ThreadMessageDto[],
  options: PrepareReadyMessagesOptions,
): PreparedMessage[] => {
  const { isNodeRunning, isThreadStopped, currentThreadLastRunId } = options;
  const allowCallingIndicators = isNodeRunning && !isThreadStopped;

  const isLatestRun = (runId?: string): boolean => {
    if (!currentThreadLastRunId) return true;
    if (!runId) return false;
    return runId === currentThreadLastRunId;
  };

  const buildToolCallResultIndex = (
    allMessages: ThreadMessageDto[],
  ): Record<string, ThreadMessageDto[]> => {
    return allMessages.reduce<Record<string, ThreadMessageDto[]>>(
      (acc, msg) => {
        if (!isToolLikeRole(msg.message?.role as string)) {
          return acc;
        }
        const toolCallId = getMessageString(msg.message, 'toolCallId');
        if (!toolCallId) {
          return acc;
        }
        if (!acc[toolCallId]) {
          acc[toolCallId] = [];
        }
        acc[toolCallId].push(msg);
        return acc;
      },
      {},
    );
  };

  const toolCallResultsById = buildToolCallResultIndex(msgs);
  const consumedToolCallIds = new Set<string>();
  const consumedToolMessageKeys = new Set<string>();

  // Collect all subagents_run_task tool call IDs so only those are treated as
  // subagent parents.  Without this, the recursive call would re-scan inner
  // messages (which also carry __toolCallId) and skip them all.
  const subagentToolCallIds = new Set<string>();
  const communicationToolCallIds = new Set<string>();
  // Map communication_exec tool call ID → target agent name from args.
  // Used as a fallback to group inner messages when __toolCallId doesn't match.
  const commToolCallAgentName = new Map<string, string>();
  for (const msg of msgs) {
    if ((msg.message?.role as string) !== 'ai') continue;
    const tcs = getMessageValue<ToolCall[]>(msg.message, 'toolCalls');
    if (!tcs) continue;
    for (const tc of tcs) {
      const tcName = tc.name || tc.function?.name;
      if (tcName === 'subagents_run_task' && tc.id) {
        subagentToolCallIds.add(tc.id);
      }
      if (tcName === 'communication_exec' && tc.id) {
        communicationToolCallIds.add(tc.id);
        const tcArgs = argsToObject(tc.function?.arguments ?? tc.args);
        const agentName =
          typeof tcArgs?.agent === 'string' ? tcArgs.agent : undefined;
        if (agentName) {
          commToolCallAgentName.set(tc.id, agentName);
        }
      }
    }
  }

  // Pre-scan: group subagent inner messages by parent tool call ID
  const subagentInnerByToolCallId = new Map<string, ThreadMessageDto[]>();
  const subagentInnerMsgIds = new Set<string>();

  // Pre-scan: group communication inner messages by parent tool call ID
  const commInnerByToolCallId = new Map<string, ThreadMessageDto[]>();
  const commInstructionByToolCallId = new Map<string, ThreadMessageDto>();
  const commInnerMsgIds = new Set<string>();

  /** Try to match an inter-agent message to a communication_exec tool call ID
   *  by checking if the message's externalThreadId contains the target agent name. */
  const resolveCommToolCallId = (msg: ThreadMessageDto): string | undefined => {
    const extId = msg.externalThreadId;
    if (!extId) return undefined;
    for (const [tcId, agentName] of commToolCallAgentName) {
      if (extId.includes(`__${agentName}`)) {
        return tcId;
      }
    }
    // Fallback: if there is only one communication_exec call, assign all
    // __interAgentCommunication messages to it.
    if (communicationToolCallIds.size === 1) {
      return communicationToolCallIds.values().next().value;
    }
    return undefined;
  };

  for (const msg of msgs) {
    const additional = getAdditionalKwargs(msg.message);
    const parentToolCallId =
      typeof additional?.__toolCallId === 'string'
        ? additional.__toolCallId
        : undefined;
    const isInterAgent = Boolean(additional?.__interAgentCommunication);

    // Only group into subagent blocks if NOT an inter-agent communication message.
    // Communication inner messages may carry a __toolCallId that points to a
    // subagent call within the communication; those should stay in the communication
    // block and be handled by the recursive call inside it.
    if (
      parentToolCallId &&
      subagentToolCallIds.has(parentToolCallId) &&
      !isInterAgent
    ) {
      if (!subagentInnerByToolCallId.has(parentToolCallId)) {
        subagentInnerByToolCallId.set(parentToolCallId, []);
      }
      subagentInnerByToolCallId.get(parentToolCallId)!.push(msg);
      if (msg.id) subagentInnerMsgIds.add(msg.id);
      const key = getToolMessageKey(msg);
      if (key) subagentInnerMsgIds.add(key);
    }

    // Group communication inner messages.  The backend may set __toolCallId to
    // the communication_exec call ID, or it may only flag __interAgentCommunication
    // without a matching __toolCallId.  Handle both cases.
    let commParentId: string | undefined;
    if (parentToolCallId && communicationToolCallIds.has(parentToolCallId)) {
      commParentId = parentToolCallId;
    } else if (isInterAgent) {
      commParentId = resolveCommToolCallId(msg);
    }

    if (commParentId) {
      // The "Providing Instructions" message is the instruction message
      const isInstruction = Boolean(
        additional?.__isAgentInstructionMessage ??
        additional?.isAgentInstructionMessage,
      );
      if (isInstruction && !commInstructionByToolCallId.has(commParentId)) {
        commInstructionByToolCallId.set(commParentId, msg);
      } else {
        if (!commInnerByToolCallId.has(commParentId)) {
          commInnerByToolCallId.set(commParentId, []);
        }
        commInnerByToolCallId.get(commParentId)!.push(msg);
      }
      if (msg.id) commInnerMsgIds.add(msg.id);
      const key = getToolMessageKey(msg);
      if (key) commInnerMsgIds.add(key);
    }
  }

  const markToolMessageConsumed = (msg?: ThreadMessageDto) => {
    const key = getToolMessageKey(msg);
    if (key) {
      consumedToolMessageKeys.add(key);
    }
  };

  const markToolCallConsumed = (toolCallId?: string) => {
    if (toolCallId) {
      consumedToolCallIds.add(toolCallId);
    }
  };

  const consumeToolResultById = (
    toolCallId?: string,
  ): ThreadMessageDto | undefined => {
    if (!toolCallId) return undefined;
    const queue = toolCallResultsById[toolCallId];
    if (!queue || queue.length === 0) {
      return undefined;
    }
    const next = queue.shift();
    markToolCallConsumed(toolCallId);
    markToolMessageConsumed(next);
    return next;
  };

  const isInterAgentCommunication = (msg: ThreadMessageDto): boolean => {
    const additional = getAdditionalKwargs(msg.message);
    return Boolean(additional?.__interAgentCommunication);
  };

  const getSourceAgentNodeId = (msg: ThreadMessageDto): string | undefined => {
    const additional = getAdditionalKwargs(msg.message);
    return typeof additional?.__sourceAgentNodeId === 'string'
      ? additional.__sourceAgentNodeId
      : undefined;
  };

  // Build a set of all tool call IDs that exist in current messages
  const existingToolCallIds = new Set<string>();
  msgs.forEach((m) => {
    const role = (m.message?.role as string) || '';
    if (role === 'ai') {
      const messageToolCalls = getMessageValue<ToolCall[]>(
        m.message,
        'toolCalls',
      );
      if (messageToolCalls && messageToolCalls.length > 0) {
        messageToolCalls.forEach((tc) => {
          if (tc.id) {
            existingToolCallIds.add(tc.id);
          }
        });
      }
    }
  });

  // First pass: mark tool results that belong to AI messages as consumed
  msgs.forEach((m) => {
    const role = (m.message?.role as string) || '';
    if (role === 'ai') {
      const messageToolCalls = getMessageValue<ToolCall[]>(
        m.message,
        'toolCalls',
      );
      if (messageToolCalls && messageToolCalls.length > 0) {
        messageToolCalls.forEach((tc) => {
          if (tc.id) {
            const queue = toolCallResultsById[tc.id];
            if (queue && queue.length > 0) {
              markToolCallConsumed(tc.id);
              markToolMessageConsumed(queue[0]);
            }
          }
        });
      }
    }
  });

  const prepared: PreparedMessage[] = [];
  let i = 0;

  while (i < msgs.length) {
    const m = msgs[i];

    // Skip subagent / communication inner messages — consumed into blocks
    const mToolKey = getToolMessageKey(m);
    if (
      (m.id && (subagentInnerMsgIds.has(m.id) || commInnerMsgIds.has(m.id))) ||
      (mToolKey &&
        (subagentInnerMsgIds.has(mToolKey) || commInnerMsgIds.has(mToolKey)))
    ) {
      i++;
      continue;
    }

    const role = (m.message?.role as string) || '';
    const isInterAgent = isInterAgentCommunication(m);
    const sourceAgentNodeId = getSourceAgentNodeId(m);

    if (role === 'reasoning') {
      if (!isBlankContent(m.message?.content)) {
        prepared.push({
          type: 'reasoning',
          message: m,
          id: `reasoning-${m.id || m.createdAt}`,
          nodeId: m.nodeId,
          createdAt: m.createdAt,
          inCommunicationExec: isInterAgent,
          sourceAgentNodeId,
        });
      }
      i++;
      continue;
    }

    if (role === 'system') {
      prepared.push({
        type: 'system',
        message: m,
        id: `system-${m.id || m.createdAt}`,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        inCommunicationExec: isInterAgent,
        sourceAgentNodeId,
      });
      i++;
      continue;
    }

    const messageToolCalls = getMessageValue<ToolCall[]>(
      m.message,
      'toolCalls',
    );
    if (role === 'ai' && messageToolCalls && messageToolCalls.length > 0) {
      const hasNonBlankContent = !isBlankContent(m.message?.content);

      // Check whether any tool call in this AI message is communication_exec.
      // If so, the AI text content will be folded INTO the communication block
      // instead of being emitted as a separate chat message.
      const hasCommToolCall = messageToolCalls.some(
        (tc) =>
          (tc.name || tc.function?.name) === 'communication_exec' &&
          tc.id &&
          communicationToolCallIds.has(tc.id),
      );

      if (hasNonBlankContent && !hasCommToolCall) {
        prepared.push({
          type: 'chat',
          message: m,
          id: `chat-${m.id || m.createdAt}`,
          nodeId: m.nodeId,
          createdAt: m.createdAt,
          inCommunicationExec: isInterAgent,
          sourceAgentNodeId,
          // Mark as tool-call content so it renders inside the working block
          // rather than as a standalone chat bubble.
          isToolCallContent: true,
        });
      }

      const followingTools: ThreadMessageDto[] = [];
      let j = i + 1;
      while (
        j < msgs.length &&
        isToolLikeRole(msgs[j].message?.role as string)
      ) {
        followingTools.push(msgs[j]);
        j++;
      }

      for (let idx = 0; idx < messageToolCalls.length; idx++) {
        const tc = messageToolCalls[idx];
        const name = tc.name || tc.function?.name || 'tool';
        const callTitle =
          (tc.title && tc.title.trim().length > 0 ? tc.title : undefined) ??
          (tc.__title && tc.__title.trim().length > 0
            ? tc.__title
            : undefined) ??
          (tc.function?.title && tc.function.title.trim().length > 0
            ? tc.function.title
            : undefined) ??
          (tc.function?.__title && tc.function.__title.trim().length > 0
            ? tc.function.__title
            : undefined);
        let matched = consumeToolResultById(tc.id);
        if (!matched) {
          matched = followingTools.find(
            (tm) => getMessageString(tm.message, 'toolCallId') === tc.id,
          );
          if (matched) {
            markToolCallConsumed(
              tc.id || getMessageString(matched.message, 'toolCallId'),
            );
            markToolMessageConsumed(matched);
          }
        }
        const resultContent = matched?.message?.content;
        const toolArgs = tc.function?.arguments ?? tc.args;
        const toolCallRunId =
          getMessageRunId(m.message) ?? getMessageRunId(matched?.message);

        // Subagent tool call → emit a 'subagent' prepared message
        const isSubagentTool =
          name === 'subagents_run_task' &&
          tc.id &&
          subagentInnerByToolCallId.has(tc.id);
        if (isSubagentTool) {
          const innerRawMessages = subagentInnerByToolCallId.get(tc.id!) ?? [];
          const innerPrepared = prepareReadyMessages(innerRawMessages, options);

          const resultObj = isPlainObject(resultContent)
            ? (resultContent as Record<string, unknown>)
            : typeof resultContent === 'string'
              ? (parseJsonSafe(resultContent) as Record<string, unknown> | null)
              : null;
          const statistics =
            (resultObj?.statistics as SubagentStatistics) ?? undefined;
          const resultText =
            typeof resultObj?.result === 'string'
              ? resultObj.result
              : undefined;
          const errorText =
            typeof resultObj?.error === 'string' ? resultObj.error : undefined;

          const parsedArgs = argsToObject(toolArgs);
          const taskDescription =
            typeof parsedArgs?.task === 'string'
              ? parsedArgs.task
              : typeof parsedArgs?.prompt === 'string'
                ? (parsedArgs.prompt as string)
                : undefined;
          const purpose =
            typeof parsedArgs?.purpose === 'string'
              ? parsedArgs.purpose
              : undefined;
          const agentId =
            typeof parsedArgs?.agentId === 'string'
              ? parsedArgs.agentId
              : undefined;

          const model = extractSubagentModel(innerRawMessages);

          prepared.push({
            type: 'subagent',
            toolCallId: tc.id!,
            purpose,
            taskDescription,
            agentId,
            innerMessages: innerPrepared,
            statistics,
            resultText,
            errorText,
            model,
            status: matched
              ? 'executed'
              : allowCallingIndicators && isLatestRun(toolCallRunId)
                ? 'calling'
                : 'stopped',
            id: `subagent-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
            nodeId: matched?.nodeId ?? m.nodeId,
            createdAt: m.createdAt,
            inCommunicationExec: isInterAgent,
            sourceAgentNodeId,
          });
          continue;
        }

        // Communication tool call → emit a 'communication' prepared message
        const isCommTool =
          name === 'communication_exec' &&
          tc.id &&
          communicationToolCallIds.has(tc.id);
        if (isCommTool) {
          const innerRawMessages = commInnerByToolCallId.get(tc.id!) ?? [];
          const innerPrepared = prepareReadyMessages(innerRawMessages, options);
          const instructionMsg = commInstructionByToolCallId.get(tc.id!);

          const commResultObj = isPlainObject(resultContent)
            ? (resultContent as Record<string, unknown>)
            : typeof resultContent === 'string'
              ? (parseJsonSafe(resultContent) as Record<string, unknown> | null)
              : null;
          const commResultText =
            typeof commResultObj?.result === 'string'
              ? commResultObj.result
              : typeof commResultObj?.message === 'string'
                ? commResultObj.message
                : undefined;
          const commErrorText =
            typeof commResultObj?.error === 'string'
              ? commResultObj.error
              : undefined;

          const parsedArgs = argsToObject(toolArgs);
          const targetNodeId =
            typeof parsedArgs?.targetNodeId === 'string'
              ? parsedArgs.targetNodeId
              : undefined;
          const targetAgentName =
            commToolCallAgentName.get(tc.id!) ??
            (typeof parsedArgs?.agent === 'string'
              ? (parsedArgs.agent as string)
              : undefined);

          const commModel = extractSubagentModel(innerRawMessages);

          // Pass the parent AI message so its text content can be shown
          // as the first item inside the communication block.
          const parentHasContent = !isBlankContent(m.message?.content);

          prepared.push({
            type: 'communication',
            toolCallId: tc.id!,
            targetNodeId,
            targetAgentName,
            parentMessage: parentHasContent ? m : undefined,
            instructionMessage: instructionMsg,
            innerMessages: innerPrepared,
            resultText: commResultText,
            errorText: commErrorText,
            model: commModel,
            status: matched
              ? 'executed'
              : allowCallingIndicators && isLatestRun(toolCallRunId)
                ? 'calling'
                : 'stopped',
            id: `comm-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
            nodeId: matched?.nodeId ?? m.nodeId,
            createdAt: m.createdAt,
            sourceAgentNodeId,
          });
          continue;
        }

        // Regular tool call
        const shellCmdFromArgs = extractShellCommandFromArgs(toolArgs);
        const resultObj = isPlainObject(resultContent)
          ? (resultContent as ShellResult)
          : null;
        const shellCommand = shellCmdFromArgs || resultObj?.command;
        const isShell = (name || '').toLowerCase() === 'shell';
        const toolOptions = argsToObject(toolArgs) || undefined;
        const matchedTitle = getMessageTitle(matched?.message);
        const effectiveTitle = matchedTitle || callTitle;

        const toolIsInterAgent = isInterAgent;
        const toolSourceAgentNodeId = sourceAgentNodeId;

        prepared.push({
          type: 'tool',
          name: name || 'tool',
          status: matched
            ? 'executed'
            : allowCallingIndicators && isLatestRun(toolCallRunId)
              ? 'calling'
              : 'stopped',
          result: resultContent,
          id: `tool-${tc.id || `${m.id || m.createdAt}-${idx}`}`,
          toolKind: isShell ? 'shell' : 'generic',
          shellCommand,
          toolOptions,
          requestTokenUsage: m.requestTokenUsage,
          requestTokenUsageIn: m.requestTokenUsage,
          requestTokenUsageOut: matched?.requestTokenUsage,
          nodeId: matched?.nodeId ?? m.nodeId,
          createdAt: matched?.createdAt ?? m.createdAt,
          roleLabel: effectiveTitle || name || 'tool',
          title: effectiveTitle,
          inCommunicationExec: toolIsInterAgent,
          sourceAgentNodeId: toolSourceAgentNodeId,
        });
      }

      i = i + 1 + followingTools.length;
      continue;
    }

    if (isToolLikeRole(role)) {
      const toolCallId = getMessageString(m.message, 'toolCallId');
      const messageKey = getToolMessageKey(m);

      if (
        (toolCallId && consumedToolCallIds.has(toolCallId)) ||
        (messageKey && consumedToolMessageKeys.has(messageKey))
      ) {
        i++;
        continue;
      }

      const name = getMessageString(m.message, 'name') || 'tool';

      // Skip communication_exec outputs when input is not in current messages
      if (
        name === 'communication_exec' &&
        toolCallId &&
        !existingToolCallIds.has(toolCallId)
      ) {
        i++;
        continue;
      }

      const title = getMessageTitle(m.message);
      const resultContent = m.message?.content;
      const resultObj = isPlainObject(resultContent)
        ? (resultContent as ShellResult)
        : null;
      const shellCommand = resultObj?.command;
      const isShell = (name || '').toLowerCase() === 'shell';
      const toolOptions = undefined;

      prepared.push({
        type: 'tool',
        name,
        status: 'executed',
        result: resultContent,
        id: `tool-standalone-${m.id || m.createdAt}`,
        toolKind: isShell ? 'shell' : 'generic',
        shellCommand,
        toolOptions,
        requestTokenUsage: m.requestTokenUsage,
        requestTokenUsageOut: m.requestTokenUsage,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        roleLabel: title || name || 'tool',
        title,
        inCommunicationExec: isInterAgent,
        sourceAgentNodeId,
      });
      i++;
      continue;
    }

    if (!isBlankContent(m.message?.content)) {
      prepared.push({
        type: 'chat',
        message: m,
        id: `chat-${m.id || m.createdAt}`,
        nodeId: m.nodeId,
        createdAt: m.createdAt,
        inCommunicationExec: isInterAgent,
        sourceAgentNodeId,
      });
    }
    i++;
  }

  return prepared;
};
