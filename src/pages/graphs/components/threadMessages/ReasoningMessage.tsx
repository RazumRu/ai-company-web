import React, { useEffect, useMemo, useRef, useState } from 'react';
import type { ThreadMessageDto } from '../../../../autogenerated';
import {
  STREAMING_REASONING_FLAG,
  getReasoningIdentifier,
} from '../../../../utils/threadMessages';
import { MarkdownContent } from './MarkdownContent';
import {
  createReasoningPreview,
  formatMessageContent,
  limitConsecutiveNewlines,
} from './messageUtils';

interface ReasoningMessageProps {
  message: ThreadMessageDto;
  isExpanded: boolean;
  onToggle: (id: string) => void;
}

export const ReasoningMessage: React.FC<ReasoningMessageProps> = ({
  message,
  isExpanded,
  onToggle,
}) => {
  const content = limitConsecutiveNewlines(formatMessageContent(message.message?.content));
  const [baseContent, setBaseContent] = useState(content);
  const [animatedChunk, setAnimatedChunk] = useState('');
  const prevContentRef = useRef(content);
  const timeoutRef = useRef<number | null>(null);
  const reasoningId = getReasoningIdentifier(message) ?? message.id;
  const preview = useMemo(() => createReasoningPreview(baseContent), [baseContent]);

  const additionalKwargs = (message.message?.additionalKwargs ?? {}) as Record<string, unknown>;
  const isStreaming = Boolean(additionalKwargs?.[STREAMING_REASONING_FLAG]);

  useEffect(() => {
    const prev = prevContentRef.current;
    if (content === prev) {
      return;
    }

    if (content.startsWith(prev)) {
      const newPart = content.slice(prev.length);
      if (typeof window === 'undefined') {
        setBaseContent(content);
        setAnimatedChunk('');
      } else {
        setBaseContent(prev);
        setAnimatedChunk(newPart);
        if (timeoutRef.current !== null) {
          window.clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = window.setTimeout(() => {
          setBaseContent(content);
          setAnimatedChunk('');
        }, 650);
      }
    } else {
      setBaseContent(content);
      setAnimatedChunk('');
    }

    prevContentRef.current = content;
  }, [content]);

  useEffect(() => {
    return () => {
      if (timeoutRef.current !== null) {
        if (typeof window !== 'undefined') {
          window.clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = null;
      }
    };
  }, []);

  const handleToggle = () => {
    onToggle(reasoningId || '');
  };

  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleToggle();
    }
  };

  const containerClassName = `reasoning-message${
    isStreaming ? ' reasoning-message_streaming' : ''
  }`;

  const collapsedStyle: React.CSSProperties = {
    maxHeight: '6.2em',
    overflow: 'hidden',
    position: 'relative',
    cursor: 'pointer',
    textAlign: 'left',
  };

  const expandedStyle: React.CSSProperties = {
    whiteSpace: 'pre-wrap',
    wordBreak: 'break-word',
    textAlign: 'left',
  };

  return (
    <div
      className={containerClassName}
      role="button"
      tabIndex={0}
      onClick={handleToggle}
      onKeyDown={handleKeyDown}>
      {isExpanded ? (
        <div style={expandedStyle}>
          <MarkdownContent content={baseContent} allowHorizontalScroll={isExpanded} />
          {animatedChunk && (
            <div className="reasoning-message_chunk-appear">
              <MarkdownContent content={animatedChunk} allowHorizontalScroll={isExpanded} />
            </div>
          )}
        </div>
      ) : (
        <div style={collapsedStyle}>
          <MarkdownContent content={preview.text} allowHorizontalScroll={false} />
          <div
            style={{
              position: 'absolute',
              bottom: 0,
              left: 0,
              right: 0,
              height: '24px',
              background: 'linear-gradient(180deg, rgba(255,255,255,0) 0%, #fff 100%)',
              pointerEvents: 'none',
            }}
          />
        </div>
      )}
      <div
        style={{
          marginTop: 2,
          fontSize: 11,
          color: '#9a9a9a',
          fontStyle: 'italic',
        }}>
        {isStreaming ? 'still thinkingâ€¦' : ''}
      </div>
    </div>
  );
};
