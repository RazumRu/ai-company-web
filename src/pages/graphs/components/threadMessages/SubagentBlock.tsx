import { LoadingOutlined } from '@ant-design/icons';
import { Popover, Tag, Typography } from 'antd';
import React, { useMemo } from 'react';

import type { ThreadMessageDtoRequestTokenUsage } from '../../../../autogenerated';
import { StyledSection } from './StyledSection';
import type {
  PreparedMessage,
  SubagentStatistics,
} from './threadMessagesTypes';
import {
  formatRequestTokenCount,
  formatRequestUsdShort,
} from './threadMessagesViewUtils';
import { TokenUsagePopoverIcon } from './TokenUsagePopoverIcon';

const { Text } = Typography;

const HEADER_LABEL_STYLE: React.CSSProperties = {
  fontSize: 12,
  fontWeight: 600,
  color: '#434343',
  flex: 1,
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap',
};

const INNER_AREA_STYLE: React.CSSProperties = {
  overflowX: 'hidden',
  padding: '8px 10px',
  backgroundColor: '#fafafa',
  borderRadius: 6,
  border: '1px solid #f0f0f0',
};

const TAG_STYLE: React.CSSProperties = {
  margin: 0,
  fontSize: 11,
  lineHeight: '18px',
};

const FOOTER_STYLE: React.CSSProperties = {
  display: 'flex',
  flexWrap: 'wrap',
  gap: 10,
  paddingTop: 4,
  fontSize: 11,
  color: '#8c8c8c',
};

export interface SubagentBlockProps {
  purpose?: string;
  taskDescription?: string;
  model?: string;
  status: 'calling' | 'executed' | 'stopped';
  innerMessages: PreparedMessage[];
  statistics?: SubagentStatistics;
  resultText?: string;
  errorText?: string;
  /** Pre-rendered popover content (built via renderToolPopoverContent in the parent). */
  popoverContent?: React.ReactNode;
  renderItem: (item: PreparedMessage, index: number) => React.ReactNode;
}

/**
 * Filter out the last chat message inside the subagent block when it has no
 * tool calls — its content is already surfaced as the `resultText` below the
 * inner messages area, so showing it twice is redundant.
 *
 * Only filters when `resultText` is provided; otherwise the trailing chat is
 * the only place the final AI response is visible.
 */
const filterTrailingChat = (
  messages: PreparedMessage[],
  hasResultText: boolean,
): PreparedMessage[] => {
  if (!hasResultText || messages.length === 0) return messages;
  const last = messages[messages.length - 1];
  if (last.type === 'chat' && !last.isToolCallContent) {
    return messages.slice(0, -1);
  }
  return messages;
};

export const SubagentBlock: React.FC<SubagentBlockProps> = ({
  purpose,
  taskDescription,
  model,
  status,
  innerMessages,
  statistics,
  resultText,
  errorText,
  popoverContent,
  renderItem,
}) => {
  const isCalling = status === 'calling';

  const headerLabel = useMemo(
    () => (purpose ? `Subagent: ${purpose}` : 'Subagent'),
    [purpose],
  );

  const filteredInnerMessages = useMemo(
    () => filterTrailingChat(innerMessages, !!resultText),
    [innerMessages, resultText],
  );

  const isClickable =
    (status === 'executed' || status === 'stopped') && !!popoverContent;

  const headerRow = (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: 6,
        cursor: isClickable ? 'pointer' : undefined,
      }}
      aria-label={
        isClickable ? `View subagent details for ${headerLabel}` : undefined
      }>
      {isCalling && (
        <LoadingOutlined style={{ fontSize: 11, color: '#595959' }} />
      )}
      <Text style={HEADER_LABEL_STYLE}>{headerLabel}</Text>
      {status === 'executed' && !errorText && (
        <Tag color="success" style={TAG_STYLE}>
          done
        </Tag>
      )}
      {status === 'executed' && errorText && (
        <Tag color="error" style={TAG_STYLE}>
          error
        </Tag>
      )}
      {status === 'stopped' && <Tag style={TAG_STYLE}>stopped</Tag>}
      {status === 'calling' && (
        <Tag color="processing" style={TAG_STYLE}>
          running
        </Tag>
      )}
    </div>
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        gap: 6,
        width: '100%',
      }}>
      {/* Header row — wrapped in Popover for click-to-view input/output */}
      {isClickable ? (
        <Popover
          content={popoverContent}
          trigger={['click']}
          placement="topLeft">
          {headerRow}
        </Popover>
      ) : (
        headerRow
      )}

      {taskDescription && (
        <StyledSection variant="task" label="Task" content={taskDescription} />
      )}

      {/* Inner messages area */}
      {(filteredInnerMessages.length > 0 || isCalling) && (
        <div style={INNER_AREA_STYLE}>
          {filteredInnerMessages.length === 0 && isCalling && (
            <Text
              type="secondary"
              style={{ fontSize: 12, fontStyle: 'italic' }}>
              Subagent is working...
            </Text>
          )}
          {filteredInnerMessages.map((item, idx) => (
            <div key={item.id || idx} style={{ marginBottom: 6 }}>
              {renderItem(item, idx)}
            </div>
          ))}
        </div>
      )}

      {errorText && (
        <StyledSection variant="error" label="Error" content={errorText} />
      )}

      {resultText && !errorText && (
        <StyledSection variant="result" label="Result" content={resultText} />
      )}

      {/* Statistics footer */}
      <StatisticsFooter statistics={statistics} model={model} />
    </div>
  );
};

const StatisticsFooter: React.FC<{
  statistics?: SubagentStatistics;
  model?: string;
}> = ({ statistics, model }) => {
  if (!statistics && !model) return null;

  const items: { label: string; value: string }[] = [];

  if (statistics?.usage?.totalTokens) {
    items.push({
      label: 'Tokens',
      value: formatRequestTokenCount(statistics.usage.totalTokens),
    });
  }
  const totalPrice = statistics?.usage?.totalPrice ?? statistics?.totalPrice;
  if (typeof totalPrice === 'number' && totalPrice > 0) {
    items.push({
      label: 'Cost',
      value: formatRequestUsdShort(totalPrice),
    });
  }
  if (typeof statistics?.toolCallsMade === 'number') {
    items.push({ label: 'Tools', value: String(statistics.toolCallsMade) });
  }
  if (model) {
    items.push({ label: 'Model', value: model });
  }

  if (items.length === 0) return null;

  // Build a token-usage object compatible with TokenUsagePopoverIcon
  const tokenUsage: ThreadMessageDtoRequestTokenUsage | undefined = statistics
    ?.usage?.totalTokens
    ? (statistics.usage as unknown as ThreadMessageDtoRequestTokenUsage)
    : undefined;

  return (
    <div style={FOOTER_STYLE}>
      {items.map((item) => (
        <span key={item.label}>
          <Text type="secondary" style={{ fontSize: 11, fontWeight: 600 }}>
            {item.label}:
          </Text>{' '}
          <Text type="secondary" style={{ fontSize: 11 }}>
            {item.value}
          </Text>
        </span>
      ))}
      {tokenUsage && <TokenUsagePopoverIcon requestTokenUsage={tokenUsage} />}
    </div>
  );
};

SubagentBlock.displayName = 'SubagentBlock';
