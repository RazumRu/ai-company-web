import { LoadingOutlined } from '@ant-design/icons';
import { Popover, Typography } from 'antd';
import React, { useMemo } from 'react';

import type { ThreadMessageDtoRequestTokenUsage } from '../../../../autogenerated';
import { HEADER_LABEL_STYLE, INNER_AREA_STYLE } from './blockStyles';
import { StatisticsFooter } from './StatisticsFooter';
import { StatusTag } from './StatusTag';
import { StyledSection } from './StyledSection';
import type {
  PreparedMessage,
  SubagentStatistics,
} from './threadMessagesTypes';

const { Text } = Typography;

export interface SubagentBlockProps {
  purpose?: string;
  taskDescription?: string;
  model?: string;
  status: 'calling' | 'executed' | 'stopped';
  innerMessages: PreparedMessage[];
  statistics?: SubagentStatistics;
  resultText?: string;
  errorText?: string;
  /** Pre-rendered popover content (built via renderToolPopoverContent in the parent). */
  popoverContent?: React.ReactNode;
  /** LLM request-level token usage (input message that triggered the tool call). */
  requestTokenUsageIn?: ThreadMessageDtoRequestTokenUsage | null;
  /** LLM request-level token usage (tool result message). */
  requestTokenUsageOut?: ThreadMessageDtoRequestTokenUsage | null;
  renderItem: (item: PreparedMessage, index: number) => React.ReactNode;
}

/**
 * Filter out the last chat message inside the subagent block when it has no
 * tool calls — its content is already surfaced as the `resultText` below the
 * inner messages area, so showing it twice is redundant.
 *
 * Only filters when `resultText` is provided; otherwise the trailing chat is
 * the only place the final AI response is visible.
 */
const filterTrailingChat = (
  messages: PreparedMessage[],
  hasResultText: boolean,
): PreparedMessage[] => {
  if (!hasResultText || messages.length === 0) return messages;
  const last = messages[messages.length - 1];
  if (last.type === 'chat' && !last.isToolCallContent) {
    return messages.slice(0, -1);
  }
  return messages;
};

export const SubagentBlock: React.FC<SubagentBlockProps> = ({
  purpose,
  taskDescription,
  model,
  status,
  innerMessages,
  statistics,
  resultText,
  errorText,
  popoverContent,
  requestTokenUsageIn,
  requestTokenUsageOut,
  renderItem,
}) => {
  const isCalling = status === 'calling';

  const headerLabel = purpose ? `Subagent: ${purpose}` : 'Subagent';

  const filteredInnerMessages = useMemo(
    () => filterTrailingChat(innerMessages, !!resultText),
    [innerMessages, resultText],
  );

  const isClickable =
    (status === 'executed' || status === 'stopped') && !!popoverContent;

  const headerRow = (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: 6,
        cursor: isClickable ? 'pointer' : undefined,
      }}
      aria-label={
        isClickable ? `View subagent details for ${headerLabel}` : undefined
      }>
      {isCalling && (
        <LoadingOutlined style={{ fontSize: 11, color: '#595959' }} />
      )}
      <Text style={HEADER_LABEL_STYLE}>{headerLabel}</Text>
      <StatusTag status={status} hasError={!!errorText} />
    </div>
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        gap: 6,
        width: '100%',
      }}>
      {/* Header row — wrapped in Popover for click-to-view input/output */}
      {isClickable ? (
        <Popover
          content={popoverContent}
          trigger={['click']}
          placement="topLeft">
          {headerRow}
        </Popover>
      ) : (
        headerRow
      )}

      {taskDescription && (
        <StyledSection variant="task" label="Task" content={taskDescription} />
      )}

      {/* Inner messages area */}
      {(filteredInnerMessages.length > 0 || isCalling) && (
        <div style={INNER_AREA_STYLE}>
          {filteredInnerMessages.length === 0 && isCalling && (
            <Text
              type="secondary"
              style={{ fontSize: 12, fontStyle: 'italic' }}>
              Subagent is working...
            </Text>
          )}
          {filteredInnerMessages.map((item, idx) => (
            <div key={item.id || idx} style={{ marginBottom: 6 }}>
              {renderItem(item, idx)}
            </div>
          ))}
        </div>
      )}

      {errorText && (
        <StyledSection variant="error" label="Error" content={errorText} />
      )}

      {resultText && !errorText && (
        <StyledSection variant="result" label="Result" content={resultText} />
      )}

      {/* Statistics footer */}
      <StatisticsFooter
        statistics={statistics}
        model={model}
        requestTokenUsageIn={requestTokenUsageIn}
        requestTokenUsageOut={requestTokenUsageOut}
      />
    </div>
  );
};

SubagentBlock.displayName = 'SubagentBlock';
