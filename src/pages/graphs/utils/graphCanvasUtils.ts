import type { TemplateDto } from '../../../autogenerated';
import type { GraphEdge, GraphNode, GraphNodeData } from '../types';

const slug = (value: string | number | undefined | null): string =>
  String(value ?? '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-');

export const makeHandleId = (
  dir: 'source' | 'target',
  rule: ConnectionRule,
): string => `${dir}-${rule.type}-${slug(rule.value)}`;

export type HandleDirection = {
  sourceHandle?: string;
  targetHandle?: string;
};

export interface ConnectionPreview {
  fromHandleType: 'source' | 'target';
  handleId: string;
  rule?: ConnectionRule;
  template?: TemplateDto;
}

export interface ConnectionRule {
  type: 'kind' | 'template';
  value: string;
  required?: boolean;
  multiple?: boolean;
}

export const createEdge = (
  source: string,
  target: string,
  sourceHandle?: string,
  targetHandle?: string,
  label?: string,
): GraphEdge => {
  // Generate deterministic ID based on connection
  // This ensures the same connection always gets the same ID
  const idParts = [source, target];
  if (sourceHandle) idParts.push(sourceHandle);
  if (targetHandle) idParts.push(targetHandle);
  const deterministicId = `edge-${idParts.join('-')}`;

  return {
    id: deterministicId,
    source,
    target,
    sourceHandle,
    targetHandle,
    label,
  };
};

export const resolveHandlesForNodes = (
  sourceNode: GraphNode | undefined,
  targetNode: GraphNode | undefined,
  templates: TemplateDto[],
): HandleDirection => {
  if (!sourceNode || !targetNode) {
    return {};
  }

  const sourceTemplate = templates.find(
    (template) =>
      template.id === (sourceNode.data as unknown as GraphNodeData).template,
  );
  const targetTemplate = templates.find(
    (template) =>
      template.id === (targetNode.data as unknown as GraphNodeData).template,
  );

  if (!sourceTemplate || !targetTemplate) {
    return {};
  }

  const isRule = (rule: unknown): rule is ConnectionRule =>
    (!!rule &&
      typeof rule === 'object' &&
      (rule as { type?: unknown }).type === 'kind') ||
    (rule as { type?: unknown }).type === 'template';

  const targetInputs: ConnectionRule[] = Array.isArray(targetTemplate.inputs)
    ? (targetTemplate.inputs.filter((rule) => isRule(rule)) as ConnectionRule[])
    : [];
  const sourceOutputs: ConnectionRule[] = Array.isArray(sourceTemplate.outputs)
    ? (sourceTemplate.outputs.filter((rule) =>
        isRule(rule),
      ) as ConnectionRule[])
    : [];

  const targetByTemplate = targetInputs.find(
    (rule) => rule.type === 'template' && rule.value === sourceTemplate.id,
  );
  const targetByKind = targetInputs.find(
    (rule) =>
      rule.type === 'kind' &&
      slug(rule.value) ===
        slug((sourceTemplate as TemplateDto & { kind?: string }).kind),
  );
  const targetRule = targetByTemplate || targetByKind;

  const sourceByTemplate = sourceOutputs.find(
    (rule) => rule.type === 'template' && rule.value === targetTemplate.id,
  );
  const sourceByKind = sourceOutputs.find(
    (rule) =>
      rule.type === 'kind' &&
      slug(rule.value) ===
        slug((targetTemplate as TemplateDto & { kind?: string }).kind),
  );
  const sourceRule = sourceByTemplate || sourceByKind;

  const result: HandleDirection = {};
  if (targetRule) {
    result.targetHandle = makeHandleId('target', targetRule);
  } else if (targetInputs.length > 0) {
    result.targetHandle = makeHandleId('target', targetInputs[0]);
  }

  if (sourceRule) {
    result.sourceHandle = makeHandleId('source', sourceRule);
  } else if (sourceOutputs.length > 0) {
    result.sourceHandle = makeHandleId('source', sourceOutputs[0]);
  } else {
    result.sourceHandle = 'source-out';
  }

  return result;
};
