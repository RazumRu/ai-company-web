import { message as antdMessage } from 'antd';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useLocation, useNavigate } from 'react-router';

import { graphsApi, templatesApi, threadsApi } from '../../../api';
import type { GraphDto, TemplateDto, ThreadDto } from '../../../autogenerated';
import {
  GetThreadsStatusesEnum,
  GraphDtoStatusEnum,
} from '../../../autogenerated';
import { useWebSocket } from '../../../hooks/useWebSocket';
import { extractApiErrorMessage } from '../../../utils/errors';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
  type TriggerNodeInfo,
} from '../../../utils/graphThreads';
import type {
  DraftThread,
  GraphCacheEntry,
  ThreadStatusTabKey,
} from '../types';
import {
  isDraftThreadId,
  isResolvedThreadStatus,
  isValidationExceptionsError,
  THREADS_PAGE_SIZE,
} from '../utils/chatsPageUtils';

export const useChatsThreadList = () => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [threadsOffset, setThreadsOffset] = useState(0);
  const [threadsHasMore, setThreadsHasMore] = useState(true);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadsLoadingMore, setThreadsLoadingMore] = useState(false);

  const [threadStatusTab, setThreadStatusTab] =
    useState<ThreadStatusTabKey>('all');
  const [resolvedStatusesFilterSupported, setResolvedStatusesFilterSupported] =
    useState(true);

  const [selectedThreadId, setSelectedThreadId] = useState<string | undefined>(
    undefined,
  );
  const [selectedThreadShadow, setSelectedThreadShadow] =
    useState<ThreadDto | null>(null);
  const [selectedAgentNodeId, setSelectedAgentNodeId] = useState<string | null>(
    null,
  );
  const [draftThread, setDraftThread] = useState<DraftThread | null>(null);

  const [graphCache, setGraphCache] = useState<Record<string, GraphCacheEntry>>(
    {},
  );
  const graphCacheRef = useRef(graphCache);
  graphCacheRef.current = graphCache;
  const [templatesById, setTemplatesById] = useState<
    Record<string, TemplateDto>
  >({});
  const [templatesLoading, setTemplatesLoading] = useState(false);

  const [triggerNodesForSelectedThread, setTriggerNodesForSelectedThread] =
    useState<TriggerNodeInfo[]>([]);

  const [graphPickerOpen, setGraphPickerOpen] = useState(false);
  const [graphPickerLoading, setGraphPickerLoading] = useState(false);
  const [graphPickerGraphs, setGraphPickerGraphs] = useState<GraphDto[]>([]);
  const [graphPickerError, setGraphPickerError] = useState<string | null>(null);

  const threadsContainerRef = useRef<HTMLDivElement | null>(null);
  const pendingThreadSelectionRef = useRef<string | null>(null);
  const subscribedGraphsRef = useRef<Set<string>>(new Set());
  const threadsRef = useRef<ThreadDto[]>([]);
  const threadsHasMoreRef = useRef(threadsHasMore);
  threadsHasMoreRef.current = threadsHasMore;
  const threadsLoadingRef = useRef(threadsLoading);
  threadsLoadingRef.current = threadsLoading;
  const threadsLoadingMoreRef = useRef(threadsLoadingMore);
  threadsLoadingMoreRef.current = threadsLoadingMore;
  const threadsOffsetRef = useRef(threadsOffset);
  threadsOffsetRef.current = threadsOffset;

  const { subscribeToGraph, unsubscribeFromGraph } = useWebSocket();
  const location = useLocation();
  const navigate = useNavigate();

  const [graphFilterId, setGraphFilterId] = useState<string | undefined>(() => {
    const params = new URLSearchParams(location.search);
    return params.get('graphId') ?? undefined;
  });

  const getThreadTimestamp = useCallback((thread: ThreadDto) => {
    const value = thread.updatedAt ?? thread.createdAt;
    return value ? Date.parse(value) : Number.NaN;
  }, []);

  const sortThreadsByTimestampDesc = useCallback(
    (list: ThreadDto[]) => {
      return [...list].sort((a, b) => {
        const bTs = getThreadTimestamp(b);
        const aTs = getThreadTimestamp(a);
        const safeBTs = Number.isFinite(bTs) ? bTs : -Infinity;
        const safeATs = Number.isFinite(aTs) ? aTs : -Infinity;
        if (safeBTs !== safeATs) {
          return safeBTs - safeATs;
        }
        return (b.createdAt ?? '').localeCompare(a.createdAt ?? '');
      });
    },
    [getThreadTimestamp],
  );

  // --- URL & filter sync ---

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const incomingGraphId = params.get('graphId') ?? undefined;
    setGraphFilterId((prev) =>
      prev === incomingGraphId ? prev : incomingGraphId,
    );
  }, [location.search]);

  useEffect(() => {
    setThreads([]);
    setThreadsOffset(0);
    setThreadsHasMore(true);
    setSelectedThreadId(undefined);
    setSelectedThreadShadow(null);
    setDraftThread(null);
  }, [graphFilterId]);

  // --- Selected thread memo ---

  const selectedThread = useMemo(() => {
    if (!selectedThreadId) return undefined;
    if (draftThread && draftThread.id === selectedThreadId) {
      return draftThread;
    }
    return (
      threads.find((thread) => thread.id === selectedThreadId) ??
      (selectedThreadShadow?.id === selectedThreadId
        ? selectedThreadShadow
        : undefined)
    );
  }, [threads, selectedThreadId, draftThread, selectedThreadShadow]);

  useEffect(() => {
    if (!selectedThreadId || isDraftThreadId(selectedThreadId)) {
      setSelectedThreadShadow(null);
      return;
    }

    const inList = threads.find((thread) => thread.id === selectedThreadId);
    if (inList) {
      setSelectedThreadShadow(inList);
      return;
    }

    let mounted = true;
    const fetchSelected = async () => {
      try {
        const res = await threadsApi.getThreadById(selectedThreadId);
        if (!mounted) return;
        if (res.data) {
          setSelectedThreadShadow(res.data);
        }
      } catch (error) {
        console.warn('Failed to refresh selected thread', error);
      }
    };

    void fetchSelected();
    return () => {
      mounted = false;
    };
  }, [selectedThreadId, threads]);

  // --- Thread status tabs & filtering ---

  const threadStatusesFilter = useMemo<
    GetThreadsStatusesEnum[] | undefined
  >(() => {
    if (threadStatusTab === 'all') return undefined;
    if (threadStatusTab === 'open') {
      return [
        GetThreadsStatusesEnum.Running,
        GetThreadsStatusesEnum.NeedMoreInfo,
        GetThreadsStatusesEnum.Stopped,
      ];
    }
    if (!resolvedStatusesFilterSupported) return undefined;
    return [GetThreadsStatusesEnum.Done];
  }, [threadStatusTab, resolvedStatusesFilterSupported]);

  const filteredThreads = useMemo(() => {
    if (threadStatusTab === 'all') {
      return threads;
    }
    const matchesTab =
      threadStatusTab === 'resolved'
        ? (thread: ThreadDto) => isResolvedThreadStatus(thread.status)
        : (thread: ThreadDto) => !isResolvedThreadStatus(thread.status);

    const base = threads.filter(matchesTab);

    if (selectedThreadId && !isDraftThreadId(selectedThreadId)) {
      const selected =
        threads.find((thread) => thread.id === selectedThreadId) ??
        (selectedThreadShadow?.id === selectedThreadId
          ? selectedThreadShadow
          : null);
      if (selected && !base.some((thread) => thread.id === selected.id)) {
        return [selected, ...base];
      }
    }

    return base;
  }, [threadStatusTab, threads, selectedThreadId, selectedThreadShadow]);

  const shouldShowDraftThread = Boolean(draftThread);

  const handleThreadStatusTabChange = useCallback(
    (key: string) => {
      const nextTab = key as ThreadStatusTabKey;
      setThreadStatusTab(nextTab);
      setThreads([]);
      setThreadsOffset(0);
      setThreadsHasMore(true);
      setSelectedThreadId((prev) => {
        if (!draftThread) return undefined;
        if (prev !== draftThread.id) return undefined;
        return prev;
      });
    },
    [draftThread],
  );

  // --- Selection side-effects ---

  useEffect(() => {
    if (!selectedThreadId) return;
    if (draftThread && draftThread.id === selectedThreadId) {
      if (!shouldShowDraftThread) {
        setSelectedThreadId(undefined);
      }
    }
  }, [draftThread, selectedThreadId, shouldShowDraftThread]);

  useEffect(() => {
    setSelectedAgentNodeId(null);
  }, [selectedThreadId]);

  // --- Trigger nodes for selected thread ---

  useEffect(() => {
    if (!selectedThread) {
      setTriggerNodesForSelectedThread([]);
      return;
    }
    const graphEntry = graphCache[selectedThread.graphId];
    if (graphEntry) {
      setTriggerNodesForSelectedThread(graphEntry.triggerNodes ?? []);
    } else {
      setTriggerNodesForSelectedThread([]);
    }
  }, [selectedThread, graphCache]);

  // --- Load templates once ---

  useEffect(() => {
    let mounted = true;
    const fetchTemplates = async () => {
      try {
        setTemplatesLoading(true);
        const response = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templateList = response.data || [];
        const map = templateList.reduce<Record<string, TemplateDto>>(
          (acc, template) => {
            acc[template.id] = template;
            return acc;
          },
          {},
        );
        setTemplatesById(map);
      } catch (error) {
        console.error('Error loading templates', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load templates metadata',
        );
        antdMessage.error(errorMessage);
      } finally {
        if (mounted) setTemplatesLoading(false);
      }
    };

    void fetchTemplates();
    return () => {
      mounted = false;
    };
  }, []);

  // --- Cleanup WS subscriptions ---

  useEffect(() => {
    const subscribedGraphs = subscribedGraphsRef.current;
    return () => {
      subscribedGraphs.forEach((graphId) => {
        unsubscribeFromGraph(graphId);
      });
      subscribedGraphs.clear();
    };
  }, [unsubscribeFromGraph]);

  // --- Graph picker ---

  useEffect(() => {
    if (!graphPickerOpen) return;
    let mounted = true;
    const loadGraphs = async () => {
      try {
        setGraphPickerLoading(true);
        setGraphPickerError(null);
        const response = await graphsApi.getAllGraphs();
        if (!mounted) return;
        setGraphPickerGraphs(response.data || []);
      } catch (error) {
        if (!mounted) return;
        console.error('Error loading graphs for picker', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load graphs',
        );
        setGraphPickerError(errorMessage);
        antdMessage.error(errorMessage);
      } finally {
        if (mounted) setGraphPickerLoading(false);
      }
    };

    void loadGraphs();
    return () => {
      mounted = false;
    };
  }, [graphPickerOpen]);

  // --- Graph cache management ---

  const templatesByIdRef = useRef(templatesById);
  templatesByIdRef.current = templatesById;

  const ensureGraphsLoaded = useCallback(
    async (threadsToCheck: (ThreadDto | DraftThread)[]) => {
      if (!threadsToCheck.length) return;
      const uniqueGraphIds = Array.from(
        new Set(threadsToCheck.map((thread) => thread.graphId)),
      );

      uniqueGraphIds.forEach((graphId) => {
        if (!subscribedGraphsRef.current.has(graphId)) {
          subscribeToGraph(graphId);
          subscribedGraphsRef.current.add(graphId);
        }
      });

      const missingGraphIds = uniqueGraphIds.filter(
        (graphId) => !graphCacheRef.current[graphId],
      );
      if (!missingGraphIds.length) return;

      try {
        const response = await graphsApi.getAllGraphs(missingGraphIds);
        const graphs = response.data || [];

        setGraphCache((prev) => {
          const next = { ...prev };
          graphs.forEach((graph) => {
            next[graph.id] = {
              graph,
              triggerNodes: buildTriggerNodes(graph, templatesByIdRef.current),
              nodeDisplayNames: buildNodeDisplayNames(graph),
            };
          });
          return next;
        });
      } catch (error) {
        console.error('Error loading graph metadata', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load graph metadata for threads',
        );
        antdMessage.error(errorMessage);
      }
    },
    [subscribeToGraph],
  );

  useEffect(() => {
    if (!selectedThread) return;

    const graphEntry = graphCache[selectedThread.graphId];

    if (!graphEntry) {
      void ensureGraphsLoaded([selectedThread]);
      return;
    }

    if (
      graphEntry.triggerNodes.length === 0 &&
      Object.keys(templatesById).length > 0
    ) {
      const updatedTriggers = buildTriggerNodes(
        graphEntry.graph,
        templatesById,
      );
      if (updatedTriggers.length > 0) {
        setGraphCache((prev) => ({
          ...prev,
          [selectedThread.graphId]: {
            ...graphEntry,
            triggerNodes: updatedTriggers,
          },
        }));
      }
    }
  }, [selectedThread, graphCache, ensureGraphsLoaded, templatesById]);

  useEffect(() => {
    if (!Object.keys(templatesById).length) return;
    setGraphCache((prev) => {
      const nextEntries: Record<string, GraphCacheEntry> = {};
      let changed = false;
      Object.entries(prev).forEach(([graphId, entry]) => {
        const updatedTriggers = buildTriggerNodes(entry.graph, templatesById);
        nextEntries[graphId] = {
          graph: entry.graph,
          triggerNodes: updatedTriggers,
          nodeDisplayNames: entry.nodeDisplayNames,
        };
        if (updatedTriggers.length !== entry.triggerNodes.length) {
          changed = true;
        }
      });
      return changed ? nextEntries : prev;
    });
  }, [templatesById]);

  // --- Load threads ---

  const loadThreads = useCallback(
    async (options?: { append?: boolean }) => {
      const requestedGraphId = graphFilterId;
      const isAppend = options?.append ?? false;
      if (isAppend) {
        if (!threadsHasMoreRef.current || threadsLoadingMoreRef.current) return;
        setThreadsLoadingMore(true);
      } else if (threadsLoadingRef.current) {
        return;
      } else {
        setThreadsLoading(true);
      }

      try {
        const offset = isAppend ? threadsOffsetRef.current : 0;
        let response;

        try {
          response = await threadsApi.getThreads(
            requestedGraphId,
            threadStatusesFilter,
            THREADS_PAGE_SIZE,
            offset,
          );
        } catch (error) {
          const shouldRetryWithoutStatuses =
            threadStatusTab === 'resolved' &&
            resolvedStatusesFilterSupported &&
            threadStatusesFilter?.length === 1 &&
            threadStatusesFilter[0] === GetThreadsStatusesEnum.Done &&
            isValidationExceptionsError(error);

          if (!shouldRetryWithoutStatuses) {
            throw error;
          }

          setResolvedStatusesFilterSupported(false);
          response = await threadsApi.getThreads(
            requestedGraphId,
            undefined,
            THREADS_PAGE_SIZE,
            offset,
          );
        }

        const fetched = response.data || [];
        const filteredFetched = requestedGraphId
          ? fetched.filter((thread) => thread.graphId === requestedGraphId)
          : fetched;

        if (graphFilterId !== requestedGraphId) return;

        setThreads((prev) => {
          const base =
            requestedGraphId === undefined
              ? prev
              : prev.filter((thread) => thread.graphId === requestedGraphId);
          if (!isAppend) {
            return sortThreadsByTimestampDesc(filteredFetched);
          }
          const existingIds = new Set(base.map((thread) => thread.id));
          const merged = [
            ...base,
            ...filteredFetched.filter((thread) => !existingIds.has(thread.id)),
          ];
          return sortThreadsByTimestampDesc(merged);
        });

        setThreadsOffset((current) =>
          isAppend ? current + fetched.length : fetched.length,
        );
        setThreadsHasMore(fetched.length === THREADS_PAGE_SIZE);

        void ensureGraphsLoaded(filteredFetched);
      } catch (error) {
        console.error('Error loading threads', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load threads list',
        );
        antdMessage.error(errorMessage);
        setThreadsHasMore(false);
      } finally {
        if (isAppend) {
          setThreadsLoadingMore(false);
        } else {
          setThreadsLoading(false);
        }
      }
    },
    [
      ensureGraphsLoaded,
      sortThreadsByTimestampDesc,
      graphFilterId,
      threadStatusesFilter,
      threadStatusTab,
      resolvedStatusesFilterSupported,
    ],
  );

  const loadThreadsRef = useRef(loadThreads);
  useEffect(() => {
    loadThreadsRef.current = loadThreads;
  }, [loadThreads]);

  useEffect(() => {
    void loadThreadsRef.current();
  }, [graphFilterId, threadStatusTab]);

  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);

  const handleRefreshThreads = useCallback(() => {
    void loadThreads();
  }, [loadThreads]);

  const handleThreadsScroll = useCallback(() => {
    const el = threadsContainerRef.current;
    if (!el) return;
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    if (
      nearBottom &&
      threadsHasMoreRef.current &&
      !threadsLoadingMoreRef.current &&
      !threadsLoadingRef.current
    ) {
      void loadThreads({ append: true });
    }
  }, [loadThreads]);

  // --- Derived state ---

  const selectedGraphStatus = selectedThread
    ? graphCache[selectedThread.graphId]?.graph.status
    : undefined;
  const graphIsRunning = selectedGraphStatus === GraphDtoStatusEnum.Running;
  const selectedThreadIsDraft =
    selectedThread !== undefined &&
    'isDraft' in selectedThread &&
    selectedThread.isDraft === true;

  const filteredGraphLabel = useMemo(() => {
    if (!graphFilterId) return undefined;
    const graphName = graphCache[graphFilterId]?.graph.name;
    if (graphName && graphName.trim().length > 0) return graphName;
    if (graphFilterId.length <= 10) return graphFilterId;
    return `â€¦${graphFilterId.slice(-6)}`;
  }, [graphFilterId, graphCache]);

  // --- Thread CRUD ---

  const handleClearGraphFilter = useCallback(() => {
    const params = new URLSearchParams(location.search);
    params.delete('graphId');
    navigate(
      {
        pathname: location.pathname,
        search: params.toString() ? `?${params.toString()}` : '',
      },
      { replace: true },
    );
  }, [location.pathname, location.search, navigate]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          setSelectedThreadId(undefined);
        }
        antdMessage.success('Thread deleted successfully');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to delete thread',
        );
        antdMessage.error(errorMessage);
      }
    },
    [selectedThreadId],
  );

  const createDraftThreadForGraph = useCallback(
    (draftGraphId: string) => {
      const scrollThreadsToTop = () => {
        const el = threadsContainerRef.current;
        if (!el) return;
        el.scrollTo({ top: 0, behavior: 'smooth' });
      };

      if (draftThread && draftThread.graphId === draftGraphId) {
        setSelectedThreadId(draftThread.id);
        requestAnimationFrame(scrollThreadsToTop);
        return;
      }

      const now = new Date().toISOString();
      const newDraft: DraftThread = {
        id: `draft-${Date.now()}`,
        graphId: draftGraphId,
        name: 'New Chat',
        status: 'draft',
        createdAt: now,
        updatedAt: now,
        externalThreadId: '',
        isDraft: true,
      };

      setDraftThread(newDraft);
      setSelectedThreadId(newDraft.id);
      requestAnimationFrame(scrollThreadsToTop);
    },
    [draftThread],
  );

  const handleCreateDraftThread = useCallback(() => {
    if (!graphFilterId) {
      setGraphPickerOpen(true);
      return;
    }
    createDraftThreadForGraph(graphFilterId);
  }, [createDraftThreadForGraph, graphFilterId]);

  const handleGraphPickerSelect = useCallback(
    (graphId: string) => {
      const selectedGraph = graphPickerGraphs.find(
        (graph) => graph.id === graphId,
      );
      if (selectedGraph) {
        setGraphCache((prev) => ({
          ...prev,
          [graphId]: {
            graph: selectedGraph,
            triggerNodes: buildTriggerNodes(selectedGraph, templatesById),
            nodeDisplayNames: buildNodeDisplayNames(selectedGraph),
          },
        }));
      }
      setGraphPickerOpen(false);
      createDraftThreadForGraph(graphId);
    },
    [createDraftThreadForGraph, graphPickerGraphs, templatesById],
  );

  const handleThreadChatSwitchRequest = useCallback(
    (externalThreadId: string | null) => {
      pendingThreadSelectionRef.current = externalThreadId;
    },
    [],
  );

  return {
    threads,
    setThreads,
    threadsLoading,
    threadsLoadingMore,
    threadStatusTab,
    selectedThreadId,
    setSelectedThreadId,
    setSelectedThreadShadow,
    selectedAgentNodeId,
    setSelectedAgentNodeId,
    draftThread,
    setDraftThread,
    graphCache,
    templatesById,
    templatesLoading,
    triggerNodesForSelectedThread,
    graphPickerOpen,
    setGraphPickerOpen,
    graphPickerLoading,
    graphPickerError,
    graphPickerGraphs,
    threadsContainerRef,
    pendingThreadSelectionRef,
    threadsRef,
    graphFilterId,
    graphIsRunning,
    selectedThreadIsDraft,
    selectedThread,
    filteredThreads,
    shouldShowDraftThread,
    filteredGraphLabel,
    getThreadTimestamp,
    sortThreadsByTimestampDesc,
    ensureGraphsLoaded,
    handleRefreshThreads,
    handleThreadsScroll,
    handleThreadStatusTabChange,
    handleClearGraphFilter,
    handleDeleteThread,
    handleCreateDraftThread,
    handleGraphPickerSelect,
    handleThreadChatSwitchRequest,
  };
};
