import { message as antdMessage } from 'antd';
import { useCallback, useEffect, useMemo, useState } from 'react';

import { threadsApi } from '../../../api';
import type {
  ThreadDto,
  ThreadUsageStatisticsDto,
} from '../../../autogenerated';
import type {
  DraftThread,
  GraphCacheEntry,
  ThreadTokenUsageSnapshot,
} from '../types';
import { mergeTokenUsageByNode, sumUsage } from '../utils/chatsPageUtils';

interface UseChatsUsageStatsDeps {
  selectedThread: ThreadDto | DraftThread | undefined;
  selectedThreadId: string | undefined;
  selectedThreadIsDraft: boolean;
  selectedAgentNodeId: string | null;
  graphCache: Record<string, GraphCacheEntry>;
}

export const useChatsUsageStats = (deps: UseChatsUsageStatsDeps) => {
  const {
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedAgentNodeId,
    graphCache,
  } = deps;

  const [threadTokenUsageByNode, setThreadTokenUsageByNode] = useState<
    Record<string, Record<string, ThreadTokenUsageSnapshot>>
  >({});

  const [threadUsageStats, setThreadUsageStats] = useState<
    Record<string, ThreadUsageStatisticsDto>
  >({});
  const [threadUsageStatsLoading, setThreadUsageStatsLoading] = useState<
    Record<string, boolean>
  >({});

  const [usageStatsModalOpen, setUsageStatsModalOpen] = useState(false);
  const [usageStatsModalThreadId, setUsageStatsModalThreadId] = useState<
    string | null
  >(null);

  const selectedThreadTokenUsageFromApi = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft || !selectedThreadId)
      return undefined;

    const usageStats = threadUsageStats[selectedThreadId];
    if (!usageStats) return undefined;

    const usage: ThreadTokenUsageSnapshot & {
      byNode?: Record<string, ThreadTokenUsageSnapshot>;
    } = {
      inputTokens: usageStats.total.inputTokens,
      cachedInputTokens: usageStats.total.cachedInputTokens,
      outputTokens: usageStats.total.outputTokens,
      reasoningTokens: usageStats.total.reasoningTokens,
      totalTokens: usageStats.total.totalTokens,
      totalPrice: usageStats.total.totalPrice,
      currentContext: usageStats.total.currentContext,
    };

    if (usageStats.byNode) {
      usage.byNode = Object.entries(usageStats.byNode).reduce<
        Record<string, ThreadTokenUsageSnapshot>
      >((acc, [nodeId, nodeStats]) => {
        acc[nodeId] = {
          inputTokens: nodeStats.inputTokens,
          cachedInputTokens: nodeStats.cachedInputTokens,
          outputTokens: nodeStats.outputTokens,
          reasoningTokens: nodeStats.reasoningTokens,
          totalTokens: nodeStats.totalTokens,
          totalPrice: nodeStats.totalPrice,
          currentContext: nodeStats.currentContext,
        };
        return acc;
      }, {});
    }

    return usage;
  }, [
    selectedThread,
    selectedThreadIsDraft,
    selectedThreadId,
    threadUsageStats,
  ]);

  const selectedThreadGraph = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.graph;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const getSchemaNode = useCallback(
    (nodeId: string) => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      return (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
    },
    [selectedThreadGraph],
  );

  const getNodeConfigNumber = useCallback(
    (nodeId: string, key: string): number | undefined => {
      const node = getSchemaNode(nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
    },
    [getSchemaNode],
  );

  const getNodeTemplateId = useCallback(
    (nodeId: string): string | undefined => {
      return getSchemaNode(nodeId)?.template;
    },
    [getSchemaNode],
  );

  const getNodeConfigString = useCallback(
    (nodeId: string, key: 'name' | 'description'): string | undefined => {
      const node = getSchemaNode(nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'string' && value.trim().length > 0
        ? value.trim()
        : undefined;
    },
    [getSchemaNode],
  );

  const selectedThreadUsageByNode = useMemo(() => {
    if (!selectedThreadId) return {};
    return (
      threadTokenUsageByNode[selectedThreadId] ??
      selectedThreadTokenUsageFromApi?.byNode ??
      {}
    );
  }, [
    selectedThreadId,
    selectedThreadTokenUsageFromApi?.byNode,
    threadTokenUsageByNode,
  ]);

  const selectedThreadAggregateUsage = useMemo(() => {
    const nodeUsages = Object.values(selectedThreadUsageByNode);
    if (!nodeUsages.length) return undefined;
    return sumUsage(nodeUsages);
  }, [selectedThreadUsageByNode]);

  const selectedThreadThreadUsage = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return (
      selectedThreadAggregateUsage ??
      selectedThreadTokenUsageFromApi ??
      undefined
    );
  }, [
    selectedThread,
    selectedThreadAggregateUsage,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi,
  ]);

  // Merge API usage into token-by-node state
  useEffect(() => {
    if (!selectedThreadId) return;
    if (!selectedThread || selectedThreadIsDraft) return;
    const byNode = selectedThreadTokenUsageFromApi?.byNode;
    if (!byNode || Object.keys(byNode).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existing = prev[selectedThreadId] ?? {};
      const merged = mergeTokenUsageByNode(byNode, existing);
      if (prev[selectedThreadId] === merged) return prev;
      return { ...prev, [selectedThreadId]: merged };
    });
  }, [
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi?.byNode,
  ]);

  const selectedThreadContextPercent = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;

    let sumContext = 0;
    let sumMaxTokens = 0;
    let hasAny = false;

    entries.forEach(([nodeId, usage]) => {
      if (!usage) return;
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current)) return;
      sumContext += current;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });

    if (!hasAny || sumMaxTokens <= 0) return undefined;
    const percent = (sumContext / sumMaxTokens) * 100;
    return Number.isFinite(percent) ? percent : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadContextMaxTokens = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;
    let sumMaxTokens = 0;
    let hasAny = false;
    entries.forEach(([nodeId]) => {
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });
    return hasAny && sumMaxTokens > 0 ? sumMaxTokens : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadHeaderUsage = useMemo(() => {
    if (selectedAgentNodeId) {
      return selectedThreadUsageByNode[selectedAgentNodeId];
    }
    return selectedThreadThreadUsage;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
  ]);

  const selectedThreadHeaderContextPercent = useMemo(() => {
    if (selectedAgentNodeId) {
      const usage = selectedThreadUsageByNode[selectedAgentNodeId];
      if (!usage) return undefined;
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      if (!maxTokens || maxTokens <= 0) return undefined;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current))
        return undefined;
      const percent = (current / maxTokens) * 100;
      return Number.isFinite(percent) ? percent : undefined;
    }
    return selectedThreadContextPercent;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadContextPercent,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const selectedThreadHeaderContextMaxTokens = useMemo(() => {
    if (selectedAgentNodeId) {
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      return maxTokens && maxTokens > 0 ? maxTokens : undefined;
    }
    return selectedThreadContextMaxTokens;
  }, [
    selectedAgentNodeId,
    selectedThreadContextMaxTokens,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const selectedThreadNodeDisplayNames = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.nodeDisplayNames;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const formatNodeLabel = useCallback(
    (nodeIdentifier: string): string => {
      const mapped = selectedThreadNodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) return mapped;
      if (nodeIdentifier.length <= 10) return nodeIdentifier;
      return `Node ${nodeIdentifier.slice(-6)}`;
    },
    [selectedThreadNodeDisplayNames],
  );

  // --- Fetch with retry ---

  const fetchUsageStatsWithRetry = useCallback(
    (threadId: string, onFinalFailure?: () => void) => {
      let retryCount = 0;
      const maxRetries = 3;
      const retryDelay = 2000;
      let timeoutId: NodeJS.Timeout | null = null;

      const load = async () => {
        try {
          setThreadUsageStatsLoading((prev) => ({
            ...prev,
            [threadId]: true,
          }));
          const response = await threadsApi.getThreadUsageStatistics(threadId);
          setThreadUsageStats((prev) => ({
            ...prev,
            [threadId]: response.data,
          }));
          setThreadUsageStatsLoading((prev) => ({
            ...prev,
            [threadId]: false,
          }));
        } catch (error) {
          console.error(
            `Error loading thread usage statistics (attempt ${retryCount + 1}/${maxRetries + 1}):`,
            error,
          );

          if (retryCount < maxRetries) {
            retryCount++;
            timeoutId = setTimeout(() => {
              void load();
            }, retryDelay);
          } else {
            setThreadUsageStatsLoading((prev) => ({
              ...prev,
              [threadId]: false,
            }));
            console.error(
              'Max retries reached for loading thread usage statistics',
            );
            onFinalFailure?.();
          }
        }
      };

      void load();
      return () => {
        if (timeoutId) clearTimeout(timeoutId);
      };
    },
    [],
  );

  // Auto-load usage stats for the selected thread
  const selectedThreadIdForUsageStats = selectedThreadIsDraft
    ? undefined
    : selectedThread?.id;
  const hasUsageStatsForSelected = Boolean(
    selectedThreadIdForUsageStats &&
      threadUsageStats[selectedThreadIdForUsageStats],
  );
  const isLoadingUsageStatsForSelected = Boolean(
    selectedThreadIdForUsageStats &&
      threadUsageStatsLoading[selectedThreadIdForUsageStats],
  );

  useEffect(() => {
    if (
      !selectedThreadIdForUsageStats ||
      hasUsageStatsForSelected ||
      isLoadingUsageStatsForSelected
    )
      return;

    return fetchUsageStatsWithRetry(selectedThreadIdForUsageStats);
  }, [
    selectedThreadIdForUsageStats,
    hasUsageStatsForSelected,
    isLoadingUsageStatsForSelected,
    fetchUsageStatsWithRetry,
  ]);

  const handleOpenUsageStatsModal = useCallback(() => {
    if (!selectedThreadId || selectedThreadIsDraft) return;
    setUsageStatsModalThreadId(selectedThreadId);
    setUsageStatsModalOpen(true);

    fetchUsageStatsWithRetry(selectedThreadId, () => {
      antdMessage.error(
        'Failed to load usage statistics after multiple attempts',
      );
    });
  }, [fetchUsageStatsWithRetry, selectedThreadId, selectedThreadIsDraft]);

  const handleCloseUsageStatsModal = useCallback(() => {
    setUsageStatsModalOpen(false);
  }, []);

  return {
    threadTokenUsageByNode,
    setThreadTokenUsageByNode,
    threadUsageStats,
    threadUsageStatsLoading,
    usageStatsModalOpen,
    usageStatsModalThreadId,
    selectedThreadTokenUsageFromApi,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
    selectedThreadContextPercent,
    selectedThreadContextMaxTokens,
    selectedThreadHeaderUsage,
    selectedThreadHeaderContextPercent,
    selectedThreadHeaderContextMaxTokens,
    selectedThreadNodeDisplayNames,
    selectedThreadGraph,
    getNodeConfigString,
    getNodeConfigNumber,
    getNodeTemplateId,
    formatNodeLabel,
    handleOpenUsageStatsModal,
    handleCloseUsageStatsModal,
  };
};
