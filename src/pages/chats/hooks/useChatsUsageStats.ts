import { useCallback, useEffect, useMemo, useState } from 'react';

import { threadsApi } from '../../../api';
import type {
  ThreadDto,
  ThreadUsageStatisticsDto,
} from '../../../autogenerated';
import type {
  AntdMessageApi,
  DraftThread,
  GraphCacheEntry,
  ThreadTokenUsageSnapshot,
} from '../types';
import { mergeTokenUsageByNode, sumUsage } from '../utils/chatsPageUtils';

interface UseChatsUsageStatsDeps {
  antdMessage: AntdMessageApi;
  selectedThread: ThreadDto | DraftThread | undefined;
  selectedThreadId: string | undefined;
  selectedThreadIsDraft: boolean;
  selectedAgentNodeId: string | null;
  graphCache: Record<string, GraphCacheEntry>;
}

export const useChatsUsageStats = (deps: UseChatsUsageStatsDeps) => {
  const {
    antdMessage,
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedAgentNodeId,
    graphCache,
  } = deps;

  const [threadTokenUsageByNode, setThreadTokenUsageByNode] = useState<
    Record<string, Record<string, ThreadTokenUsageSnapshot>>
  >({});

  const [threadUsageStats, setThreadUsageStats] = useState<
    Record<string, ThreadUsageStatisticsDto>
  >({});
  const [threadUsageStatsLoading, setThreadUsageStatsLoading] = useState<
    Record<string, boolean>
  >({});

  const [usageStatsModalOpen, setUsageStatsModalOpen] = useState(false);
  const [usageStatsModalThreadId, setUsageStatsModalThreadId] = useState<
    string | null
  >(null);

  const selectedThreadTokenUsageFromApi = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft || !selectedThreadId)
      return undefined;

    const usageStats = threadUsageStats[selectedThreadId];
    if (!usageStats) return undefined;

    const usage: ThreadTokenUsageSnapshot & {
      byNode?: Record<string, ThreadTokenUsageSnapshot>;
    } = {
      inputTokens: usageStats.total.inputTokens,
      cachedInputTokens: usageStats.total.cachedInputTokens,
      outputTokens: usageStats.total.outputTokens,
      reasoningTokens: usageStats.total.reasoningTokens,
      totalTokens: usageStats.total.totalTokens,
      totalPrice: usageStats.total.totalPrice,
      currentContext: usageStats.total.currentContext,
    };

    if (usageStats.byNode) {
      usage.byNode = Object.entries(usageStats.byNode).reduce<
        Record<string, ThreadTokenUsageSnapshot>
      >((acc, [nodeId, nodeStats]) => {
        acc[nodeId] = {
          inputTokens: nodeStats.inputTokens,
          cachedInputTokens: nodeStats.cachedInputTokens,
          outputTokens: nodeStats.outputTokens,
          reasoningTokens: nodeStats.reasoningTokens,
          totalTokens: nodeStats.totalTokens,
          totalPrice: nodeStats.totalPrice,
          currentContext: nodeStats.currentContext,
        };
        return acc;
      }, {});
    }

    return usage;
  }, [
    selectedThread,
    selectedThreadIsDraft,
    selectedThreadId,
    threadUsageStats,
  ]);

  const selectedThreadGraph = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.graph;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const getSchemaNode = useCallback(
    (nodeId: string) => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      return (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
    },
    [selectedThreadGraph],
  );

  const getNodeConfigNumber = useCallback(
    (nodeId: string, key: string): number | undefined => {
      const node = getSchemaNode(nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
    },
    [getSchemaNode],
  );

  const getNodeTemplateId = useCallback(
    (nodeId: string): string | undefined => {
      return getSchemaNode(nodeId)?.template;
    },
    [getSchemaNode],
  );

  const getNodeConfigString = useCallback(
    (nodeId: string, key: 'name' | 'description'): string | undefined => {
      const node = getSchemaNode(nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'string' && value.trim().length > 0
        ? value.trim()
        : undefined;
    },
    [getSchemaNode],
  );

  const selectedThreadUsageByNode = useMemo(() => {
    if (!selectedThreadId) return {};
    return (
      threadTokenUsageByNode[selectedThreadId] ??
      selectedThreadTokenUsageFromApi?.byNode ??
      {}
    );
  }, [
    selectedThreadId,
    selectedThreadTokenUsageFromApi?.byNode,
    threadTokenUsageByNode,
  ]);

  const selectedThreadAggregateUsage = useMemo(() => {
    const nodeUsages = Object.values(selectedThreadUsageByNode);
    if (!nodeUsages.length) return undefined;
    return sumUsage(nodeUsages);
  }, [selectedThreadUsageByNode]);

  const selectedThreadThreadUsage = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;

    // Prefer the authoritative API total when available — it includes all
    // agents, tools, and sub-calls and is the single source of truth.
    // Fall back to the real-time aggregated per-node sum only while the
    // API total hasn't been fetched yet (e.g. thread still running).
    return selectedThreadTokenUsageFromApi ?? selectedThreadAggregateUsage;
  }, [
    selectedThread,
    selectedThreadAggregateUsage,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi,
  ]);

  // Merge API usage into token-by-node state
  useEffect(() => {
    if (!selectedThreadId) return;
    if (!selectedThread || selectedThreadIsDraft) return;
    const byNode = selectedThreadTokenUsageFromApi?.byNode;
    if (!byNode || Object.keys(byNode).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existing = prev[selectedThreadId] ?? {};
      const merged = mergeTokenUsageByNode(byNode, existing);
      if (prev[selectedThreadId] === merged) return prev;
      return { ...prev, [selectedThreadId]: merged };
    });
  }, [
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi?.byNode,
  ]);

  const selectedThreadContextPercent = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;

    let sumContext = 0;
    let sumMaxTokens = 0;
    let hasAny = false;

    entries.forEach(([nodeId, usage]) => {
      if (!usage) return;
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current)) return;
      sumContext += current;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });

    if (!hasAny || sumMaxTokens <= 0) return undefined;
    const percent = (sumContext / sumMaxTokens) * 100;
    return Number.isFinite(percent) ? percent : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadContextMaxTokens = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;
    let sumMaxTokens = 0;
    let hasAny = false;
    entries.forEach(([nodeId]) => {
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });
    return hasAny && sumMaxTokens > 0 ? sumMaxTokens : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadHeaderUsage = useMemo(() => {
    if (selectedAgentNodeId) {
      const nodeUsage = selectedThreadUsageByNode[selectedAgentNodeId];
      if (!nodeUsage) return undefined;

      // The backend may not distribute totalPrice to individual nodes.
      // When only one node exists, all cost belongs to it — use the API total.
      // When multiple nodes exist, try proportional distribution by totalTokens.
      if (!nodeUsage.totalPrice || nodeUsage.totalPrice === 0) {
        const apiPrice = selectedThreadTokenUsageFromApi?.totalPrice;
        if (apiPrice && apiPrice > 0) {
          const nodeEntries = Object.values(selectedThreadUsageByNode);
          if (nodeEntries.length === 1) {
            return { ...nodeUsage, totalPrice: apiPrice };
          }
          // Proportional distribution based on token share
          const totalTokensAll = nodeEntries.reduce(
            (sum, u) => sum + (u.totalTokens ?? 0),
            0,
          );
          if (totalTokensAll > 0 && nodeUsage.totalTokens) {
            const share = nodeUsage.totalTokens / totalTokensAll;
            return { ...nodeUsage, totalPrice: apiPrice * share };
          }
        }
      }
      return nodeUsage;
    }
    return selectedThreadThreadUsage;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
    selectedThreadTokenUsageFromApi,
  ]);

  const selectedThreadHeaderContextPercent = useMemo(() => {
    if (selectedAgentNodeId) {
      const usage = selectedThreadUsageByNode[selectedAgentNodeId];
      if (!usage) return undefined;
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      if (!maxTokens || maxTokens <= 0) return undefined;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current))
        return undefined;
      const percent = (current / maxTokens) * 100;
      return Number.isFinite(percent) ? percent : undefined;
    }
    return selectedThreadContextPercent;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadContextPercent,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const selectedThreadHeaderContextMaxTokens = useMemo(() => {
    if (selectedAgentNodeId) {
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      return maxTokens && maxTokens > 0 ? maxTokens : undefined;
    }
    return selectedThreadContextMaxTokens;
  }, [
    selectedAgentNodeId,
    selectedThreadContextMaxTokens,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const selectedThreadNodeDisplayNames = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.nodeDisplayNames;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const formatNodeLabel = useCallback(
    (nodeIdentifier: string): string => {
      const mapped = selectedThreadNodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) return mapped;
      if (nodeIdentifier.length <= 10) return nodeIdentifier;
      return `Node ${nodeIdentifier.slice(-6)}`;
    },
    [selectedThreadNodeDisplayNames],
  );

  // --- Fetch with retry ---

  const fetchUsageStatsWithRetry = useCallback(
    (threadId: string, onFinalFailure?: () => void) => {
      let retryCount = 0;
      const maxRetries = 3;
      const retryDelay = 2000;
      let timeoutId: NodeJS.Timeout | null = null;
      let cancelled = false;

      const load = async () => {
        try {
          setThreadUsageStatsLoading((prev) => ({
            ...prev,
            [threadId]: true,
          }));
          const response = await threadsApi.getThreadUsageStatistics(threadId);
          if (cancelled) return;
          setThreadUsageStats((prev) => ({
            ...prev,
            [threadId]: response.data,
          }));
          setThreadUsageStatsLoading((prev) => ({
            ...prev,
            [threadId]: false,
          }));
        } catch (error) {
          if (cancelled) return;
          console.error(
            `Error loading thread usage statistics (attempt ${retryCount + 1}/${maxRetries + 1}):`,
            error,
          );

          if (retryCount < maxRetries) {
            retryCount++;
            timeoutId = setTimeout(() => {
              void load();
            }, retryDelay);
          } else {
            setThreadUsageStatsLoading((prev) => ({
              ...prev,
              [threadId]: false,
            }));
            console.error(
              'Max retries reached for loading thread usage statistics',
            );
            onFinalFailure?.();
          }
        }
      };

      void load();
      return () => {
        cancelled = true;
        if (timeoutId) clearTimeout(timeoutId);
      };
    },
    [],
  );

  // Auto-load usage stats for the selected thread
  const selectedThreadIdForUsageStats = selectedThreadIsDraft
    ? undefined
    : selectedThread?.id;
  const hasUsageStatsForSelected = Boolean(
    selectedThreadIdForUsageStats &&
    threadUsageStats[selectedThreadIdForUsageStats],
  );

  useEffect(() => {
    if (!selectedThreadIdForUsageStats || hasUsageStatsForSelected) return;

    return fetchUsageStatsWithRetry(selectedThreadIdForUsageStats);
  }, [
    selectedThreadIdForUsageStats,
    hasUsageStatsForSelected,
    fetchUsageStatsWithRetry,
  ]);

  const handleOpenUsageStatsModal = useCallback(() => {
    if (!selectedThreadId || selectedThreadIsDraft) return;
    setUsageStatsModalThreadId(selectedThreadId);
    setUsageStatsModalOpen(true);

    fetchUsageStatsWithRetry(selectedThreadId, () => {
      antdMessage.error(
        'Failed to load usage statistics after multiple attempts',
      );
    });
  }, [
    antdMessage,
    fetchUsageStatsWithRetry,
    selectedThreadId,
    selectedThreadIsDraft,
  ]);

  const handleCloseUsageStatsModal = useCallback(() => {
    setUsageStatsModalOpen(false);
  }, []);

  const invalidateThreadUsageStats = useCallback((threadId: string) => {
    setThreadUsageStats((prev) => {
      if (!prev[threadId]) return prev;
      const next = { ...prev };
      delete next[threadId];
      return next;
    });
    setThreadUsageStatsLoading((prev) => {
      if (!prev[threadId]) return prev;
      const next = { ...prev };
      delete next[threadId];
      return next;
    });
  }, []);

  return {
    threadTokenUsageByNode,
    setThreadTokenUsageByNode,
    threadUsageStats,
    threadUsageStatsLoading,
    usageStatsModalOpen,
    usageStatsModalThreadId,
    selectedThreadTokenUsageFromApi,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
    selectedThreadContextPercent,
    selectedThreadContextMaxTokens,
    selectedThreadHeaderUsage,
    selectedThreadHeaderContextPercent,
    selectedThreadHeaderContextMaxTokens,
    selectedThreadNodeDisplayNames,
    selectedThreadGraph,
    getNodeConfigString,
    getNodeConfigNumber,
    getNodeTemplateId,
    formatNodeLabel,
    handleOpenUsageStatsModal,
    handleCloseUsageStatsModal,
    invalidateThreadUsageStats,
  };
};
