import { message as antdMessage } from 'antd';
import { useCallback, useEffect, useMemo, useState } from 'react';

import { litellmApi, threadsApi } from '../../../api';
import type { LiteLlmModelDto, ThreadDto } from '../../../autogenerated';
import { extractApiErrorMessage } from '../../../utils/errors';
import type { DraftThread, ThreadSocketEventEntry } from '../types';

interface UseChatsAnalysisDeps {
  selectedThread: ThreadDto | DraftThread | undefined;
  selectedThreadId: string | undefined;
  selectedThreadIsDraft: boolean;
  graphIsRunning: boolean;
  threadSocketEvents: Record<string, ThreadSocketEventEntry[]>;
}

export const useChatsAnalysis = (deps: UseChatsAnalysisDeps) => {
  const {
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    graphIsRunning,
    threadSocketEvents,
  } = deps;

  const [analyzeModalOpen, setAnalyzeModalOpen] = useState(false);
  const [analyzeLoading, setAnalyzeLoading] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<string | null>(null);
  const [analysisUserInput, setAnalysisUserInput] = useState('');
  const [analysisConversationId, setAnalysisConversationId] = useState<
    string | null
  >(null);
  const [analysisModel, setAnalysisModel] = useState<string | undefined>(
    undefined,
  );
  const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
  const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);

  const [threadSocketEventsModalOpen, setThreadSocketEventsModalOpen] =
    useState(false);
  const [threadSocketEventsModalThreadId, setThreadSocketEventsModalThreadId] =
    useState<string | null>(null);

  const analysisButtonDisabled =
    !selectedThread || selectedThreadIsDraft || !graphIsRunning;

  // Reset analysis state on thread change
  useEffect(() => {
    setAnalyzeModalOpen(false);
    setAnalyzeLoading(false);
    setAnalysisResult(null);
    setAnalysisUserInput('');
    setAnalysisConversationId(null);
  }, [selectedThreadId]);

  const handleOpenAnalyzeModal = useCallback(() => {
    if (analysisButtonDisabled) return;
    setAnalyzeModalOpen(true);
  }, [analysisButtonDisabled]);

  const handleCloseAnalyzeModal = useCallback(() => {
    setAnalyzeModalOpen(false);
  }, []);

  const handleAnalyzeThread = useCallback(async () => {
    if (!selectedThread || selectedThreadIsDraft) return;
    try {
      setAnalyzeLoading(true);
      const response = await threadsApi.analyzeThread(selectedThread.id, {
        userInput:
          analysisUserInput && analysisUserInput.trim().length > 0
            ? analysisUserInput
            : undefined,
        threadId: analysisConversationId ?? undefined,
        model: analysisModel,
      });
      const analysisText = response.data?.analysis ?? '';
      const conversationId = response.data?.conversationId ?? null;
      if (conversationId) {
        setAnalysisConversationId(conversationId);
      }
      setAnalysisUserInput('');
      setAnalysisResult(
        analysisText && analysisText.trim().length > 0
          ? analysisText
          : 'No analysis returned for this thread.',
      );
    } catch (error) {
      console.error('Error analyzing thread', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to analyze thread',
      );
      antdMessage.error(errorMessage);
    } finally {
      setAnalyzeLoading(false);
    }
  }, [
    selectedThread,
    selectedThreadIsDraft,
    analysisUserInput,
    analysisConversationId,
    analysisModel,
  ]);

  // Load LiteLLM models when modal opens
  useEffect(() => {
    if (!analyzeModalOpen) return;
    if (liteLlmModels.length > 0) return;

    let isActive = true;

    const fetchLiteLlmModels = async () => {
      try {
        setLitellmModelsLoading(true);
        const response = await litellmApi.listModels();
        if (!isActive) return;
        setLiteLlmModels(response.data ?? []);
      } catch (error) {
        if (!isActive) return;
        console.error('Failed to load LiteLLM models:', error);
        antdMessage.error(
          extractApiErrorMessage(error, 'Failed to load LiteLLM models'),
        );
      } finally {
        if (isActive) setLitellmModelsLoading(false);
      }
    };

    fetchLiteLlmModels();

    return () => {
      isActive = false;
    };
  }, [analyzeModalOpen, liteLlmModels.length]);

  // Socket events modal
  const handleOpenThreadSocketEventsModal = useCallback((threadId: string) => {
    setThreadSocketEventsModalThreadId(threadId);
    setThreadSocketEventsModalOpen(true);
  }, []);

  const handleCloseThreadSocketEventsModal = useCallback(() => {
    setThreadSocketEventsModalOpen(false);
    setThreadSocketEventsModalThreadId(null);
  }, []);

  const socketEventsForModalThread = useMemo(() => {
    if (!threadSocketEventsModalThreadId) return [];
    return threadSocketEvents[threadSocketEventsModalThreadId] ?? [];
  }, [threadSocketEvents, threadSocketEventsModalThreadId]);

  const socketEventsJson = useMemo(() => {
    return JSON.stringify(socketEventsForModalThread, null, 2);
  }, [socketEventsForModalThread]);

  const handleCopyThreadSocketEventsJson = useCallback(async () => {
    if (!threadSocketEventsModalThreadId) return;
    if (socketEventsForModalThread.length === 0) {
      antdMessage.info('No socket events available for this thread.');
      return;
    }
    try {
      await navigator.clipboard.writeText(socketEventsJson);
      antdMessage.success('Socket events copied as JSON.');
    } catch (error) {
      console.error('Failed to copy socket events JSON:', error);
      antdMessage.error('Failed to copy socket events JSON.');
    }
  }, [
    socketEventsForModalThread.length,
    socketEventsJson,
    threadSocketEventsModalThreadId,
  ]);

  return {
    analyzeModalOpen,
    analyzeLoading,
    analysisResult,
    analysisUserInput,
    setAnalysisUserInput,
    analysisModel,
    setAnalysisModel,
    liteLlmModels,
    litellmModelsLoading,
    analysisButtonDisabled,
    handleOpenAnalyzeModal,
    handleCloseAnalyzeModal,
    handleAnalyzeThread,
    threadSocketEventsModalOpen,
    threadSocketEventsModalThreadId,
    socketEventsForModalThread,
    handleOpenThreadSocketEventsModal,
    handleCloseThreadSocketEventsModal,
    handleCopyThreadSocketEventsJson,
  };
};
