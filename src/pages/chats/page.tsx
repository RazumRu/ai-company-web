import {
  CloseOutlined,
  DeleteOutlined,
  EllipsisOutlined,
  LinkOutlined,
  PlusOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import {
  Avatar,
  Button,
  Dropdown,
  Empty,
  Input,
  message as antdMessage,
  Modal,
  Popconfirm,
  Popover,
  Space,
  Spin,
  Tag,
  Typography,
} from 'antd';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router';

import { graphsApi, templatesApi, threadsApi } from '../../api';
import type { GraphDto, TemplateDto, ThreadDto } from '../../autogenerated';
import { GraphDtoStatusEnum, ThreadDtoStatusEnum } from '../../autogenerated';
import { useThreadMessageStore } from '../../hooks/useThreadMessageStore';
import { useWebSocket, useWebSocketEvent } from '../../hooks/useWebSocket';
import type {
  AgentMessageNotification,
  AgentStateUpdateNotification,
  GraphNodeUpdateNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import { getAgentAvatarDataUri } from '../../utils/agentAvatars';
import { extractApiErrorMessage } from '../../utils/errors';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
  type TriggerNodeInfo,
} from '../../utils/graphThreads';
import {
  buildIdSet,
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../utils/threadMessages';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import { MarkdownContent } from '../graphs/components/threadMessages/MarkdownContent';
import ThreadChatPanel from './components/ThreadChatPanel';

const THREADS_PAGE_SIZE = 30;

const { Title, Text } = Typography;

type ThreadTokenUsageSnapshot = {
  inputTokens?: number;
  cachedInputTokens?: number;
  outputTokens?: number;
  reasoningTokens?: number;
  totalTokens?: number;
  totalPrice?: number;
  currentContext?: number;
};

const mergeTokenUsageByNode = (
  baseline: Record<string, ThreadTokenUsageSnapshot>,
  overrides: Record<string, ThreadTokenUsageSnapshot>,
): Record<string, ThreadTokenUsageSnapshot> => {
  const keys = new Set([...Object.keys(baseline), ...Object.keys(overrides)]);
  const merged: Record<string, ThreadTokenUsageSnapshot> = {};
  keys.forEach((key) => {
    merged[key] = { ...(baseline[key] ?? {}), ...(overrides[key] ?? {}) };
  });
  return merged;
};

const formatUsd = (amount?: number | null): string => {
  if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
  if (amount === 0 || (amount > 0 && amount < 0.01)) return '<$0.01';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
};

const formatCompactNumber = (value?: number | null): string => {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '—';
  return new Intl.NumberFormat('en-US', {
    notation: 'compact',
    compactDisplay: 'short',
    maximumFractionDigits: 0,
  }).format(value);
};

const safeNumber = (value: unknown): number | undefined => {
  return typeof value === 'number' && Number.isFinite(value)
    ? value
    : undefined;
};

const compactUsageUpdate = (
  source: AgentStateUpdateNotification['data'],
): Partial<ThreadTokenUsageSnapshot> => {
  const next: Partial<ThreadTokenUsageSnapshot> = {};

  const inputTokens = safeNumber(source?.inputTokens);
  if (inputTokens !== undefined) next.inputTokens = inputTokens;

  const cachedInputTokens = safeNumber(source?.cachedInputTokens);
  if (cachedInputTokens !== undefined)
    next.cachedInputTokens = cachedInputTokens;

  const outputTokens = safeNumber(source?.outputTokens);
  if (outputTokens !== undefined) next.outputTokens = outputTokens;

  const reasoningTokens = safeNumber(source?.reasoningTokens);
  if (reasoningTokens !== undefined) next.reasoningTokens = reasoningTokens;

  const totalTokens = safeNumber(source?.totalTokens);
  if (totalTokens !== undefined) next.totalTokens = totalTokens;

  const totalPrice = safeNumber(source?.totalPrice);
  if (totalPrice !== undefined) next.totalPrice = totalPrice;

  const currentContext = safeNumber(source?.currentContext);
  if (currentContext !== undefined) next.currentContext = currentContext;

  return next;
};

const sumUsage = (
  usages: ThreadTokenUsageSnapshot[],
): ThreadTokenUsageSnapshot => {
  const sumField = (
    key: keyof ThreadTokenUsageSnapshot,
  ): number | undefined => {
    let hasAny = false;
    const total = usages.reduce((acc, usage) => {
      const value = usage[key];
      if (typeof value === 'number' && Number.isFinite(value)) {
        hasAny = true;
        return acc + value;
      }
      return acc;
    }, 0);
    return hasAny ? total : undefined;
  };

  const maxField = (
    key: keyof ThreadTokenUsageSnapshot,
  ): number | undefined => {
    let hasAny = false;
    const max = usages.reduce(
      (acc, usage) => {
        const value = usage[key];
        if (typeof value === 'number' && Number.isFinite(value)) {
          hasAny = true;
          return acc === undefined || value > acc ? value : acc;
        }
        return acc;
      },
      undefined as number | undefined,
    );
    return hasAny ? max : undefined;
  };

  return {
    inputTokens: sumField('inputTokens'),
    cachedInputTokens: sumField('cachedInputTokens'),
    outputTokens: sumField('outputTokens'),
    reasoningTokens: sumField('reasoningTokens'),
    totalTokens: sumField('totalTokens'),
    totalPrice: sumField('totalPrice'),
    currentContext: maxField('currentContext'),
  };
};

const clampPercent = (value: number): number => {
  if (!Number.isFinite(value)) return 0;
  return Math.max(0, Math.min(100, value));
};

const getPercentColor = (percent: number): string => {
  if (percent >= 90) return '#ff4d4f';
  if (percent >= 75) return '#faad14';
  return '#52c41a';
};

const ContextUsageGauge: React.FC<{
  percent: number;
  size?: number;
}> = ({ percent, size = 15 }) => {
  const safePercent = clampPercent(percent);
  const strokeWidth = 3;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const dashOffset = circumference * (1 - safePercent / 100);
  const color = getPercentColor(safePercent);
  const label = `${Math.round(safePercent)}%`;

  return (
    <span
      style={{
        width: size,
        height: size,
        position: 'relative',
        display: 'inline-block',
        verticalAlign: 'middle',
        flexShrink: 0,
      }}
      aria-label={`Context usage ${label}`}>
      <svg width={size} height={size} style={{ display: 'block' }}>
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="#d9d9d9"
          strokeWidth={strokeWidth}
          fill="transparent"
        />
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke={color}
          strokeWidth={strokeWidth}
          fill="transparent"
          strokeDasharray={circumference}
          strokeDashoffset={dashOffset}
          strokeLinecap="round"
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />
      </svg>
    </span>
  );
};

const ThreadTokenUsageLine: React.FC<{
  usage?: ThreadTokenUsageSnapshot | null;
  withPopover?: boolean;
  contextMaxTokens?: number;
  contextPercent?: number;
}> = ({ usage, withPopover = false, contextMaxTokens, contextPercent }) => {
  const totalTokens = usage?.totalTokens;
  const totalPrice = usage?.totalPrice;
  const currentContext = usage?.currentContext;
  if (typeof totalTokens !== 'number') return null;

  const percent =
    typeof contextPercent === 'number'
      ? contextPercent
      : typeof currentContext === 'number' &&
          typeof contextMaxTokens === 'number' &&
          Number.isFinite(contextMaxTokens) &&
          contextMaxTokens > 0
        ? (currentContext / contextMaxTokens) * 100
        : undefined;

  const line = (
    <span
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        gap: 8,
      }}>
      <Text type="secondary" style={{ fontSize: 12, margin: 0 }}>
        Token usage: {formatCompactNumber(totalTokens)} ({formatUsd(totalPrice)}
        )
      </Text>
      {typeof percent === 'number' && <ContextUsageGauge percent={percent} />}
    </span>
  );

  if (!withPopover) return line;

  const popoverContent = (
    <Space direction="vertical" size={2} style={{ maxWidth: 340 }}>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Input tokens: {usage?.inputTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Cached input tokens: {usage?.cachedInputTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Output tokens: {usage?.outputTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Reasoning tokens: {usage?.reasoningTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Total tokens: {usage?.totalTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Total cost: {formatUsd(usage?.totalPrice)}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Current context: {usage?.currentContext ?? '—'}
      </Text>
      {typeof percent === 'number' && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          Context usage: {Math.round(clampPercent(percent))}%
          {typeof contextMaxTokens === 'number' &&
            Number.isFinite(contextMaxTokens) &&
            contextMaxTokens > 0 && (
              <> ({formatCompactNumber(contextMaxTokens)})</>
            )}
        </Text>
      )}
    </Space>
  );

  return (
    <Popover
      content={popoverContent}
      trigger={['hover']}
      placement="bottomLeft">
      <span style={{ display: 'inline-block' }}>{line}</span>
    </Popover>
  );
};

const isDraftThreadId = (threadId?: string | null): boolean => {
  return Boolean(threadId && threadId.startsWith('draft-'));
};

interface GraphCacheEntry {
  graph: GraphDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames: Record<string, string>;
}

interface DraftThread {
  id: string;
  graphId: string;
  name: string | null;
  status: 'draft';
  createdAt: string;
  updatedAt: string;
  externalThreadId: string;
  isDraft: true;
}

export const ChatsPage = () => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [threadsOffset, setThreadsOffset] = useState(0);
  const [threadsHasMore, setThreadsHasMore] = useState(true);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadsLoadingMore, setThreadsLoadingMore] = useState(false);

  const [selectedThreadId, setSelectedThreadId] = useState<string | undefined>(
    undefined,
  );
  const [selectedAgentNodeId, setSelectedAgentNodeId] = useState<string | null>(
    null,
  );
  const [draftThread, setDraftThread] = useState<DraftThread | null>(null);

  const [graphCache, setGraphCache] = useState<Record<string, GraphCacheEntry>>(
    {},
  );
  const [templatesById, setTemplatesById] = useState<
    Record<string, TemplateDto>
  >({});
  const [templatesLoading, setTemplatesLoading] = useState(false);

  const [threadTokenUsageByNode, setThreadTokenUsageByNode] = useState<
    Record<string, Record<string, ThreadTokenUsageSnapshot>>
  >({});

  const [triggerNodesForSelectedThread, setTriggerNodesForSelectedThread] =
    useState<TriggerNodeInfo[]>([]);
  const [analyzeModalOpen, setAnalyzeModalOpen] = useState(false);
  const [analyzeLoading, setAnalyzeLoading] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<string | null>(null);
  const [analysisUserInput, setAnalysisUserInput] = useState('');
  const [analysisConversationId, setAnalysisConversationId] = useState<
    string | null
  >(null);

  const threadsContainerRef = useRef<HTMLDivElement | null>(null);
  const pendingThreadSelectionRef = useRef<string | null>(null);
  const subscribedGraphsRef = useRef<Set<string>>(new Set());

  const { subscribeToGraph, unsubscribeFromGraph } = useWebSocket();
  const location = useLocation();
  const navigate = useNavigate();
  const [graphFilterId, setGraphFilterId] = useState<string | undefined>(() => {
    const params = new URLSearchParams(location.search);
    return params.get('graphId') ?? undefined;
  });

  const {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
  } = useThreadMessageStore();

  const threadsRef = useRef<ThreadDto[]>([]);

  const getThreadTimestamp = useCallback((thread: ThreadDto) => {
    const value = thread.updatedAt ?? thread.createdAt;
    return value ? Date.parse(value) : Number.NaN;
  }, []);

  const resolveInternalThreadId = useCallback((externalThreadId?: string) => {
    if (!externalThreadId) return undefined;
    const found = threadsRef.current.find(
      (thread) => thread.externalThreadId === externalThreadId,
    );
    return found?.id;
  }, []);

  const sortThreadsByTimestampDesc = useCallback(
    (list: ThreadDto[]) => {
      return [...list].sort((a, b) => {
        const bTs = getThreadTimestamp(b);
        const aTs = getThreadTimestamp(a);
        const safeBTs = Number.isFinite(bTs) ? bTs : -Infinity;
        const safeATs = Number.isFinite(aTs) ? aTs : -Infinity;
        if (safeBTs !== safeATs) {
          return safeBTs - safeATs;
        }
        return (b.createdAt ?? '').localeCompare(a.createdAt ?? '');
      });
    },
    [getThreadTimestamp],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadDtoStatusEnum.Done ||
        existing.status === ThreadDtoStatusEnum.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === ThreadDtoStatusEnum.Running
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  type MessageMeta = {
    loading: boolean;
    loadingMore: boolean;
    hasMore: boolean;
    offset: number;
  };

  const defaultMessageMeta = useMemo<MessageMeta>(
    () => ({
      loading: false,
      loadingMore: false,
      hasMore: true,
      offset: 0,
    }),
    [],
  );

  const [messageMeta, setMessageMeta] = useState<Record<string, MessageMeta>>(
    {},
  );

  const getMessageMeta = useCallback(
    (threadId?: string): MessageMeta => {
      if (!threadId) return defaultMessageMeta;
      return messageMeta[threadId] ?? defaultMessageMeta;
    },
    [defaultMessageMeta, messageMeta],
  );

  const updateMessageMeta = useCallback(
    (threadId: string, updater: (prev: MessageMeta) => MessageMeta) => {
      setMessageMeta((prev) => {
        const existing = prev[threadId] ?? defaultMessageMeta;
        return {
          ...prev,
          [threadId]: updater(existing),
        };
      });
    },
    [defaultMessageMeta],
  );

  const loadMessagesForThread = useCallback(
    async (threadId: string, force = false) => {
      // Draft threads are local-only; they can never have persisted messages.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
          offset: prev.offset,
        }));
        return;
      }

      const meta = getMessageMeta(threadId);
      if (!force && (meta.loading || meta.offset > 0)) {
        return;
      }

      updateMessageMeta(threadId, (prev) => ({
        ...prev,
        loading: true,
        loadingMore: false,
        hasMore: true,
        offset: force ? 0 : prev.offset,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          undefined,
          50,
          0,
        );
        const fetched = response.data?.reverse() || [];
        updateMessages(threadId, () => fetched);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: fetched.length === 50,
          offset: fetched.length,
        }));

        const extId =
          fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
          externalThreadIds[threadId];
        if (extId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: extId,
          }));
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load messages',
        );
        antdMessage.error(errorMessage);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [
      getMessageMeta,
      updateMessageMeta,
      updateMessages,
      externalThreadIds,
      setExternalThreadIds,
    ],
  );

  const loadMoreMessagesForThread = useCallback(
    async (threadId: string) => {
      // Draft threads are local-only; there is nothing to paginate from the API.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
        return;
      }

      const meta = getMessageMeta(threadId);
      if (meta.loading || meta.loadingMore || !meta.hasMore) {
        return;
      }

      updateMessageMeta(threadId, (prev) => ({ ...prev, loadingMore: true }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          undefined,
          50,
          meta.offset,
        );
        const fetched = response.data?.reverse() || [];

        if (fetched.length > 0) {
          updateMessages(threadId, (prev) =>
            mergeMessagesReplacingStreaming(prev, fetched),
          );
          updateMessageMeta(threadId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: fetched.length === 50,
            offset: prev.offset + fetched.length,
          }));
        } else {
          updateMessageMeta(threadId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: false,
          }));
        }
      } catch (error) {
        console.error('Error loading more messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load more messages',
        );
        antdMessage.error(errorMessage);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateMessages],
  );

  const handleThreadChatSwitchRequest = useCallback(
    (externalThreadId: string | null) => {
      pendingThreadSelectionRef.current = externalThreadId;
    },
    [],
  );

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const incomingGraphId = params.get('graphId') ?? undefined;
    setGraphFilterId((prev) =>
      prev === incomingGraphId ? prev : incomingGraphId,
    );
  }, [location.search]);

  useEffect(() => {
    setThreads([]);
    setThreadsOffset(0);
    setThreadsHasMore(true);
    setSelectedThreadId(undefined);
    setDraftThread(null);
  }, [graphFilterId]);

  const selectedThread = useMemo(() => {
    if (!selectedThreadId) return undefined;
    if (draftThread && draftThread.id === selectedThreadId) {
      return draftThread;
    }
    return threads.find((thread) => thread.id === selectedThreadId);
  }, [threads, selectedThreadId, draftThread]);

  useEffect(() => {
    // Reset agent filter when changing threads
    setSelectedAgentNodeId(null);
  }, [selectedThreadId]);

  useEffect(() => {
    setAnalyzeModalOpen(false);
    setAnalyzeLoading(false);
    setAnalysisResult(null);
    setAnalysisUserInput('');
    setAnalysisConversationId(null);
  }, [selectedThreadId]);

  useEffect(() => {
    // Don't load messages for draft threads
    if (!selectedThread || (selectedThread as DraftThread)?.isDraft) return;

    const meta = getMessageMeta(selectedThread.id);
    const existingMessages = messages[selectedThread.id]?.['all'] ?? [];

    if (existingMessages.length > 0) {
      if (meta.offset === 0) {
        updateMessageMeta(selectedThread.id, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          offset: existingMessages.length,
        }));
      }
      return;
    }

    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForThread(selectedThread.id);
    }
  }, [
    selectedThread,
    getMessageMeta,
    loadMessagesForThread,
    messages,
    updateMessageMeta,
  ]);

  // Update trigger nodes when selected thread or graph cache changes
  useEffect(() => {
    if (!selectedThread) {
      setTriggerNodesForSelectedThread([]);
      return;
    }

    const graphEntry = graphCache[selectedThread.graphId];
    if (graphEntry) {
      setTriggerNodesForSelectedThread(graphEntry.triggerNodes ?? []);
    } else {
      setTriggerNodesForSelectedThread([]);
    }
  }, [selectedThread, graphCache]);

  // Load templates once
  useEffect(() => {
    let mounted = true;
    const fetchTemplates = async () => {
      try {
        setTemplatesLoading(true);
        const response = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templateList = response.data || [];
        const map = templateList.reduce<Record<string, TemplateDto>>(
          (acc, template) => {
            acc[template.id] = template;
            return acc;
          },
          {},
        );
        setTemplatesById(map);
      } catch (error) {
        console.error('Error loading templates', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load templates metadata',
        );
        antdMessage.error(errorMessage);
      } finally {
        if (mounted) {
          setTemplatesLoading(false);
        }
      }
    };

    void fetchTemplates();
    return () => {
      mounted = false;
    };
  }, []);

  // Cleanup subscriptions on unmount
  useEffect(() => {
    const subscribedGraphs = subscribedGraphsRef.current;
    return () => {
      subscribedGraphs.forEach((graphId) => {
        unsubscribeFromGraph(graphId);
      });
      subscribedGraphs.clear();
    };
  }, [unsubscribeFromGraph]);

  const ensureGraphsLoaded = useCallback(
    async (threadsToCheck: (ThreadDto | DraftThread)[]) => {
      if (!threadsToCheck.length) return;
      const uniqueGraphIds = Array.from(
        new Set(threadsToCheck.map((thread) => thread.graphId)),
      );

      uniqueGraphIds.forEach((graphId) => {
        if (!subscribedGraphsRef.current.has(graphId)) {
          subscribeToGraph(graphId);
          subscribedGraphsRef.current.add(graphId);
        }
      });

      const missingGraphIds = uniqueGraphIds.filter(
        (graphId) => !graphCache[graphId],
      );
      if (!missingGraphIds.length) return;

      try {
        const responses = await Promise.all(
          missingGraphIds.map((graphId) => graphsApi.findGraphById(graphId)),
        );

        setGraphCache((prev) => {
          const next = { ...prev };
          responses.forEach((res, idx) => {
            const graph = res.data;
            if (!graph) return;
            next[missingGraphIds[idx]] = {
              graph,
              triggerNodes: buildTriggerNodes(graph, templatesById),
              nodeDisplayNames: buildNodeDisplayNames(graph),
            };
          });
          return next;
        });
      } catch (error) {
        console.error('Error loading graph metadata', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load graph metadata for threads',
        );
        antdMessage.error(errorMessage);
      }
    },
    [graphCache, subscribeToGraph, templatesById],
  );

  // Ensure graph metadata and trigger nodes are ready for the selected thread
  useEffect(() => {
    if (!selectedThread) return;

    const graphEntry = graphCache[selectedThread.graphId];

    // If graph metadata missing, load it
    if (!graphEntry) {
      void ensureGraphsLoaded([selectedThread]);
      return;
    }

    // If graph exists but trigger nodes were empty, rebuild once templates are available
    if (
      graphEntry.triggerNodes.length === 0 &&
      Object.keys(templatesById).length > 0
    ) {
      const updatedTriggers = buildTriggerNodes(
        graphEntry.graph,
        templatesById,
      );
      if (updatedTriggers.length > 0) {
        setGraphCache((prev) => ({
          ...prev,
          [selectedThread.graphId]: {
            ...graphEntry,
            triggerNodes: updatedTriggers,
          },
        }));
      }
    }
  }, [selectedThread, graphCache, ensureGraphsLoaded, templatesById]);

  // Recompute trigger nodes when templates change
  useEffect(() => {
    if (!Object.keys(templatesById).length) return;
    setGraphCache((prev) => {
      const nextEntries: Record<string, GraphCacheEntry> = {};
      let changed = false;
      Object.entries(prev).forEach(([graphId, entry]) => {
        const updatedTriggers = buildTriggerNodes(entry.graph, templatesById);
        nextEntries[graphId] = {
          graph: entry.graph,
          triggerNodes: updatedTriggers,
          nodeDisplayNames: entry.nodeDisplayNames,
        };
        if (updatedTriggers.length !== entry.triggerNodes.length) {
          changed = true;
        }
      });
      return changed ? nextEntries : prev;
    });
  }, [templatesById]);

  const loadThreads = useCallback(
    async (options?: { append?: boolean }) => {
      const requestedGraphId = graphFilterId;
      const isAppend = options?.append ?? false;
      if (isAppend) {
        if (!threadsHasMore || threadsLoadingMore) return;
        setThreadsLoadingMore(true);
      } else if (threadsLoading) {
        return;
      } else {
        setThreadsLoading(true);
      }

      try {
        const response = await threadsApi.getThreads(
          requestedGraphId,
          THREADS_PAGE_SIZE,
          isAppend ? threadsOffset : 0,
        );
        const fetched = response.data || [];
        const filteredFetched = requestedGraphId
          ? fetched.filter((thread) => thread.graphId === requestedGraphId)
          : fetched;

        if (graphFilterId !== requestedGraphId) {
          return;
        }

        setThreads((prev) => {
          const base =
            requestedGraphId === undefined
              ? prev
              : prev.filter((thread) => thread.graphId === requestedGraphId);
          if (!isAppend) {
            return sortThreadsByTimestampDesc(filteredFetched);
          }
          const existingIds = new Set(base.map((thread) => thread.id));
          const merged = [
            ...base,
            ...filteredFetched.filter((thread) => !existingIds.has(thread.id)),
          ];
          return sortThreadsByTimestampDesc(merged);
        });

        setThreadsOffset((current) =>
          isAppend ? current + fetched.length : fetched.length,
        );
        setThreadsHasMore(fetched.length === THREADS_PAGE_SIZE);

        void ensureGraphsLoaded(filteredFetched);
      } catch (error) {
        console.error('Error loading threads', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load threads list',
        );
        antdMessage.error(errorMessage);
        setThreadsHasMore(false);
      } finally {
        if (isAppend) {
          setThreadsLoadingMore(false);
        } else {
          setThreadsLoading(false);
        }
      }
    },
    [
      ensureGraphsLoaded,
      threadsHasMore,
      threadsLoading,
      threadsLoadingMore,
      threadsOffset,
      sortThreadsByTimestampDesc,
      graphFilterId,
    ],
  );

  useEffect(() => {
    void loadThreads();
    // We intentionally re-fetch only when graph filter changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graphFilterId]);

  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);

  // Only clear selection if selected thread no longer exists (e.g., deleted)
  useEffect(() => {
    // If draft is selected, don't change selection
    if (draftThread && draftThread.id === selectedThreadId) {
      return;
    }

    // Only clear selection if selected thread was deleted
    if (selectedThreadId && threads.length > 0) {
      const stillExists = threads.some(
        (thread) => thread.id === selectedThreadId,
      );
      if (!stillExists) {
        // Thread was deleted, clear selection (don't auto-select another)
        setSelectedThreadId(undefined);
      }
    }
  }, [threads, selectedThreadId, draftThread]);

  const handleThreadsScroll = useCallback(() => {
    const el = threadsContainerRef.current;
    if (!el) return;
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    if (
      nearBottom &&
      threadsHasMore &&
      !threadsLoadingMore &&
      !threadsLoading
    ) {
      void loadThreads({ append: true });
    }
  }, [loadThreads, threadsHasMore, threadsLoading, threadsLoadingMore]);

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      if (!newThread) return;
      if (graphFilterId && newThread.graphId !== graphFilterId) {
        return;
      }

      // Check if this is replacing a draft thread
      const isDraftReplacement =
        draftThread &&
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId;

      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          const updated = prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
          return sortThreadsByTimestampDesc(updated);
        }
        return sortThreadsByTimestampDesc([newThread, ...prev]);
      });
      void ensureGraphsLoaded([newThread]);

      // Update external thread ID if present
      if (newThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [newThread.id]: newThread.externalThreadId,
        }));
      }

      if (isDraftReplacement) {
        // Replace draft thread with real thread
        const draftId = draftThread.id;

        // Migrate messages and pending messages from draft to real thread
        const draftThreadMessages = messages[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            // Update threadId in all migrated messages to match the new thread
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThread.id,
              externalThreadId:
                newThread.externalThreadId || msg.externalThreadId,
            }));
            updateMessages(newThread.id, () => migratedMessages, nodeScope);
          });

          // Carry over meta so we don't refetch immediately and flash loader
          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThread.id]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
            },
          }));
        }

        const draftPending = pendingMessages[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThread.id, () => msgs ?? [], nodeScope);
          });
        }

        // Clear draft and select new thread
        setDraftThread(null);
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      } else if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        // Regular thread switch (not draft)
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      ensureGraphsLoaded,
      setExternalThreadIds,
      sortThreadsByTimestampDesc,
      graphFilterId,
      draftThread,
      messages,
      pendingMessages,
      updateMessages,
      updatePendingMessages,
    ],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      if (graphFilterId && updatedThread.graphId !== graphFilterId) {
        return;
      }
      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          return prev;
        }
        const currentThread = prev[index];

        if (!shouldApplyThreadUpdate(currentThread, updatedThread)) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return sortThreadsByTimestampDesc(next);
      });

      // Update external thread ID if present
      if (updatedThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [updatedThread.id]: updatedThread.externalThreadId,
        }));
      }

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      setExternalThreadIds,
      shouldApplyThreadUpdate,
      sortThreadsByTimestampDesc,
      graphFilterId,
    ],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadId === deletedThread.id) {
        setSelectedThreadId(undefined);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [selectedThreadId],
  );

  useWebSocketEvent(
    'thread.create',
    (notification) =>
      handleThreadCreateEvent(notification as ThreadCreateNotification),
    [handleThreadCreateEvent],
  );
  useWebSocketEvent(
    'thread.update',
    (notification) =>
      handleThreadUpdateEvent(notification as ThreadUpdateNotification),
    [handleThreadUpdateEvent],
  );
  useWebSocketEvent(
    'thread.delete',
    (notification) =>
      handleThreadDeleteEvent(notification as ThreadDeleteNotification),
    [handleThreadDeleteEvent],
  );
  useWebSocketEvent(
    'graph.node.update',
    (notification) => {
      const data = notification as GraphNodeUpdateNotification;
      const eventThreadId =
        (typeof data.threadId === 'string' && data.threadId.length > 0
          ? data.threadId
          : undefined) ??
        (typeof data.data?.metadata?.threadId === 'string'
          ? data.data.metadata.threadId
          : undefined);
      const eventInternalThreadId =
        typeof data.internalThreadId === 'string' &&
        data.internalThreadId.length > 0
          ? data.internalThreadId
          : undefined;
      const metadataRunId =
        typeof data.data?.metadata?.runId === 'string'
          ? data.data.metadata.runId
          : undefined;
      const internalThreadId =
        eventInternalThreadId || resolveInternalThreadId(eventThreadId);

      const targetThreadId = internalThreadId ?? eventThreadId;
      if (!targetThreadId) {
        return;
      }

      const externalThreadIdForTarget =
        externalThreadIds[targetThreadId] ?? eventThreadId;

      if (eventThreadId) {
        setExternalThreadIds((prev) => {
          const existing = prev[targetThreadId];
          if (existing === eventThreadId) return prev;
          return { ...prev, [targetThreadId]: eventThreadId };
        });
      }
      const _targetRunIds = buildIdSet(data.runId, metadataRunId);

      const reasoningChunks =
        data.data?.additionalNodeMetadata?.reasoningChunks;

      // Only process reasoning chunks if they exist
      // Don't clear streaming reasoning when chunks are absent - they should persist
      // until replaced by final non-streaming reasoning messages
      if (!reasoningChunks) {
        return;
      }

      const applyUpdateToKeys = [undefined, data.nodeId];

      const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
        eventThreadId,
        externalThreadIdForTarget,
        data.runId ?? metadataRunId,
      ]);
      const reasoningEntries = extractReasoningEntries(reasoningContainer, {
        threadId: externalThreadIdForTarget ?? eventThreadId,
        runId: data.runId ?? metadataRunId,
      });

      // Only upsert if we have valid reasoning entries
      if (reasoningEntries.length > 0) {
        applyUpdateToKeys.forEach((key) => {
          updateMessages(
            targetThreadId,
            (prev) =>
              upsertReasoningEntries(prev, reasoningEntries, {
                externalThreadId: externalThreadIdForTarget,
                runId: data.runId ?? metadataRunId,
                selectedThreadId: targetThreadId,
                nodeId: key,
              }),
            key,
          );
        });
      }
    },
    [
      resolveInternalThreadId,
      externalThreadIds,
      updateMessages,
      upsertReasoningEntries,
      setExternalThreadIds,
    ],
  );

  // Handle agent messages - update shared state for all listeners
  useWebSocketEvent(
    'agent.message',
    (notification) => {
      const data = notification as AgentMessageNotification;
      if (!data.internalThreadId) return;

      const threadId = data.internalThreadId;
      const nodeId = data.nodeId;
      const incomingMessage = data.data;

      // Update shared messages for both 'all' (thread-level) and node-specific
      updateMessages(threadId, (prev) => {
        return mergeMessagesReplacingStreaming(prev, [incomingMessage]);
      });

      // If nodeId exists, also update node-specific messages
      if (nodeId) {
        updateMessages(
          threadId,
          (prev) => {
            return mergeMessagesReplacingStreaming(prev, [incomingMessage]);
          },
          nodeId,
        );
      }

      // Clear pending that matches this incoming message (by content for human messages)
      const incomingContent =
        typeof incomingMessage.message?.content === 'string'
          ? (incomingMessage.message?.content as string)
          : undefined;
      const incomingRole = incomingMessage.message?.role as string | undefined;
      if (incomingContent && incomingRole === 'human') {
        const applyPendingToKeys = [undefined, nodeId];
        applyPendingToKeys.forEach((key) => {
          updatePendingMessages(
            threadId,
            (prev) =>
              prev.filter(
                (p) =>
                  typeof p.content !== 'string' ||
                  p.content !== incomingContent,
              ),
            key,
          );
        });
      }

      // Update external thread ID if present
      if (incomingMessage.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [threadId]: incomingMessage.externalThreadId,
        }));
      }
    },
    [updateMessages, updatePendingMessages, setExternalThreadIds],
  );

  useWebSocketEvent(
    'agent.state.update',
    (notification) => {
      const data = notification as AgentStateUpdateNotification;
      const internalThreadId =
        (typeof data.internalThreadId === 'string' && data.internalThreadId) ||
        resolveInternalThreadId(data.threadId);
      if (!internalThreadId) return;
      if (!data.nodeId) return;

      const usageUpdate = compactUsageUpdate(data.data ?? {});
      if (Object.keys(usageUpdate).length === 0) return;

      setThreadTokenUsageByNode((prev) => {
        const existingThread = prev[internalThreadId] ?? {};
        const existingNode = existingThread[data.nodeId] ?? {};
        return {
          ...prev,
          [internalThreadId]: {
            ...existingThread,
            [data.nodeId]: {
              ...existingNode,
              ...usageUpdate,
            },
          },
        };
      });
    },
    [resolveInternalThreadId],
  );
  const threadStatusMeta = selectedThread
    ? 'isDraft' in selectedThread && selectedThread.isDraft
      ? null
      : getThreadStatusDisplay((selectedThread as ThreadDto).status)
    : null;
  const selectedGraphStatus = selectedThread
    ? graphCache[selectedThread.graphId]?.graph.status
    : undefined;
  const graphIsRunning = selectedGraphStatus === GraphDtoStatusEnum.Running;
  const selectedThreadIsDraft =
    selectedThread !== undefined &&
    'isDraft' in selectedThread &&
    selectedThread.isDraft === true;
  const analysisButtonDisabled =
    !selectedThread || selectedThreadIsDraft || !graphIsRunning;

  const handleOpenAnalyzeModal = useCallback(() => {
    if (analysisButtonDisabled) return;
    setAnalyzeModalOpen(true);
  }, [analysisButtonDisabled]);

  const handleCloseAnalyzeModal = useCallback(() => {
    setAnalyzeModalOpen(false);
  }, []);

  const handleAnalyzeThread = useCallback(async () => {
    if (!selectedThread || selectedThreadIsDraft) return;
    try {
      setAnalyzeLoading(true);
      const response = await threadsApi.analyzeThread(selectedThread.id, {
        userInput:
          analysisUserInput && analysisUserInput.trim().length > 0
            ? analysisUserInput
            : undefined,
        threadId: analysisConversationId ?? undefined,
      });
      const analysisText = response.data?.analysis ?? '';
      const conversationId = response.data?.conversationId ?? null;
      if (conversationId) {
        setAnalysisConversationId(conversationId);
      }
      setAnalysisUserInput('');
      setAnalysisResult(
        analysisText && analysisText.trim().length > 0
          ? analysisText
          : 'No analysis returned for this thread.',
      );
    } catch (error) {
      console.error('Error analyzing thread', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to analyze thread',
      );
      antdMessage.error(errorMessage);
    } finally {
      setAnalyzeLoading(false);
    }
  }, [
    selectedThread,
    selectedThreadIsDraft,
    analysisUserInput,
    analysisConversationId,
  ]);

  const filteredGraphLabel = useMemo(() => {
    if (!graphFilterId) return undefined;
    const graphName = graphCache[graphFilterId]?.graph.name;
    if (graphName && graphName.trim().length > 0) {
      return graphName;
    }
    if (graphFilterId.length <= 10) {
      return graphFilterId;
    }
    return `…${graphFilterId.slice(-6)}`;
  }, [graphFilterId, graphCache]);

  const selectedThreadAllMessages = useMemo(() => {
    if (!selectedThreadId) return [];
    return messages[selectedThreadId]?.['all'] || [];
  }, [messages, selectedThreadId]);

  const selectedThreadTokenUsageFromApi = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    const usage = (selectedThread as ThreadDto).tokenUsage as
      | (ThreadTokenUsageSnapshot & {
          byNode?: Record<string, ThreadTokenUsageSnapshot>;
        })
      | null
      | undefined;
    return usage ?? undefined;
  }, [selectedThread, selectedThreadIsDraft]);

  const selectedThreadUsageByNode = useMemo(() => {
    if (!selectedThreadId) return {};
    return (
      threadTokenUsageByNode[selectedThreadId] ??
      selectedThreadTokenUsageFromApi?.byNode ??
      {}
    );
  }, [
    selectedThreadId,
    selectedThreadTokenUsageFromApi?.byNode,
    threadTokenUsageByNode,
  ]);

  const selectedThreadAggregateUsage = useMemo(() => {
    const nodeUsages = Object.values(selectedThreadUsageByNode);
    if (!nodeUsages.length) return undefined;
    return sumUsage(nodeUsages);
  }, [selectedThreadUsageByNode]);

  const selectedThreadThreadUsage = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return (
      selectedThreadAggregateUsage ??
      selectedThreadTokenUsageFromApi ??
      undefined
    );
  }, [
    selectedThread,
    selectedThreadAggregateUsage,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi,
  ]);

  useEffect(() => {
    if (!selectedThreadId) return;
    if (!selectedThread || selectedThreadIsDraft) return;
    const byNode = selectedThreadTokenUsageFromApi?.byNode;
    if (!byNode || Object.keys(byNode).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existing = prev[selectedThreadId] ?? {};
      // Baseline from API, but keep any live socket-updated overrides.
      const merged = mergeTokenUsageByNode(byNode, existing);
      if (prev[selectedThreadId] === merged) return prev;
      return { ...prev, [selectedThreadId]: merged };
    });
  }, [
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi?.byNode,
  ]);

  const selectedThreadNodeDisplayNames = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.nodeDisplayNames;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const selectedThreadGraph = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.graph;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const getNodeConfigString = useCallback(
    (nodeId: string, key: 'name' | 'description'): string | undefined => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      const node = (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'string' && value.trim().length > 0
        ? value.trim()
        : undefined;
    },
    [selectedThreadGraph],
  );

  const getNodeConfigNumber = useCallback(
    (nodeId: string, key: string): number | undefined => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      const node = (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
    },
    [selectedThreadGraph],
  );

  const getNodeTemplateId = useCallback(
    (nodeId: string): string | undefined => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      const node = (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
      return node?.template;
    },
    [selectedThreadGraph],
  );

  const selectedThreadContextPercent = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;

    let sumContext = 0;
    let sumMaxTokens = 0;
    let hasAny = false;

    entries.forEach(([nodeId, usage]) => {
      if (!usage) return;
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current)) return;
      sumContext += current;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });

    if (!hasAny || sumMaxTokens <= 0) return undefined;
    const percent = (sumContext / sumMaxTokens) * 100;
    return Number.isFinite(percent) ? percent : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadContextMaxTokens = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;
    let sumMaxTokens = 0;
    let hasAny = false;
    entries.forEach(([nodeId]) => {
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });
    return hasAny && sumMaxTokens > 0 ? sumMaxTokens : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadHeaderUsage = useMemo(() => {
    if (selectedAgentNodeId) {
      return selectedThreadUsageByNode[selectedAgentNodeId];
    }
    return selectedThreadThreadUsage;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
  ]);

  const selectedThreadHeaderContextPercent = useMemo(() => {
    if (selectedAgentNodeId) {
      const usage = selectedThreadUsageByNode[selectedAgentNodeId];
      if (!usage) return undefined;
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      if (!maxTokens || maxTokens <= 0) return undefined;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current))
        return undefined;
      const percent = (current / maxTokens) * 100;
      return Number.isFinite(percent) ? percent : undefined;
    }
    return selectedThreadContextPercent;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadContextPercent,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const selectedThreadHeaderContextMaxTokens = useMemo(() => {
    if (selectedAgentNodeId) {
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      return maxTokens && maxTokens > 0 ? maxTokens : undefined;
    }
    return selectedThreadContextMaxTokens;
  }, [
    selectedAgentNodeId,
    selectedThreadContextMaxTokens,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const formatNodeLabel = useCallback(
    (nodeIdentifier: string): string => {
      const mapped = selectedThreadNodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) {
        return mapped;
      }
      if (nodeIdentifier.length <= 10) {
        return nodeIdentifier;
      }
      return `Node ${nodeIdentifier.slice(-6)}`;
    },
    [selectedThreadNodeDisplayNames],
  );

  const agentsForSelectedThread = useMemo(() => {
    if (!selectedThreadId || !selectedThread || selectedThreadIsDraft) {
      return [];
    }

    const seen = new Set<string>();
    const agents: {
      nodeId: string;
      label: string;
      description?: string;
      avatarSrc?: string;
    }[] = [];

    selectedThreadAllMessages.forEach((msg) => {
      const nodeId = msg.nodeId;
      if (!nodeId) return;
      const role = msg.message?.role as string | undefined;
      const isAgentMessage = role === 'ai' || role === 'reasoning';
      if (!isAgentMessage) return;
      if (seen.has(nodeId)) return;
      seen.add(nodeId);

      const configName = getNodeConfigString(nodeId, 'name');
      const configDescription = getNodeConfigString(nodeId, 'description');

      agents.push({
        nodeId,
        label: configName ?? formatNodeLabel(nodeId),
        description: configDescription,
        avatarSrc: getAgentAvatarDataUri(nodeId),
      });
    });

    return agents;
  }, [
    formatNodeLabel,
    getNodeConfigString,
    selectedThread,
    selectedThreadAllMessages,
    selectedThreadId,
    selectedThreadIsDraft,
  ]);

  const visibleMessagesForSelectedThread = useMemo(() => {
    if (!selectedThreadId) return [];
    if (!selectedAgentNodeId) return selectedThreadAllMessages;
    return selectedThreadAllMessages.filter(
      (msg) => msg.nodeId === selectedAgentNodeId,
    );
  }, [selectedAgentNodeId, selectedThreadAllMessages, selectedThreadId]);

  const visiblePendingMessagesForSelectedThread = useMemo(() => {
    if (!selectedThreadId) return [];
    if (selectedAgentNodeId) return [];
    return pendingMessages[selectedThreadId]?.['all'] || [];
  }, [pendingMessages, selectedAgentNodeId, selectedThreadId]);

  const handleClearGraphFilter = useCallback(() => {
    const params = new URLSearchParams(location.search);
    params.delete('graphId');
    navigate(
      {
        pathname: location.pathname,
        search: params.toString() ? `?${params.toString()}` : '',
      },
      { replace: true },
    );
  }, [location.pathname, location.search, navigate]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          setSelectedThreadId(undefined);
        }
        antdMessage.success('Thread deleted successfully');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to delete thread',
        );
        antdMessage.error(errorMessage);
      }
    },
    [selectedThreadId],
  );

  const handleCreateDraftThread = useCallback(() => {
    if (draftThread) {
      // If draft already exists, just focus it
      setSelectedThreadId(draftThread.id);
      return;
    }

    // Determine graphId for draft
    const draftGraphId = graphFilterId || threads[0]?.graphId;
    if (!draftGraphId) {
      antdMessage.warning('Please select a graph first or filter by graph');
      return;
    }

    // Create new draft thread
    const now = new Date().toISOString();
    const newDraft: DraftThread = {
      id: `draft-${Date.now()}`,
      graphId: draftGraphId,
      name: 'New Chat',
      status: 'draft',
      createdAt: now,
      updatedAt: now,
      externalThreadId: '',
      isDraft: true,
    };

    setDraftThread(newDraft);
    setSelectedThreadId(newDraft.id);
  }, [draftThread, graphFilterId, threads]);

  const handleDraftMessageSent = useCallback(
    (newThreadId: string) => {
      if (draftThread) {
        const draftId = draftThread.id;

        // Migrate any optimistic/pending messages from the draft thread
        const draftThreadMessages = messages[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            // Update threadId in all migrated messages to match the new thread
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThreadId,
            }));
            updateMessages(newThreadId, () => migratedMessages, nodeScope);
          });

          // Carry over meta so we don't refetch immediately and flash loader
          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThreadId]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
            },
          }));
        }

        const draftPending = pendingMessages[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThreadId, () => msgs ?? [], nodeScope);
          });
        }
      }

      // Delete draft and select the newly created thread
      const wasDraftSelected =
        draftThread && draftThread.id === selectedThreadId;
      setDraftThread(null);
      if (wasDraftSelected) {
        setSelectedThreadId(newThreadId);
      }
    },
    [
      draftThread,
      messages,
      pendingMessages,
      selectedThreadId,
      updateMessages,
      updatePendingMessages,
    ],
  );

  const renderThreadItem = (thread: ThreadDto | DraftThread) => {
    const isActive = thread.id === selectedThreadId;
    const isDraft = 'isDraft' in thread && thread.isDraft === true;
    const statusMeta = isDraft
      ? { label: 'Draft', color: '#d9d9d9' }
      : getThreadStatusDisplay(
          (thread as ThreadDto).status as ThreadDtoStatusEnum,
        );
    const graphName = graphCache[thread.graphId]?.graph.name;
    const createdAt = new Date(thread.createdAt).toLocaleString();

    return (
      <div
        key={thread.id}
        onClick={() => setSelectedThreadId(thread.id)}
        onMouseEnter={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fafafa';
          }
        }}
        onMouseLeave={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fff';
          }
        }}
        style={{
          padding: '12px 16px',
          borderBottom: '1px solid #f0f0f0',
          cursor: 'pointer',
          backgroundColor: isActive ? '#f5f9ff' : '#fff',
          overflow: 'hidden',
          transition: 'background-color 0.2s ease',
        }}>
        <Space
          direction="vertical"
          size={4}
          style={{ width: '100%', minWidth: 0 }}>
          <div
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: 8,
              minWidth: 0,
            }}>
            <div style={{ flex: 1, minWidth: 0 }}>
              <Text
                strong
                ellipsis={{
                  tooltip: thread.name || `Thread ${thread.id.slice(-6)}`,
                }}
                style={{
                  width: '100%',
                  display: 'block',
                }}>
                {thread.name || `Thread ${thread.id.slice(-6)}`}
              </Text>
            </div>
            {statusMeta && (
              <Tag
                color={statusMeta.color}
                style={{ margin: 0, flexShrink: 0, whiteSpace: 'nowrap' }}>
                {statusMeta.label}
              </Tag>
            )}
            {!isDraft && (
              <Dropdown
                menu={{
                  items: [
                    {
                      key: 'delete',
                      label: (
                        <Popconfirm
                          title="Delete thread"
                          description="Are you sure you want to delete this thread?"
                          onConfirm={(e) => {
                            e?.stopPropagation();
                            handleDeleteThread(thread.id);
                          }}
                          onCancel={(e) => e?.stopPropagation()}
                          okText="Delete"
                          cancelText="Cancel"
                          okButtonProps={{ danger: true }}>
                          <div
                            onClick={(e) => e.stopPropagation()}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: 8,
                            }}>
                            <DeleteOutlined />
                            Delete
                          </div>
                        </Popconfirm>
                      ),
                    },
                  ],
                }}
                trigger={['click']}
                placement="bottomRight">
                <Button
                  type="text"
                  size="small"
                  icon={<EllipsisOutlined />}
                  onClick={(e) => e.stopPropagation()}
                  style={{
                    flexShrink: 0,
                    padding: '4px 8px',
                  }}
                />
              </Dropdown>
            )}
          </div>
          <Text
            type="secondary"
            title={graphName || 'Loading graph…'}
            style={{
              fontSize: 12,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              minWidth: 0,
            }}>
            {graphName || 'Loading graph…'}
          </Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Created {createdAt}
          </Text>
          {isActive && !isDraft && (
            <div style={{ marginTop: 6 }}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                <div
                  onClick={(e) => {
                    e.stopPropagation();
                    setSelectedAgentNodeId(null);
                  }}
                  onMouseEnter={(e) => {
                    if (selectedAgentNodeId) {
                      e.currentTarget.style.backgroundColor = '#fafafa';
                    }
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.backgroundColor = selectedAgentNodeId
                      ? '#fff'
                      : '#e6f4ff';
                  }}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 10,
                    padding: '8px 10px',
                    borderRadius: 10,
                    border: `1px solid ${
                      selectedAgentNodeId ? '#f0f0f0' : '#91caff'
                    }`,
                    backgroundColor: selectedAgentNodeId ? '#fff' : '#e6f4ff',
                    cursor: 'pointer',
                    transition:
                      'background-color 0.15s ease, border-color 0.15s ease',
                  }}>
                  <div style={{ minWidth: 0, flex: 1 }}>
                    <Text strong style={{ display: 'block', fontSize: 13 }}>
                      All agents
                    </Text>
                    <Text
                      type="secondary"
                      style={{
                        fontSize: 12,
                        display: '-webkit-box',
                        WebkitLineClamp: 1,
                        WebkitBoxOrient: 'vertical',
                        overflow: 'hidden',
                      }}>
                      show the full thread
                    </Text>
                    <ThreadTokenUsageLine
                      usage={selectedThreadThreadUsage}
                      contextPercent={selectedThreadContextPercent}
                      contextMaxTokens={selectedThreadContextMaxTokens}
                    />
                  </div>
                </div>

                {agentsForSelectedThread.length > 0 ? (
                  agentsForSelectedThread.map((agent) => {
                    const isSelected = selectedAgentNodeId === agent.nodeId;
                    const agentUsage = selectedThreadUsageByNode[agent.nodeId];
                    const templateId = getNodeTemplateId(agent.nodeId);
                    const summarizeMaxTokens =
                      templateId === 'simple-agent'
                        ? getNodeConfigNumber(
                            agent.nodeId,
                            'summarizeMaxTokens',
                          )
                        : undefined;
                    return (
                      <div
                        key={agent.nodeId}
                        onClick={(e) => {
                          e.stopPropagation();
                          setSelectedAgentNodeId(agent.nodeId);
                        }}
                        onMouseEnter={(e) => {
                          if (!isSelected) {
                            e.currentTarget.style.backgroundColor = '#fafafa';
                          }
                        }}
                        onMouseLeave={(e) => {
                          if (!isSelected) {
                            e.currentTarget.style.backgroundColor = '#fff';
                          }
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: 10,
                          padding: '8px 10px',
                          borderRadius: 10,
                          border: `1px solid ${
                            isSelected ? '#91caff' : '#f0f0f0'
                          }`,
                          backgroundColor: isSelected ? '#e6f4ff' : '#fff',
                          cursor: 'pointer',
                          transition:
                            'background-color 0.15s ease, border-color 0.15s ease',
                        }}>
                        <Avatar
                          size={28}
                          src={agent.avatarSrc}
                          style={{ background: '#f0f0f0', flexShrink: 0 }}
                        />
                        <div style={{ minWidth: 0, flex: 1 }}>
                          <Text
                            strong
                            style={{
                              display: 'block',
                              fontSize: 13,
                              whiteSpace: 'nowrap',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                            }}>
                            {agent.label}
                          </Text>
                          <Text
                            type="secondary"
                            style={{
                              fontSize: 12,
                              display: '-webkit-box',
                              WebkitLineClamp: 1,
                              WebkitBoxOrient: 'vertical',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              whiteSpace: 'nowrap',
                            }}>
                            {agent.description || ''}
                          </Text>
                          <ThreadTokenUsageLine
                            usage={agentUsage}
                            contextMaxTokens={summarizeMaxTokens}
                          />
                        </div>
                      </div>
                    );
                  })
                ) : (
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    No agents yet
                  </Text>
                )}
              </div>
            </div>
          )}
        </Space>
      </div>
    );
  };

  const threadsEmpty =
    !threadsLoading && !threadsLoadingMore && threads.length === 0;

  return (
    <div
      style={{
        height: 'calc(100vh - 64px)',
        maxHeight: 'calc(100vh - 64px)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}>
      <div
        style={{
          display: 'flex',
          flex: 1,
          minHeight: 0,
          overflow: 'hidden',
        }}>
        <div
          style={{
            width: 340,
            borderRight: '1px solid #f0f0f0',
            display: 'flex',
            flexDirection: 'column',
            background: '#fff',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <div
              style={{
                width: '100%',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'flex-start',
                gap: 12,
                minWidth: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  minWidth: 0,
                  flex: 1,
                }}>
                <Title level={4} style={{ margin: 0 }}>
                  Chats
                </Title>
              </div>
              <Space>
                <Button
                  size="small"
                  icon={<PlusOutlined />}
                  onClick={handleCreateDraftThread}
                  style={{
                    border: 'none',
                    boxShadow: 'none',
                  }}
                />
                <Button
                  size="small"
                  icon={<ReloadOutlined />}
                  onClick={() => loadThreads()}
                  loading={threadsLoading}
                  style={{
                    border: 'none',
                    boxShadow: 'none',
                  }}
                />
              </Space>
            </div>
          </div>
          {graphFilterId && (
            <div
              style={{
                padding: '10px 16px',
                borderBottom: '1px solid #f0f0f0',
                background: '#fafafa',
                flexShrink: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 12,
                  minWidth: 0,
                }}>
                <div style={{ minWidth: 0, flex: 1 }}>
                  <Text
                    type="secondary"
                    style={{
                      fontSize: 11,
                      display: 'block',
                      marginBottom: 2,
                    }}>
                    Current graph
                  </Text>
                  <Text
                    strong
                    ellipsis={{ tooltip: filteredGraphLabel }}
                    style={{ display: 'block' }}>
                    {filteredGraphLabel}
                  </Text>
                </div>
                <Button
                  type="text"
                  size="small"
                  icon={<CloseOutlined />}
                  onClick={handleClearGraphFilter}
                  aria-label="Clear graph filter"
                />
              </div>
            </div>
          )}
          <div
            ref={threadsContainerRef}
            onScroll={handleThreadsScroll}
            style={{
              flex: 1,
              minHeight: 0,
              overflowY: 'auto',
            }}>
            {draftThread && renderThreadItem(draftThread)}
            {threads.map(renderThreadItem)}
            {threadsLoading && (
              <div style={{ padding: 24, textAlign: 'center' }}>
                <Spin />
              </div>
            )}
            {threadsEmpty && (
              <div style={{ padding: 24 }}>
                <Empty
                  description={
                    graphFilterId
                      ? 'No threads found for this graph'
                      : 'No threads yet'
                  }
                />
              </div>
            )}
            {threadsLoadingMore && (
              <div style={{ padding: 12, textAlign: 'center' }}>
                <Spin size="small" />
              </div>
            )}
          </div>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: 24,
              display: 'flex',
              flexDirection: 'column',
              flex: 1,
              minHeight: 0,
              background: '#fff',
              overflow: 'hidden',
            }}>
            {selectedThread ? (
              <>
                <div
                  style={{
                    marginBottom: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}>
                  <div>
                    <Title level={4} style={{ margin: 0 }}>
                      {selectedThread.name ||
                        `Thread ${selectedThread.id.slice(-6)}`}
                    </Title>
                    <Space size="small" wrap>
                      <Text type="secondary">
                        Graph:{' '}
                        {graphCache[selectedThread.graphId]?.graph.name ||
                          'Loading…'}
                      </Text>
                      <Link
                        to={`/graphs/${selectedThread.graphId}`}
                        style={{
                          display: 'inline-flex',
                          alignItems: 'center',
                          color: '#1677ff',
                          textDecoration: 'none',
                          position: 'relative',
                          top: '2px',
                          padding: '0 3px',
                        }}
                        aria-label="Open graph details"
                        title="Open graph details">
                        <LinkOutlined />
                      </Link>
                      {selectedThread && (
                        <Space size={8} align="center">
                          {threadStatusMeta && (
                            <Tag color={threadStatusMeta.color}>
                              {threadStatusMeta.label}
                            </Tag>
                          )}
                          <Button
                            type="link"
                            size="small"
                            style={{
                              padding: 0,
                              height: 'auto',
                              fontSize: 12,
                            }}
                            onClick={handleOpenAnalyzeModal}
                            disabled={analysisButtonDisabled}
                            title={
                              selectedThreadIsDraft
                                ? 'Create the thread before analyzing it'
                                : undefined
                            }>
                            Analyze thread
                          </Button>
                        </Space>
                      )}
                    </Space>
                  </div>
                  <div style={{ marginLeft: 'auto', textAlign: 'right' }}>
                    <ThreadTokenUsageLine
                      usage={selectedThreadHeaderUsage}
                      withPopover
                      contextPercent={selectedThreadHeaderContextPercent}
                      contextMaxTokens={selectedThreadHeaderContextMaxTokens}
                    />
                  </div>
                </div>

                <div
                  style={{
                    flex: 1,
                    minHeight: 0,
                    display: 'flex',
                    flexDirection: 'column',
                  }}>
                  <ThreadChatPanel
                    graphId={selectedThread.graphId}
                    thread={selectedThread as ThreadDto}
                    triggerNodes={triggerNodesForSelectedThread}
                    templatesLoading={templatesLoading}
                    nodeDisplayNames={
                      graphCache[selectedThread.graphId]?.nodeDisplayNames
                    }
                    graphLoaded={Boolean(graphCache[selectedThread.graphId])}
                    onRequestThreadSwitch={handleThreadChatSwitchRequest}
                    isDraft={draftThread?.id === selectedThreadId}
                    onDraftMessageSent={handleDraftMessageSent}
                    messages={
                      selectedThreadId ? visibleMessagesForSelectedThread : []
                    }
                    messagesLoading={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).loading
                        : false
                    }
                    hasMoreMessages={
                      selectedThreadId
                        ? isDraftThreadId(selectedThreadId)
                          ? false
                          : getMessageMeta(selectedThreadId).hasMore
                        : false
                    }
                    loadingMoreMessages={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).loadingMore
                        : false
                    }
                    pendingMessages={
                      selectedThreadId
                        ? visiblePendingMessagesForSelectedThread
                        : []
                    }
                    externalThreadId={
                      selectedThreadId
                        ? externalThreadIds[selectedThreadId]
                        : undefined
                    }
                    onLoadMoreMessages={
                      selectedThreadId
                        ? isDraftThreadId(selectedThreadId)
                          ? undefined
                          : () => loadMoreMessagesForThread(selectedThreadId)
                        : undefined
                    }
                    onUpdateSharedMessages={updateMessages}
                    onUpdateSharedPendingMessages={updatePendingMessages}
                  />
                </div>
              </>
            ) : (
              <div
                style={{
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}>
                <Empty
                  description="Select a thread to view its messages"
                  image={Empty.PRESENTED_IMAGE_SIMPLE}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <Modal
        title="Analyze thread"
        open={analyzeModalOpen}
        onCancel={handleCloseAnalyzeModal}
        destroyOnClose
        footer={[
          <Button key="cancel" onClick={handleCloseAnalyzeModal}>
            Close
          </Button>,
          <Button
            key="analyze"
            type="primary"
            onClick={handleAnalyzeThread}
            loading={analyzeLoading}
            disabled={analysisButtonDisabled}>
            Analyze
          </Button>,
        ]}>
        <Space direction="vertical" size={12} style={{ width: '100%' }}>
          <Text>
            AI will analyze this thread and share hints about improvements or
            potential problems.
          </Text>
          <Input.TextArea
            rows={4}
            placeholder="Optional context or questions for the analysis"
            value={analysisUserInput}
            onChange={(e) => setAnalysisUserInput(e.target.value)}
            disabled={analysisButtonDisabled || analyzeLoading}
          />
          {analysisResult ? (
            <div
              style={{
                maxHeight: 360,
                overflowY: 'auto',
                padding: 12,
                border: '1px solid #f0f0f0',
                borderRadius: 8,
              }}>
              <MarkdownContent content={analysisResult} />
            </div>
          ) : (
            <Text type="secondary">
              Run the analysis to see AI feedback for this thread.
            </Text>
          )}
        </Space>
      </Modal>
    </div>
  );
};

export default ChatsPage;
