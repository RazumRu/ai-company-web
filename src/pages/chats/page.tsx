import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  Typography,
  Button,
  Space,
  Spin,
  Tag,
  Empty,
  Dropdown,
  Popconfirm,
  message as antdMessage,
} from 'antd';
import {
  ReloadOutlined,
  EllipsisOutlined,
  DeleteOutlined,
  LinkOutlined,
} from '@ant-design/icons';
import type { GraphDto, TemplateDto, ThreadDto } from '../../autogenerated';
import { ThreadDtoStatusEnum } from '../../autogenerated';
import { graphsApi, templatesApi, threadsApi } from '../../api';
import { Link, useLocation } from 'react-router';
import { useWebSocket, useWebSocketEvent } from '../../hooks/useWebSocket';
import type {
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import ThreadChatPanel from './components/ThreadChatPanel';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
  type TriggerNodeInfo,
} from '../../utils/graphThreads';

const THREADS_PAGE_SIZE = 30;

const { Title, Text } = Typography;

interface GraphCacheEntry {
  graph: GraphDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames: Record<string, string>;
}

export const ChatsPage = () => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [threadsOffset, setThreadsOffset] = useState(0);
  const [threadsHasMore, setThreadsHasMore] = useState(true);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadsLoadingMore, setThreadsLoadingMore] = useState(false);

  const [selectedThreadId, setSelectedThreadId] = useState<string | undefined>(
    undefined,
  );

  const [graphCache, setGraphCache] = useState<Record<string, GraphCacheEntry>>(
    {},
  );
  const [templatesByName, setTemplatesByName] = useState<
    Record<string, TemplateDto>
  >({});
  const [templatesLoading, setTemplatesLoading] = useState(false);

  const [triggerNodesForSelectedThread, setTriggerNodesForSelectedThread] =
    useState<TriggerNodeInfo[]>([]);

  const threadsContainerRef = useRef<HTMLDivElement | null>(null);
  const pendingThreadSelectionRef = useRef<string | null>(null);
  const subscribedGraphsRef = useRef<Set<string>>(new Set());

  const { subscribeToGraph, unsubscribeFromGraph } = useWebSocket();
  const location = useLocation();
  const [graphFilterId, setGraphFilterId] = useState<string | undefined>(
    undefined,
  );

  const handleThreadChatSwitchRequest = useCallback(
    (externalThreadId: string | null) => {
      pendingThreadSelectionRef.current = externalThreadId;
    },
    [],
  );

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const incomingGraphId = params.get('graphId') ?? undefined;
    setGraphFilterId((prev) =>
      prev === incomingGraphId ? prev : incomingGraphId,
    );
  }, [location.search]);

  useEffect(() => {
    setThreads([]);
    setThreadsOffset(0);
    setThreadsHasMore(true);
    setSelectedThreadId(undefined);
  }, [graphFilterId]);

  const selectedThread = useMemo(
    () => threads.find((thread) => thread.id === selectedThreadId),
    [threads, selectedThreadId],
  );

  // Update trigger nodes when selected thread or graph cache changes
  useEffect(() => {
    if (!selectedThread) {
      setTriggerNodesForSelectedThread([]);
      return;
    }

    const graphEntry = graphCache[selectedThread.graphId];
    if (graphEntry) {
      setTriggerNodesForSelectedThread(graphEntry.triggerNodes ?? []);
    } else {
      setTriggerNodesForSelectedThread([]);
    }
  }, [selectedThread, graphCache]);

  // Load templates once
  useEffect(() => {
    let mounted = true;
    const fetchTemplates = async () => {
      try {
        setTemplatesLoading(true);
        const response = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templateList = response.data || [];
        const map = templateList.reduce<Record<string, TemplateDto>>(
          (acc, template) => {
            acc[template.name] = template;
            return acc;
          },
          {},
        );
        setTemplatesByName(map);
      } catch (error) {
        console.error('Error loading templates', error);
        antdMessage.error('Failed to load templates metadata');
      } finally {
        if (mounted) {
          setTemplatesLoading(false);
        }
      }
    };

    void fetchTemplates();
    return () => {
      mounted = false;
    };
  }, []);

  // Cleanup subscriptions on unmount
  useEffect(() => {
    return () => {
      subscribedGraphsRef.current.forEach((graphId) => {
        unsubscribeFromGraph(graphId);
      });
      subscribedGraphsRef.current.clear();
    };
  }, [unsubscribeFromGraph]);

  const ensureGraphsLoaded = useCallback(
    async (threadsToCheck: ThreadDto[]) => {
      if (!threadsToCheck.length) return;
      const uniqueGraphIds = Array.from(
        new Set(threadsToCheck.map((thread) => thread.graphId)),
      );

      uniqueGraphIds.forEach((graphId) => {
        if (!subscribedGraphsRef.current.has(graphId)) {
          subscribeToGraph(graphId);
          subscribedGraphsRef.current.add(graphId);
        }
      });

      const missingGraphIds = uniqueGraphIds.filter(
        (graphId) => !graphCache[graphId],
      );
      if (!missingGraphIds.length) return;

      try {
        const responses = await Promise.all(
          missingGraphIds.map((graphId) => graphsApi.findGraphById(graphId)),
        );

        setGraphCache((prev) => {
          const next = { ...prev };
          responses.forEach((res, idx) => {
            const graph = res.data;
            if (!graph) return;
            next[missingGraphIds[idx]] = {
              graph,
              triggerNodes: buildTriggerNodes(graph, templatesByName),
              nodeDisplayNames: buildNodeDisplayNames(graph),
            };
          });
          return next;
        });
      } catch (error) {
        console.error('Error loading graph metadata', error);
        antdMessage.error('Failed to load graph metadata for threads');
      }
    },
    [graphCache, subscribeToGraph, templatesByName],
  );

  // Ensure graph metadata and trigger nodes are ready for the selected thread
  useEffect(() => {
    if (!selectedThread) return;

    const graphEntry = graphCache[selectedThread.graphId];

    // If graph metadata missing, load it
    if (!graphEntry) {
      void ensureGraphsLoaded([selectedThread]);
      return;
    }

    // If graph exists but trigger nodes were empty, rebuild once templates are available
    if (
      graphEntry.triggerNodes.length === 0 &&
      Object.keys(templatesByName).length > 0
    ) {
      const updatedTriggers = buildTriggerNodes(
        graphEntry.graph,
        templatesByName,
      );
      if (updatedTriggers.length > 0) {
        setGraphCache((prev) => ({
          ...prev,
          [selectedThread.graphId]: {
            ...graphEntry,
            triggerNodes: updatedTriggers,
          },
        }));
      }
    }
  }, [selectedThread, graphCache, ensureGraphsLoaded, templatesByName]);

  // Recompute trigger nodes when templates change
  useEffect(() => {
    if (!Object.keys(templatesByName).length) return;
    setGraphCache((prev) => {
      const nextEntries: Record<string, GraphCacheEntry> = {};
      let changed = false;
      Object.entries(prev).forEach(([graphId, entry]) => {
        const updatedTriggers = buildTriggerNodes(entry.graph, templatesByName);
        nextEntries[graphId] = {
          graph: entry.graph,
          triggerNodes: updatedTriggers,
          nodeDisplayNames: entry.nodeDisplayNames,
        };
        if (updatedTriggers.length !== entry.triggerNodes.length) {
          changed = true;
        }
      });
      return changed ? nextEntries : prev;
    });
  }, [templatesByName]);

  const loadThreads = useCallback(
    async (options?: { append?: boolean }) => {
      const isAppend = options?.append ?? false;
      if (isAppend) {
        if (!threadsHasMore || threadsLoadingMore) return;
        setThreadsLoadingMore(true);
      } else if (threadsLoading) {
        return;
      } else {
        setThreadsLoading(true);
      }

      try {
        const response = await threadsApi.getThreads(
          graphFilterId,
          THREADS_PAGE_SIZE,
          isAppend ? threadsOffset : 0,
        );
        const fetched = response.data || [];

        setThreads((prev) => {
          if (!isAppend) {
            return fetched;
          }
          const existingIds = new Set(prev.map((thread) => thread.id));
          const merged = [
            ...prev,
            ...fetched.filter((thread) => !existingIds.has(thread.id)),
          ];
          return merged;
        });

        setThreadsOffset((current) =>
          isAppend ? current + fetched.length : fetched.length,
        );
        setThreadsHasMore(fetched.length === THREADS_PAGE_SIZE);

        void ensureGraphsLoaded(fetched);
      } catch (error) {
        console.error('Error loading threads', error);
        antdMessage.error('Failed to load threads list');
        setThreadsHasMore(false);
      } finally {
        if (isAppend) {
          setThreadsLoadingMore(false);
        } else {
          setThreadsLoading(false);
        }
      }
    },
    [
      ensureGraphsLoaded,
      graphFilterId,
      threadsHasMore,
      threadsLoading,
      threadsLoadingMore,
      threadsOffset,
    ],
  );

  useEffect(() => {
    void loadThreads();
    // We intentionally re-fetch only when graph filter changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graphFilterId]);

  // Auto select first thread if none selected
  useEffect(() => {
    if (!threads.length) {
      setSelectedThreadId(undefined);
      return;
    }

    if (!selectedThreadId) {
      setSelectedThreadId(threads[0].id);
      return;
    }

    const stillExists = threads.some(
      (thread) => thread.id === selectedThreadId,
    );
    if (!stillExists) {
      setSelectedThreadId(threads[0].id);
    }
  }, [threads, selectedThreadId]);

  const handleThreadsScroll = useCallback(() => {
    const el = threadsContainerRef.current;
    if (!el) return;
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    if (
      nearBottom &&
      threadsHasMore &&
      !threadsLoadingMore &&
      !threadsLoading
    ) {
      void loadThreads({ append: true });
    }
  }, [loadThreads, threadsHasMore, threadsLoading, threadsLoadingMore]);

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      if (!newThread) return;
      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          return prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
        }
        return [newThread, ...prev];
      });
      void ensureGraphsLoaded([newThread]);

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [ensureGraphsLoaded],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return next;
      });
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadId === deletedThread.id) {
        setSelectedThreadId(undefined);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [selectedThreadId],
  );

  useWebSocketEvent(
    'thread.create',
    (notification) =>
      handleThreadCreateEvent(notification as ThreadCreateNotification),
    [handleThreadCreateEvent],
  );
  useWebSocketEvent(
    'thread.update',
    (notification) =>
      handleThreadUpdateEvent(notification as ThreadUpdateNotification),
    [handleThreadUpdateEvent],
  );
  useWebSocketEvent(
    'thread.delete',
    (notification) =>
      handleThreadDeleteEvent(notification as ThreadDeleteNotification),
    [handleThreadDeleteEvent],
  );
  const threadStatusMeta = selectedThread
    ? getThreadStatusDisplay(selectedThread.status)
    : null;

  const filteredGraphLabel = useMemo(() => {
    if (!graphFilterId) return undefined;
    const graphName = graphCache[graphFilterId]?.graph.name;
    if (graphName && graphName.trim().length > 0) {
      return graphName;
    }
    if (graphFilterId.length <= 10) {
      return graphFilterId;
    }
    return `…${graphFilterId.slice(-6)}`;
  }, [graphFilterId, graphCache]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          setSelectedThreadId(undefined);
        }
        antdMessage.success('Thread deleted successfully');
      } catch (error) {
        console.error('Error deleting thread:', error);
        antdMessage.error('Failed to delete thread');
      }
    },
    [selectedThreadId],
  );

  const renderThreadItem = (thread: ThreadDto) => {
    const isActive = thread.id === selectedThreadId;
    const statusMeta = getThreadStatusDisplay(thread.status);
    const graphName = graphCache[thread.graphId]?.graph.name;
    const createdAt = new Date(thread.createdAt).toLocaleString();

    return (
      <div
        key={thread.id}
        onClick={() => setSelectedThreadId(thread.id)}
        onMouseEnter={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fafafa';
          }
        }}
        onMouseLeave={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fff';
          }
        }}
        style={{
          padding: '12px 16px',
          borderBottom: '1px solid #f0f0f0',
          cursor: 'pointer',
          backgroundColor: isActive ? '#f5f9ff' : '#fff',
          overflow: 'hidden',
          transition: 'background-color 0.2s ease',
        }}>
        <Space
          direction="vertical"
          size={4}
          style={{ width: '100%', minWidth: 0 }}>
          <div
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: 8,
              minWidth: 0,
            }}>
            <div style={{ flex: 1, minWidth: 0 }}>
              <Text
                strong
                ellipsis={{
                  tooltip: thread.name || `Thread ${thread.id.slice(-6)}`,
                }}
                style={{
                  width: '100%',
                  display: 'block',
                }}>
                {thread.name || `Thread ${thread.id.slice(-6)}`}
              </Text>
            </div>
            {statusMeta && (
              <Tag
                color={statusMeta.color}
                style={{ margin: 0, flexShrink: 0, whiteSpace: 'nowrap' }}>
                {statusMeta.label}
              </Tag>
            )}
            <Dropdown
              menu={{
                items: [
                  {
                    key: 'delete',
                    label: (
                      <Popconfirm
                        title="Delete thread"
                        description="Are you sure you want to delete this thread?"
                        onConfirm={(e) => {
                          e?.stopPropagation();
                          handleDeleteThread(thread.id);
                        }}
                        onCancel={(e) => e?.stopPropagation()}
                        okText="Delete"
                        cancelText="Cancel"
                        okButtonProps={{ danger: true }}>
                        <div
                          onClick={(e) => e.stopPropagation()}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: 8,
                          }}>
                          <DeleteOutlined />
                          Delete
                        </div>
                      </Popconfirm>
                    ),
                  },
                ],
              }}
              trigger={['click']}
              placement="bottomRight">
              <Button
                type="text"
                size="small"
                icon={<EllipsisOutlined />}
                onClick={(e) => e.stopPropagation()}
                style={{
                  flexShrink: 0,
                  padding: '4px 8px',
                }}
              />
            </Dropdown>
          </div>
          <Text
            type="secondary"
            title={graphName || 'Loading graph…'}
            style={{
              fontSize: 12,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              minWidth: 0,
            }}>
            {graphName || 'Loading graph…'}
          </Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Created {createdAt}
          </Text>
        </Space>
      </div>
    );
  };

  const threadsEmpty =
    !threadsLoading && !threadsLoadingMore && threads.length === 0;

  return (
    <div
      style={{
        height: 'calc(100vh - 64px)',
        maxHeight: 'calc(100vh - 64px)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}>
      <div
        style={{
          display: 'flex',
          flex: 1,
          minHeight: 0,
          overflow: 'hidden',
        }}>
        <div
          style={{
            width: 340,
            borderRight: '1px solid #f0f0f0',
            display: 'flex',
            flexDirection: 'column',
            background: '#fff',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <Space
              align="center"
              style={{ width: '100%', justifyContent: 'space-between' }}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                <Title level={4} style={{ margin: 0 }}>
                  Chats
                </Title>
                {graphFilterId && (
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    Showing threads for graph:{' '}
                    <span style={{ fontWeight: 600 }}>
                      {filteredGraphLabel}
                    </span>
                  </Text>
                )}
              </div>
              <Button
                size="small"
                icon={<ReloadOutlined />}
                onClick={() => loadThreads()}
                loading={threadsLoading}
                style={{
                  border: 'none',
                }}
              />
            </Space>
          </div>
          <div
            ref={threadsContainerRef}
            onScroll={handleThreadsScroll}
            style={{
              flex: 1,
              minHeight: 0,
              overflowY: 'auto',
            }}>
            {threads.map(renderThreadItem)}
            {threadsLoading && (
              <div style={{ padding: 24, textAlign: 'center' }}>
                <Spin />
              </div>
            )}
            {threadsEmpty && (
              <div style={{ padding: 24 }}>
                <Empty
                  description={
                    graphFilterId
                      ? 'No threads found for this graph'
                      : 'No threads yet'
                  }
                />
              </div>
            )}
            {threadsLoadingMore && (
              <div style={{ padding: 12, textAlign: 'center' }}>
                <Spin size="small" />
              </div>
            )}
          </div>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: 24,
              display: 'flex',
              flexDirection: 'column',
              flex: 1,
              minHeight: 0,
              background: '#fff',
              overflow: 'hidden',
            }}>
            {selectedThread ? (
              <>
                <div
                  style={{
                    marginBottom: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}>
                  <div>
                    <Title level={4} style={{ margin: 0 }}>
                      {selectedThread.name ||
                        `Thread ${selectedThread.id.slice(-6)}`}
                    </Title>
                    <Space size="small" wrap>
                      <Text type="secondary">
                        Graph:{' '}
                        {graphCache[selectedThread.graphId]?.graph.name ||
                          'Loading…'}
                      </Text>
                      <Link
                        to={`/graphs/${selectedThread.graphId}`}
                        style={{
                          display: 'inline-flex',
                          alignItems: 'center',
                          color: '#1677ff',
                          textDecoration: 'none',
                          position: 'relative',
                          top: '2px',
                          padding: '0 3px',
                        }}
                        aria-label="Open graph details"
                        title="Open graph details">
                        <LinkOutlined />
                      </Link>
                      {threadStatusMeta && (
                        <Tag color={threadStatusMeta.color}>
                          {threadStatusMeta.label}
                        </Tag>
                      )}
                    </Space>
                  </div>
                </div>

                <div
                  style={{
                    flex: 1,
                    minHeight: 0,
                    display: 'flex',
                    flexDirection: 'column',
                  }}>
                  <ThreadChatPanel
                    graphId={selectedThread.graphId}
                    thread={selectedThread}
                    triggerNodes={triggerNodesForSelectedThread}
                    templatesLoading={templatesLoading}
                    nodeDisplayNames={
                      graphCache[selectedThread.graphId]?.nodeDisplayNames
                    }
                    graphLoaded={Boolean(graphCache[selectedThread.graphId])}
                    onRequestThreadSwitch={handleThreadChatSwitchRequest}
                  />
                </div>
              </>
            ) : (
              <div
                style={{
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}>
                <Empty
                  description="Select a thread to view its messages"
                  image={Empty.PRESENTED_IMAGE_SIMPLE}
                />
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ChatsPage;
