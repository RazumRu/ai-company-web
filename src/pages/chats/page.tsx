import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  Typography,
  Button,
  Space,
  Spin,
  Tag,
  Input,
  Empty,
  Dropdown,
  Popconfirm,
  message as antdMessage,
} from 'antd';
import {
  ReloadOutlined,
  SendOutlined,
  EllipsisOutlined,
  DeleteOutlined,
} from '@ant-design/icons';
import type {
  ExecuteTriggerDto,
  GraphDto,
  TemplateDto,
  ThreadDto,
  ThreadMessageDto,
} from '../../autogenerated';
import { ThreadDtoStatusEnum } from '../../autogenerated';
import { graphsApi, templatesApi, threadsApi } from '../../api';
import ThreadMessagesView from '../graphs/components/ThreadMessagesView';
import { useWebSocket, useWebSocketEvent } from '../../hooks/useWebSocket';
import type {
  AgentMessageNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import { mergeMessagesReplacingStreaming } from '../../utils/threadMessages';
import { getThreadStatusDisplay } from '../../utils/threadStatus';

const THREADS_PAGE_SIZE = 30;
const MESSAGES_PAGE_SIZE = 50;

const { Title, Text } = Typography;

interface TriggerNodeInfo {
  id: string;
  name: string;
  template: string;
}

interface GraphCacheEntry {
  graph: GraphDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames: Record<string, string>;
}

const buildTriggerNodes = (
  graph: GraphDto,
  templates: Record<string, TemplateDto>,
): TriggerNodeInfo[] => {
  const metadataNodes =
    graph.metadata?.nodes?.reduce<Record<string, string>>((acc, node) => {
      acc[node.id] = node.name ?? '';
      return acc;
    }, {}) ?? {};

  const nodes = graph.schema?.nodes ?? [];
  return nodes
    .filter((node) => {
      const template = templates[node.template];
      return (template?.kind ?? '').toLowerCase() === 'trigger';
    })
    .map((node) => ({
      id: node.id,
      name: metadataNodes[node.id] || node.template,
      template: node.template,
    }));
};

const buildNodeDisplayNames = (graph: GraphDto): Record<string, string> => {
  const metadataNodes = graph.metadata?.nodes ?? [];
  return metadataNodes.reduce<Record<string, string>>((acc, node) => {
    if (!node.id) {
      return acc;
    }
    const metadataName = node.name?.trim();
    if (metadataName && metadataName.length > 0) {
      acc[node.id] = metadataName;
    }
    return acc;
  }, {});
};

const extractThreadSubId = (externalThreadId?: string | null) => {
  if (!externalThreadId) return undefined;
  const parts = externalThreadId.split(':');
  return parts[parts.length - 1];
};

export const ChatsPage = () => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [threadsOffset, setThreadsOffset] = useState(0);
  const [threadsHasMore, setThreadsHasMore] = useState(true);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadsLoadingMore, setThreadsLoadingMore] = useState(false);

  const [messages, setMessages] = useState<ThreadMessageDto[]>([]);
  const [messagesLoading, setMessagesLoading] = useState(false);
  const [messagesLoadingMore, setMessagesLoadingMore] = useState(false);
  const [messagesOffset, setMessagesOffset] = useState(0);
  const [hasMoreMessages, setHasMoreMessages] = useState(false);

  const [selectedThreadId, setSelectedThreadId] = useState<string | undefined>(
    undefined,
  );
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(undefined);

  const [graphCache, setGraphCache] = useState<Record<string, GraphCacheEntry>>(
    {},
  );
  const [templatesByName, setTemplatesByName] = useState<
    Record<string, TemplateDto>
  >({});
  const [templatesLoading, setTemplatesLoading] = useState(false);

  const [selectedTriggerId, setSelectedTriggerId] = useState<
    string | undefined
  >(undefined);
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [triggerNodesForSelectedThread, setTriggerNodesForSelectedThread] =
    useState<TriggerNodeInfo[]>([]);

  const threadsContainerRef = useRef<HTMLDivElement | null>(null);
  const pendingThreadSelectionRef = useRef<string | null>(null);
  const subscribedGraphsRef = useRef<Set<string>>(new Set());

  const { subscribeToGraph, unsubscribeFromGraph } = useWebSocket();

  const selectedThread = useMemo(
    () => threads.find((thread) => thread.id === selectedThreadId),
    [threads, selectedThreadId],
  );

  // Update trigger nodes when selected thread or graph cache changes
  useEffect(() => {
    if (!selectedThread) {
      setTriggerNodesForSelectedThread([]);
      setSelectedTriggerId(undefined);
      return;
    }

    const graphEntry = graphCache[selectedThread.graphId];
    if (graphEntry) {
      const triggers = graphEntry.triggerNodes ?? [];
      setTriggerNodesForSelectedThread(triggers);

      // Auto-select first trigger if none selected or current selection is invalid
      if (triggers.length > 0) {
        const isCurrentTriggerValid = triggers.some(
          (t) => t.id === selectedTriggerId,
        );
        if (!selectedTriggerId || !isCurrentTriggerValid) {
          setSelectedTriggerId(triggers[0].id);
        }
      } else {
        setSelectedTriggerId(undefined);
      }
    } else {
      // Graph not loaded yet
      setTriggerNodesForSelectedThread([]);
      setSelectedTriggerId(undefined);
    }
  }, [selectedThread, graphCache, selectedTriggerId]);

  // Load templates once
  useEffect(() => {
    let mounted = true;
    const fetchTemplates = async () => {
      try {
        setTemplatesLoading(true);
        const response = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templateList = response.data || [];
        const map = templateList.reduce<Record<string, TemplateDto>>(
          (acc, template) => {
            acc[template.name] = template;
            return acc;
          },
          {},
        );
        setTemplatesByName(map);
      } catch (error) {
        console.error('Error loading templates', error);
        antdMessage.error('Failed to load templates metadata');
      } finally {
        if (mounted) {
          setTemplatesLoading(false);
        }
      }
    };

    void fetchTemplates();
    return () => {
      mounted = false;
    };
  }, []);

  // Cleanup subscriptions on unmount
  useEffect(() => {
    return () => {
      subscribedGraphsRef.current.forEach((graphId) => {
        unsubscribeFromGraph(graphId);
      });
      subscribedGraphsRef.current.clear();
    };
  }, [unsubscribeFromGraph]);

  const ensureGraphsLoaded = useCallback(
    async (threadsToCheck: ThreadDto[]) => {
      if (!threadsToCheck.length) return;
      const uniqueGraphIds = Array.from(
        new Set(threadsToCheck.map((thread) => thread.graphId)),
      );

      uniqueGraphIds.forEach((graphId) => {
        if (!subscribedGraphsRef.current.has(graphId)) {
          subscribeToGraph(graphId);
          subscribedGraphsRef.current.add(graphId);
        }
      });

      const missingGraphIds = uniqueGraphIds.filter(
        (graphId) => !graphCache[graphId],
      );
      if (!missingGraphIds.length) return;

      try {
        const responses = await Promise.all(
          missingGraphIds.map((graphId) => graphsApi.findGraphById(graphId)),
        );

        setGraphCache((prev) => {
          const next = { ...prev };
          responses.forEach((res, idx) => {
            const graph = res.data;
            if (!graph) return;
            next[missingGraphIds[idx]] = {
              graph,
              triggerNodes: buildTriggerNodes(graph, templatesByName),
              nodeDisplayNames: buildNodeDisplayNames(graph),
            };
          });
          return next;
        });
      } catch (error) {
        console.error('Error loading graph metadata', error);
        antdMessage.error('Failed to load graph metadata for threads');
      }
    },
    [graphCache, subscribeToGraph, templatesByName],
  );

  // Ensure graph metadata and trigger nodes are ready for the selected thread
  useEffect(() => {
    if (!selectedThread) return;

    const graphEntry = graphCache[selectedThread.graphId];

    // If graph metadata missing, load it
    if (!graphEntry) {
      void ensureGraphsLoaded([selectedThread]);
      return;
    }

    // If graph exists but trigger nodes were empty, rebuild once templates are available
    if (
      graphEntry.triggerNodes.length === 0 &&
      Object.keys(templatesByName).length > 0
    ) {
      const updatedTriggers = buildTriggerNodes(
        graphEntry.graph,
        templatesByName,
      );
      if (updatedTriggers.length > 0) {
        setGraphCache((prev) => ({
          ...prev,
          [selectedThread.graphId]: {
            ...graphEntry,
            triggerNodes: updatedTriggers,
          },
        }));
      }
    }
  }, [selectedThread, graphCache, ensureGraphsLoaded, templatesByName]);

  // Recompute trigger nodes when templates change
  useEffect(() => {
    if (!Object.keys(templatesByName).length) return;
    setGraphCache((prev) => {
      const nextEntries: Record<string, GraphCacheEntry> = {};
      let changed = false;
      Object.entries(prev).forEach(([graphId, entry]) => {
        const updatedTriggers = buildTriggerNodes(entry.graph, templatesByName);
        nextEntries[graphId] = {
          graph: entry.graph,
          triggerNodes: updatedTriggers,
          nodeDisplayNames: entry.nodeDisplayNames,
        };
        if (updatedTriggers.length !== entry.triggerNodes.length) {
          changed = true;
        }
      });
      return changed ? nextEntries : prev;
    });
  }, [templatesByName]);

  const loadThreads = useCallback(
    async (options?: { append?: boolean }) => {
      const isAppend = options?.append ?? false;
      if (isAppend) {
        if (!threadsHasMore || threadsLoadingMore) return;
        setThreadsLoadingMore(true);
      } else if (threadsLoading) {
        return;
      } else {
        setThreadsLoading(true);
      }

      try {
        const response = await threadsApi.getThreads(
          undefined,
          THREADS_PAGE_SIZE,
          isAppend ? threadsOffset : 0,
        );
        const fetched = response.data || [];

        setThreads((prev) => {
          if (!isAppend) {
            return fetched;
          }
          const existingIds = new Set(prev.map((thread) => thread.id));
          const merged = [
            ...prev,
            ...fetched.filter((thread) => !existingIds.has(thread.id)),
          ];
          return merged;
        });

        setThreadsOffset((current) =>
          isAppend ? current + fetched.length : fetched.length,
        );
        setThreadsHasMore(fetched.length === THREADS_PAGE_SIZE);

        void ensureGraphsLoaded(fetched);
      } catch (error) {
        console.error('Error loading threads', error);
        antdMessage.error('Failed to load threads list');
        setThreadsHasMore(false);
      } finally {
        if (isAppend) {
          setThreadsLoadingMore(false);
        } else {
          setThreadsLoading(false);
        }
      }
    },
    [
      ensureGraphsLoaded,
      threadsHasMore,
      threadsLoading,
      threadsLoadingMore,
      threadsOffset,
    ],
  );

  const initialThreadsLoadedRef = useRef(false);

  useEffect(() => {
    if (initialThreadsLoadedRef.current) {
      return;
    }
    initialThreadsLoadedRef.current = true;
    void loadThreads();
  }, [loadThreads]);

  // Auto select first thread if none selected
  useEffect(() => {
    if (!threads.length) {
      setSelectedThreadId(undefined);
      setMessages([]);
      setHasMoreMessages(false);
      return;
    }

    if (!selectedThreadId) {
      setSelectedThreadId(threads[0].id);
      return;
    }

    const stillExists = threads.some(
      (thread) => thread.id === selectedThreadId,
    );
    if (!stillExists) {
      setSelectedThreadId(threads[0].id);
    }
  }, [threads, selectedThreadId]);

  const loadMessages = useCallback(async (threadId: string) => {
    try {
      setMessagesLoading(true);
      setMessages([]);
      setMessagesOffset(0);
      setHasMoreMessages(false);
      setSelectedThreadExternalId(undefined);

      const response = await threadsApi.getThreadMessages(
        threadId,
        undefined,
        MESSAGES_PAGE_SIZE,
        0,
      );

      const fetched = response.data?.reverse() || [];
      setMessages(fetched);
      setMessagesOffset(fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);

      const extId =
        fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
        undefined;
      setSelectedThreadExternalId(extId);
    } catch (error) {
      console.error('Error loading messages', error);
      antdMessage.error('Failed to load messages for thread');
      setMessages([]);
      setHasMoreMessages(false);
    } finally {
      setMessagesLoading(false);
    }
  }, []);

  useEffect(() => {
    if (!selectedThreadId) {
      setMessages([]);
      setHasMoreMessages(false);
      setSelectedThreadExternalId(undefined);
      return;
    }
    void loadMessages(selectedThreadId);
  }, [loadMessages, selectedThreadId]);

  const handleLoadMoreMessages = useCallback(async () => {
    if (
      !selectedThreadId ||
      messagesLoadingMore ||
      !hasMoreMessages ||
      messagesLoading
    ) {
      return;
    }
    try {
      setMessagesLoadingMore(true);
      const response = await threadsApi.getThreadMessages(
        selectedThreadId,
        undefined,
        MESSAGES_PAGE_SIZE,
        messagesOffset,
      );
      const fetched = response.data?.reverse() || [];
      setMessages((prev) => mergeMessagesReplacingStreaming(prev, fetched));
      setMessagesOffset((current) => current + fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);
    } catch (error) {
      console.error('Error loading more messages', error);
      antdMessage.error('Failed to load more messages');
      setHasMoreMessages(false);
    } finally {
      setMessagesLoadingMore(false);
    }
  }, [
    hasMoreMessages,
    messagesLoading,
    messagesLoadingMore,
    messagesOffset,
    selectedThreadId,
  ]);

  const handleThreadsScroll = useCallback(() => {
    const el = threadsContainerRef.current;
    if (!el) return;
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    if (
      nearBottom &&
      threadsHasMore &&
      !threadsLoadingMore &&
      !threadsLoading
    ) {
      void loadThreads({ append: true });
    }
  }, [loadThreads, threadsHasMore, threadsLoading, threadsLoadingMore]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedThread || !selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }
    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        selectedThread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto: ExecuteTriggerDto = {
        messages: [messageInput.trim()],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
      };
      const response = await graphsApi.executeTrigger(
        selectedThread.graphId,
        selectedTriggerId,
        executeTriggerDto,
      );
      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== selectedThread.externalThreadId;

      pendingThreadSelectionRef.current = shouldSelectNewThread
        ? returnedExternalThreadId
        : null;

      antdMessage.success('Message sent');
      setMessageInput('');
    } catch (error) {
      console.error('Error sending message', error);
      antdMessage.error('Failed to send message');
    } finally {
      setSendingMessage(false);
    }
  }, [
    selectedThread,
    selectedThreadExternalId,
    messageInput,
    selectedTriggerId,
  ]);

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      if (!newThread) return;
      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          return prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
        }
        return [newThread, ...prev];
      });
      void ensureGraphsLoaded([newThread]);

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [ensureGraphsLoaded],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return next;
      });
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadId === deletedThread.id) {
        setSelectedThreadId(undefined);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [selectedThreadId],
  );

  const handleAgentMessageEvent = useCallback(
    (notification: AgentMessageNotification) => {
      if (!selectedThreadId) return;
      if (notification.internalThreadId !== selectedThreadId) return;
      const incomingMessage = notification.data;
      setMessages((prev) =>
        mergeMessagesReplacingStreaming(prev, [incomingMessage]),
      );
      if (incomingMessage.externalThreadId) {
        setSelectedThreadExternalId(incomingMessage.externalThreadId);
      }
    },
    [selectedThreadId],
  );

  useWebSocketEvent(
    'thread.create',
    (notification) =>
      handleThreadCreateEvent(notification as ThreadCreateNotification),
    [handleThreadCreateEvent],
  );
  useWebSocketEvent(
    'thread.update',
    (notification) =>
      handleThreadUpdateEvent(notification as ThreadUpdateNotification),
    [handleThreadUpdateEvent],
  );
  useWebSocketEvent(
    'thread.delete',
    (notification) =>
      handleThreadDeleteEvent(notification as ThreadDeleteNotification),
    [handleThreadDeleteEvent],
  );
  useWebSocketEvent(
    'agent.message',
    (notification) =>
      handleAgentMessageEvent(notification as AgentMessageNotification),
    [handleAgentMessageEvent],
  );

  const threadStatusMeta = selectedThread
    ? getThreadStatusDisplay(selectedThread.status)
    : null;

  const memoizedThreadMessagesView = useMemo(() => {
    if (!selectedThread) {
      return null;
    }

    return (
      <ThreadMessagesView
        messages={messages}
        messagesLoading={messagesLoading}
        selectedThreadId={selectedThreadId}
        isAgentNode
        onLoadMoreMessages={
          hasMoreMessages ? handleLoadMoreMessages : undefined
        }
        hasMoreMessages={hasMoreMessages}
        loadingMore={messagesLoadingMore}
        isNodeRunning={selectedThread.status === ThreadDtoStatusEnum.Running}
        nodeDisplayNames={
          graphCache[selectedThread.graphId]?.nodeDisplayNames
        }
        showNodeHeadings
      />
    );
  }, [
    selectedThread,
    messages,
    messagesLoading,
    selectedThreadId,
    hasMoreMessages,
    handleLoadMoreMessages,
    messagesLoadingMore,
    graphCache,
  ]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          setSelectedThreadId(undefined);
          setMessages([]);
          setHasMoreMessages(false);
          setSelectedThreadExternalId(undefined);
        }
        antdMessage.success('Thread deleted successfully');
      } catch (error) {
        console.error('Error deleting thread:', error);
        antdMessage.error('Failed to delete thread');
      }
    },
    [selectedThreadId],
  );

  const renderThreadItem = (thread: ThreadDto) => {
    const isActive = thread.id === selectedThreadId;
    const statusMeta = getThreadStatusDisplay(thread.status);
    const graphName = graphCache[thread.graphId]?.graph.name;
    const createdAt = new Date(thread.createdAt).toLocaleString();

    return (
      <div
        key={thread.id}
        onClick={() => setSelectedThreadId(thread.id)}
        onMouseEnter={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fafafa';
          }
        }}
        onMouseLeave={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fff';
          }
        }}
        style={{
          padding: '12px 16px',
          borderBottom: '1px solid #f0f0f0',
          cursor: 'pointer',
          backgroundColor: isActive ? '#f5f9ff' : '#fff',
          overflow: 'hidden',
          transition: 'background-color 0.2s ease',
        }}>
        <Space
          direction="vertical"
          size={4}
          style={{ width: '100%', minWidth: 0 }}>
          <div
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: 8,
              minWidth: 0,
            }}>
            <div style={{ flex: 1, minWidth: 0 }}>
              <Text
                strong
                ellipsis={{
                  tooltip: thread.name || `Thread ${thread.id.slice(-6)}`,
                }}
                style={{
                  width: '100%',
                  display: 'block',
                }}>
                {thread.name || `Thread ${thread.id.slice(-6)}`}
              </Text>
            </div>
            {statusMeta && (
              <Tag
                color={statusMeta.color}
                style={{ margin: 0, flexShrink: 0, whiteSpace: 'nowrap' }}>
                {statusMeta.label}
              </Tag>
            )}
            <Dropdown
              menu={{
                items: [
                  {
                    key: 'delete',
                    label: (
                      <Popconfirm
                        title="Delete thread"
                        description="Are you sure you want to delete this thread?"
                        onConfirm={(e) => {
                          e?.stopPropagation();
                          handleDeleteThread(thread.id);
                        }}
                        onCancel={(e) => e?.stopPropagation()}
                        okText="Delete"
                        cancelText="Cancel"
                        okButtonProps={{ danger: true }}>
                        <div
                          onClick={(e) => e.stopPropagation()}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: 8,
                          }}>
                          <DeleteOutlined />
                          Delete
                        </div>
                      </Popconfirm>
                    ),
                  },
                ],
              }}
              trigger={['click']}
              placement="bottomRight">
              <Button
                type="text"
                size="small"
                icon={<EllipsisOutlined />}
                onClick={(e) => e.stopPropagation()}
                style={{
                  flexShrink: 0,
                  padding: '4px 8px',
                }}
              />
            </Dropdown>
          </div>
          <Text
            type="secondary"
            title={graphName || 'Loading graph…'}
            style={{
              fontSize: 12,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              minWidth: 0,
            }}>
            {graphName || 'Loading graph…'}
          </Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Created {createdAt}
          </Text>
        </Space>
      </div>
    );
  };

  const threadsEmpty =
    !threadsLoading && !threadsLoadingMore && threads.length === 0;

  return (
    <div
      style={{
        height: 'calc(100vh - 64px)',
        maxHeight: 'calc(100vh - 64px)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}>
      <div
        style={{
          display: 'flex',
          flex: 1,
          minHeight: 0,
          overflow: 'hidden',
        }}>
        <div
          style={{
            width: 340,
            borderRight: '1px solid #f0f0f0',
            display: 'flex',
            flexDirection: 'column',
            background: '#fff',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <Space
              align="center"
              style={{ width: '100%', justifyContent: 'space-between' }}>
              <Title level={4} style={{ margin: 0 }}>
                Chats
              </Title>
              <Button
                size="small"
                icon={<ReloadOutlined />}
                onClick={() => loadThreads()}
                loading={threadsLoading}
                style={{
                  border: 'none',
                }}
              />
            </Space>
          </div>
          <div
            ref={threadsContainerRef}
            onScroll={handleThreadsScroll}
            style={{
              flex: 1,
              minHeight: 0,
              overflowY: 'auto',
            }}>
            {threads.map(renderThreadItem)}
            {threadsLoading && (
              <div style={{ padding: 24, textAlign: 'center' }}>
                <Spin />
              </div>
            )}
            {threadsEmpty && (
              <div style={{ padding: 24 }}>
                <Empty description="No threads yet" />
              </div>
            )}
            {threadsLoadingMore && (
              <div style={{ padding: 12, textAlign: 'center' }}>
                <Spin size="small" />
              </div>
            )}
          </div>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: 24,
              display: 'flex',
              flexDirection: 'column',
              flex: 1,
              minHeight: 0,
              background: '#fff',
              overflow: 'hidden',
            }}>
            {selectedThread ? (
              <>
                <div
                  style={{
                    marginBottom: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}>
                  <div>
                    <Title level={4} style={{ margin: 0 }}>
                      {selectedThread.name ||
                        `Thread ${selectedThread.id.slice(-6)}`}
                    </Title>
                    <Space size="small" wrap>
                      <Text type="secondary">
                        Graph:{' '}
                        {graphCache[selectedThread.graphId]?.graph.name ||
                          'Loading…'}
                      </Text>
                      {threadStatusMeta && (
                        <Tag color={threadStatusMeta.color}>
                          {threadStatusMeta.label}
                        </Tag>
                      )}
                    </Space>
                  </div>
                </div>

                <div
                  style={{
                    flex: 1,
                    minHeight: 0,
                    border: '1px solid #f0f0f0',
                    borderRadius: 8,
                    background: '#fafafa',
                    display: 'flex',
                    flexDirection: 'column',
                    overflow: 'hidden',
                  }}>
                  {memoizedThreadMessagesView}
                </div>

                <div
                  style={{
                    marginTop: 16,
                    padding: '12px 16px',
                    border: '1px solid #f0f0f0',
                    borderRadius: 8,
                    background: '#fff',
                  }}>
                  {triggerNodesForSelectedThread.length > 0 ? (
                    <div
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 12,
                      }}>
                      <Dropdown
                        menu={{
                          items: triggerNodesForSelectedThread.map(
                            (trigger) => ({
                              key: trigger.id,
                              label: trigger.name,
                              onClick: () => setSelectedTriggerId(trigger.id),
                            }),
                          ),
                          selectedKeys: selectedTriggerId
                            ? [selectedTriggerId]
                            : [],
                        }}
                        trigger={['click']}>
                        <Button
                          type="default"
                          size="middle"
                          style={{
                            flexShrink: 0,
                          }}>
                          {triggerNodesForSelectedThread.find(
                            (t) => t.id === selectedTriggerId,
                          )?.name || 'Select trigger'}
                        </Button>
                      </Dropdown>
                      <Input
                        placeholder="Type your message..."
                        value={messageInput}
                        onChange={(e) => setMessageInput(e.target.value)}
                        onPressEnter={(e) => {
                          if (!e.shiftKey) {
                            e.preventDefault();
                            handleSendMessage();
                          }
                        }}
                        disabled={sendingMessage || !selectedTriggerId}
                        style={{ flex: 1 }}
                      />
                      <Button
                        type="primary"
                        icon={<SendOutlined />}
                        onClick={handleSendMessage}
                        loading={sendingMessage}
                        disabled={
                          !messageInput.trim() ||
                          !selectedTriggerId ||
                          templatesLoading
                        }
                        style={{ flexShrink: 0 }}>
                        Send
                      </Button>
                    </div>
                  ) : (
                    <div style={{ textAlign: 'center', padding: '8px 0' }}>
                      <Text type="secondary" style={{ fontSize: 13 }}>
                        {templatesLoading
                          ? 'Loading triggers...'
                          : graphCache[selectedThread.graphId]
                            ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
                            : 'Loading graph data...'}
                      </Text>
                    </div>
                  )}
                </div>
              </>
            ) : (
              <div
                style={{
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}>
                <Empty
                  description="Select a thread to view its messages"
                  image={Empty.PRESENTED_IMAGE_SIMPLE}
                />
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ChatsPage;
