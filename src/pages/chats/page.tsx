import {
  BarChartOutlined,
  CloseOutlined,
  DeleteOutlined,
  EllipsisOutlined,
  LinkOutlined,
  PlusOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import {
  Avatar,
  Button,
  Dropdown,
  Empty,
  Input,
  message as antdMessage,
  Modal,
  Popconfirm,
  Popover,
  Select,
  Space,
  Spin,
  Tabs,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { isAxiosError } from 'axios';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Link, useLocation, useNavigate } from 'react-router';

import { graphsApi, litellmApi, templatesApi, threadsApi } from '../../api';
import type {
  GraphDto,
  LiteLlmModelDto,
  TemplateDto,
  ThreadDto,
  ThreadMessageDto,
  ThreadUsageStatisticsDto,
} from '../../autogenerated';
import {
  GetThreadsStatusesEnum,
  GraphDtoStatusEnum,
  ThreadDtoStatusEnum,
} from '../../autogenerated';
import { MarkdownContent } from '../../components/markdown/MarkdownContent';
import { useThreadMessageStore } from '../../hooks/useThreadMessageStore';
import { useWebSocket, useWebSocketEvent } from '../../hooks/useWebSocket';
import type {
  AgentMessageNotification,
  AgentStateUpdateNotification,
  GraphNodeUpdateNotification,
  SocketNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import { getAgentAvatarDataUri } from '../../utils/agentAvatars';
import { extractApiErrorMessage } from '../../utils/errors';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
  type TriggerNodeInfo,
} from '../../utils/graphThreads';
import {
  buildIdSet,
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../utils/threadMessages';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import { ThreadUsageDisplay } from '../graphs/components/ThreadUsageDisplay';
import ThreadChatPanel from './components/ThreadChatPanel';

const THREADS_PAGE_SIZE = 30;
const THREAD_MESSAGES_PAGE_SIZE = 100;
const MAX_THREAD_SOCKET_EVENTS = 200;

const { Title, Text } = Typography;

type ThreadTokenUsageSnapshot = {
  inputTokens?: number;
  cachedInputTokens?: number;
  outputTokens?: number;
  reasoningTokens?: number;
  totalTokens?: number;
  totalPrice?: number;
  currentContext?: number;
};

type ThreadSocketEventEntry = {
  id: string;
  receivedAt: string;
  type: string;
  nodeId?: string;
  runId?: string;
  graphId?: string;
  payload: SocketNotification;
};

const mergeTokenUsageByNode = (
  baseline: Record<string, ThreadTokenUsageSnapshot>,
  overrides: Record<string, ThreadTokenUsageSnapshot>,
): Record<string, ThreadTokenUsageSnapshot> => {
  const keys = new Set([...Object.keys(baseline), ...Object.keys(overrides)]);
  const merged: Record<string, ThreadTokenUsageSnapshot> = {};
  keys.forEach((key) => {
    merged[key] = { ...(baseline[key] ?? {}), ...(overrides[key] ?? {}) };
  });
  return merged;
};

const formatUsd = (amount?: number | null): string => {
  if (typeof amount !== 'number' || !Number.isFinite(amount)) return '$—';
  if (amount === 0 || (amount > 0 && amount < 0.01)) return '<$0.01';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
};

const formatCompactNumber = (value?: number | null): string => {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '—';
  return new Intl.NumberFormat('en-US', {
    notation: 'compact',
    compactDisplay: 'short',
    maximumFractionDigits: 0,
  }).format(value);
};

const safeNumber = (value: unknown): number | undefined => {
  return typeof value === 'number' && Number.isFinite(value)
    ? value
    : undefined;
};

const compactUsageUpdate = (
  source: AgentStateUpdateNotification['data'],
): Partial<ThreadTokenUsageSnapshot> => {
  const next: Partial<ThreadTokenUsageSnapshot> = {};

  const inputTokens = safeNumber(source?.inputTokens);
  if (inputTokens !== undefined) next.inputTokens = inputTokens;

  const cachedInputTokens = safeNumber(source?.cachedInputTokens);
  if (cachedInputTokens !== undefined)
    next.cachedInputTokens = cachedInputTokens;

  const outputTokens = safeNumber(source?.outputTokens);
  if (outputTokens !== undefined) next.outputTokens = outputTokens;

  const reasoningTokens = safeNumber(source?.reasoningTokens);
  if (reasoningTokens !== undefined) next.reasoningTokens = reasoningTokens;

  const totalTokens = safeNumber(source?.totalTokens);
  if (totalTokens !== undefined) next.totalTokens = totalTokens;

  const totalPrice = safeNumber(source?.totalPrice);
  if (totalPrice !== undefined) next.totalPrice = totalPrice;

  const currentContext = safeNumber(source?.currentContext);
  if (currentContext !== undefined) next.currentContext = currentContext;

  return next;
};

const sumUsage = (
  usages: ThreadTokenUsageSnapshot[],
): ThreadTokenUsageSnapshot => {
  const sumField = (
    key: keyof ThreadTokenUsageSnapshot,
  ): number | undefined => {
    let hasAny = false;
    const total = usages.reduce((acc, usage) => {
      const value = usage[key];
      if (typeof value === 'number' && Number.isFinite(value)) {
        hasAny = true;
        return acc + value;
      }
      return acc;
    }, 0);
    return hasAny ? total : undefined;
  };

  const maxField = (
    key: keyof ThreadTokenUsageSnapshot,
  ): number | undefined => {
    let hasAny = false;
    const max = usages.reduce(
      (acc, usage) => {
        const value = usage[key];
        if (typeof value === 'number' && Number.isFinite(value)) {
          hasAny = true;
          return acc === undefined || value > acc ? value : acc;
        }
        return acc;
      },
      undefined as number | undefined,
    );
    return hasAny ? max : undefined;
  };

  return {
    inputTokens: sumField('inputTokens'),
    cachedInputTokens: sumField('cachedInputTokens'),
    outputTokens: sumField('outputTokens'),
    reasoningTokens: sumField('reasoningTokens'),
    totalTokens: sumField('totalTokens'),
    totalPrice: sumField('totalPrice'),
    currentContext: maxField('currentContext'),
  };
};

const clampPercent = (value: number): number => {
  if (!Number.isFinite(value)) return 0;
  return Math.max(0, Math.min(100, value));
};

const getPercentColor = (percent: number): string => {
  if (percent >= 90) return '#ff4d4f';
  if (percent >= 75) return '#faad14';
  return '#52c41a';
};

const ContextUsageGauge: React.FC<{
  percent: number;
  size?: number;
}> = ({ percent, size = 15 }) => {
  const safePercent = clampPercent(percent);
  const strokeWidth = 3;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const dashOffset = circumference * (1 - safePercent / 100);
  const color = getPercentColor(safePercent);
  const label = `${Math.round(safePercent)}%`;

  return (
    <span
      style={{
        width: size,
        height: size,
        position: 'relative',
        display: 'inline-block',
        verticalAlign: 'middle',
        flexShrink: 0,
      }}
      aria-label={`Context usage ${label}`}>
      <svg width={size} height={size} style={{ display: 'block' }}>
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="#d9d9d9"
          strokeWidth={strokeWidth}
          fill="transparent"
        />
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke={color}
          strokeWidth={strokeWidth}
          fill="transparent"
          strokeDasharray={circumference}
          strokeDashoffset={dashOffset}
          strokeLinecap="round"
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />
      </svg>
    </span>
  );
};

const ThreadTokenUsageLine: React.FC<{
  usage?: ThreadTokenUsageSnapshot | null;
  withPopover?: boolean;
  contextMaxTokens?: number;
  contextPercent?: number;
}> = ({ usage, withPopover = false, contextMaxTokens, contextPercent }) => {
  const totalTokens = usage?.totalTokens;
  const totalPrice = usage?.totalPrice;
  const currentContext = usage?.currentContext;
  if (typeof totalTokens !== 'number') return null;

  const percent =
    typeof contextPercent === 'number'
      ? contextPercent
      : typeof currentContext === 'number' &&
          typeof contextMaxTokens === 'number' &&
          Number.isFinite(contextMaxTokens) &&
          contextMaxTokens > 0
        ? (currentContext / contextMaxTokens) * 100
        : undefined;

  const line = (
    <span
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        gap: 8,
      }}>
      <Text type="secondary" style={{ fontSize: 12, margin: 0 }}>
        Token usage: {formatCompactNumber(totalTokens)} ({formatUsd(totalPrice)}
        )
      </Text>
      {typeof percent === 'number' && <ContextUsageGauge percent={percent} />}
    </span>
  );

  if (!withPopover) return line;

  const popoverContent = (
    <Space direction="vertical" size={2} style={{ maxWidth: 340 }}>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Input tokens: {usage?.inputTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Cached input tokens: {usage?.cachedInputTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Output tokens: {usage?.outputTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Reasoning tokens: {usage?.reasoningTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Total tokens: {usage?.totalTokens ?? '—'}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Total cost: {formatUsd(usage?.totalPrice)}
      </Text>
      <Text type="secondary" style={{ fontSize: 12 }}>
        Current context: {usage?.currentContext ?? '—'}
      </Text>
      {typeof percent === 'number' && (
        <Text type="secondary" style={{ fontSize: 12 }}>
          Context usage: {Math.round(clampPercent(percent))}%
          {typeof contextMaxTokens === 'number' &&
            Number.isFinite(contextMaxTokens) &&
            contextMaxTokens > 0 && (
              <> ({formatCompactNumber(contextMaxTokens)})</>
            )}
        </Text>
      )}
    </Space>
  );

  return (
    <Popover
      content={popoverContent}
      trigger={['hover']}
      placement="bottomLeft">
      <span style={{ display: 'inline-block' }}>{line}</span>
    </Popover>
  );
};

const isDraftThreadId = (threadId?: string | null): boolean => {
  return Boolean(threadId && threadId.startsWith('draft-'));
};

interface GraphCacheEntry {
  graph: GraphDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames: Record<string, string>;
}

interface DraftThread {
  id: string;
  graphId: string;
  name: string | null;
  status: 'draft';
  createdAt: string;
  updatedAt: string;
  externalThreadId: string;
  isDraft: true;
}

type ThreadStatusTabKey = 'open' | 'resolved' | 'all';

const isResolvedThreadStatus = (status?: ThreadDto['status']): boolean => {
  return status === ThreadDtoStatusEnum.Done;
};

const GRAPH_STATUS_META: Record<
  GraphDtoStatusEnum,
  { label: string; color: string }
> = {
  [GraphDtoStatusEnum.Running]: { label: 'Running', color: '#52c41a' },
  [GraphDtoStatusEnum.Compiling]: { label: 'Compiled', color: '#1677ff' },
  [GraphDtoStatusEnum.Created]: { label: 'Created', color: '#1677ff' },
  [GraphDtoStatusEnum.Stopped]: { label: 'Stopped', color: '#bfbfbf' },
  [GraphDtoStatusEnum.Error]: { label: 'Error', color: '#ff4d4f' },
};

const isValidationExceptionsError = (error: unknown): boolean => {
  if (!isAxiosError(error)) return false;

  const data: unknown = error.response?.data;
  if (!data) return false;

  if (typeof data === 'string') {
    return data.toLowerCase().includes('validation exception');
  }

  if (typeof data === 'object') {
    const message: unknown = (data as Record<string, unknown>)['message'];
    if (typeof message === 'string') {
      return message.toLowerCase().includes('validation exception');
    }
  }

  return false;
};

const normalizeIncomingCreatedAtForDisplay = (
  prev: ThreadMessageDto[],
  incoming: ThreadMessageDto,
): ThreadMessageDto => {
  // If we already have this message id, don't mutate timestamps.
  if (prev.some((m) => m.id === incoming.id)) return incoming;

  if (prev.length === 0) return incoming;
  const last = prev[prev.length - 1];
  const lastMs = new Date(last.createdAt).getTime();
  const incomingMs = new Date(incoming.createdAt).getTime();

  if (!Number.isFinite(lastMs) || !Number.isFinite(incomingMs)) {
    return incoming;
  }

  if (incomingMs >= lastMs) {
    return incoming;
  }

  return {
    ...incoming,
    createdAt: new Date(lastMs + 1).toISOString(),
  };
};

export const ChatsPage = () => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [threadsOffset, setThreadsOffset] = useState(0);
  const [threadsHasMore, setThreadsHasMore] = useState(true);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadsLoadingMore, setThreadsLoadingMore] = useState(false);

  const [threadStatusTab, setThreadStatusTab] =
    useState<ThreadStatusTabKey>('all');

  const [resolvedStatusesFilterSupported, setResolvedStatusesFilterSupported] =
    useState(true);

  const [selectedThreadId, setSelectedThreadId] = useState<string | undefined>(
    undefined,
  );
  const [selectedThreadShadow, setSelectedThreadShadow] =
    useState<ThreadDto | null>(null);
  const [selectedAgentNodeId, setSelectedAgentNodeId] = useState<string | null>(
    null,
  );
  const [draftThread, setDraftThread] = useState<DraftThread | null>(null);

  const [graphCache, setGraphCache] = useState<Record<string, GraphCacheEntry>>(
    {},
  );
  const [templatesById, setTemplatesById] = useState<
    Record<string, TemplateDto>
  >({});
  const [templatesLoading, setTemplatesLoading] = useState(false);

  const [threadTokenUsageByNode, setThreadTokenUsageByNode] = useState<
    Record<string, Record<string, ThreadTokenUsageSnapshot>>
  >({});

  const [threadUsageStats, setThreadUsageStats] = useState<
    Record<string, ThreadUsageStatisticsDto>
  >({});
  const [threadUsageStatsLoading, setThreadUsageStatsLoading] = useState<
    Record<string, boolean>
  >({});

  const [triggerNodesForSelectedThread, setTriggerNodesForSelectedThread] =
    useState<TriggerNodeInfo[]>([]);
  const [analyzeModalOpen, setAnalyzeModalOpen] = useState(false);
  const [analyzeLoading, setAnalyzeLoading] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<string | null>(null);
  const [analysisUserInput, setAnalysisUserInput] = useState('');
  const [analysisConversationId, setAnalysisConversationId] = useState<
    string | null
  >(null);
  const [analysisModel, setAnalysisModel] = useState<string | undefined>(
    undefined,
  );
  const [liteLlmModels, setLiteLlmModels] = useState<LiteLlmModelDto[]>([]);
  const [litellmModelsLoading, setLitellmModelsLoading] = useState(false);

  const [graphPickerOpen, setGraphPickerOpen] = useState(false);
  const [graphPickerLoading, setGraphPickerLoading] = useState(false);
  const [graphPickerGraphs, setGraphPickerGraphs] = useState<GraphDto[]>([]);
  const [graphPickerError, setGraphPickerError] = useState<string | null>(null);

  const [usageStatsModalOpen, setUsageStatsModalOpen] = useState(false);
  const [usageStatsModalThreadId, setUsageStatsModalThreadId] = useState<
    string | null
  >(null);
  const [threadSocketEvents, setThreadSocketEvents] = useState<
    Record<string, ThreadSocketEventEntry[]>
  >({});
  const [threadSocketEventsModalOpen, setThreadSocketEventsModalOpen] =
    useState(false);
  const [threadSocketEventsModalThreadId, setThreadSocketEventsModalThreadId] =
    useState<string | null>(null);

  const threadsContainerRef = useRef<HTMLDivElement | null>(null);
  const pendingThreadSelectionRef = useRef<string | null>(null);
  const subscribedGraphsRef = useRef<Set<string>>(new Set());

  const { subscribeToGraph, unsubscribeFromGraph } = useWebSocket();
  const location = useLocation();
  const navigate = useNavigate();
  const [graphFilterId, setGraphFilterId] = useState<string | undefined>(() => {
    const params = new URLSearchParams(location.search);
    return params.get('graphId') ?? undefined;
  });

  const {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
  } = useThreadMessageStore();

  const threadsRef = useRef<ThreadDto[]>([]);

  const getThreadTimestamp = useCallback((thread: ThreadDto) => {
    const value = thread.updatedAt ?? thread.createdAt;
    return value ? Date.parse(value) : Number.NaN;
  }, []);

  const resolveInternalThreadId = useCallback((externalThreadId?: string) => {
    if (!externalThreadId) return undefined;
    const found = threadsRef.current.find(
      (thread) => thread.externalThreadId === externalThreadId,
    );
    return found?.id;
  }, []);

  const appendThreadSocketEvent = useCallback(
    (threadId: string | undefined, notification: SocketNotification) => {
      if (!threadId) return;
      setThreadSocketEvents((prev) => {
        const existing = prev[threadId] ?? [];
        const receivedAt = new Date().toISOString();
        const nextEntry: ThreadSocketEventEntry = {
          id: `${threadId}-${Date.now()}-${existing.length}`,
          receivedAt,
          type: notification.type,
          nodeId: notification.nodeId,
          runId: notification.runId,
          graphId: notification.graphId,
          payload: notification,
        };
        const next = [...existing, nextEntry].slice(-MAX_THREAD_SOCKET_EVENTS);
        return { ...prev, [threadId]: next };
      });
    },
    [],
  );

  const sortThreadsByTimestampDesc = useCallback(
    (list: ThreadDto[]) => {
      return [...list].sort((a, b) => {
        const bTs = getThreadTimestamp(b);
        const aTs = getThreadTimestamp(a);
        const safeBTs = Number.isFinite(bTs) ? bTs : -Infinity;
        const safeATs = Number.isFinite(aTs) ? aTs : -Infinity;
        if (safeBTs !== safeATs) {
          return safeBTs - safeATs;
        }
        return (b.createdAt ?? '').localeCompare(a.createdAt ?? '');
      });
    },
    [getThreadTimestamp],
  );

  const isAgentNodeIdInGraph = useCallback(
    (graphId: string | undefined, nodeId: string | undefined): boolean => {
      if (!graphId || !nodeId) return false;
      const graph = graphCache[graphId]?.graph;
      if (!graph) return false;
      const schemaNode = (graph.schema?.nodes ?? []).find(
        (n) => n.id === nodeId,
      );
      if (!schemaNode) return false;
      const template = templatesById[schemaNode.template];
      // Prefer template.kind, but fall back to the well-known template id.
      const kind = (template?.kind || '').toLowerCase();
      return kind === 'simpleagent' || schemaNode.template === 'simple-agent';
    },
    [graphCache, templatesById],
  );

  const buildAgentMessageScopeKeysForGraph = useCallback(
    (graphId: string | undefined, nodeId: string | undefined) => {
      return isAgentNodeIdInGraph(graphId, nodeId)
        ? [undefined, nodeId]
        : [undefined];
    },
    [isAgentNodeIdInGraph],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadDtoStatusEnum.Done ||
        existing.status === ThreadDtoStatusEnum.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === ThreadDtoStatusEnum.Running
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  type MessageMeta = {
    loading: boolean;
    loadingMore: boolean;
    hasMore: boolean;
    offset: number;
    /**
     * When the initial (offset=0) fetch fails, we must not auto-retry in a loop.
     * This flag is cleared on an explicit user retry (force load).
     */
    initialLoadFailed: boolean;
  };

  const defaultMessageMeta = useMemo<MessageMeta>(
    () => ({
      loading: false,
      loadingMore: false,
      hasMore: true,
      offset: 0,
      initialLoadFailed: false,
    }),
    [],
  );

  const [messageMeta, setMessageMeta] = useState<Record<string, MessageMeta>>(
    {},
  );

  const getMessageMeta = useCallback(
    (threadId?: string): MessageMeta => {
      if (!threadId) return defaultMessageMeta;
      return messageMeta[threadId] ?? defaultMessageMeta;
    },
    [defaultMessageMeta, messageMeta],
  );

  const updateMessageMeta = useCallback(
    (threadId: string, updater: (prev: MessageMeta) => MessageMeta) => {
      setMessageMeta((prev) => {
        const existing = prev[threadId] ?? defaultMessageMeta;
        return {
          ...prev,
          [threadId]: updater(existing),
        };
      });
    },
    [defaultMessageMeta],
  );

  const loadMessagesForThread = useCallback(
    async (threadId: string, force = false) => {
      // Draft threads are local-only; they can never have persisted messages.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
          offset: prev.offset,
        }));
        return;
      }

      const meta = getMessageMeta(threadId);
      if (
        !force &&
        (meta.loading || meta.offset > 0 || meta.initialLoadFailed)
      ) {
        return;
      }

      updateMessageMeta(threadId, (prev) => ({
        ...prev,
        loading: true,
        loadingMore: false,
        hasMore: true,
        offset: force ? 0 : prev.offset,
        initialLoadFailed: false,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          undefined,
          THREAD_MESSAGES_PAGE_SIZE,
          0,
        );
        const fetched = response.data?.reverse() || [];
        updateMessages(threadId, () => fetched);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: fetched.length === THREAD_MESSAGES_PAGE_SIZE,
          offset: fetched.length,
        }));

        const extId =
          fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
          externalThreadIds[threadId];
        if (extId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: extId,
          }));
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load messages',
        );
        antdMessage.error(errorMessage);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
          initialLoadFailed: true,
        }));
      }
    },
    [
      getMessageMeta,
      updateMessageMeta,
      updateMessages,
      externalThreadIds,
      setExternalThreadIds,
    ],
  );

  const loadMoreMessagesForThread = useCallback(
    async (threadId: string) => {
      // Draft threads are local-only; there is nothing to paginate from the API.
      if (isDraftThreadId(threadId)) {
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
        return;
      }

      const meta = getMessageMeta(threadId);
      if (meta.loading || meta.loadingMore || !meta.hasMore) {
        return;
      }

      updateMessageMeta(threadId, (prev) => ({ ...prev, loadingMore: true }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          undefined,
          THREAD_MESSAGES_PAGE_SIZE,
          meta.offset,
        );
        const fetched = response.data?.reverse() || [];

        if (fetched.length > 0) {
          updateMessages(threadId, (prev) =>
            mergeMessagesReplacingStreaming(prev, fetched),
          );
          updateMessageMeta(threadId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: fetched.length === THREAD_MESSAGES_PAGE_SIZE,
            offset: prev.offset + fetched.length,
          }));
        } else {
          updateMessageMeta(threadId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: false,
          }));
        }
      } catch (error) {
        console.error('Error loading more messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load more messages',
        );
        antdMessage.error(errorMessage);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateMessages],
  );

  const handleThreadChatSwitchRequest = useCallback(
    (externalThreadId: string | null) => {
      pendingThreadSelectionRef.current = externalThreadId;
    },
    [],
  );

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const incomingGraphId = params.get('graphId') ?? undefined;
    setGraphFilterId((prev) =>
      prev === incomingGraphId ? prev : incomingGraphId,
    );
  }, [location.search]);

  useEffect(() => {
    setThreads([]);
    setThreadsOffset(0);
    setThreadsHasMore(true);
    setSelectedThreadId(undefined);
    setSelectedThreadShadow(null);
    setDraftThread(null);
  }, [graphFilterId]);

  const selectedThread = useMemo(() => {
    if (!selectedThreadId) return undefined;
    if (draftThread && draftThread.id === selectedThreadId) {
      return draftThread;
    }
    return (
      threads.find((thread) => thread.id === selectedThreadId) ??
      (selectedThreadShadow?.id === selectedThreadId
        ? selectedThreadShadow
        : undefined)
    );
  }, [threads, selectedThreadId, draftThread, selectedThreadShadow]);

  useEffect(() => {
    if (!selectedThreadId || isDraftThreadId(selectedThreadId)) {
      setSelectedThreadShadow(null);
      return;
    }

    const inList = threads.find((thread) => thread.id === selectedThreadId);
    if (inList) {
      setSelectedThreadShadow(inList);
      return;
    }

    let mounted = true;
    const fetchSelected = async () => {
      try {
        const res = await threadsApi.getThreadById(selectedThreadId);
        if (!mounted) return;
        if (res.data) {
          setSelectedThreadShadow(res.data);
        }
      } catch (error) {
        // Don't toast on background refresh; selection can still remain.
        console.warn('Failed to refresh selected thread', error);
      }
    };

    void fetchSelected();
    return () => {
      mounted = false;
    };
  }, [selectedThreadId, threads]);

  const threadStatusesFilter = useMemo<
    GetThreadsStatusesEnum[] | undefined
  >(() => {
    if (threadStatusTab === 'all') return undefined;
    if (threadStatusTab === 'open') {
      return [
        GetThreadsStatusesEnum.Running,
        GetThreadsStatusesEnum.NeedMoreInfo,
        GetThreadsStatusesEnum.Stopped,
      ];
    }
    if (!resolvedStatusesFilterSupported) return undefined;
    return [GetThreadsStatusesEnum.Done];
  }, [threadStatusTab, resolvedStatusesFilterSupported]);

  const filteredThreads = useMemo(() => {
    if (threadStatusTab === 'all') {
      return threads;
    }
    const matchesTab =
      threadStatusTab === 'resolved'
        ? (thread: ThreadDto) => isResolvedThreadStatus(thread.status)
        : (thread: ThreadDto) => !isResolvedThreadStatus(thread.status);

    const base = threads.filter(matchesTab);

    // Keep the currently selected thread visible even if it no longer matches the active tab filter.
    if (selectedThreadId && !isDraftThreadId(selectedThreadId)) {
      const selected =
        threads.find((thread) => thread.id === selectedThreadId) ??
        (selectedThreadShadow?.id === selectedThreadId
          ? selectedThreadShadow
          : null);
      if (selected && !base.some((thread) => thread.id === selected.id)) {
        return [selected, ...base];
      }
    }

    return base;
  }, [threadStatusTab, threads, selectedThreadId, selectedThreadShadow]);

  const shouldShowDraftThread = Boolean(draftThread);

  const handleThreadStatusTabChange = useCallback(
    (key: string) => {
      const nextTab = key as ThreadStatusTabKey;
      setThreadStatusTab(nextTab);
      setThreads([]);
      setThreadsOffset(0);
      setThreadsHasMore(true);
      setSelectedThreadId((prev) => {
        if (!draftThread) return undefined;
        if (prev !== draftThread.id) return undefined;
        return prev;
      });
    },
    [draftThread],
  );

  useEffect(() => {
    if (!selectedThreadId) return;

    if (draftThread && draftThread.id === selectedThreadId) {
      if (!shouldShowDraftThread) {
        setSelectedThreadId(undefined);
      }
    }
  }, [draftThread, selectedThreadId, shouldShowDraftThread]);

  useEffect(() => {
    // Reset agent filter when changing threads
    setSelectedAgentNodeId(null);
  }, [selectedThreadId]);

  useEffect(() => {
    setAnalyzeModalOpen(false);
    setAnalyzeLoading(false);
    setAnalysisResult(null);
    setAnalysisUserInput('');
    setAnalysisConversationId(null);
  }, [selectedThreadId]);

  useEffect(() => {
    // Don't load messages for draft threads
    if (!selectedThread || (selectedThread as DraftThread)?.isDraft) return;

    const meta = getMessageMeta(selectedThread.id);
    const existingMessages = messages[selectedThread.id]?.['all'] ?? [];

    if (existingMessages.length > 0) {
      if (meta.offset === 0) {
        updateMessageMeta(selectedThread.id, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          offset: existingMessages.length,
        }));
      }
      return;
    }

    // If the initial load failed, don't auto-retry. Let the user explicitly retry.
    if (meta.initialLoadFailed) {
      return;
    }

    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForThread(selectedThread.id);
    }
  }, [
    selectedThread,
    getMessageMeta,
    loadMessagesForThread,
    messages,
    updateMessageMeta,
  ]);

  // Update trigger nodes when selected thread or graph cache changes
  useEffect(() => {
    if (!selectedThread) {
      setTriggerNodesForSelectedThread([]);
      return;
    }

    const graphEntry = graphCache[selectedThread.graphId];
    if (graphEntry) {
      setTriggerNodesForSelectedThread(graphEntry.triggerNodes ?? []);
    } else {
      setTriggerNodesForSelectedThread([]);
    }
  }, [selectedThread, graphCache]);

  // Load thread usage statistics when a thread is selected with retry logic
  useEffect(() => {
    if (!selectedThread) {
      return;
    }

    // Check if this is a draft thread
    const isDraft =
      'isDraft' in selectedThread && selectedThread.isDraft === true;
    if (isDraft) {
      return;
    }

    const threadId = selectedThread.id;

    // Check if we already have stats or are loading
    if (threadUsageStats[threadId] || threadUsageStatsLoading[threadId]) {
      return;
    }

    let retryCount = 0;
    const maxRetries = 3;
    const retryDelay = 2000; // 2 seconds between retries
    let timeoutId: NodeJS.Timeout | null = null;

    const loadUsageStats = async () => {
      try {
        setThreadUsageStatsLoading((prev) => ({ ...prev, [threadId]: true }));
        const response = await threadsApi.getThreadUsageStatistics(threadId);
        setThreadUsageStats((prev) => ({ ...prev, [threadId]: response.data }));
        setThreadUsageStatsLoading((prev) => ({ ...prev, [threadId]: false }));
      } catch (error) {
        console.error(
          `Error loading thread usage statistics (attempt ${retryCount + 1}/${maxRetries + 1}):`,
          error,
        );

        // Retry logic: retry up to maxRetries times with a delay
        if (retryCount < maxRetries) {
          retryCount++;
          timeoutId = setTimeout(() => {
            void loadUsageStats();
          }, retryDelay);
        } else {
          // Max retries reached, give up
          setThreadUsageStatsLoading((prev) => ({
            ...prev,
            [threadId]: false,
          }));
          console.error(
            'Max retries reached for loading thread usage statistics',
          );
        }
      }
    };

    void loadUsageStats();

    // Cleanup function to cancel pending retry
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [selectedThread, threadUsageStats, threadUsageStatsLoading]);

  // Load templates once
  useEffect(() => {
    let mounted = true;
    const fetchTemplates = async () => {
      try {
        setTemplatesLoading(true);
        const response = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templateList = response.data || [];
        const map = templateList.reduce<Record<string, TemplateDto>>(
          (acc, template) => {
            acc[template.id] = template;
            return acc;
          },
          {},
        );
        setTemplatesById(map);
      } catch (error) {
        console.error('Error loading templates', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load templates metadata',
        );
        antdMessage.error(errorMessage);
      } finally {
        if (mounted) {
          setTemplatesLoading(false);
        }
      }
    };

    void fetchTemplates();
    return () => {
      mounted = false;
    };
  }, []);

  // Cleanup subscriptions on unmount
  useEffect(() => {
    const subscribedGraphs = subscribedGraphsRef.current;
    return () => {
      subscribedGraphs.forEach((graphId) => {
        unsubscribeFromGraph(graphId);
      });
      subscribedGraphs.clear();
    };
  }, [unsubscribeFromGraph]);

  useEffect(() => {
    if (!graphPickerOpen) return;
    let mounted = true;
    const loadGraphs = async () => {
      try {
        setGraphPickerLoading(true);
        setGraphPickerError(null);
        const response = await graphsApi.getAllGraphs();
        if (!mounted) return;
        setGraphPickerGraphs(response.data || []);
      } catch (error) {
        if (!mounted) return;
        console.error('Error loading graphs for picker', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load graphs',
        );
        setGraphPickerError(errorMessage);
        antdMessage.error(errorMessage);
      } finally {
        if (mounted) {
          setGraphPickerLoading(false);
        }
      }
    };

    void loadGraphs();
    return () => {
      mounted = false;
    };
  }, [graphPickerOpen]);

  const ensureGraphsLoaded = useCallback(
    async (threadsToCheck: (ThreadDto | DraftThread)[]) => {
      if (!threadsToCheck.length) return;
      const uniqueGraphIds = Array.from(
        new Set(threadsToCheck.map((thread) => thread.graphId)),
      );

      uniqueGraphIds.forEach((graphId) => {
        if (!subscribedGraphsRef.current.has(graphId)) {
          subscribeToGraph(graphId);
          subscribedGraphsRef.current.add(graphId);
        }
      });

      const missingGraphIds = uniqueGraphIds.filter(
        (graphId) => !graphCache[graphId],
      );
      if (!missingGraphIds.length) return;

      try {
        // Use getAllGraphs with ids parameter to fetch all missing graphs in one request
        const response = await graphsApi.getAllGraphs(missingGraphIds);
        const graphs = response.data || [];

        setGraphCache((prev) => {
          const next = { ...prev };
          graphs.forEach((graph) => {
            next[graph.id] = {
              graph,
              triggerNodes: buildTriggerNodes(graph, templatesById),
              nodeDisplayNames: buildNodeDisplayNames(graph),
            };
          });
          return next;
        });
      } catch (error) {
        console.error('Error loading graph metadata', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load graph metadata for threads',
        );
        antdMessage.error(errorMessage);
      }
    },
    [graphCache, subscribeToGraph, templatesById],
  );

  // Ensure graph metadata and trigger nodes are ready for the selected thread
  useEffect(() => {
    if (!selectedThread) return;

    const graphEntry = graphCache[selectedThread.graphId];

    // If graph metadata missing, load it
    if (!graphEntry) {
      void ensureGraphsLoaded([selectedThread]);
      return;
    }

    // If graph exists but trigger nodes were empty, rebuild once templates are available
    if (
      graphEntry.triggerNodes.length === 0 &&
      Object.keys(templatesById).length > 0
    ) {
      const updatedTriggers = buildTriggerNodes(
        graphEntry.graph,
        templatesById,
      );
      if (updatedTriggers.length > 0) {
        setGraphCache((prev) => ({
          ...prev,
          [selectedThread.graphId]: {
            ...graphEntry,
            triggerNodes: updatedTriggers,
          },
        }));
      }
    }
  }, [selectedThread, graphCache, ensureGraphsLoaded, templatesById]);

  // Recompute trigger nodes when templates change
  useEffect(() => {
    if (!Object.keys(templatesById).length) return;
    setGraphCache((prev) => {
      const nextEntries: Record<string, GraphCacheEntry> = {};
      let changed = false;
      Object.entries(prev).forEach(([graphId, entry]) => {
        const updatedTriggers = buildTriggerNodes(entry.graph, templatesById);
        nextEntries[graphId] = {
          graph: entry.graph,
          triggerNodes: updatedTriggers,
          nodeDisplayNames: entry.nodeDisplayNames,
        };
        if (updatedTriggers.length !== entry.triggerNodes.length) {
          changed = true;
        }
      });
      return changed ? nextEntries : prev;
    });
  }, [templatesById]);

  const loadThreads = useCallback(
    async (options?: { append?: boolean }) => {
      const requestedGraphId = graphFilterId;
      const isAppend = options?.append ?? false;
      if (isAppend) {
        if (!threadsHasMore || threadsLoadingMore) return;
        setThreadsLoadingMore(true);
      } else if (threadsLoading) {
        return;
      } else {
        setThreadsLoading(true);
      }

      try {
        const offset = isAppend ? threadsOffset : 0;
        let response;

        try {
          response = await threadsApi.getThreads(
            requestedGraphId,
            threadStatusesFilter,
            THREADS_PAGE_SIZE,
            offset,
          );
        } catch (error) {
          /**
           * Some backends reject `statuses=done` with a validation error.
           * When that happens, fall back to fetching without the `statuses` filter
           * and rely on client-side filtering for the Resolved tab.
           */
          const shouldRetryWithoutStatuses =
            threadStatusTab === 'resolved' &&
            resolvedStatusesFilterSupported &&
            threadStatusesFilter?.length === 1 &&
            threadStatusesFilter[0] === GetThreadsStatusesEnum.Done &&
            isValidationExceptionsError(error);

          if (!shouldRetryWithoutStatuses) {
            throw error;
          }

          setResolvedStatusesFilterSupported(false);
          response = await threadsApi.getThreads(
            requestedGraphId,
            undefined,
            THREADS_PAGE_SIZE,
            offset,
          );
        }

        const fetched = response.data || [];
        const filteredFetched = requestedGraphId
          ? fetched.filter((thread) => thread.graphId === requestedGraphId)
          : fetched;

        if (graphFilterId !== requestedGraphId) {
          return;
        }

        setThreads((prev) => {
          const base =
            requestedGraphId === undefined
              ? prev
              : prev.filter((thread) => thread.graphId === requestedGraphId);
          if (!isAppend) {
            return sortThreadsByTimestampDesc(filteredFetched);
          }
          const existingIds = new Set(base.map((thread) => thread.id));
          const merged = [
            ...base,
            ...filteredFetched.filter((thread) => !existingIds.has(thread.id)),
          ];
          return sortThreadsByTimestampDesc(merged);
        });

        setThreadsOffset((current) =>
          isAppend ? current + fetched.length : fetched.length,
        );
        setThreadsHasMore(fetched.length === THREADS_PAGE_SIZE);

        void ensureGraphsLoaded(filteredFetched);
      } catch (error) {
        console.error('Error loading threads', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load threads list',
        );
        antdMessage.error(errorMessage);
        setThreadsHasMore(false);
      } finally {
        if (isAppend) {
          setThreadsLoadingMore(false);
        } else {
          setThreadsLoading(false);
        }
      }
    },
    [
      ensureGraphsLoaded,
      threadsHasMore,
      threadsLoading,
      threadsLoadingMore,
      threadsOffset,
      sortThreadsByTimestampDesc,
      graphFilterId,
      threadStatusesFilter,
      threadStatusTab,
      resolvedStatusesFilterSupported,
    ],
  );

  const loadThreadsRef = useRef(loadThreads);

  useEffect(() => {
    loadThreadsRef.current = loadThreads;
  }, [loadThreads]);

  useEffect(() => {
    void loadThreadsRef.current();
  }, [graphFilterId, threadStatusTab]);

  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);

  // Selection is cleared explicitly on delete events / delete actions.

  const handleThreadsScroll = useCallback(() => {
    const el = threadsContainerRef.current;
    if (!el) return;
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    if (
      nearBottom &&
      threadsHasMore &&
      !threadsLoadingMore &&
      !threadsLoading
    ) {
      void loadThreads({ append: true });
    }
  }, [loadThreads, threadsHasMore, threadsLoading, threadsLoadingMore]);

  const applyThreadCreate = useCallback(
    (newThread: ThreadDto) => {
      if (graphFilterId && newThread.graphId !== graphFilterId) {
        return;
      }

      // Check if this is replacing a draft thread
      const isDraftReplacement =
        draftThread &&
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId;

      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          const updated = prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
          return sortThreadsByTimestampDesc(updated);
        }
        return sortThreadsByTimestampDesc([newThread, ...prev]);
      });
      void ensureGraphsLoaded([newThread]);

      // Update external thread ID if present
      if (newThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [newThread.id]: newThread.externalThreadId,
        }));
      }

      if (isDraftReplacement) {
        // Replace draft thread with real thread
        const draftId = draftThread.id;

        // Migrate messages and pending messages from draft to real thread
        const draftThreadMessages = messages[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            // Update threadId in all migrated messages to match the new thread
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThread.id,
              externalThreadId:
                newThread.externalThreadId || msg.externalThreadId,
            }));
            updateMessages(newThread.id, () => migratedMessages, nodeScope);
          });

          // Carry over meta so we don't refetch immediately and flash loader
          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThread.id]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
              initialLoadFailed: false,
            },
          }));
        }

        const draftPending = pendingMessages[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThread.id, () => msgs ?? [], nodeScope);
          });
        }

        // Clear draft and select new thread
        setDraftThread(null);
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      } else if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        // Regular thread switch (not draft)
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      ensureGraphsLoaded,
      setExternalThreadIds,
      sortThreadsByTimestampDesc,
      graphFilterId,
      draftThread,
      messages,
      pendingMessages,
      updateMessages,
      updatePendingMessages,
    ],
  );

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      const newThreadId =
        newThread?.id ||
        notification.internalThreadId ||
        resolveInternalThreadId(notification.threadId);
      appendThreadSocketEvent(newThreadId, notification);
      if (newThread) {
        applyThreadCreate(newThread);
        return;
      }

      const externalThreadId = notification.threadId;
      if (!externalThreadId) return;

      void (async () => {
        try {
          const response =
            await threadsApi.getThreadByExternalId(externalThreadId);
          const fetchedThread = response.data;
          if (!fetchedThread) return;
          applyThreadCreate(fetchedThread);
        } catch (error) {
          console.error('Error fetching thread by external ID:', error);
        }
      })();
    },
    [appendThreadSocketEvent, applyThreadCreate, resolveInternalThreadId],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      appendThreadSocketEvent(updatedThread.id, notification);
      if (graphFilterId && updatedThread.graphId !== graphFilterId) {
        return;
      }
      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          if (selectedThreadId === updatedThread.id) {
            return sortThreadsByTimestampDesc([updatedThread, ...prev]);
          }
          return prev;
        }
        const currentThread = prev[index];

        if (!shouldApplyThreadUpdate(currentThread, updatedThread)) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return sortThreadsByTimestampDesc(next);
      });

      if (selectedThreadId === updatedThread.id) {
        setSelectedThreadShadow(updatedThread);
      }

      // Update external thread ID if present
      if (updatedThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [updatedThread.id]: updatedThread.externalThreadId,
        }));
      }

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      appendThreadSocketEvent,
      selectedThreadId,
      setExternalThreadIds,
      shouldApplyThreadUpdate,
      sortThreadsByTimestampDesc,
      graphFilterId,
      setSelectedThreadShadow,
    ],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      appendThreadSocketEvent(deletedThread.id, notification);
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadId === deletedThread.id) {
        setSelectedThreadId(undefined);
        setSelectedThreadShadow(null);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [appendThreadSocketEvent, selectedThreadId],
  );

  useWebSocketEvent('thread.create', (notification) =>
    handleThreadCreateEvent(notification as ThreadCreateNotification),
  );
  useWebSocketEvent('thread.update', (notification) =>
    handleThreadUpdateEvent(notification as ThreadUpdateNotification),
  );
  useWebSocketEvent('thread.delete', (notification) =>
    handleThreadDeleteEvent(notification as ThreadDeleteNotification),
  );
  useWebSocketEvent('graph.node.update', (notification) => {
    const data = notification as GraphNodeUpdateNotification;
    const eventThreadId =
      (typeof data.threadId === 'string' && data.threadId.length > 0
        ? data.threadId
        : undefined) ??
      (typeof data.data?.metadata?.threadId === 'string'
        ? data.data.metadata.threadId
        : undefined);
    const eventInternalThreadId =
      typeof data.internalThreadId === 'string' &&
      data.internalThreadId.length > 0
        ? data.internalThreadId
        : undefined;
    const metadataRunId =
      typeof data.data?.metadata?.runId === 'string'
        ? data.data.metadata.runId
        : undefined;
    const internalThreadId =
      eventInternalThreadId || resolveInternalThreadId(eventThreadId);

    const targetThreadId = internalThreadId ?? eventThreadId;
    if (!targetThreadId) {
      return;
    }
    appendThreadSocketEvent(targetThreadId, data);

    const externalThreadIdForTarget =
      externalThreadIds[targetThreadId] ?? eventThreadId;

    if (eventThreadId) {
      setExternalThreadIds((prev) => {
        const existing = prev[targetThreadId];
        if (existing === eventThreadId) return prev;
        return { ...prev, [targetThreadId]: eventThreadId };
      });
    }
    const _targetRunIds = buildIdSet(data.runId, metadataRunId);

    const reasoningChunks = data.data?.additionalNodeMetadata?.reasoningChunks;

    // Only process reasoning chunks if they exist
    // Don't clear streaming reasoning when chunks are absent - they should persist
    // until replaced by final non-streaming reasoning messages
    if (!reasoningChunks) {
      return;
    }

    const applyUpdateToKeys = buildAgentMessageScopeKeysForGraph(
      data.graphId,
      data.nodeId,
    );

    const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
      eventThreadId,
      externalThreadIdForTarget,
      data.runId ?? metadataRunId,
    ]);
    const reasoningEntries = extractReasoningEntries(reasoningContainer, {
      threadId: externalThreadIdForTarget ?? eventThreadId,
      runId: data.runId ?? metadataRunId,
    });

    // Only upsert if we have valid reasoning entries
    if (reasoningEntries.length > 0) {
      applyUpdateToKeys.forEach((key) => {
        updateMessages(
          targetThreadId,
          (prev) =>
            upsertReasoningEntries(prev, reasoningEntries, {
              externalThreadId: externalThreadIdForTarget,
              runId: data.runId ?? metadataRunId,
              selectedThreadId: targetThreadId,
              nodeId: key,
            }),
          key,
        );
      });
    }
  });

  // Handle agent messages - update shared state for all listeners
  useWebSocketEvent('agent.message', (notification) => {
    const data = notification as AgentMessageNotification;
    if (!data.internalThreadId) return;

    const threadId = data.internalThreadId;
    appendThreadSocketEvent(threadId, data);
    const nodeId = data.nodeId;
    const incomingMessage = data.data;

    const applyMessageKeys = buildAgentMessageScopeKeysForGraph(
      data.graphId,
      nodeId,
    );
    applyMessageKeys.forEach((key) => {
      updateMessages(
        threadId,
        (prev) => {
          const normalized = normalizeIncomingCreatedAtForDisplay(
            prev,
            incomingMessage,
          );
          return mergeMessagesReplacingStreaming(prev, [normalized]);
        },
        key,
      );
    });

    // Clear pending that matches this incoming message (by content for human messages)
    const incomingContent =
      typeof incomingMessage.message?.content === 'string'
        ? (incomingMessage.message?.content as string)
        : undefined;
    const incomingRole = incomingMessage.message?.role as string | undefined;
    if (incomingContent && incomingRole === 'human') {
      const applyPendingToKeys = applyMessageKeys;
      applyPendingToKeys.forEach((key) => {
        updatePendingMessages(
          threadId,
          (prev) =>
            prev.filter(
              (p) =>
                typeof p.content !== 'string' || p.content !== incomingContent,
            ),
          key,
        );
      });
    }

    // Update external thread ID if present
    if (incomingMessage.externalThreadId) {
      setExternalThreadIds((prev) => ({
        ...prev,
        [threadId]: incomingMessage.externalThreadId,
      }));
    }
  });

  useWebSocketEvent('agent.state.update', (notification) => {
    const data = notification as AgentStateUpdateNotification;
    const internalThreadId =
      (typeof data.internalThreadId === 'string' && data.internalThreadId) ||
      resolveInternalThreadId(data.threadId);
    if (!internalThreadId) return;
    appendThreadSocketEvent(internalThreadId, data);
    if (!data.nodeId) return;

    const usageUpdate = compactUsageUpdate(data.data ?? {});
    if (Object.keys(usageUpdate).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existingThread = prev[internalThreadId] ?? {};
      const existingNode = existingThread[data.nodeId] ?? {};
      return {
        ...prev,
        [internalThreadId]: {
          ...existingThread,
          [data.nodeId]: {
            ...existingNode,
            ...usageUpdate,
          },
        },
      };
    });
  });
  const threadStatusMeta = selectedThread
    ? 'isDraft' in selectedThread && selectedThread.isDraft
      ? null
      : getThreadStatusDisplay((selectedThread as ThreadDto).status)
    : null;
  const selectedGraphStatus = selectedThread
    ? graphCache[selectedThread.graphId]?.graph.status
    : undefined;
  const graphIsRunning = selectedGraphStatus === GraphDtoStatusEnum.Running;
  const selectedThreadIsDraft =
    selectedThread !== undefined &&
    'isDraft' in selectedThread &&
    selectedThread.isDraft === true;

  const selectedThreadTokenUsageFromApi = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft || !selectedThreadId)
      return undefined;

    const usageStats = threadUsageStats[selectedThreadId];
    if (!usageStats) return undefined;

    // Convert ThreadUsageStatisticsDto to the format expected by the UI
    const usage: ThreadTokenUsageSnapshot & {
      byNode?: Record<string, ThreadTokenUsageSnapshot>;
    } = {
      inputTokens: usageStats.total.inputTokens,
      cachedInputTokens: usageStats.total.cachedInputTokens,
      outputTokens: usageStats.total.outputTokens,
      reasoningTokens: usageStats.total.reasoningTokens,
      totalTokens: usageStats.total.totalTokens,
      totalPrice: usageStats.total.totalPrice,
      currentContext: usageStats.total.currentContext,
    };

    // Add byNode data if available
    if (usageStats.byNode) {
      usage.byNode = Object.entries(usageStats.byNode).reduce<
        Record<string, ThreadTokenUsageSnapshot>
      >((acc, [nodeId, nodeStats]) => {
        acc[nodeId] = {
          inputTokens: nodeStats.inputTokens,
          cachedInputTokens: nodeStats.cachedInputTokens,
          outputTokens: nodeStats.outputTokens,
          reasoningTokens: nodeStats.reasoningTokens,
          totalTokens: nodeStats.totalTokens,
          totalPrice: nodeStats.totalPrice,
          currentContext: nodeStats.currentContext,
        };
        return acc;
      }, {});
    }

    return usage;
  }, [
    selectedThread,
    selectedThreadIsDraft,
    selectedThreadId,
    threadUsageStats,
  ]);

  const analysisButtonDisabled =
    !selectedThread || selectedThreadIsDraft || !graphIsRunning;

  const socketEventsForUsageStatsThread = useMemo(() => {
    if (!usageStatsModalThreadId) return [];
    return threadSocketEvents[usageStatsModalThreadId] ?? [];
  }, [threadSocketEvents, usageStatsModalThreadId]);

  const socketEventsForModalThread = useMemo(() => {
    if (!threadSocketEventsModalThreadId) return [];
    return threadSocketEvents[threadSocketEventsModalThreadId] ?? [];
  }, [threadSocketEvents, threadSocketEventsModalThreadId]);

  const socketEventsJson = useMemo(() => {
    return JSON.stringify(socketEventsForModalThread, null, 2);
  }, [socketEventsForModalThread]);

  const handleOpenAnalyzeModal = useCallback(() => {
    if (analysisButtonDisabled) return;
    setAnalyzeModalOpen(true);
  }, [analysisButtonDisabled]);

  const handleCloseAnalyzeModal = useCallback(() => {
    setAnalyzeModalOpen(false);
  }, []);

  const handleOpenUsageStatsModal = useCallback(() => {
    if (!selectedThreadId || selectedThreadIsDraft) return;
    setUsageStatsModalThreadId(selectedThreadId);
    setUsageStatsModalOpen(true);

    // Always fetch fresh usage statistics when opening the modal (even if we have cached data)
    let retryCount = 0;
    const maxRetries = 3;
    const retryDelay = 2000; // 2 seconds between retries

    const loadUsageStats = async () => {
      try {
        setThreadUsageStatsLoading((prev) => ({
          ...prev,
          [selectedThreadId]: true,
        }));
        const response =
          await threadsApi.getThreadUsageStatistics(selectedThreadId);
        setThreadUsageStats((prev) => ({
          ...prev,
          [selectedThreadId]: response.data,
        }));
        setThreadUsageStatsLoading((prev) => ({
          ...prev,
          [selectedThreadId]: false,
        }));
      } catch (error) {
        console.error(
          `Error loading thread usage statistics (attempt ${retryCount + 1}/${maxRetries + 1}):`,
          error,
        );

        // Retry logic: retry up to maxRetries times with a delay
        if (retryCount < maxRetries) {
          retryCount++;
          setTimeout(() => {
            void loadUsageStats();
          }, retryDelay);
        } else {
          // Max retries reached, give up and show error
          setThreadUsageStatsLoading((prev) => ({
            ...prev,
            [selectedThreadId]: false,
          }));
          console.error(
            'Max retries reached for loading thread usage statistics',
          );
          antdMessage.error(
            'Failed to load usage statistics after multiple attempts',
          );
        }
      }
    };

    void loadUsageStats();
  }, [selectedThreadId, selectedThreadIsDraft]);

  const handleCloseUsageStatsModal = useCallback(() => {
    setUsageStatsModalOpen(false);
  }, []);

  const handleOpenThreadSocketEventsModal = useCallback((threadId: string) => {
    setThreadSocketEventsModalThreadId(threadId);
    setThreadSocketEventsModalOpen(true);
  }, []);

  const handleCloseThreadSocketEventsModal = useCallback(() => {
    setThreadSocketEventsModalOpen(false);
    setThreadSocketEventsModalThreadId(null);
  }, []);

  const handleCopyThreadSocketEventsJson = useCallback(async () => {
    if (!threadSocketEventsModalThreadId) return;
    if (socketEventsForModalThread.length === 0) {
      antdMessage.info('No socket events available for this thread.');
      return;
    }
    try {
      await navigator.clipboard.writeText(socketEventsJson);
      antdMessage.success('Socket events copied as JSON.');
    } catch (error) {
      console.error('Failed to copy socket events JSON:', error);
      antdMessage.error('Failed to copy socket events JSON.');
    }
  }, [
    socketEventsForModalThread.length,
    socketEventsJson,
    threadSocketEventsModalThreadId,
  ]);

  const handleAnalyzeThread = useCallback(async () => {
    if (!selectedThread || selectedThreadIsDraft) return;
    try {
      setAnalyzeLoading(true);
      const response = await threadsApi.analyzeThread(selectedThread.id, {
        userInput:
          analysisUserInput && analysisUserInput.trim().length > 0
            ? analysisUserInput
            : undefined,
        threadId: analysisConversationId ?? undefined,
        model: analysisModel,
      });
      const analysisText = response.data?.analysis ?? '';
      const conversationId = response.data?.conversationId ?? null;
      if (conversationId) {
        setAnalysisConversationId(conversationId);
      }
      setAnalysisUserInput('');
      setAnalysisResult(
        analysisText && analysisText.trim().length > 0
          ? analysisText
          : 'No analysis returned for this thread.',
      );
    } catch (error) {
      console.error('Error analyzing thread', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to analyze thread',
      );
      antdMessage.error(errorMessage);
    } finally {
      setAnalyzeLoading(false);
    }
  }, [
    selectedThread,
    selectedThreadIsDraft,
    analysisUserInput,
    analysisConversationId,
    analysisModel,
  ]);

  const analysisModelOptions = useMemo(
    () =>
      liteLlmModels.map((model) => ({
        label: model.ownedBy ? `${model.id} (${model.ownedBy})` : model.id,
        value: model.id,
      })),
    [liteLlmModels],
  );

  useEffect(() => {
    if (!analyzeModalOpen) return;
    if (liteLlmModels.length > 0) return;

    let isActive = true;

    const fetchLiteLlmModels = async () => {
      try {
        setLitellmModelsLoading(true);
        const response = await litellmApi.listModels();
        if (!isActive) return;
        setLiteLlmModels(response.data ?? []);
      } catch (error) {
        if (!isActive) return;
        console.error('Failed to load LiteLLM models:', error);
        antdMessage.error(
          extractApiErrorMessage(error, 'Failed to load LiteLLM models'),
        );
      } finally {
        if (isActive) {
          setLitellmModelsLoading(false);
        }
      }
    };

    fetchLiteLlmModels();

    return () => {
      isActive = false;
    };
  }, [analyzeModalOpen, liteLlmModels.length]);

  const filteredGraphLabel = useMemo(() => {
    if (!graphFilterId) return undefined;
    const graphName = graphCache[graphFilterId]?.graph.name;
    if (graphName && graphName.trim().length > 0) {
      return graphName;
    }
    if (graphFilterId.length <= 10) {
      return graphFilterId;
    }
    return `…${graphFilterId.slice(-6)}`;
  }, [graphFilterId, graphCache]);

  const selectedThreadAllMessages = useMemo(() => {
    if (!selectedThreadId) return [];
    return messages[selectedThreadId]?.['all'] || [];
  }, [messages, selectedThreadId]);

  const selectedThreadUsageByNode = useMemo(() => {
    if (!selectedThreadId) return {};
    return (
      threadTokenUsageByNode[selectedThreadId] ??
      selectedThreadTokenUsageFromApi?.byNode ??
      {}
    );
  }, [
    selectedThreadId,
    selectedThreadTokenUsageFromApi?.byNode,
    threadTokenUsageByNode,
  ]);

  const selectedThreadAggregateUsage = useMemo(() => {
    const nodeUsages = Object.values(selectedThreadUsageByNode);
    if (!nodeUsages.length) return undefined;
    return sumUsage(nodeUsages);
  }, [selectedThreadUsageByNode]);

  const selectedThreadThreadUsage = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return (
      selectedThreadAggregateUsage ??
      selectedThreadTokenUsageFromApi ??
      undefined
    );
  }, [
    selectedThread,
    selectedThreadAggregateUsage,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi,
  ]);

  useEffect(() => {
    if (!selectedThreadId) return;
    if (!selectedThread || selectedThreadIsDraft) return;
    const byNode = selectedThreadTokenUsageFromApi?.byNode;
    if (!byNode || Object.keys(byNode).length === 0) return;

    setThreadTokenUsageByNode((prev) => {
      const existing = prev[selectedThreadId] ?? {};
      // Baseline from API, but keep any live socket-updated overrides.
      const merged = mergeTokenUsageByNode(byNode, existing);
      if (prev[selectedThreadId] === merged) return prev;
      return { ...prev, [selectedThreadId]: merged };
    });
  }, [
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
    selectedThreadTokenUsageFromApi?.byNode,
  ]);

  const selectedThreadNodeDisplayNames = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.nodeDisplayNames;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const selectedThreadGraph = useMemo(() => {
    if (!selectedThread || selectedThreadIsDraft) return undefined;
    return graphCache[selectedThread.graphId]?.graph;
  }, [graphCache, selectedThread, selectedThreadIsDraft]);

  const getNodeConfigString = useCallback(
    (nodeId: string, key: 'name' | 'description'): string | undefined => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      const node = (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'string' && value.trim().length > 0
        ? value.trim()
        : undefined;
    },
    [selectedThreadGraph],
  );

  const getNodeConfigNumber = useCallback(
    (nodeId: string, key: string): number | undefined => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      const node = (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
      if (!node) return undefined;
      const config = node.config as unknown;
      if (!config || typeof config !== 'object') return undefined;
      const value = (config as Record<string, unknown>)[key];
      return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
    },
    [selectedThreadGraph],
  );

  const getNodeTemplateId = useCallback(
    (nodeId: string): string | undefined => {
      const graph = selectedThreadGraph;
      if (!graph) return undefined;
      const node = (graph.schema?.nodes ?? []).find((n) => n.id === nodeId);
      return node?.template;
    },
    [selectedThreadGraph],
  );

  const selectedThreadContextPercent = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;

    let sumContext = 0;
    let sumMaxTokens = 0;
    let hasAny = false;

    entries.forEach(([nodeId, usage]) => {
      if (!usage) return;
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current)) return;
      sumContext += current;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });

    if (!hasAny || sumMaxTokens <= 0) return undefined;
    const percent = (sumContext / sumMaxTokens) * 100;
    return Number.isFinite(percent) ? percent : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadContextMaxTokens = useMemo(() => {
    const entries = Object.entries(selectedThreadUsageByNode);
    if (!entries.length) return undefined;
    let sumMaxTokens = 0;
    let hasAny = false;
    entries.forEach(([nodeId]) => {
      if (getNodeTemplateId(nodeId) !== 'simple-agent') return;
      const maxTokens = getNodeConfigNumber(nodeId, 'summarizeMaxTokens');
      if (!maxTokens || maxTokens <= 0) return;
      sumMaxTokens += maxTokens;
      hasAny = true;
    });
    return hasAny && sumMaxTokens > 0 ? sumMaxTokens : undefined;
  }, [getNodeConfigNumber, getNodeTemplateId, selectedThreadUsageByNode]);

  const selectedThreadHeaderUsage = useMemo(() => {
    if (selectedAgentNodeId) {
      return selectedThreadUsageByNode[selectedAgentNodeId];
    }
    return selectedThreadThreadUsage;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadThreadUsage,
  ]);

  const selectedThreadHeaderContextPercent = useMemo(() => {
    if (selectedAgentNodeId) {
      const usage = selectedThreadUsageByNode[selectedAgentNodeId];
      if (!usage) return undefined;
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      if (!maxTokens || maxTokens <= 0) return undefined;
      const current = usage.currentContext;
      if (typeof current !== 'number' || !Number.isFinite(current))
        return undefined;
      const percent = (current / maxTokens) * 100;
      return Number.isFinite(percent) ? percent : undefined;
    }
    return selectedThreadContextPercent;
  }, [
    selectedAgentNodeId,
    selectedThreadUsageByNode,
    selectedThreadContextPercent,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const selectedThreadHeaderContextMaxTokens = useMemo(() => {
    if (selectedAgentNodeId) {
      const templateId = getNodeTemplateId(selectedAgentNodeId);
      if (templateId !== 'simple-agent') return undefined;
      const maxTokens = getNodeConfigNumber(
        selectedAgentNodeId,
        'summarizeMaxTokens',
      );
      return maxTokens && maxTokens > 0 ? maxTokens : undefined;
    }
    return selectedThreadContextMaxTokens;
  }, [
    selectedAgentNodeId,
    selectedThreadContextMaxTokens,
    getNodeConfigNumber,
    getNodeTemplateId,
  ]);

  const formatNodeLabel = useCallback(
    (nodeIdentifier: string): string => {
      const mapped = selectedThreadNodeDisplayNames?.[nodeIdentifier];
      if (mapped && mapped.trim().length > 0) {
        return mapped;
      }
      if (nodeIdentifier.length <= 10) {
        return nodeIdentifier;
      }
      return `Node ${nodeIdentifier.slice(-6)}`;
    },
    [selectedThreadNodeDisplayNames],
  );

  const agentsForSelectedThread = useMemo(() => {
    if (!selectedThreadId || !selectedThread || selectedThreadIsDraft) {
      return [];
    }

    const agents: {
      nodeId: string;
      label: string;
      description?: string;
      avatarSrc?: string;
    }[] = [];

    const graphId = selectedThread.graphId;
    const graph = graphCache[graphId]?.graph;
    const schemaNodes = graph?.schema?.nodes ?? [];

    schemaNodes.forEach((node) => {
      const nodeId = node.id;
      if (!isAgentNodeIdInGraph(graphId, nodeId)) {
        return;
      }

      const configName = getNodeConfigString(nodeId, 'name');
      const configDescription = getNodeConfigString(nodeId, 'description');

      agents.push({
        nodeId,
        label: configName ?? formatNodeLabel(nodeId),
        description: configDescription,
        avatarSrc: getAgentAvatarDataUri(nodeId),
      });
    });

    return agents;
  }, [
    formatNodeLabel,
    graphCache,
    getNodeConfigString,
    isAgentNodeIdInGraph,
    selectedThread,
    selectedThreadId,
    selectedThreadIsDraft,
  ]);

  const visibleMessagesForSelectedThread = useMemo(() => {
    if (!selectedThreadId) return [];
    if (!selectedAgentNodeId) return selectedThreadAllMessages;
    return selectedThreadAllMessages.filter(
      (msg) => msg.nodeId === selectedAgentNodeId,
    );
  }, [selectedAgentNodeId, selectedThreadAllMessages, selectedThreadId]);

  const visiblePendingMessagesForSelectedThread = useMemo(() => {
    if (!selectedThreadId) return [];
    if (selectedAgentNodeId) return [];
    return pendingMessages[selectedThreadId]?.['all'] || [];
  }, [pendingMessages, selectedAgentNodeId, selectedThreadId]);

  const handleClearGraphFilter = useCallback(() => {
    const params = new URLSearchParams(location.search);
    params.delete('graphId');
    navigate(
      {
        pathname: location.pathname,
        search: params.toString() ? `?${params.toString()}` : '',
      },
      { replace: true },
    );
  }, [location.pathname, location.search, navigate]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          setSelectedThreadId(undefined);
        }
        antdMessage.success('Thread deleted successfully');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to delete thread',
        );
        antdMessage.error(errorMessage);
      }
    },
    [selectedThreadId],
  );

  const createDraftThreadForGraph = useCallback(
    (draftGraphId: string) => {
      const scrollThreadsToTop = () => {
        const el = threadsContainerRef.current;
        if (!el) return;
        el.scrollTo({ top: 0, behavior: 'smooth' });
      };

      if (draftThread && draftThread.graphId === draftGraphId) {
        // If draft already exists for this graph, just focus it
        setSelectedThreadId(draftThread.id);
        requestAnimationFrame(scrollThreadsToTop);
        return;
      }

      // Create new draft thread
      const now = new Date().toISOString();
      const newDraft: DraftThread = {
        id: `draft-${Date.now()}`,
        graphId: draftGraphId,
        name: 'New Chat',
        status: 'draft',
        createdAt: now,
        updatedAt: now,
        externalThreadId: '',
        isDraft: true,
      };

      setDraftThread(newDraft);
      setSelectedThreadId(newDraft.id);
      requestAnimationFrame(scrollThreadsToTop);
    },
    [draftThread],
  );

  const handleCreateDraftThread = useCallback(() => {
    if (!graphFilterId) {
      setGraphPickerOpen(true);
      return;
    }
    createDraftThreadForGraph(graphFilterId);
  }, [createDraftThreadForGraph, graphFilterId]);

  const handleGraphPickerSelect = useCallback(
    (graphId: string) => {
      const selectedGraph = graphPickerGraphs.find(
        (graph) => graph.id === graphId,
      );
      if (selectedGraph) {
        setGraphCache((prev) => ({
          ...prev,
          [graphId]: {
            graph: selectedGraph,
            triggerNodes: buildTriggerNodes(selectedGraph, templatesById),
            nodeDisplayNames: buildNodeDisplayNames(selectedGraph),
          },
        }));
      }
      setGraphPickerOpen(false);
      createDraftThreadForGraph(graphId);
    },
    [createDraftThreadForGraph, graphPickerGraphs, templatesById],
  );

  const handleDraftMessageSent = useCallback(
    (newThread: ThreadDto) => {
      applyThreadCreate(newThread);
    },
    [applyThreadCreate],
  );

  const renderThreadItem = (thread: ThreadDto | DraftThread) => {
    const isActive = thread.id === selectedThreadId;
    const isDraft = 'isDraft' in thread && thread.isDraft === true;
    const statusMeta = isDraft
      ? { label: 'Draft', color: '#d9d9d9' }
      : getThreadStatusDisplay(
          (thread as ThreadDto).status as ThreadDtoStatusEnum,
        );
    const graphName = graphCache[thread.graphId]?.graph.name;
    const createdAt = new Date(thread.createdAt).toLocaleString();

    return (
      <div
        key={thread.id}
        onClick={() => setSelectedThreadId(thread.id)}
        onMouseEnter={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fafafa';
          }
        }}
        onMouseLeave={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fff';
          }
        }}
        style={{
          padding: '12px 16px',
          borderBottom: '1px solid #f0f0f0',
          cursor: 'pointer',
          backgroundColor: isActive ? '#f5f9ff' : '#fff',
          overflow: 'hidden',
          transition: 'background-color 0.2s ease',
        }}>
        <Space
          direction="vertical"
          size={4}
          style={{ width: '100%', minWidth: 0 }}>
          <div
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: 8,
              minWidth: 0,
            }}>
            <div style={{ flex: 1, minWidth: 0 }}>
              <Text
                strong
                ellipsis={{
                  tooltip: thread.name || `Thread ${thread.id.slice(-6)}`,
                }}
                style={{
                  width: '100%',
                  display: 'block',
                }}>
                {thread.name || `Thread ${thread.id.slice(-6)}`}
              </Text>
            </div>
            {statusMeta && (
              <Tag
                color={statusMeta.color}
                style={{ margin: 0, flexShrink: 0, whiteSpace: 'nowrap' }}>
                {statusMeta.label}
              </Tag>
            )}
            {!isDraft && (
              <Dropdown
                menu={{
                  items: [
                    {
                      key: 'delete',
                      label: (
                        <Popconfirm
                          title="Delete thread"
                          description="Are you sure you want to delete this thread?"
                          onConfirm={(e) => {
                            e?.stopPropagation();
                            handleDeleteThread(thread.id);
                          }}
                          onCancel={(e) => e?.stopPropagation()}
                          okText="Delete"
                          cancelText="Cancel"
                          okButtonProps={{ danger: true }}>
                          <div
                            onClick={(e) => e.stopPropagation()}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: 8,
                            }}>
                            <DeleteOutlined />
                            Delete
                          </div>
                        </Popconfirm>
                      ),
                    },
                  ],
                }}
                trigger={['click']}
                placement="bottomRight">
                <Button
                  type="text"
                  size="small"
                  icon={<EllipsisOutlined />}
                  onClick={(e) => e.stopPropagation()}
                  style={{
                    flexShrink: 0,
                    padding: '4px 8px',
                  }}
                />
              </Dropdown>
            )}
          </div>
          <Text
            type="secondary"
            title={graphName || 'Loading graph…'}
            style={{
              fontSize: 12,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              minWidth: 0,
            }}>
            {graphName || 'Loading graph…'}
          </Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Created {createdAt}
          </Text>
          {isActive && !isDraft && (
            <div style={{ marginTop: 6 }}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                <div
                  onClick={(e) => {
                    e.stopPropagation();
                    setSelectedAgentNodeId(null);
                  }}
                  onMouseEnter={(e) => {
                    if (selectedAgentNodeId) {
                      e.currentTarget.style.backgroundColor = '#fafafa';
                    }
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.backgroundColor = selectedAgentNodeId
                      ? '#fff'
                      : '#e6f4ff';
                  }}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 10,
                    padding: '8px 10px',
                    borderRadius: 10,
                    border: `1px solid ${
                      selectedAgentNodeId ? '#f0f0f0' : '#91caff'
                    }`,
                    backgroundColor: selectedAgentNodeId ? '#fff' : '#e6f4ff',
                    cursor: 'pointer',
                    transition:
                      'background-color 0.15s ease, border-color 0.15s ease',
                  }}>
                  <div style={{ minWidth: 0, flex: 1 }}>
                    <Text strong style={{ display: 'block', fontSize: 13 }}>
                      All agents
                    </Text>
                    <Text
                      type="secondary"
                      style={{
                        fontSize: 12,
                        display: '-webkit-box',
                        WebkitLineClamp: 1,
                        WebkitBoxOrient: 'vertical',
                        overflow: 'hidden',
                      }}>
                      show the full thread
                    </Text>
                    <ThreadTokenUsageLine
                      usage={selectedThreadThreadUsage}
                      contextPercent={selectedThreadContextPercent}
                      contextMaxTokens={selectedThreadContextMaxTokens}
                      withPopover
                    />
                  </div>
                </div>

                {agentsForSelectedThread.length > 0 ? (
                  agentsForSelectedThread.map((agent) => {
                    const isSelected = selectedAgentNodeId === agent.nodeId;
                    const agentUsage = selectedThreadUsageByNode[agent.nodeId];
                    const templateId = getNodeTemplateId(agent.nodeId);
                    const summarizeMaxTokens =
                      templateId === 'simple-agent'
                        ? getNodeConfigNumber(
                            agent.nodeId,
                            'summarizeMaxTokens',
                          )
                        : undefined;
                    return (
                      <div
                        key={agent.nodeId}
                        onClick={(e) => {
                          e.stopPropagation();
                          setSelectedAgentNodeId(agent.nodeId);
                        }}
                        onMouseEnter={(e) => {
                          if (!isSelected) {
                            e.currentTarget.style.backgroundColor = '#fafafa';
                          }
                        }}
                        onMouseLeave={(e) => {
                          if (!isSelected) {
                            e.currentTarget.style.backgroundColor = '#fff';
                          }
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: 10,
                          padding: '8px 10px',
                          borderRadius: 10,
                          border: `1px solid ${
                            isSelected ? '#91caff' : '#f0f0f0'
                          }`,
                          backgroundColor: isSelected ? '#e6f4ff' : '#fff',
                          cursor: 'pointer',
                          transition:
                            'background-color 0.15s ease, border-color 0.15s ease',
                        }}>
                        <Avatar
                          size={28}
                          src={agent.avatarSrc}
                          style={{ background: '#f0f0f0', flexShrink: 0 }}
                        />
                        <div style={{ minWidth: 0, flex: 1 }}>
                          <Text
                            strong
                            style={{
                              display: 'block',
                              fontSize: 13,
                              whiteSpace: 'nowrap',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                            }}>
                            {agent.label}
                          </Text>
                          <Text
                            type="secondary"
                            style={{
                              fontSize: 12,
                              display: '-webkit-box',
                              WebkitLineClamp: 1,
                              WebkitBoxOrient: 'vertical',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              whiteSpace: 'nowrap',
                            }}>
                            {agent.description || ''}
                          </Text>
                          <ThreadTokenUsageLine
                            usage={agentUsage}
                            contextMaxTokens={summarizeMaxTokens}
                            withPopover
                          />
                        </div>
                      </div>
                    );
                  })
                ) : (
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    No agents yet
                  </Text>
                )}
              </div>
            </div>
          )}
        </Space>
      </div>
    );
  };

  const threadsEmpty =
    !threadsLoading &&
    !threadsLoadingMore &&
    filteredThreads.length === 0 &&
    !shouldShowDraftThread;

  const threadsEmptyDescription = useMemo(() => {
    const scopeSuffix = graphFilterId ? ' for this graph' : '';
    if (threadStatusTab === 'resolved')
      return `No resolved threads${scopeSuffix}`;
    if (threadStatusTab === 'open') return `No open threads${scopeSuffix}`;
    return graphFilterId ? 'No threads found for this graph' : 'No threads yet';
  }, [graphFilterId, threadStatusTab]);

  const graphPickerContent = useMemo(() => {
    if (graphPickerLoading) {
      return (
        <div style={{ padding: 12, textAlign: 'center' }}>
          <Spin size="small" />
        </div>
      );
    }
    if (graphPickerError) {
      return (
        <Text type="secondary" style={{ fontSize: 12 }}>
          {graphPickerError}
        </Text>
      );
    }
    if (graphPickerGraphs.length === 0) {
      return (
        <Text type="secondary" style={{ fontSize: 12 }}>
          No graphs available
        </Text>
      );
    }
    return (
      <div
        style={{
          maxHeight: 300,
          overflowY: 'auto',
          minWidth: 260,
          display: 'flex',
          flexDirection: 'column',
          gap: 4,
        }}>
        {graphPickerGraphs.map((graph) => (
          <Button
            key={graph.id}
            type="text"
            style={{
              textAlign: 'left',
              padding: '8px 12px',
              height: 'auto',
              lineHeight: 1.2,
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'flex-start',
              border: '1px solid #f0f0f0',
              borderRadius: 6,
              width: '100%',
            }}
            onClick={() => handleGraphPickerSelect(graph.id)}>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: 6,
                width: '100%',
              }}>
              <Text strong style={{ fontSize: 12, lineHeight: 1.2 }}>
                {graph.name && graph.name.trim().length > 0
                  ? graph.name
                  : `Graph ${graph.id.slice(-6)}`}
              </Text>
              <Tag
                color={GRAPH_STATUS_META[graph.status]?.color ?? '#d9d9d9'}
                style={{
                  margin: 0,
                  borderRadius: 999,
                  fontSize: 9,
                  lineHeight: '16px',
                  padding: '0 6px',
                }}>
                {GRAPH_STATUS_META[graph.status]?.label ?? graph.status}
              </Tag>
            </div>
            <Text type="secondary" style={{ fontSize: 10, margin: 0 }}>
              v{graph.version}
            </Text>
          </Button>
        ))}
      </div>
    );
  }, [
    graphPickerError,
    graphPickerGraphs,
    graphPickerLoading,
    handleGraphPickerSelect,
  ]);

  return (
    <div
      style={{
        height: 'calc(100vh - 64px)',
        maxHeight: 'calc(100vh - 64px)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}>
      <div
        style={{
          display: 'flex',
          flex: 1,
          minHeight: 0,
          overflow: 'hidden',
        }}>
        <div
          style={{
            width: 340,
            borderRight: '1px solid #f0f0f0',
            display: 'flex',
            flexDirection: 'column',
            background: '#fff',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <div
              style={{
                width: '100%',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'flex-start',
                gap: 12,
                minWidth: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  minWidth: 0,
                  flex: 1,
                }}>
                <Title level={4} style={{ margin: 0 }}>
                  Chats
                </Title>
              </div>
              <Space>
                {graphFilterId ? (
                  <Button
                    size="small"
                    icon={<PlusOutlined />}
                    onClick={handleCreateDraftThread}
                    style={{
                      border: 'none',
                      boxShadow: 'none',
                    }}
                  />
                ) : (
                  <Popover
                    open={graphPickerOpen}
                    placement="bottomRight"
                    onOpenChange={setGraphPickerOpen}
                    content={graphPickerContent}>
                    <Button
                      size="small"
                      icon={<PlusOutlined />}
                      onClick={handleCreateDraftThread}
                      style={{
                        border: 'none',
                        boxShadow: 'none',
                      }}
                    />
                  </Popover>
                )}
                <Button
                  size="small"
                  icon={<ReloadOutlined />}
                  onClick={() => loadThreads()}
                  loading={threadsLoading}
                  style={{
                    border: 'none',
                    boxShadow: 'none',
                  }}
                />
              </Space>
            </div>
            <Tabs
              size="small"
              activeKey={threadStatusTab}
              onChange={handleThreadStatusTabChange}
              items={[
                { key: 'all', label: 'All' },
                { key: 'open', label: 'Open' },
                { key: 'resolved', label: 'Resolved' },
              ]}
              style={{ marginTop: 10 }}
            />
          </div>
          {graphFilterId && (
            <div
              style={{
                padding: '10px 16px',
                borderBottom: '1px solid #f0f0f0',
                background: '#fafafa',
                flexShrink: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 12,
                  minWidth: 0,
                }}>
                <div style={{ minWidth: 0, flex: 1 }}>
                  <Text
                    type="secondary"
                    style={{
                      fontSize: 11,
                      display: 'block',
                      marginBottom: 2,
                    }}>
                    Current graph
                  </Text>
                  <Text
                    strong
                    ellipsis={{ tooltip: filteredGraphLabel }}
                    style={{ display: 'block' }}>
                    {filteredGraphLabel}
                  </Text>
                </div>
                <Button
                  type="text"
                  size="small"
                  icon={<CloseOutlined />}
                  onClick={handleClearGraphFilter}
                  aria-label="Clear graph filter"
                />
              </div>
            </div>
          )}
          <div
            ref={threadsContainerRef}
            onScroll={handleThreadsScroll}
            style={{
              flex: 1,
              minHeight: 0,
              overflowY: 'auto',
            }}>
            {shouldShowDraftThread && draftThread
              ? renderThreadItem(draftThread)
              : null}
            {filteredThreads.map(renderThreadItem)}
            {threadsLoading && (
              <div style={{ padding: 24, textAlign: 'center' }}>
                <Spin />
              </div>
            )}
            {threadsEmpty && (
              <div style={{ padding: 24 }}>
                <Empty description={threadsEmptyDescription} />
              </div>
            )}
            {threadsLoadingMore && (
              <div style={{ padding: 12, textAlign: 'center' }}>
                <Spin size="small" />
              </div>
            )}
          </div>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: 24,
              display: 'flex',
              flexDirection: 'column',
              flex: 1,
              minHeight: 0,
              background: '#fff',
              overflow: 'hidden',
            }}>
            {selectedThread ? (
              <>
                <div
                  style={{
                    marginBottom: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}>
                  <div>
                    <Title level={4} style={{ margin: 0 }}>
                      {selectedThread.name ||
                        `Thread ${selectedThread.id.slice(-6)}`}
                    </Title>
                    <Space size="small" wrap>
                      <Text type="secondary">
                        Graph:{' '}
                        {graphCache[selectedThread.graphId]?.graph.name ||
                          'Loading…'}
                      </Text>
                      <Link
                        to={`/graphs/${selectedThread.graphId}`}
                        style={{
                          display: 'inline-flex',
                          alignItems: 'center',
                          color: '#1677ff',
                          textDecoration: 'none',
                          position: 'relative',
                          top: '2px',
                          padding: '0 3px',
                        }}
                        aria-label="Open graph details"
                        title="Open graph details">
                        <LinkOutlined />
                      </Link>
                      {selectedThread && (
                        <Space size={8} align="center">
                          {threadStatusMeta && (
                            <Tag color={threadStatusMeta.color}>
                              {threadStatusMeta.label}
                            </Tag>
                          )}
                          <Button
                            type="link"
                            size="small"
                            style={{
                              padding: 0,
                              height: 'auto',
                              fontSize: 12,
                            }}
                            onClick={handleOpenAnalyzeModal}
                            disabled={analysisButtonDisabled}
                            title={
                              selectedThreadIsDraft
                                ? 'Create the thread before analyzing it'
                                : undefined
                            }>
                            Analyze thread
                          </Button>
                        </Space>
                      )}
                    </Space>
                  </div>
                  <div
                    style={{
                      marginLeft: 'auto',
                      textAlign: 'right',
                      display: 'flex',
                      alignItems: 'center',
                      gap: 8,
                    }}>
                    <ThreadTokenUsageLine
                      usage={selectedThreadHeaderUsage}
                      withPopover
                      contextPercent={selectedThreadHeaderContextPercent}
                      contextMaxTokens={selectedThreadHeaderContextMaxTokens}
                    />
                    {selectedThreadHeaderUsage && (
                      <Tooltip title="View detailed usage statistics">
                        <Button
                          type="text"
                          size="small"
                          icon={<BarChartOutlined />}
                          onClick={handleOpenUsageStatsModal}
                          style={{ padding: '4px 8px' }}
                        />
                      </Tooltip>
                    )}
                  </div>
                </div>

                <div
                  style={{
                    flex: 1,
                    minHeight: 0,
                    display: 'flex',
                    flexDirection: 'column',
                  }}>
                  <ThreadChatPanel
                    graphId={selectedThread.graphId}
                    thread={selectedThread as ThreadDto}
                    triggerNodes={triggerNodesForSelectedThread}
                    templatesLoading={templatesLoading}
                    nodeDisplayNames={
                      graphCache[selectedThread.graphId]?.nodeDisplayNames
                    }
                    graphLoaded={Boolean(graphCache[selectedThread.graphId])}
                    onRequestThreadSwitch={handleThreadChatSwitchRequest}
                    isDraft={draftThread?.id === selectedThreadId}
                    onDraftMessageSent={handleDraftMessageSent}
                    messages={
                      selectedThreadId ? visibleMessagesForSelectedThread : []
                    }
                    messagesLoading={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).loading
                        : false
                    }
                    hasMoreMessages={
                      selectedThreadId
                        ? isDraftThreadId(selectedThreadId)
                          ? false
                          : getMessageMeta(selectedThreadId).hasMore
                        : false
                    }
                    loadingMoreMessages={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).loadingMore
                        : false
                    }
                    pendingMessages={
                      selectedThreadId
                        ? visiblePendingMessagesForSelectedThread
                        : []
                    }
                    externalThreadId={
                      selectedThreadId
                        ? externalThreadIds[selectedThreadId]
                        : undefined
                    }
                    onLoadMoreMessages={
                      selectedThreadId
                        ? isDraftThreadId(selectedThreadId)
                          ? undefined
                          : () => loadMoreMessagesForThread(selectedThreadId)
                        : undefined
                    }
                    onUpdateSharedMessages={updateMessages}
                    onUpdatePendingMessages={updatePendingMessages}
                  />
                </div>
              </>
            ) : (
              <div
                style={{
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}>
                <Empty
                  description="Select a thread to view its messages"
                  image={Empty.PRESENTED_IMAGE_SIMPLE}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <Modal
        title="Analyze thread"
        open={analyzeModalOpen}
        onCancel={handleCloseAnalyzeModal}
        destroyOnClose
        footer={[
          <Button key="cancel" onClick={handleCloseAnalyzeModal}>
            Close
          </Button>,
          <Button
            key="analyze"
            type="primary"
            onClick={handleAnalyzeThread}
            loading={analyzeLoading}
            disabled={analysisButtonDisabled}>
            Analyze
          </Button>,
        ]}>
        <Space direction="vertical" size={12} style={{ width: '100%' }}>
          <Text>
            AI will analyze this thread and share hints about improvements or
            potential problems.
          </Text>
          <div>
            <Text strong style={{ display: 'block', marginBottom: 6 }}>
              Model
            </Text>
            <Select
              value={analysisModel}
              onChange={(value) => setAnalysisModel(value)}
              allowClear
              showSearch
              loading={litellmModelsLoading}
              notFoundContent={
                litellmModelsLoading
                  ? 'Loading models...'
                  : 'No models available'
              }
              filterOption={(input, option) =>
                (option?.label ?? '')
                  .toString()
                  .toLowerCase()
                  .includes(input.toLowerCase())
              }
              options={analysisModelOptions}
              disabled={analysisButtonDisabled || analyzeLoading}
              placeholder="Select model"
              style={{ width: '100%' }}
            />
          </div>
          <Input.TextArea
            rows={4}
            placeholder="Optional context or questions for the analysis"
            value={analysisUserInput}
            onChange={(e) => setAnalysisUserInput(e.target.value)}
            disabled={analysisButtonDisabled || analyzeLoading}
          />
          {analysisResult ? (
            <div
              style={{
                maxHeight: 360,
                overflowY: 'auto',
                padding: 12,
                border: '1px solid #f0f0f0',
                borderRadius: 8,
              }}>
              <MarkdownContent content={analysisResult} />
            </div>
          ) : (
            <Text type="secondary">
              Run the analysis to see AI feedback for this thread.
            </Text>
          )}
        </Space>
      </Modal>

      <Modal
        title="Thread Usage Statistics"
        open={usageStatsModalOpen}
        onCancel={handleCloseUsageStatsModal}
        destroyOnClose
        footer={[
          <Button key="close" onClick={handleCloseUsageStatsModal}>
            Close
          </Button>,
        ]}
        width={800}>
        {usageStatsModalThreadId &&
          (() => {
            const thread = threads.find(
              (t) => t.id === usageStatsModalThreadId,
            );
            if (!thread) return null;

            const graph = graphCache[thread.graphId]?.graph;

            // Build node names and kinds from config
            const nodeNames: Record<string, string> = {};
            const nodeKinds: Record<string, string> = {};

            if (graph?.schema?.nodes) {
              graph.schema.nodes.forEach((node) => {
                const configName = node.config?.name as string | undefined;
                if (
                  configName &&
                  typeof configName === 'string' &&
                  configName.trim()
                ) {
                  nodeNames[node.id] = configName.trim();
                }

                // Get template/kind info
                const template = templatesById[node.template];
                if (template?.kind) {
                  nodeKinds[node.id] = template.kind;
                }
              });
            }

            return (
              <ThreadUsageDisplay
                usage={threadUsageStats[usageStatsModalThreadId] || null}
                loading={
                  threadUsageStatsLoading[usageStatsModalThreadId] || false
                }
                error={null}
                nodeDisplayNames={nodeNames}
                nodeKinds={nodeKinds}
                localEventsCount={socketEventsForUsageStatsThread.length}
                onShowLocalEvents={() =>
                  handleOpenThreadSocketEventsModal(thread.id)
                }
              />
            );
          })()}
      </Modal>
      <Modal
        title="Thread Socket Events"
        open={threadSocketEventsModalOpen}
        onCancel={handleCloseThreadSocketEventsModal}
        destroyOnClose
        footer={[
          <Button key="close" onClick={handleCloseThreadSocketEventsModal}>
            Close
          </Button>,
        ]}
        width={900}>
        {threadSocketEventsModalThreadId ? (
          <>
            <Text type="secondary">
              {socketEventsForModalThread.length} event
              {socketEventsForModalThread.length === 1 ? '' : 's'} recorded for
              this thread.
            </Text>
            <div style={{ marginTop: 12 }}>
              <Button
                type="primary"
                onClick={handleCopyThreadSocketEventsJson}
                disabled={socketEventsForModalThread.length === 0}>
                Copy events JSON
              </Button>
            </div>
          </>
        ) : (
          <Empty description="Select a thread to view events" />
        )}
      </Modal>
    </div>
  );
};

export default ChatsPage;
