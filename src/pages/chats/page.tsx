import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  Typography,
  Button,
  Space,
  Spin,
  Tag,
  Empty,
  Dropdown,
  Modal,
  Popconfirm,
  Input,
  message as antdMessage,
} from 'antd';
import {
  ReloadOutlined,
  EllipsisOutlined,
  DeleteOutlined,
  LinkOutlined,
  PlusOutlined,
  CloseOutlined,
} from '@ant-design/icons';
import type { GraphDto, TemplateDto, ThreadDto } from '../../autogenerated';
import { GraphDtoStatusEnum, ThreadDtoStatusEnum } from '../../autogenerated';
import { graphsApi, templatesApi, threadsApi } from '../../api';
import { Link, useLocation, useNavigate } from 'react-router';
import { useWebSocket, useWebSocketEvent } from '../../hooks/useWebSocket';
import { useThreadMessageStore } from '../../hooks/useThreadMessageStore';
import type {
  AgentMessageNotification,
  ThreadCreateNotification,
  ThreadDeleteNotification,
  GraphNodeUpdateNotification,
  ThreadUpdateNotification,
} from '../../services/WebSocketTypes';
import { getThreadStatusDisplay } from '../../utils/threadStatus';
import {
  buildIdSet,
  extractReasoningEntries,
  mergeMessagesReplacingStreaming,
  narrowReasoningContainer,
  upsertReasoningEntries,
} from '../../utils/threadMessages';
import ThreadChatPanel from './components/ThreadChatPanel';
import {
  buildNodeDisplayNames,
  buildTriggerNodes,
  type TriggerNodeInfo,
} from '../../utils/graphThreads';
import { extractApiErrorMessage } from '../../utils/errors';
import { MarkdownContent } from '../graphs/components/threadMessages/MarkdownContent';

const THREADS_PAGE_SIZE = 30;

const { Title, Text } = Typography;

interface GraphCacheEntry {
  graph: GraphDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames: Record<string, string>;
}

interface DraftThread {
  id: string;
  graphId: string;
  name: string | null;
  status: 'draft';
  createdAt: string;
  updatedAt: string;
  externalThreadId: string;
  isDraft: true;
}

export const ChatsPage = () => {
  const [threads, setThreads] = useState<ThreadDto[]>([]);
  const [threadsOffset, setThreadsOffset] = useState(0);
  const [threadsHasMore, setThreadsHasMore] = useState(true);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [threadsLoadingMore, setThreadsLoadingMore] = useState(false);

  const [selectedThreadId, setSelectedThreadId] = useState<string | undefined>(
    undefined,
  );
  const [draftThread, setDraftThread] = useState<DraftThread | null>(null);

  const [graphCache, setGraphCache] = useState<Record<string, GraphCacheEntry>>(
    {},
  );
  const [templatesById, setTemplatesById] = useState<
    Record<string, TemplateDto>
  >({});
  const [templatesLoading, setTemplatesLoading] = useState(false);

  const [triggerNodesForSelectedThread, setTriggerNodesForSelectedThread] =
    useState<TriggerNodeInfo[]>([]);
  const [analyzeModalOpen, setAnalyzeModalOpen] = useState(false);
  const [analyzeLoading, setAnalyzeLoading] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<string | null>(null);
  const [analysisUserInput, setAnalysisUserInput] = useState('');
  const [analysisConversationId, setAnalysisConversationId] = useState<
    string | null
  >(null);

  const threadsContainerRef = useRef<HTMLDivElement | null>(null);
  const pendingThreadSelectionRef = useRef<string | null>(null);
  const subscribedGraphsRef = useRef<Set<string>>(new Set());

  const { subscribeToGraph, unsubscribeFromGraph } = useWebSocket();
  const location = useLocation();
  const navigate = useNavigate();
  const [graphFilterId, setGraphFilterId] = useState<string | undefined>(() => {
    const params = new URLSearchParams(location.search);
    return params.get('graphId') ?? undefined;
  });

  const {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
  } = useThreadMessageStore();

  const threadsRef = useRef<ThreadDto[]>([]);

  const getThreadTimestamp = useCallback((thread: ThreadDto) => {
    const value = thread.updatedAt ?? thread.createdAt;
    return value ? Date.parse(value) : Number.NaN;
  }, []);

  const resolveInternalThreadId = useCallback((externalThreadId?: string) => {
    if (!externalThreadId) return undefined;
    const found = threadsRef.current.find(
      (thread) => thread.externalThreadId === externalThreadId,
    );
    return found?.id;
  }, []);

  const sortThreadsByTimestampDesc = useCallback(
    (list: ThreadDto[]) => {
      return [...list].sort((a, b) => {
        const bTs = getThreadTimestamp(b);
        const aTs = getThreadTimestamp(a);
        const safeBTs = Number.isFinite(bTs) ? bTs : -Infinity;
        const safeATs = Number.isFinite(aTs) ? aTs : -Infinity;
        if (safeBTs !== safeATs) {
          return safeBTs - safeATs;
        }
        return (b.createdAt ?? '').localeCompare(a.createdAt ?? '');
      });
    },
    [getThreadTimestamp],
  );

  const shouldApplyThreadUpdate = useCallback(
    (existing: ThreadDto, incoming: ThreadDto) => {
      const incomingTs = getThreadTimestamp(incoming);
      const existingTs = getThreadTimestamp(existing);

      const hasComparableTimestamps =
        Number.isFinite(incomingTs) && Number.isFinite(existingTs);

      if (hasComparableTimestamps && incomingTs < existingTs) {
        return false;
      }

      const existingIsTerminal =
        existing.status === ThreadDtoStatusEnum.Done ||
        existing.status === ThreadDtoStatusEnum.Stopped;

      if (
        hasComparableTimestamps &&
        incomingTs === existingTs &&
        existingIsTerminal &&
        incoming.status === ThreadDtoStatusEnum.Running
      ) {
        return false;
      }

      return true;
    },
    [getThreadTimestamp],
  );

  type MessageMeta = {
    loading: boolean;
    loadingMore: boolean;
    hasMore: boolean;
    offset: number;
  };

  const defaultMessageMeta = useMemo<MessageMeta>(
    () => ({
      loading: false,
      loadingMore: false,
      hasMore: true,
      offset: 0,
    }),
    [],
  );

  const [messageMeta, setMessageMeta] = useState<Record<string, MessageMeta>>(
    {},
  );

  const getMessageMeta = useCallback(
    (threadId?: string): MessageMeta => {
      if (!threadId) return defaultMessageMeta;
      return messageMeta[threadId] ?? defaultMessageMeta;
    },
    [defaultMessageMeta, messageMeta],
  );

  const updateMessageMeta = useCallback(
    (threadId: string, updater: (prev: MessageMeta) => MessageMeta) => {
      setMessageMeta((prev) => {
        const existing = prev[threadId] ?? defaultMessageMeta;
        return {
          ...prev,
          [threadId]: updater(existing),
        };
      });
    },
    [defaultMessageMeta],
  );

  const loadMessagesForThread = useCallback(
    async (threadId: string, force = false) => {
      const meta = getMessageMeta(threadId);
      if (!force && (meta.loading || meta.offset > 0)) {
        return;
      }

      updateMessageMeta(threadId, (prev) => ({
        ...prev,
        loading: true,
        loadingMore: false,
        hasMore: true,
        offset: force ? 0 : prev.offset,
      }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          undefined,
          50,
          0,
        );
        const fetched = response.data?.reverse() || [];
        updateMessages(threadId, () => fetched);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: fetched.length === 50,
          offset: fetched.length,
        }));

        const extId =
          fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
          externalThreadIds[threadId];
        if (extId) {
          setExternalThreadIds((prev) => ({
            ...prev,
            [threadId]: extId,
          }));
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load messages',
        );
        antdMessage.error(errorMessage);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [
      getMessageMeta,
      updateMessageMeta,
      updateMessages,
      externalThreadIds,
      setExternalThreadIds,
    ],
  );

  const loadMoreMessagesForThread = useCallback(
    async (threadId: string) => {
      const meta = getMessageMeta(threadId);
      if (meta.loading || meta.loadingMore || !meta.hasMore) {
        return;
      }

      updateMessageMeta(threadId, (prev) => ({ ...prev, loadingMore: true }));

      try {
        const response = await threadsApi.getThreadMessages(
          threadId,
          undefined,
          50,
          meta.offset,
        );
        const fetched = response.data?.reverse() || [];

        if (fetched.length > 0) {
          updateMessages(threadId, (prev) =>
            mergeMessagesReplacingStreaming(prev, fetched),
          );
          updateMessageMeta(threadId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: fetched.length === 50,
            offset: prev.offset + fetched.length,
          }));
        } else {
          updateMessageMeta(threadId, (prev) => ({
            ...prev,
            loadingMore: false,
            hasMore: false,
          }));
        }
      } catch (error) {
        console.error('Error loading more messages:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load more messages',
        );
        antdMessage.error(errorMessage);
        updateMessageMeta(threadId, (prev) => ({
          ...prev,
          loadingMore: false,
          hasMore: false,
        }));
      }
    },
    [getMessageMeta, updateMessageMeta, updateMessages],
  );

  const handleThreadChatSwitchRequest = useCallback(
    (externalThreadId: string | null) => {
      pendingThreadSelectionRef.current = externalThreadId;
    },
    [],
  );

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const incomingGraphId = params.get('graphId') ?? undefined;
    setGraphFilterId((prev) =>
      prev === incomingGraphId ? prev : incomingGraphId,
    );
  }, [location.search]);

  useEffect(() => {
    setThreads([]);
    setThreadsOffset(0);
    setThreadsHasMore(true);
    setSelectedThreadId(undefined);
    setDraftThread(null);
  }, [graphFilterId]);

  const selectedThread = useMemo(() => {
    if (!selectedThreadId) return undefined;
    if (draftThread && draftThread.id === selectedThreadId) {
      return draftThread;
    }
    return threads.find((thread) => thread.id === selectedThreadId);
  }, [threads, selectedThreadId, draftThread]);

  useEffect(() => {
    setAnalyzeModalOpen(false);
    setAnalyzeLoading(false);
    setAnalysisResult(null);
    setAnalysisUserInput('');
    setAnalysisConversationId(null);
  }, [selectedThreadId]);

  useEffect(() => {
    // Don't load messages for draft threads
    if (!selectedThread || (selectedThread as DraftThread)?.isDraft) return;

    const meta = getMessageMeta(selectedThread.id);
    const existingMessages = messages[selectedThread.id]?.['all'] ?? [];

    if (existingMessages.length > 0) {
      if (meta.offset === 0) {
        updateMessageMeta(selectedThread.id, (prev) => ({
          ...prev,
          loading: false,
          loadingMore: false,
          offset: existingMessages.length,
        }));
      }
      return;
    }

    if (meta.offset === 0 && !meta.loading) {
      void loadMessagesForThread(selectedThread.id);
    }
  }, [
    selectedThread,
    getMessageMeta,
    loadMessagesForThread,
    messages,
    updateMessageMeta,
  ]);

  // Update trigger nodes when selected thread or graph cache changes
  useEffect(() => {
    if (!selectedThread) {
      setTriggerNodesForSelectedThread([]);
      return;
    }

    const graphEntry = graphCache[selectedThread.graphId];
    if (graphEntry) {
      setTriggerNodesForSelectedThread(graphEntry.triggerNodes ?? []);
    } else {
      setTriggerNodesForSelectedThread([]);
    }
  }, [selectedThread, graphCache]);

  // Load templates once
  useEffect(() => {
    let mounted = true;
    const fetchTemplates = async () => {
      try {
        setTemplatesLoading(true);
        const response = await templatesApi.getAllTemplates();
        if (!mounted) return;
        const templateList = response.data || [];
        const map = templateList.reduce<Record<string, TemplateDto>>(
          (acc, template) => {
            acc[template.id] = template;
            return acc;
          },
          {},
        );
        setTemplatesById(map);
      } catch (error) {
        console.error('Error loading templates', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load templates metadata',
        );
        antdMessage.error(errorMessage);
      } finally {
        if (mounted) {
          setTemplatesLoading(false);
        }
      }
    };

    void fetchTemplates();
    return () => {
      mounted = false;
    };
  }, []);

  // Cleanup subscriptions on unmount
  useEffect(() => {
    const subscribedGraphs = subscribedGraphsRef.current;
    return () => {
      subscribedGraphs.forEach((graphId) => {
        unsubscribeFromGraph(graphId);
      });
      subscribedGraphs.clear();
    };
  }, [unsubscribeFromGraph]);

  const ensureGraphsLoaded = useCallback(
    async (threadsToCheck: (ThreadDto | DraftThread)[]) => {
      if (!threadsToCheck.length) return;
      const uniqueGraphIds = Array.from(
        new Set(threadsToCheck.map((thread) => thread.graphId)),
      );

      uniqueGraphIds.forEach((graphId) => {
        if (!subscribedGraphsRef.current.has(graphId)) {
          subscribeToGraph(graphId);
          subscribedGraphsRef.current.add(graphId);
        }
      });

      const missingGraphIds = uniqueGraphIds.filter(
        (graphId) => !graphCache[graphId],
      );
      if (!missingGraphIds.length) return;

      try {
        const responses = await Promise.all(
          missingGraphIds.map((graphId) => graphsApi.findGraphById(graphId)),
        );

        setGraphCache((prev) => {
          const next = { ...prev };
          responses.forEach((res, idx) => {
            const graph = res.data;
            if (!graph) return;
            next[missingGraphIds[idx]] = {
              graph,
              triggerNodes: buildTriggerNodes(graph, templatesById),
              nodeDisplayNames: buildNodeDisplayNames(graph),
            };
          });
          return next;
        });
      } catch (error) {
        console.error('Error loading graph metadata', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load graph metadata for threads',
        );
        antdMessage.error(errorMessage);
      }
    },
    [graphCache, subscribeToGraph, templatesById],
  );

  // Ensure graph metadata and trigger nodes are ready for the selected thread
  useEffect(() => {
    if (!selectedThread) return;

    const graphEntry = graphCache[selectedThread.graphId];

    // If graph metadata missing, load it
    if (!graphEntry) {
      void ensureGraphsLoaded([selectedThread]);
      return;
    }

    // If graph exists but trigger nodes were empty, rebuild once templates are available
    if (
      graphEntry.triggerNodes.length === 0 &&
      Object.keys(templatesById).length > 0
    ) {
      const updatedTriggers = buildTriggerNodes(
        graphEntry.graph,
        templatesById,
      );
      if (updatedTriggers.length > 0) {
        setGraphCache((prev) => ({
          ...prev,
          [selectedThread.graphId]: {
            ...graphEntry,
            triggerNodes: updatedTriggers,
          },
        }));
      }
    }
  }, [selectedThread, graphCache, ensureGraphsLoaded, templatesById]);

  // Recompute trigger nodes when templates change
  useEffect(() => {
    if (!Object.keys(templatesById).length) return;
    setGraphCache((prev) => {
      const nextEntries: Record<string, GraphCacheEntry> = {};
      let changed = false;
      Object.entries(prev).forEach(([graphId, entry]) => {
        const updatedTriggers = buildTriggerNodes(entry.graph, templatesById);
        nextEntries[graphId] = {
          graph: entry.graph,
          triggerNodes: updatedTriggers,
          nodeDisplayNames: entry.nodeDisplayNames,
        };
        if (updatedTriggers.length !== entry.triggerNodes.length) {
          changed = true;
        }
      });
      return changed ? nextEntries : prev;
    });
  }, [templatesById]);

  const loadThreads = useCallback(
    async (options?: { append?: boolean }) => {
      const requestedGraphId = graphFilterId;
      const isAppend = options?.append ?? false;
      if (isAppend) {
        if (!threadsHasMore || threadsLoadingMore) return;
        setThreadsLoadingMore(true);
      } else if (threadsLoading) {
        return;
      } else {
        setThreadsLoading(true);
      }

      try {
        const response = await threadsApi.getThreads(
          requestedGraphId,
          THREADS_PAGE_SIZE,
          isAppend ? threadsOffset : 0,
        );
        const fetched = response.data || [];
        const filteredFetched = requestedGraphId
          ? fetched.filter((thread) => thread.graphId === requestedGraphId)
          : fetched;

        if (graphFilterId !== requestedGraphId) {
          return;
        }

        setThreads((prev) => {
          const base =
            requestedGraphId === undefined
              ? prev
              : prev.filter((thread) => thread.graphId === requestedGraphId);
          if (!isAppend) {
            return sortThreadsByTimestampDesc(filteredFetched);
          }
          const existingIds = new Set(base.map((thread) => thread.id));
          const merged = [
            ...base,
            ...filteredFetched.filter((thread) => !existingIds.has(thread.id)),
          ];
          return sortThreadsByTimestampDesc(merged);
        });

        setThreadsOffset((current) =>
          isAppend ? current + fetched.length : fetched.length,
        );
        setThreadsHasMore(fetched.length === THREADS_PAGE_SIZE);

        void ensureGraphsLoaded(filteredFetched);
      } catch (error) {
        console.error('Error loading threads', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to load threads list',
        );
        antdMessage.error(errorMessage);
        setThreadsHasMore(false);
      } finally {
        if (isAppend) {
          setThreadsLoadingMore(false);
        } else {
          setThreadsLoading(false);
        }
      }
    },
    [
      ensureGraphsLoaded,
      threadsHasMore,
      threadsLoading,
      threadsLoadingMore,
      threadsOffset,
      sortThreadsByTimestampDesc,
      graphFilterId,
    ],
  );

  useEffect(() => {
    void loadThreads();
    // We intentionally re-fetch only when graph filter changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graphFilterId]);

  useEffect(() => {
    threadsRef.current = threads;
  }, [threads]);

  // Only clear selection if selected thread no longer exists (e.g., deleted)
  useEffect(() => {
    // If draft is selected, don't change selection
    if (draftThread && draftThread.id === selectedThreadId) {
      return;
    }

    // Only clear selection if selected thread was deleted
    if (selectedThreadId && threads.length > 0) {
      const stillExists = threads.some(
        (thread) => thread.id === selectedThreadId,
      );
      if (!stillExists) {
        // Thread was deleted, clear selection (don't auto-select another)
        setSelectedThreadId(undefined);
      }
    }
  }, [threads, selectedThreadId, draftThread]);

  const handleThreadsScroll = useCallback(() => {
    const el = threadsContainerRef.current;
    if (!el) return;
    const nearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    if (
      nearBottom &&
      threadsHasMore &&
      !threadsLoadingMore &&
      !threadsLoading
    ) {
      void loadThreads({ append: true });
    }
  }, [loadThreads, threadsHasMore, threadsLoading, threadsLoadingMore]);

  const handleThreadCreateEvent = useCallback(
    (notification: ThreadCreateNotification) => {
      const newThread = notification.data;
      if (!newThread) return;
      if (graphFilterId && newThread.graphId !== graphFilterId) {
        return;
      }

      // Check if this is replacing a draft thread
      const isDraftReplacement =
        draftThread &&
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId;

      setThreads((prev) => {
        const exists = prev.some((thread) => thread.id === newThread.id);
        if (exists) {
          const updated = prev.map((thread) =>
            thread.id === newThread.id ? newThread : thread,
          );
          return sortThreadsByTimestampDesc(updated);
        }
        return sortThreadsByTimestampDesc([newThread, ...prev]);
      });
      void ensureGraphsLoaded([newThread]);

      // Update external thread ID if present
      if (newThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [newThread.id]: newThread.externalThreadId,
        }));
      }

      if (isDraftReplacement) {
        // Replace draft thread with real thread
        const draftId = draftThread.id;

        // Migrate messages and pending messages from draft to real thread
        const draftThreadMessages = messages[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            // Update threadId in all migrated messages to match the new thread
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThread.id,
              externalThreadId:
                newThread.externalThreadId || msg.externalThreadId,
            }));
            updateMessages(newThread.id, () => migratedMessages, nodeScope);
          });

          // Carry over meta so we don't refetch immediately and flash loader
          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThread.id]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
            },
          }));
        }

        const draftPending = pendingMessages[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThread.id, () => msgs ?? [], nodeScope);
          });
        }

        // Clear draft and select new thread
        setDraftThread(null);
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      } else if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === newThread.externalThreadId
      ) {
        // Regular thread switch (not draft)
        setSelectedThreadId(newThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      ensureGraphsLoaded,
      setExternalThreadIds,
      sortThreadsByTimestampDesc,
      graphFilterId,
      draftThread,
      messages,
      pendingMessages,
      updateMessages,
      updatePendingMessages,
    ],
  );

  const handleThreadUpdateEvent = useCallback(
    (notification: ThreadUpdateNotification) => {
      const updatedThread = notification.data;
      if (!updatedThread) return;
      if (graphFilterId && updatedThread.graphId !== graphFilterId) {
        return;
      }
      setThreads((prev) => {
        const index = prev.findIndex(
          (thread) => thread.id === updatedThread.id,
        );
        if (index === -1) {
          return prev;
        }
        const currentThread = prev[index];

        if (!shouldApplyThreadUpdate(currentThread, updatedThread)) {
          return prev;
        }
        const next = [...prev];
        next[index] = updatedThread;
        return sortThreadsByTimestampDesc(next);
      });

      // Update external thread ID if present
      if (updatedThread.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [updatedThread.id]: updatedThread.externalThreadId,
        }));
      }

      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === updatedThread.externalThreadId
      ) {
        setSelectedThreadId(updatedThread.id);
        pendingThreadSelectionRef.current = null;
      }
    },
    [
      setExternalThreadIds,
      shouldApplyThreadUpdate,
      sortThreadsByTimestampDesc,
      graphFilterId,
    ],
  );

  const handleThreadDeleteEvent = useCallback(
    (notification: ThreadDeleteNotification) => {
      const deletedThread = notification.data;
      if (!deletedThread) return;
      setThreads((prev) =>
        prev.filter((thread) => thread.id !== deletedThread.id),
      );
      if (selectedThreadId === deletedThread.id) {
        setSelectedThreadId(undefined);
      }
      if (
        pendingThreadSelectionRef.current &&
        pendingThreadSelectionRef.current === deletedThread.externalThreadId
      ) {
        pendingThreadSelectionRef.current = null;
      }
    },
    [selectedThreadId],
  );

  useWebSocketEvent(
    'thread.create',
    (notification) =>
      handleThreadCreateEvent(notification as ThreadCreateNotification),
    [handleThreadCreateEvent],
  );
  useWebSocketEvent(
    'thread.update',
    (notification) =>
      handleThreadUpdateEvent(notification as ThreadUpdateNotification),
    [handleThreadUpdateEvent],
  );
  useWebSocketEvent(
    'thread.delete',
    (notification) =>
      handleThreadDeleteEvent(notification as ThreadDeleteNotification),
    [handleThreadDeleteEvent],
  );
  useWebSocketEvent(
    'graph.node.update',
    (notification) => {
      const data = notification as GraphNodeUpdateNotification;
      const eventThreadId =
        (typeof data.threadId === 'string' && data.threadId.length > 0
          ? data.threadId
          : undefined) ??
        (typeof data.data?.metadata?.threadId === 'string'
          ? data.data.metadata.threadId
          : undefined);
      const eventInternalThreadId =
        typeof data.internalThreadId === 'string' &&
        data.internalThreadId.length > 0
          ? data.internalThreadId
          : undefined;
      const metadataRunId =
        typeof data.data?.metadata?.runId === 'string'
          ? data.data.metadata.runId
          : undefined;
      const internalThreadId =
        eventInternalThreadId || resolveInternalThreadId(eventThreadId);

      const targetThreadId = internalThreadId ?? eventThreadId;
      if (!targetThreadId) {
        return;
      }

      const externalThreadIdForTarget =
        externalThreadIds[targetThreadId] ?? eventThreadId;

      if (eventThreadId) {
        setExternalThreadIds((prev) => {
          const existing = prev[targetThreadId];
          if (existing === eventThreadId) return prev;
          return { ...prev, [targetThreadId]: eventThreadId };
        });
      }
      const targetRunIds = buildIdSet(data.runId, metadataRunId);

      const reasoningChunks =
        data.data?.additionalNodeMetadata?.reasoningChunks;

      // Only process reasoning chunks if they exist
      // Don't clear streaming reasoning when chunks are absent - they should persist
      // until replaced by final non-streaming reasoning messages
      if (!reasoningChunks) {
        return;
      }

      const applyUpdateToKeys = [undefined, data.nodeId];

      const reasoningContainer = narrowReasoningContainer(reasoningChunks, [
        eventThreadId,
        externalThreadIdForTarget,
        data.runId ?? metadataRunId,
      ]);
      const reasoningEntries = extractReasoningEntries(reasoningContainer, {
        threadId: externalThreadIdForTarget ?? eventThreadId,
        runId: data.runId ?? metadataRunId,
      });

      // Only upsert if we have valid reasoning entries
      if (reasoningEntries.length > 0) {
        applyUpdateToKeys.forEach((key) => {
          updateMessages(
            targetThreadId,
            (prev) =>
              upsertReasoningEntries(prev, reasoningEntries, {
                externalThreadId: externalThreadIdForTarget,
                runId: data.runId ?? metadataRunId,
                selectedThreadId: targetThreadId,
                nodeId: key,
              }),
            key,
          );
        });
      }
    },
    [
      resolveInternalThreadId,
      externalThreadIds,
      updateMessages,
      upsertReasoningEntries,
      setExternalThreadIds,
    ],
  );

  // Handle agent messages - update shared state for all listeners
  useWebSocketEvent(
    'agent.message',
    (notification) => {
      const data = notification as AgentMessageNotification;
      if (!data.internalThreadId) return;

      const threadId = data.internalThreadId;
      const nodeId = data.nodeId;
      const incomingMessage = data.data;

      // Update shared messages for both 'all' (thread-level) and node-specific
      updateMessages(threadId, (prev) => {
        return mergeMessagesReplacingStreaming(prev, [incomingMessage]);
      });

      // If nodeId exists, also update node-specific messages
      if (nodeId) {
        updateMessages(
          threadId,
          (prev) => {
            return mergeMessagesReplacingStreaming(prev, [incomingMessage]);
          },
          nodeId,
        );
      }

      // Clear pending that matches this incoming message (by content for human messages)
      const incomingContent =
        typeof incomingMessage.message?.content === 'string'
          ? (incomingMessage.message?.content as string)
          : undefined;
      const incomingRole = incomingMessage.message?.role as string | undefined;
      if (incomingContent && incomingRole === 'human') {
        const applyPendingToKeys = [undefined, nodeId];
        applyPendingToKeys.forEach((key) => {
          updatePendingMessages(
            threadId,
            (prev) =>
              prev.filter(
                (p) =>
                  typeof p.content !== 'string' ||
                  p.content !== incomingContent,
              ),
            key,
          );
        });
      }

      // Update external thread ID if present
      if (incomingMessage.externalThreadId) {
        setExternalThreadIds((prev) => ({
          ...prev,
          [threadId]: incomingMessage.externalThreadId,
        }));
      }
    },
    [updateMessages, updatePendingMessages, setExternalThreadIds],
  );
  const threadStatusMeta = selectedThread
    ? 'isDraft' in selectedThread && selectedThread.isDraft
      ? null
      : getThreadStatusDisplay((selectedThread as ThreadDto).status)
    : null;
  const selectedGraphStatus = selectedThread
    ? graphCache[selectedThread.graphId]?.graph.status
    : undefined;
  const graphIsRunning = selectedGraphStatus === GraphDtoStatusEnum.Running;
  const selectedThreadIsDraft =
    selectedThread !== undefined &&
    'isDraft' in selectedThread &&
    selectedThread.isDraft === true;
  const analysisButtonDisabled =
    !selectedThread || selectedThreadIsDraft || !graphIsRunning;

  const handleOpenAnalyzeModal = useCallback(() => {
    if (analysisButtonDisabled) return;
    setAnalyzeModalOpen(true);
  }, [analysisButtonDisabled]);

  const handleCloseAnalyzeModal = useCallback(() => {
    setAnalyzeModalOpen(false);
  }, []);

  const handleAnalyzeThread = useCallback(async () => {
    if (!selectedThread || selectedThreadIsDraft) return;
    try {
      setAnalyzeLoading(true);
      const response = await threadsApi.analyzeThread(selectedThread.id, {
        userInput:
          analysisUserInput && analysisUserInput.trim().length > 0
            ? analysisUserInput
            : undefined,
        threadId: analysisConversationId ?? undefined,
      });
      const analysisText = response.data?.analysis ?? '';
      const conversationId = response.data?.conversationId ?? null;
      if (conversationId) {
        setAnalysisConversationId(conversationId);
      }
      setAnalysisUserInput('');
      setAnalysisResult(
        analysisText && analysisText.trim().length > 0
          ? analysisText
          : 'No analysis returned for this thread.',
      );
    } catch (error) {
      console.error('Error analyzing thread', error);
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to analyze thread',
      );
      antdMessage.error(errorMessage);
    } finally {
      setAnalyzeLoading(false);
    }
  }, [
    selectedThread,
    selectedThreadIsDraft,
    analysisUserInput,
    analysisConversationId,
  ]);

  const filteredGraphLabel = useMemo(() => {
    if (!graphFilterId) return undefined;
    const graphName = graphCache[graphFilterId]?.graph.name;
    if (graphName && graphName.trim().length > 0) {
      return graphName;
    }
    if (graphFilterId.length <= 10) {
      return graphFilterId;
    }
    return `…${graphFilterId.slice(-6)}`;
  }, [graphFilterId, graphCache]);

  const handleClearGraphFilter = useCallback(() => {
    const params = new URLSearchParams(location.search);
    params.delete('graphId');
    navigate(
      {
        pathname: location.pathname,
        search: params.toString() ? `?${params.toString()}` : '',
      },
      { replace: true },
    );
  }, [location.pathname, location.search, navigate]);

  const handleDeleteThread = useCallback(
    async (threadId: string) => {
      try {
        await threadsApi.deleteThread(threadId);
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (selectedThreadId === threadId) {
          setSelectedThreadId(undefined);
        }
        antdMessage.success('Thread deleted successfully');
      } catch (error) {
        console.error('Error deleting thread:', error);
        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to delete thread',
        );
        antdMessage.error(errorMessage);
      }
    },
    [selectedThreadId],
  );

  const handleCreateDraftThread = useCallback(() => {
    if (draftThread) {
      // If draft already exists, just focus it
      setSelectedThreadId(draftThread.id);
      return;
    }

    // Determine graphId for draft
    const draftGraphId = graphFilterId || threads[0]?.graphId;
    if (!draftGraphId) {
      antdMessage.warning('Please select a graph first or filter by graph');
      return;
    }

    // Create new draft thread
    const now = new Date().toISOString();
    const newDraft: DraftThread = {
      id: `draft-${Date.now()}`,
      graphId: draftGraphId,
      name: 'New Chat',
      status: 'draft',
      createdAt: now,
      updatedAt: now,
      externalThreadId: '',
      isDraft: true,
    };

    setDraftThread(newDraft);
    setSelectedThreadId(newDraft.id);
  }, [draftThread, graphFilterId, threads]);

  const handleDraftMessageSent = useCallback(
    (newThreadId: string) => {
      if (draftThread) {
        const draftId = draftThread.id;

        // Migrate any optimistic/pending messages from the draft thread
        const draftThreadMessages = messages[draftId];
        if (draftThreadMessages) {
          Object.entries(draftThreadMessages).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            // Update threadId in all migrated messages to match the new thread
            const migratedMessages = msgs.map((msg) => ({
              ...msg,
              threadId: newThreadId,
            }));
            updateMessages(newThreadId, () => migratedMessages, nodeScope);
          });

          // Carry over meta so we don't refetch immediately and flash loader
          const draftAllMessages = draftThreadMessages['all'] ?? [];
          setMessageMeta((prev) => ({
            ...prev,
            [newThreadId]: {
              loading: false,
              loadingMore: false,
              hasMore: true,
              offset: draftAllMessages.length,
            },
          }));
        }

        const draftPending = pendingMessages[draftId];
        if (draftPending) {
          Object.entries(draftPending).forEach(([scopeKey, msgs]) => {
            const nodeScope = scopeKey === 'all' ? undefined : scopeKey;
            updatePendingMessages(newThreadId, () => msgs ?? [], nodeScope);
          });
        }
      }

      // Delete draft and select the newly created thread
      const wasDraftSelected =
        draftThread && draftThread.id === selectedThreadId;
      setDraftThread(null);
      if (wasDraftSelected) {
        setSelectedThreadId(newThreadId);
      }
    },
    [
      draftThread,
      messages,
      pendingMessages,
      selectedThreadId,
      updateMessages,
      updatePendingMessages,
    ],
  );

  const renderThreadItem = (thread: ThreadDto | DraftThread) => {
    const isActive = thread.id === selectedThreadId;
    const isDraft = 'isDraft' in thread && thread.isDraft === true;
    const statusMeta = isDraft
      ? { label: 'Draft', color: '#d9d9d9' }
      : getThreadStatusDisplay(
          (thread as ThreadDto).status as ThreadDtoStatusEnum,
        );
    const graphName = graphCache[thread.graphId]?.graph.name;
    const createdAt = new Date(thread.createdAt).toLocaleString();

    return (
      <div
        key={thread.id}
        onClick={() => setSelectedThreadId(thread.id)}
        onMouseEnter={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fafafa';
          }
        }}
        onMouseLeave={(e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = '#fff';
          }
        }}
        style={{
          padding: '12px 16px',
          borderBottom: '1px solid #f0f0f0',
          cursor: 'pointer',
          backgroundColor: isActive ? '#f5f9ff' : '#fff',
          overflow: 'hidden',
          transition: 'background-color 0.2s ease',
        }}>
        <Space
          direction="vertical"
          size={4}
          style={{ width: '100%', minWidth: 0 }}>
          <div
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: 8,
              minWidth: 0,
            }}>
            <div style={{ flex: 1, minWidth: 0 }}>
              <Text
                strong
                ellipsis={{
                  tooltip: thread.name || `Thread ${thread.id.slice(-6)}`,
                }}
                style={{
                  width: '100%',
                  display: 'block',
                }}>
                {thread.name || `Thread ${thread.id.slice(-6)}`}
              </Text>
            </div>
            {statusMeta && (
              <Tag
                color={statusMeta.color}
                style={{ margin: 0, flexShrink: 0, whiteSpace: 'nowrap' }}>
                {statusMeta.label}
              </Tag>
            )}
            {!isDraft && (
              <Dropdown
                menu={{
                  items: [
                    {
                      key: 'delete',
                      label: (
                        <Popconfirm
                          title="Delete thread"
                          description="Are you sure you want to delete this thread?"
                          onConfirm={(e) => {
                            e?.stopPropagation();
                            handleDeleteThread(thread.id);
                          }}
                          onCancel={(e) => e?.stopPropagation()}
                          okText="Delete"
                          cancelText="Cancel"
                          okButtonProps={{ danger: true }}>
                          <div
                            onClick={(e) => e.stopPropagation()}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: 8,
                            }}>
                            <DeleteOutlined />
                            Delete
                          </div>
                        </Popconfirm>
                      ),
                    },
                  ],
                }}
                trigger={['click']}
                placement="bottomRight">
                <Button
                  type="text"
                  size="small"
                  icon={<EllipsisOutlined />}
                  onClick={(e) => e.stopPropagation()}
                  style={{
                    flexShrink: 0,
                    padding: '4px 8px',
                  }}
                />
              </Dropdown>
            )}
          </div>
          <Text
            type="secondary"
            title={graphName || 'Loading graph…'}
            style={{
              fontSize: 12,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              minWidth: 0,
            }}>
            {graphName || 'Loading graph…'}
          </Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Created {createdAt}
          </Text>
        </Space>
      </div>
    );
  };

  const threadsEmpty =
    !threadsLoading && !threadsLoadingMore && threads.length === 0;

  return (
    <div
      style={{
        height: 'calc(100vh - 64px)',
        maxHeight: 'calc(100vh - 64px)',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
      }}>
      <div
        style={{
          display: 'flex',
          flex: 1,
          minHeight: 0,
          overflow: 'hidden',
        }}>
        <div
          style={{
            width: 340,
            borderRight: '1px solid #f0f0f0',
            display: 'flex',
            flexDirection: 'column',
            background: '#fff',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              flexShrink: 0,
            }}>
            <div
              style={{
                width: '100%',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'flex-start',
                gap: 12,
                minWidth: 0,
              }}>
              <div
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 4,
                  minWidth: 0,
                  flex: 1,
                }}>
                <Title level={4} style={{ margin: 0 }}>
                  Chats
                </Title>
                {graphFilterId && (
                  <div
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: 6,
                      width: '100%',
                      minWidth: 0,
                      flexWrap: 'nowrap',
                    }}>
                    <span
                      style={{
                        flex: '1 1 auto',
                        minWidth: 0,
                        fontSize: 12,
                        color: 'rgba(0, 0, 0, 0.45)', // matches Typography.Text type="secondary"
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        display: 'block',
                      }}
                      title={`Graph: ${filteredGraphLabel ?? ''}`}>
                      Graph:{' '}
                      <span style={{ fontWeight: 600 }}>
                        {filteredGraphLabel}
                      </span>
                    </span>
                    <CloseOutlined
                      onClick={handleClearGraphFilter}
                      style={{
                        flexShrink: 0,
                        cursor: 'pointer',
                        fontSize: 10,
                        color: '#747474',
                      }}
                      aria-label="Clear graph filter"
                    />
                  </div>
                )}
              </div>
              <Space>
                <Button
                  size="small"
                  icon={<PlusOutlined />}
                  onClick={handleCreateDraftThread}
                  style={{
                    border: 'none',
                    boxShadow: 'none',
                  }}
                />
                <Button
                  size="small"
                  icon={<ReloadOutlined />}
                  onClick={() => loadThreads()}
                  loading={threadsLoading}
                  style={{
                    border: 'none',
                    boxShadow: 'none',
                  }}
                />
              </Space>
            </div>
          </div>
          <div
            ref={threadsContainerRef}
            onScroll={handleThreadsScroll}
            style={{
              flex: 1,
              minHeight: 0,
              overflowY: 'auto',
            }}>
            {draftThread && renderThreadItem(draftThread)}
            {threads.map(renderThreadItem)}
            {threadsLoading && (
              <div style={{ padding: 24, textAlign: 'center' }}>
                <Spin />
              </div>
            )}
            {threadsEmpty && (
              <div style={{ padding: 24 }}>
                <Empty
                  description={
                    graphFilterId
                      ? 'No threads found for this graph'
                      : 'No threads yet'
                  }
                />
              </div>
            )}
            {threadsLoadingMore && (
              <div style={{ padding: 12, textAlign: 'center' }}>
                <Spin size="small" />
              </div>
            )}
          </div>
        </div>

        <div
          style={{
            flex: 1,
            minHeight: 0,
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
          }}>
          <div
            style={{
              padding: 24,
              display: 'flex',
              flexDirection: 'column',
              flex: 1,
              minHeight: 0,
              background: '#fff',
              overflow: 'hidden',
            }}>
            {selectedThread ? (
              <>
                <div
                  style={{
                    marginBottom: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}>
                  <div>
                    <Title level={4} style={{ margin: 0 }}>
                      {selectedThread.name ||
                        `Thread ${selectedThread.id.slice(-6)}`}
                    </Title>
                    <Space size="small" wrap>
                      <Text type="secondary">
                        Graph:{' '}
                        {graphCache[selectedThread.graphId]?.graph.name ||
                          'Loading…'}
                      </Text>
                      <Link
                        to={`/graphs/${selectedThread.graphId}`}
                        style={{
                          display: 'inline-flex',
                          alignItems: 'center',
                          color: '#1677ff',
                          textDecoration: 'none',
                          position: 'relative',
                          top: '2px',
                          padding: '0 3px',
                        }}
                        aria-label="Open graph details"
                        title="Open graph details">
                        <LinkOutlined />
                      </Link>
                      {selectedThread && (
                        <Space size={8} align="center">
                          {threadStatusMeta && (
                            <Tag color={threadStatusMeta.color}>
                              {threadStatusMeta.label}
                            </Tag>
                          )}
                          <Button
                            type="link"
                            size="small"
                            style={{
                              padding: 0,
                              height: 'auto',
                              fontSize: 12,
                            }}
                            onClick={handleOpenAnalyzeModal}
                            disabled={analysisButtonDisabled}
                            title={
                              selectedThreadIsDraft
                                ? 'Create the thread before analyzing it'
                                : undefined
                            }>
                            Analyze thread
                          </Button>
                        </Space>
                      )}
                    </Space>
                  </div>
                </div>

                <div
                  style={{
                    flex: 1,
                    minHeight: 0,
                    display: 'flex',
                    flexDirection: 'column',
                  }}>
                  <ThreadChatPanel
                    graphId={selectedThread.graphId}
                    thread={selectedThread as ThreadDto}
                    triggerNodes={triggerNodesForSelectedThread}
                    templatesLoading={templatesLoading}
                    nodeDisplayNames={
                      graphCache[selectedThread.graphId]?.nodeDisplayNames
                    }
                    graphLoaded={Boolean(graphCache[selectedThread.graphId])}
                    onRequestThreadSwitch={handleThreadChatSwitchRequest}
                    isDraft={draftThread?.id === selectedThreadId}
                    onDraftMessageSent={handleDraftMessageSent}
                    messages={
                      selectedThreadId
                        ? messages[selectedThreadId]?.['all'] || []
                        : []
                    }
                    messagesLoading={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).loading
                        : false
                    }
                    hasMoreMessages={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).hasMore
                        : false
                    }
                    loadingMoreMessages={
                      selectedThreadId
                        ? getMessageMeta(selectedThreadId).loadingMore
                        : false
                    }
                    pendingMessages={
                      selectedThreadId
                        ? pendingMessages[selectedThreadId]?.['all'] || []
                        : []
                    }
                    externalThreadId={
                      selectedThreadId
                        ? externalThreadIds[selectedThreadId]
                        : undefined
                    }
                    onLoadMoreMessages={
                      selectedThreadId
                        ? () => loadMoreMessagesForThread(selectedThreadId)
                        : undefined
                    }
                    onUpdateSharedMessages={updateMessages}
                    onUpdateSharedPendingMessages={updatePendingMessages}
                  />
                </div>
              </>
            ) : (
              <div
                style={{
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}>
                <Empty
                  description="Select a thread to view its messages"
                  image={Empty.PRESENTED_IMAGE_SIMPLE}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <Modal
        title="Analyze thread"
        open={analyzeModalOpen}
        onCancel={handleCloseAnalyzeModal}
        destroyOnClose
        footer={[
          <Button key="cancel" onClick={handleCloseAnalyzeModal}>
            Close
          </Button>,
          <Button
            key="analyze"
            type="primary"
            onClick={handleAnalyzeThread}
            loading={analyzeLoading}
            disabled={analysisButtonDisabled}>
            Analyze
          </Button>,
        ]}>
        <Space direction="vertical" size={12} style={{ width: '100%' }}>
          <Text>
            AI will analyze this thread and share hints about improvements or
            potential problems.
          </Text>
          <Input.TextArea
            rows={4}
            placeholder="Optional context or questions for the analysis"
            value={analysisUserInput}
            onChange={(e) => setAnalysisUserInput(e.target.value)}
            disabled={analysisButtonDisabled || analyzeLoading}
          />
          {analysisResult ? (
            <div
              style={{
                maxHeight: 360,
                overflowY: 'auto',
                padding: 12,
                border: '1px solid #f0f0f0',
                borderRadius: 8,
              }}>
              <MarkdownContent content={analysisResult} />
            </div>
          ) : (
            <Text type="secondary">
              Run the analysis to see AI feedback for this thread.
            </Text>
          )}
        </Space>
      </Modal>
    </div>
  );
};

export default ChatsPage;
