import { useCallback, useEffect, useMemo, useState } from 'react';
import { Button, Dropdown, Input, Typography } from 'antd';
import { SendOutlined } from '@ant-design/icons';
import type { ThreadDto, ThreadMessageDto } from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { graphsApi, threadsApi } from '../../../api';
import ThreadMessagesView from '../../graphs/components/ThreadMessagesView';
import { mergeMessagesReplacingStreaming } from '../../../utils/threadMessages';
import { extractThreadSubId, type TriggerNodeInfo } from '../../../utils/graphThreads';
import { message as antdMessage } from 'antd';
import { useWebSocketEvent } from '../../../hooks/useWebSocket';
import type { AgentMessageNotification } from '../../../services/WebSocketTypes';

const MESSAGES_PAGE_SIZE = 50;

interface ThreadChatPanelProps {
  graphId: string;
  thread: ThreadDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames?: Record<string, string>;
  templatesLoading?: boolean;
  graphLoaded?: boolean;
  onRequestThreadSwitch?: (externalThreadId: string | null) => void;
  style?: React.CSSProperties;
}

export const ThreadChatPanel: React.FC<ThreadChatPanelProps> = ({
  graphId,
  thread,
  triggerNodes,
  nodeDisplayNames,
  templatesLoading = false,
  graphLoaded = true,
  onRequestThreadSwitch,
  style,
}) => {
  const [messages, setMessages] = useState<ThreadMessageDto[]>([]);
  const [messagesLoading, setMessagesLoading] = useState(false);
  const [messagesLoadingMore, setMessagesLoadingMore] = useState(false);
  const [messagesOffset, setMessagesOffset] = useState(0);
  const [hasMoreMessages, setHasMoreMessages] = useState(false);
  const [selectedTriggerId, setSelectedTriggerId] = useState<string | undefined>(
    () => triggerNodes[0]?.id,
  );
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(thread.externalThreadId ?? undefined);

  useEffect(() => {
    setSelectedThreadExternalId(thread.externalThreadId ?? undefined);
    setMessageInput('');
  }, [thread.externalThreadId, thread.id]);

  useEffect(() => {
    if (!triggerNodes.length) {
      setSelectedTriggerId(undefined);
      return;
    }
    setSelectedTriggerId((prev) => {
      if (prev && triggerNodes.some((node) => node.id === prev)) {
        return prev;
      }
      return triggerNodes[0].id;
    });
  }, [triggerNodes, thread.id]);

  const loadMessages = useCallback(async () => {
    try {
      setMessagesLoading(true);
      setHasMoreMessages(false);
      setMessagesOffset(0);

      const response = await threadsApi.getThreadMessages(
        thread.id,
        undefined,
        MESSAGES_PAGE_SIZE,
        0,
      );

      const fetched = response.data?.reverse() || [];
      setMessages(fetched);
      setMessagesOffset(fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);

      const extId =
        fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
        thread.externalThreadId ??
        undefined;
      setSelectedThreadExternalId(extId);
    } catch (error) {
      console.error('Error loading messages', error);
      antdMessage.error('Failed to load messages for thread');
      setMessages([]);
      setHasMoreMessages(false);
    } finally {
      setMessagesLoading(false);
    }
  }, [thread.id, thread.externalThreadId]);

  useEffect(() => {
    void loadMessages();
  }, [loadMessages]);

  const handleLoadMoreMessages = useCallback(async () => {
    if (messagesLoadingMore || !hasMoreMessages || messagesLoading) {
      return;
    }
    try {
      setMessagesLoadingMore(true);
      const response = await threadsApi.getThreadMessages(
        thread.id,
        undefined,
        MESSAGES_PAGE_SIZE,
        messagesOffset,
      );
      const fetched = response.data?.reverse() || [];
      setMessages((prev) => mergeMessagesReplacingStreaming(prev, fetched));
      setMessagesOffset((current) => current + fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);
    } catch (error) {
      console.error('Error loading more messages', error);
      antdMessage.error('Failed to load more messages');
      setHasMoreMessages(false);
    } finally {
      setMessagesLoadingMore(false);
    }
  }, [messagesLoadingMore, hasMoreMessages, messagesLoading, thread.id, messagesOffset]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }
    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        thread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto = {
        messages: [messageInput.trim()],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
      };
      const response = await graphsApi.executeTrigger(
        graphId,
        selectedTriggerId,
        executeTriggerDto,
      );

      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== thread.externalThreadId;

      if (onRequestThreadSwitch) {
        onRequestThreadSwitch(shouldSelectNewThread ? returnedExternalThreadId : null);
      }

      antdMessage.success('Message sent');
      setMessageInput('');
    } catch (error) {
      console.error('Error sending message', error);
      antdMessage.error('Failed to send message');
    } finally {
      setSendingMessage(false);
    }
  }, [
    selectedTriggerId,
    messageInput,
    graphId,
    thread.externalThreadId,
    selectedThreadExternalId,
    onRequestThreadSwitch,
  ]);

  useWebSocketEvent(
    'agent.message',
    (notification) => {
      const agentNotification = notification as AgentMessageNotification;
      if (agentNotification.internalThreadId !== thread.id) return;
      const incomingMessage = agentNotification.data;
      setMessages((prev) =>
        mergeMessagesReplacingStreaming(prev, [incomingMessage]),
      );
      if (incomingMessage.externalThreadId) {
        setSelectedThreadExternalId(incomingMessage.externalThreadId);
      }
    },
    [thread.id],
  );

  const triggerMenuItems = useMemo(
    () =>
      triggerNodes.map((trigger) => ({
        key: trigger.id,
        label: trigger.name,
        onClick: () => setSelectedTriggerId(trigger.id),
      })),
    [triggerNodes],
  );

  const triggerHelperText = templatesLoading
    ? 'Loading triggers...'
    : graphLoaded
      ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
      : 'Loading graph data...';

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        minHeight: 0,
        ...style,
      }}>
      <div
        style={{
          flex: 1,
          minHeight: 0,
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fafafa',
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
        }}>
        <ThreadMessagesView
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={thread.id}
          isAgentNode
          onLoadMoreMessages={hasMoreMessages ? handleLoadMoreMessages : undefined}
          hasMoreMessages={hasMoreMessages}
          loadingMore={messagesLoadingMore}
          isNodeRunning={thread.status === ThreadDtoStatusEnum.Running}
          nodeDisplayNames={nodeDisplayNames}
          showNodeHeadings
        />
      </div>

      <div
        style={{
          marginTop: 16,
          padding: '12px 16px',
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fff',
        }}>
        {triggerNodes.length > 0 ? (
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 12,
            }}>
            <Dropdown
              menu={{
                items: triggerMenuItems,
                selectedKeys: selectedTriggerId ? [selectedTriggerId] : [],
              }}
              trigger={['click']}>
              <Button
                type="default"
                size="middle"
                style={{
                  flexShrink: 0,
                }}>
                {triggerNodes.find((t) => t.id === selectedTriggerId)?.name ||
                  'Select trigger'}
              </Button>
            </Dropdown>
            <Input
              placeholder="Type your message..."
              value={messageInput}
              onChange={(e) => setMessageInput(e.target.value)}
              onPressEnter={(e) => {
                if (!e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage();
                }
              }}
              disabled={sendingMessage || !selectedTriggerId}
              style={{ flex: 1 }}
            />
            <Button
              type="primary"
              icon={<SendOutlined />}
              onClick={handleSendMessage}
              loading={sendingMessage}
              disabled={
                !messageInput.trim() ||
                !selectedTriggerId ||
                templatesLoading ||
                sendingMessage
              }
              style={{ flexShrink: 0 }}>
              Send
            </Button>
          </div>
        ) : (
          <div style={{ textAlign: 'center', padding: '8px 0' }}>
            <Typography.Text type="secondary" style={{ fontSize: 13 }}>
              {triggerHelperText}
            </Typography.Text>
          </div>
        )}
      </div>
    </div>
  );
};

export default ThreadChatPanel;


