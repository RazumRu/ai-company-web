import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { Button, Dropdown, Input, Typography } from 'antd';
import { SendOutlined } from '@ant-design/icons';
import type {
  ThreadDto,
  ThreadMessageDto,
  GraphNodeWithStatusDto,
  GraphDtoStatusEnum,
} from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { graphsApi, threadsApi } from '../../../api';
import ThreadMessagesView from '../../graphs/components/ThreadMessagesView';
import {
  mergeMessagesReplacingStreaming,
  sortMessagesChronologically,
} from '../../../utils/threadMessages';
import {
  extractThreadSubId,
  type TriggerNodeInfo,
} from '../../../utils/graphThreads';
import { message as antdMessage } from 'antd';
import { useWebSocketEvent } from '../../../hooks/useWebSocket';
import type {
  AgentMessageNotification,
  ThreadCreateNotification,
  GraphNodeUpdateNotification,
} from '../../../services/WebSocketTypes';

const MESSAGES_PAGE_SIZE = 50;

interface ThreadChatPanelProps {
  graphId: string;
  thread: ThreadDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames?: Record<string, string>;
  templatesLoading?: boolean;
  graphLoaded?: boolean;
  onRequestThreadSwitch?: (externalThreadId: string | null) => void;
  isDraft?: boolean;
  onDraftMessageSent?: (newThreadId: string) => void;
  style?: React.CSSProperties;
  sharedMessages?: ThreadMessageDto[];
  sharedExternalThreadId?: string;
  onUpdateSharedMessages?: (
    threadId: string,
    updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
    nodeId?: string,
  ) => void;
}

export const ThreadChatPanel: React.FC<ThreadChatPanelProps> = ({
  graphId,
  thread,
  triggerNodes,
  nodeDisplayNames,
  templatesLoading = false,
  graphLoaded = true,
  onRequestThreadSwitch,
  isDraft = false,
  onDraftMessageSent,
  style,
  sharedMessages,
  sharedExternalThreadId,
  onUpdateSharedMessages,
}) => {
  const [messages, setMessages] = useState<ThreadMessageDto[]>([]);
  const [messagesLoading, setMessagesLoading] = useState(false);
  const [messagesLoadingMore, setMessagesLoadingMore] = useState(false);
  const [messagesOffset, setMessagesOffset] = useState(0);
  const [hasMoreMessages, setHasMoreMessages] = useState(false);
  const [selectedTriggerId, setSelectedTriggerId] = useState<
    string | undefined
  >(() => triggerNodes[0]?.id);
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(thread.externalThreadId ?? undefined);
  const [pendingDraftExternalId, setPendingDraftExternalId] = useState<
    string | undefined
  >(undefined);
  const pendingDraftExternalIdRef = useRef<string | undefined>(undefined);
  const isSendingMessageRef = useRef(false);
  const optimisticMessageIdsRef = useRef<Set<string>>(new Set());
  const pendingOptimisticMessagesRef = useRef<Map<string, ThreadMessageDto>>(
    new Map(),
  );
  const [compiledNodesMap, setCompiledNodesMap] = useState<
    Record<string, GraphNodeWithStatusDto>
  >({});
  const [compiledNodesLoading, setCompiledNodesLoading] = useState(false);
  // Local pending messages (sent while thread is running, before they appear in compiled nodes)
  const [localPendingMessages, setLocalPendingMessages] = useState<
    Array<{
      content: string;
      role: 'human' | 'ai';
      createdAt?: string;
    }>
  >([]);

  useEffect(() => {
    setSelectedThreadExternalId(thread.externalThreadId ?? undefined);
    setMessageInput('');
    // Clear pending draft external ID when thread changes (e.g., draft is cleared)
    if (!isDraft) {
      setPendingDraftExternalId(undefined);
      pendingDraftExternalIdRef.current = undefined;
    }
    // Clear local pending messages when thread changes
    setLocalPendingMessages([]);
    // Restore pending optimistic messages when thread changes (e.g., draft -> real thread)
    if (pendingOptimisticMessagesRef.current.size > 0) {
      setMessages((prev) => {
        const existingIds = new Set(prev.map((msg) => msg.id));
        const optimisticToAdd = Array.from(
          pendingOptimisticMessagesRef.current.values(),
        )
          .filter((msg) => !existingIds.has(msg.id))
          .map((msg) => ({
            ...msg,
            threadId: thread.id, // Update threadId to match new thread
          }));
        if (optimisticToAdd.length > 0) {
          return sortMessagesChronologically([...prev, ...optimisticToAdd]);
        }
        return prev;
      });
    }
  }, [thread.externalThreadId, thread.id, isDraft]);

  useEffect(() => {
    if (!triggerNodes.length) {
      setSelectedTriggerId(undefined);
      return;
    }
    setSelectedTriggerId((prev) => {
      if (prev && triggerNodes.some((node) => node.id === prev)) {
        return prev;
      }
      return triggerNodes[0].id;
    });
  }, [triggerNodes, thread.id]);

  const loadMessages = useCallback(async () => {
    try {
      setMessagesLoading(true);
      setHasMoreMessages(false);
      setMessagesOffset(0);

      const response = await threadsApi.getThreadMessages(
        thread.id,
        undefined,
        MESSAGES_PAGE_SIZE,
        0,
      );

      const fetched = response.data?.reverse() || [];

      // Preserve optimistic messages when loading real messages
      const optimisticFromState = messages.filter((msg) =>
        optimisticMessageIdsRef.current.has(msg.id),
      );
      const optimisticFromRef = Array.from(
        pendingOptimisticMessagesRef.current.values(),
      )
        .filter((msg) => !messages.some((m) => m.id === msg.id))
        .map((msg) => ({
          ...msg,
          threadId: thread.id, // Update threadId to match current thread
        }));
      const allOptimistic = [...optimisticFromState, ...optimisticFromRef];
      const mergedMessages = sortMessagesChronologically([
        ...allOptimistic,
        ...fetched,
      ]);

      setMessages(mergedMessages);

      // Update shared state if available
      if (onUpdateSharedMessages) {
        onUpdateSharedMessages(thread.id, () => mergedMessages);
      }

      setMessagesOffset(fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);

      const extId =
        fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
        thread.externalThreadId ??
        sharedExternalThreadId ??
        undefined;
      setSelectedThreadExternalId(extId);
    } catch (error) {
      console.error('Error loading messages', error);
      antdMessage.error('Failed to load messages for thread');
      // Preserve optimistic messages even on error
      setMessages((prev) =>
        prev.filter((msg) => optimisticMessageIdsRef.current.has(msg.id)),
      );
      setHasMoreMessages(false);
    } finally {
      setMessagesLoading(false);
    }
  }, [thread.id, thread.externalThreadId]);

  useEffect(() => {
    if (!isDraft) {
      // Don't clear messages if we're currently sending a message
      if (isSendingMessageRef.current) {
        return;
      }
      void loadMessages();
    } else {
      // For draft threads, clear all messages except optimistic ones (if sending)
      setMessages((prev) => {
        // Only keep optimistic messages if we're currently sending
        if (isSendingMessageRef.current) {
          return prev.filter((msg) =>
            optimisticMessageIdsRef.current.has(msg.id),
          );
        }
        // Otherwise, clear all messages for draft thread
        return [];
      });
      setMessagesLoading(false);
      setHasMoreMessages(false);
      // Clear optimistic message IDs when switching to draft (unless sending)
      if (!isSendingMessageRef.current) {
        optimisticMessageIdsRef.current.clear();
      }
    }
  }, [loadMessages, isDraft, thread.id]);

  // Fetch compiled nodes to get pending messages
  const fetchCompiledNodes = useCallback(async () => {
    if (isDraft || !graphId) return;

    try {
      setCompiledNodesLoading(true);
      const response = await graphsApi.getCompiledNodes(
        graphId,
        selectedThreadExternalId || thread.externalThreadId || undefined,
      );
      const nodesWithStatus = response.data || [];

      // Collect all pending message contents from compiled nodes
      const compiledPendingContents = new Set<string>();
      nodesWithStatus.forEach((node) => {
        if (
          node.additionalNodeMetadata?.pendingMessages &&
          Array.isArray(node.additionalNodeMetadata.pendingMessages)
        ) {
          const nodePendingMessages = node.additionalNodeMetadata
            .pendingMessages as Array<{ content: string }>;
          nodePendingMessages.forEach((msg) => {
            compiledPendingContents.add(msg.content);
          });
        }
      });

      // Remove local pending messages that now appear in compiled nodes
      if (compiledPendingContents.size > 0) {
        setLocalPendingMessages((prevPending) =>
          prevPending.filter(
            (msg) => !compiledPendingContents.has(msg.content),
          ),
        );
      }

      setCompiledNodesMap(() => {
        const next = nodesWithStatus.reduce<
          Record<string, GraphNodeWithStatusDto>
        >((acc, node) => {
          acc[node.id] = node;
          return acc;
        }, {});
        return next;
      });
    } catch (error) {
      console.error('Error loading compiled nodes:', error);
    } finally {
      setCompiledNodesLoading(false);
    }
  }, [graphId, selectedThreadExternalId, thread.externalThreadId, isDraft]);

  useEffect(() => {
    if (!isDraft && graphId && thread.status === ThreadDtoStatusEnum.Running) {
      void fetchCompiledNodes();
    } else {
      setCompiledNodesMap({});
    }
  }, [fetchCompiledNodes, isDraft, graphId, thread.status]);

  // Listen to graph.node.update events to update compiled nodes
  useWebSocketEvent(
    'graph.node.update',
    (notification) => {
      if (isDraft || !graphId) return;
      const event = notification as GraphNodeUpdateNotification;
      if (event.graphId !== graphId) return;

      // Check if this event is for the current thread
      // Match by external thread ID, internal thread ID, or if both are missing
      const eventThreadId =
        (typeof event.threadId === 'string' && event.threadId.length > 0
          ? event.threadId
          : undefined) ??
        (typeof event.data?.metadata?.threadId === 'string'
          ? event.data.metadata.threadId
          : undefined);
      const eventInternalThreadId =
        typeof event.internalThreadId === 'string' &&
        event.internalThreadId.length > 0
          ? event.internalThreadId
          : undefined;

      const threadMatches =
        eventThreadId === selectedThreadExternalId ||
        eventThreadId === thread.externalThreadId ||
        eventInternalThreadId === thread.id ||
        (!eventThreadId &&
          !selectedThreadExternalId &&
          !thread.externalThreadId &&
          !eventInternalThreadId);

      if (!threadMatches) {
        return;
      }

      // Update compiled nodes map
      setCompiledNodesMap((prev) => {
        const existing = prev[event.nodeId];
        const nextStatus = event.data.status;
        const nextError = event.data.error ?? existing?.error ?? null;
        const nextMetadata = event.data.metadata ?? existing?.metadata;
        const nextAdditionalNodeMetadata =
          event.data.additionalNodeMetadata ?? existing?.additionalNodeMetadata;

        // If this node has pending messages, remove matching local pending messages
        if (
          nextAdditionalNodeMetadata?.pendingMessages &&
          Array.isArray(nextAdditionalNodeMetadata.pendingMessages)
        ) {
          const nodePendingMessages =
            nextAdditionalNodeMetadata.pendingMessages as Array<{
              content: string;
            }>;
          const nodePendingContents = new Set(
            nodePendingMessages.map((msg) => msg.content),
          );
          setLocalPendingMessages((prevPending) =>
            prevPending.filter((msg) => !nodePendingContents.has(msg.content)),
          );
        }

        if (!existing) {
          return {
            ...prev,
            [event.nodeId]: {
              id: event.nodeId,
              name: event.nodeId,
              template: '',
              type: 'runtime',
              status: nextStatus,
              config: {},
              error: nextError,
              metadata: nextMetadata,
              additionalNodeMetadata: nextAdditionalNodeMetadata,
            },
          };
        }

        return {
          ...prev,
          [event.nodeId]: {
            ...existing,
            status: nextStatus,
            error: nextError,
            metadata: nextMetadata,
            additionalNodeMetadata: nextAdditionalNodeMetadata,
          },
        };
      });
    },
    [
      graphId,
      selectedThreadExternalId,
      thread.externalThreadId,
      thread.id,
      isDraft,
    ],
  );

  // Extract pending messages and newMessageMode from compiled nodes
  // Merge with local pending messages (sent while thread is running)
  // Use a ref to track previous values for deep comparison
  const pendingMessagesRef = useRef<
    Array<{
      content: string;
      role: 'human' | 'ai';
      additionalKwargs?: {
        run_id?: string;
        created_at?: string;
        [key: string]: unknown;
      };
      createdAt?: string;
    }>
  >([]);
  const newMessageModeRef = useRef<
    'inject_after_tool_call' | 'wait_for_completion' | undefined
  >(undefined);

  const { pendingMessages, newMessageMode } = useMemo(() => {
    if (isDraft) {
      return { pendingMessages: undefined, newMessageMode: undefined };
    }

    // Find agent nodes (simpleAgent type) that have pending messages
    const agentNodes = Object.values(compiledNodesMap).filter(
      (node) => node.type === 'simpleAgent',
    );

    // Collect pending messages from all agent nodes
    const allPendingMessages: Array<{
      content: string;
      role: 'human' | 'ai';
      additionalKwargs?: {
        run_id?: string;
        created_at?: string;
        [key: string]: unknown;
      };
      createdAt?: string;
    }> = [];

    let foundNewMessageMode:
      | 'inject_after_tool_call'
      | 'wait_for_completion'
      | undefined = undefined;

    for (const node of agentNodes) {
      const nodePendingMessages = node.additionalNodeMetadata
        ?.pendingMessages as
        | Array<{
            content: string;
            role: 'human' | 'ai';
            additionalKwargs?: {
              run_id?: string;
              created_at?: string;
              [key: string]: unknown;
            };
            createdAt?: string;
          }>
        | undefined;

      if (nodePendingMessages && nodePendingMessages.length > 0) {
        allPendingMessages.push(...nodePendingMessages);
      }

      // Extract newMessageMode from node config (use first found)
      if (!foundNewMessageMode) {
        const nodeNewMessageMode = (node.config as Record<string, unknown>)
          ?.newMessageMode as
          | 'inject_after_tool_call'
          | 'wait_for_completion'
          | undefined;
        if (nodeNewMessageMode) {
          foundNewMessageMode = nodeNewMessageMode;
        }
      }
    }

    // Merge with local pending messages, but filter out duplicates
    // (if a local message appears in compiled nodes, use the one from compiled nodes)
    const compiledMessageContents = new Set(
      allPendingMessages.map((msg) => msg.content),
    );
    const localMessagesToAdd = localPendingMessages.filter(
      (localMsg) => !compiledMessageContents.has(localMsg.content),
    );

    const mergedPendingMessages = [
      ...allPendingMessages,
      ...localMessagesToAdd,
    ];

    // Deep comparison to avoid creating new array reference if content hasn't changed
    const prevPending = pendingMessagesRef.current;
    const prevNewMessageMode = newMessageModeRef.current;

    const newPendingMessages: typeof mergedPendingMessages | undefined =
      mergedPendingMessages.length > 0 ? mergedPendingMessages : undefined;

    // Compare arrays by content to avoid unnecessary re-renders
    let stablePendingMessages = newPendingMessages;
    if (
      newPendingMessages &&
      prevPending.length === newPendingMessages.length
    ) {
      // Check if content is the same
      const contentsMatch = newPendingMessages.every(
        (msg, idx) =>
          prevPending[idx]?.content === msg.content &&
          prevPending[idx]?.role === msg.role,
      );
      if (contentsMatch) {
        // Reuse previous array reference if content is the same
        stablePendingMessages = prevPending as typeof newPendingMessages;
      } else {
        // Content changed, update ref
        pendingMessagesRef.current =
          (newPendingMessages as typeof prevPending) || [];
      }
    } else {
      // Length changed, update ref
      pendingMessagesRef.current =
        (newPendingMessages as typeof prevPending) || [];
    }

    // Compare newMessageMode
    let stableNewMessageMode = foundNewMessageMode;
    if (foundNewMessageMode === prevNewMessageMode) {
      stableNewMessageMode = prevNewMessageMode;
    } else {
      newMessageModeRef.current = foundNewMessageMode;
    }

    return {
      pendingMessages: stablePendingMessages,
      newMessageMode: stableNewMessageMode,
    };
  }, [compiledNodesMap, localPendingMessages, isDraft]);

  const handleLoadMoreMessages = useCallback(async () => {
    if (messagesLoadingMore || !hasMoreMessages || messagesLoading) {
      return;
    }
    try {
      setMessagesLoadingMore(true);
      const response = await threadsApi.getThreadMessages(
        thread.id,
        undefined,
        MESSAGES_PAGE_SIZE,
        messagesOffset,
      );
      const fetched = response.data?.reverse() || [];
      const merged = mergeMessagesReplacingStreaming(messages, fetched);
      setMessages(merged);

      // Update shared state if available
      if (onUpdateSharedMessages) {
        onUpdateSharedMessages(thread.id, () => merged);
      }

      setMessagesOffset((current) => current + fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);
    } catch (error) {
      console.error('Error loading more messages', error);
      antdMessage.error('Failed to load more messages');
      setHasMoreMessages(false);
    } finally {
      setMessagesLoadingMore(false);
    }
  }, [
    messagesLoadingMore,
    hasMoreMessages,
    messagesLoading,
    thread.id,
    messagesOffset,
  ]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }

    const messageText = messageInput.trim();
    const now = new Date().toISOString();
    const isThreadRunning = thread.status === ThreadDtoStatusEnum.Running;

    // If thread is running, add message as pending instead of optimistic
    if (isThreadRunning) {
      // Add to local pending messages
      setLocalPendingMessages((prev) => [
        ...prev,
        {
          content: messageText,
          role: 'human',
          createdAt: now,
        },
      ]);
      setMessageInput('');
    } else {
      // Create optimistic user message (for non-running threads)
      const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      optimisticMessageIdsRef.current.add(optimisticMessageId);

      const optimisticMessage: ThreadMessageDto = {
        id: optimisticMessageId,
        threadId: thread.id,
        nodeId: selectedTriggerId,
        externalThreadId:
          thread.externalThreadId ?? selectedThreadExternalId ?? '',
        createdAt: now,
        updatedAt: now,
        message: {
          role: 'human',
          content: messageText,
        } as ThreadMessageDto['message'],
      };

      // Store optimistic message in ref for persistence across thread switches
      pendingOptimisticMessagesRef.current.set(
        optimisticMessageId,
        optimisticMessage,
      );

      // Add optimistic message immediately and sort chronologically
      setMessages((prev) =>
        sortMessagesChronologically([...prev, optimisticMessage]),
      );
      setMessageInput('');
      isSendingMessageRef.current = true;
    }

    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        thread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto = {
        messages: [messageText],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
      };
      const response = await graphsApi.executeTrigger(
        graphId,
        selectedTriggerId,
        executeTriggerDto,
      );

      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== thread.externalThreadId;

      if (isDraft && returnedExternalThreadId && onDraftMessageSent) {
        // For draft threads, store the external thread ID to match with thread.create event
        setPendingDraftExternalId(returnedExternalThreadId);
        pendingDraftExternalIdRef.current = returnedExternalThreadId;
        // Fallback: if thread.create event doesn't fire, try to fetch by external ID after a delay
        setTimeout(async () => {
          if (
            pendingDraftExternalIdRef.current === returnedExternalThreadId &&
            onDraftMessageSent
          ) {
            // Still pending, try to fetch the thread
            try {
              const response = await threadsApi.getThreadByExternalId(
                returnedExternalThreadId,
              );
              const existingThread = response.data;
              if (existingThread) {
                onDraftMessageSent(existingThread.id);
                setPendingDraftExternalId(undefined);
                pendingDraftExternalIdRef.current = undefined;
              }
            } catch (error) {
              console.error('Error fetching thread by external ID:', error);
            }
          }
        }, 2000);
      } else if (onRequestThreadSwitch) {
        onRequestThreadSwitch(
          shouldSelectNewThread ? returnedExternalThreadId : null,
        );
      }

      antdMessage.success('Message sent');
    } catch (error) {
      console.error('Error sending message', error);
      const isThreadRunning = thread.status === ThreadDtoStatusEnum.Running;

      if (isThreadRunning) {
        // Remove local pending message on error
        setLocalPendingMessages((prev) =>
          prev.filter((msg) => msg.content !== messageText),
        );
      } else {
        // Remove optimistic message on error
        const optimisticMessageId = Array.from(
          optimisticMessageIdsRef.current,
        ).find((id) => {
          const msg = pendingOptimisticMessagesRef.current.get(id);
          return msg?.message?.content === messageText;
        });
        if (optimisticMessageId) {
          optimisticMessageIdsRef.current.delete(optimisticMessageId);
          pendingOptimisticMessagesRef.current.delete(optimisticMessageId);
          setMessages((prev) =>
            prev.filter((msg) => msg.id !== optimisticMessageId),
          );
        }
      }
      antdMessage.error('Failed to send message');
      // Restore message input
      setMessageInput(messageText);
    } finally {
      setSendingMessage(false);
      // Don't clear isSendingMessageRef immediately - keep it true until message arrives
      // This prevents clearing optimistic messages during thread switch
    }
  }, [
    selectedTriggerId,
    messageInput,
    graphId,
    thread.id,
    thread.externalThreadId,
    thread.status,
    selectedThreadExternalId,
    onRequestThreadSwitch,
    isDraft,
    onDraftMessageSent,
  ]);

  // Use shared messages from props instead of WebSocket listener
  // The WebSocket listener is now handled at GraphPage level
  useEffect(() => {
    if (isDraft || !sharedMessages) return;

    // Sync shared messages to local state, preserving optimistic messages
    // But remove optimistic messages that match incoming real messages
    setMessages((prev) => {
      // Get optimistic messages from local state
      const optimisticFromState = prev.filter((msg) =>
        optimisticMessageIdsRef.current.has(msg.id),
      );

      // Create a set of incoming message contents for quick lookup
      const incomingHumanMessages = new Set<string>();
      sharedMessages.forEach((msg) => {
        const msgRole = (msg.message?.role as string) || '';
        if (msgRole === 'human') {
          const msgContent =
            typeof msg.message?.content === 'string' ? msg.message.content : '';
          if (msgContent) {
            incomingHumanMessages.add(msgContent);
          }
        }
      });

      // Remove optimistic messages that match any incoming human message by content
      const filteredOptimistic = optimisticFromState.filter((msg) => {
        const msgRole = (msg.message?.role as string) || '';
        const msgContent =
          typeof msg.message?.content === 'string' ? msg.message.content : '';

        // Remove optimistic human message if it matches any incoming human message
        if (
          msgRole === 'human' &&
          msgContent &&
          incomingHumanMessages.has(msgContent)
        ) {
          optimisticMessageIdsRef.current.delete(msg.id);
          pendingOptimisticMessagesRef.current.delete(msg.id);
          isSendingMessageRef.current = false; // Clear sending flag when message arrives
          return false;
        }
        return true;
      });

      // For non-human optimistic messages, remove if older than 5 seconds
      const now = Date.now();
      const finalOptimistic = filteredOptimistic.filter((msg) => {
        const msgRole = (msg.message?.role as string) || '';
        if (msgRole !== 'human') {
          const msgTime = new Date(msg.createdAt).getTime();
          if (now - msgTime >= 5000) {
            optimisticMessageIdsRef.current.delete(msg.id);
            pendingOptimisticMessagesRef.current.delete(msg.id);
            return false;
          }
        }
        return true;
      });

      // Merge shared messages (which already includes reasoning updates) with remaining optimistic
      // Use shared messages as the source of truth for reasoning messages
      const sharedWithoutOptimistic = sharedMessages.filter(
        (msg) => !optimisticMessageIdsRef.current.has(msg.id),
      );
      return sortMessagesChronologically([
        ...finalOptimistic,
        ...sharedWithoutOptimistic,
      ]);
    });
  }, [sharedMessages, isDraft]);

  useEffect(() => {
    if (sharedExternalThreadId && !selectedThreadExternalId) {
      setSelectedThreadExternalId(sharedExternalThreadId);
    }
  }, [sharedExternalThreadId, selectedThreadExternalId]);

  // Listen for thread.create event when sending from draft
  useWebSocketEvent(
    'thread.create',
    (notification) => {
      if (!isDraft || !onDraftMessageSent) return;
      const threadCreateNotification = notification as ThreadCreateNotification;
      const newThread = threadCreateNotification.data;
      const pendingId = pendingDraftExternalIdRef.current;
      if (newThread && pendingId && newThread.externalThreadId === pendingId) {
        onDraftMessageSent(newThread.id);
        setPendingDraftExternalId(undefined);
        pendingDraftExternalIdRef.current = undefined;
      }
    },
    [isDraft, onDraftMessageSent],
  );

  // Reasoning message handling logic moved to ThreadMessagesView component

  // Memoize callbacks to prevent unnecessary re-renders
  const handleExternalThreadIdChange = useCallback(
    (externalThreadId: string | undefined) => {
      setSelectedThreadExternalId(externalThreadId);
    },
    [],
  );

  const handleMessagesUpdate = useCallback(
    (updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[]) => {
      setMessages((prev) => {
        const updated = updater(prev);
        // Also update shared state if available (for reasoning messages and other updates)
        if (onUpdateSharedMessages) {
          onUpdateSharedMessages(thread.id, () => updated);
        }
        return updated;
      });
    },
    [thread.id, onUpdateSharedMessages],
  );

  const triggerMenuItems = useMemo(
    () =>
      triggerNodes.map((trigger) => ({
        key: trigger.id,
        label: trigger.name,
        onClick: () => setSelectedTriggerId(trigger.id),
      })),
    [triggerNodes],
  );

  const triggerHelperText = templatesLoading
    ? 'Loading triggers...'
    : graphLoaded
      ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
      : 'Loading graph data...';

  // Memoize onLoadMoreMessages to prevent creating new function reference
  const memoizedOnLoadMoreMessages = useMemo(
    () => (hasMoreMessages ? handleLoadMoreMessages : undefined),
    [hasMoreMessages, handleLoadMoreMessages],
  );

  // Memoize input change handler to prevent recreation
  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setMessageInput(e.target.value);
    },
    [],
  );

  // Memoize input enter handler
  const handleInputEnter = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (!e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    },
    [handleSendMessage],
  );

  // Extract input section to prevent rerenders of ThreadMessagesView when typing
  const ChatInputSection = useMemo(
    () => (
      <div
        style={{
          padding: '12px 16px',
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fff',
        }}>
        {triggerNodes.length > 0 ? (
          <div
            style={{
              display: 'flex',
              alignItems: 'flex-end',
              gap: 12,
            }}>
            <Dropdown
              menu={{
                items: triggerMenuItems,
                selectedKeys: selectedTriggerId ? [selectedTriggerId] : [],
              }}
              trigger={['click']}>
              <Button
                type="default"
                size="middle"
                style={{
                  flexShrink: 0,
                }}>
                {triggerNodes.find((t) => t.id === selectedTriggerId)?.name ||
                  'Select trigger'}
              </Button>
            </Dropdown>
            <Input.TextArea
              placeholder="Type your message..."
              value={messageInput}
              onChange={handleInputChange}
              onPressEnter={handleInputEnter}
              disabled={sendingMessage || !selectedTriggerId}
              autoSize={{ minRows: 1, maxRows: 5 }}
              style={{ flex: 1, resize: 'none', outline: 'none' }}
            />
            <Button
              type="primary"
              icon={<SendOutlined />}
              onClick={handleSendMessage}
              loading={sendingMessage}
              disabled={
                !messageInput.trim() ||
                !selectedTriggerId ||
                templatesLoading ||
                sendingMessage
              }
              style={{ flexShrink: 0 }}>
              Send
            </Button>
          </div>
        ) : (
          <div style={{ textAlign: 'center', padding: '8px 0' }}>
            <Typography.Text type="secondary" style={{ fontSize: 13 }}>
              {triggerHelperText}
            </Typography.Text>
          </div>
        )}
      </div>
    ),
    [
      triggerNodes,
      triggerMenuItems,
      selectedTriggerId,
      messageInput,
      sendingMessage,
      templatesLoading,
      triggerHelperText,
      handleInputChange,
      handleInputEnter,
      handleSendMessage,
    ],
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        minHeight: 0,
        ...style,
      }}>
      <div
        style={{
          flex: 1,
          minHeight: 0,
          borderRadius: 8,
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
        }}>
        <ThreadMessagesView
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={thread.id}
          isAgentNode
          onLoadMoreMessages={memoizedOnLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMore={messagesLoadingMore}
          isNodeRunning={thread.status === ThreadDtoStatusEnum.Running}
          nodeDisplayNames={nodeDisplayNames}
          showNodeHeadings
          graphId={graphId}
          externalThreadId={selectedThreadExternalId}
          onExternalThreadIdChange={handleExternalThreadIdChange}
          isDraft={isDraft}
          onMessagesUpdate={handleMessagesUpdate}
          pendingMessages={pendingMessages}
          newMessageMode={newMessageMode}
        />
      </div>

      {ChatInputSection}
    </div>
  );
};

export default ThreadChatPanel;
