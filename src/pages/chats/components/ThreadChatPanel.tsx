import { LoadingOutlined, SendOutlined, XFilled } from '@ant-design/icons';
import { Button, Dropdown, Input, Tooltip, Typography } from 'antd';
import { message as antdMessage } from 'antd';
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';

import { graphsApi, threadsApi } from '../../../api';
import type { ThreadDto, ThreadMessageDto } from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { extractApiErrorMessage } from '../../../utils/errors';
import {
  extractThreadSubId,
  type TriggerNodeInfo,
} from '../../../utils/graphThreads';
import { sortMessagesChronologically } from '../../../utils/threadMessages';
import ThreadMessagesView from '../../graphs/components/ThreadMessagesView';
import type { PendingMessage } from '../../graphs/types/messages';

interface ThreadChatPanelProps {
  graphId: string;
  thread: ThreadDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames?: Record<string, string>;
  templatesLoading?: boolean;
  graphLoaded?: boolean;
  onRequestThreadSwitch?: (externalThreadId: string | null) => void;
  isDraft?: boolean;
  onDraftMessageSent?: (newThread: ThreadDto) => void;
  style?: React.CSSProperties;
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  hasMoreMessages: boolean;
  loadingMoreMessages: boolean;
  pendingMessages?: PendingMessage[];
  externalThreadId?: string;
  onLoadMoreMessages?: () => void;
  onUpdateSharedMessages: (
    threadId: string,
    updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
    nodeId?: string,
  ) => void;
  onUpdatePendingMessages?: (
    threadId: string,
    updater: (prev: PendingMessage[]) => PendingMessage[],
    nodeId?: string,
  ) => void;
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

export const ThreadChatPanel: React.FC<ThreadChatPanelProps> = ({
  graphId,
  thread,
  triggerNodes,
  nodeDisplayNames,
  templatesLoading = false,
  graphLoaded = true,
  onRequestThreadSwitch,
  isDraft = false,
  onDraftMessageSent,
  style,
  messages,
  messagesLoading,
  hasMoreMessages,
  loadingMoreMessages,
  pendingMessages: pendingMessagesProp = [],
  externalThreadId,
  onLoadMoreMessages,
  onUpdateSharedMessages,
  onUpdatePendingMessages,
  newMessageMode = 'wait_for_completion',
}) => {
  const effectiveNewMessageMode =
    newMessageMode ?? ('wait_for_completion' as const);
  const [selectedTriggerId, setSelectedTriggerId] = useState<
    string | undefined
  >(() => triggerNodes[0]?.id);
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [stoppingThread, setStoppingThread] = useState(false);
  const [threadStatusOverride, setThreadStatusOverride] = useState<
    ThreadDto['status'] | undefined
  >(undefined);
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(externalThreadId ?? thread.externalThreadId ?? undefined);
  const pendingDraftExternalIdRef = useRef<string | undefined>(undefined);
  const previousThreadIdRef = useRef<string>(thread.id);

  useEffect(() => {
    setSelectedThreadExternalId(
      externalThreadId ?? thread.externalThreadId ?? undefined,
    );
  }, [externalThreadId, thread.externalThreadId]);

  useEffect(() => {
    const previousThreadId = previousThreadIdRef.current;
    previousThreadIdRef.current = thread.id;
    if (previousThreadId === thread.id) {
      return;
    }

    setMessageInput('');
    setThreadStatusOverride(undefined);

    if (!isDraft) {
      pendingDraftExternalIdRef.current = undefined;
    }
  }, [thread.id, isDraft]);

  useEffect(() => {
    if (threadStatusOverride && thread.status !== ThreadDtoStatusEnum.Running) {
      setThreadStatusOverride(undefined);
    }
  }, [thread.status, threadStatusOverride]);

  useEffect(() => {
    if (!triggerNodes.length) {
      setSelectedTriggerId(undefined);
      return;
    }
    setSelectedTriggerId((prev) => {
      if (prev && triggerNodes.some((node) => node.id === prev)) {
        return prev;
      }
      return triggerNodes[0].id;
    });
  }, [triggerNodes, thread.id]);

  // No node.update listener here; pending comes from shared store in GraphPage

  const effectiveThreadStatus = threadStatusOverride ?? thread.status;
  const isThreadRunning = effectiveThreadStatus === ThreadDtoStatusEnum.Running;
  const prevIsThreadRunningRef = useRef<boolean>(isThreadRunning);

  // Use pending messages provided from the shared store
  const pendingMessages = useMemo(() => {
    if (isDraft) return undefined;
    return pendingMessagesProp && pendingMessagesProp.length > 0
      ? pendingMessagesProp
      : undefined;
  }, [pendingMessagesProp, isDraft]);

  // Send pending messages when thread completes (for wait_for_completion mode)
  // or after tool execution (for inject_after_tool_call mode)
  const sendPendingMessage = useCallback(
    async (message: PendingMessage) => {
      if (!selectedTriggerId || isDraft) return;

      const messageText = message.content;
      const now = new Date().toISOString();
      const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      const optimisticMessage: ThreadMessageDto = {
        id: optimisticMessageId,
        threadId: thread.id,
        nodeId: selectedTriggerId,
        externalThreadId:
          thread.externalThreadId ?? selectedThreadExternalId ?? '',
        createdAt: now,
        updatedAt: now,
        message: {
          role: 'human',
          content: messageText,
        } as ThreadMessageDto['message'],
      };

      // Add optimistic message to both scopes
      onUpdateSharedMessages(thread.id, (prev) =>
        sortMessagesChronologically([...prev, optimisticMessage]),
      );
      onUpdateSharedMessages(
        thread.id,
        (prev) => sortMessagesChronologically([...prev, optimisticMessage]),
        selectedTriggerId,
      );

      try {
        const threadSubId = extractThreadSubId(
          thread.externalThreadId ?? selectedThreadExternalId,
        );
        const executeTriggerDto = {
          messages: [messageText],
          async: true,
          ...(threadSubId ? { threadSubId } : {}),
        };
        await graphsApi.executeTrigger(
          graphId,
          selectedTriggerId,
          executeTriggerDto,
        );
      } catch (error) {
        console.error('Error sending pending message', error);

        // Remove optimistic message on error
        onUpdateSharedMessages(thread.id, (prev) =>
          prev.filter((msg) => msg.id !== optimisticMessageId),
        );
        onUpdateSharedMessages(
          thread.id,
          (prev) => prev.filter((msg) => msg.id !== optimisticMessageId),
          selectedTriggerId,
        );

        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to send pending message',
        );
        antdMessage.error(errorMessage);
      }
    },
    [
      selectedTriggerId,
      isDraft,
      thread.id,
      thread.externalThreadId,
      selectedThreadExternalId,
      onUpdateSharedMessages,
      graphId,
    ],
  );

  // Effect to send pending messages when thread transitions from Running to not-Running
  useEffect(() => {
    const wasRunning = prevIsThreadRunningRef.current;
    prevIsThreadRunningRef.current = isThreadRunning;

    // Only send pending messages when transitioning from running to not-running
    // and only in wait_for_completion mode
    if (
      wasRunning &&
      !isThreadRunning &&
      effectiveNewMessageMode === 'wait_for_completion' &&
      pendingMessages &&
      pendingMessages.length > 0 &&
      onUpdatePendingMessages
    ) {
      // Send all pending messages
      pendingMessages.forEach((msg) => {
        sendPendingMessage(msg);
      });

      // Clear pending messages after sending
      onUpdatePendingMessages(thread.id, () => []);
      antdMessage.success('Pending messages sent');
    }
  }, [
    isThreadRunning,
    pendingMessages,
    sendPendingMessage,
    onUpdatePendingMessages,
    thread.id,
    effectiveNewMessageMode,
  ]);

  const handleStopThread = useCallback(async () => {
    if (isDraft) return;
    try {
      setStoppingThread(true);
      setThreadStatusOverride(ThreadDtoStatusEnum.Stopped);
      const response = await threadsApi.stopThread(thread.id);
      const stoppedThread = response.data;
      if (
        stoppedThread?.status &&
        stoppedThread.status !== ThreadDtoStatusEnum.Running
      ) {
        setThreadStatusOverride(stoppedThread.status);
      }
      antdMessage.success('Thread stop requested');
    } catch (error) {
      console.error('Error stopping thread', error);
      antdMessage.error(
        extractApiErrorMessage(error, 'Failed to stop thread execution'),
      );
      setThreadStatusOverride(undefined);
    } finally {
      setStoppingThread(false);
    }
  }, [isDraft, thread.id]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }

    const messageText = messageInput.trim();

    // If thread is running, add to pending messages instead of sending immediately
    if (isThreadRunning && !isDraft && onUpdatePendingMessages) {
      const pendingMessage: PendingMessage = {
        role: 'human',
        content: messageText,
      };

      onUpdatePendingMessages(thread.id, (prev) => [...prev, pendingMessage]);
      setMessageInput('');
      antdMessage.info(
        effectiveNewMessageMode === 'inject_after_tool_call'
          ? 'Message will be sent after next tool execution'
          : 'Message will be sent after agent completes current task',
      );
      return;
    }

    const now = new Date().toISOString();
    const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    const optimisticMessage: ThreadMessageDto = {
      id: optimisticMessageId,
      threadId: thread.id,
      nodeId: selectedTriggerId,
      externalThreadId:
        thread.externalThreadId ?? selectedThreadExternalId ?? '',
      createdAt: now,
      updatedAt: now,
      message: {
        role: 'human',
        content: messageText,
      } as ThreadMessageDto['message'],
    };

    // Add optimistic message to both scopes
    onUpdateSharedMessages(thread.id, (prev) =>
      sortMessagesChronologically([...prev, optimisticMessage]),
    );
    onUpdateSharedMessages(
      thread.id,
      (prev) => sortMessagesChronologically([...prev, optimisticMessage]),
      selectedTriggerId,
    );

    setMessageInput('');

    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        thread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto = {
        messages: [messageText],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
      };
      const response = await graphsApi.executeTrigger(
        graphId,
        selectedTriggerId,
        executeTriggerDto,
      );

      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== thread.externalThreadId;

      if (isDraft && returnedExternalThreadId && onDraftMessageSent) {
        pendingDraftExternalIdRef.current = returnedExternalThreadId;
        if (onRequestThreadSwitch) {
          onRequestThreadSwitch(returnedExternalThreadId);
        }
        setTimeout(async () => {
          if (
            pendingDraftExternalIdRef.current === returnedExternalThreadId &&
            onDraftMessageSent
          ) {
            try {
              const response = await threadsApi.getThreadByExternalId(
                returnedExternalThreadId,
              );
              const existingThread = response.data;
              if (existingThread) {
                onDraftMessageSent(existingThread);
                pendingDraftExternalIdRef.current = undefined;
              }
            } catch (error) {
              console.error('Error fetching thread by external ID:', error);
            }
          }
        }, 2000);
      } else if (onRequestThreadSwitch) {
        onRequestThreadSwitch(
          shouldSelectNewThread ? returnedExternalThreadId : null,
        );
      }

      antdMessage.success('Message sent');
    } catch (error) {
      console.error('Error sending message', error);

      // Remove optimistic message on error
      onUpdateSharedMessages(thread.id, (prev) =>
        prev.filter((msg) => msg.id !== optimisticMessageId),
      );
      onUpdateSharedMessages(
        thread.id,
        (prev) => prev.filter((msg) => msg.id !== optimisticMessageId),
        selectedTriggerId,
      );

      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to send message',
      );
      antdMessage.error(errorMessage);
      setMessageInput(messageText);
    } finally {
      setSendingMessage(false);
    }
  }, [
    selectedTriggerId,
    messageInput,
    graphId,
    thread.id,
    thread.externalThreadId,
    selectedThreadExternalId,
    onRequestThreadSwitch,
    isDraft,
    onDraftMessageSent,
    onUpdateSharedMessages,
    isThreadRunning,
    onUpdatePendingMessages,
    effectiveNewMessageMode,
  ]);

  // Deduplication of optimistic messages is handled automatically in the store

  useEffect(() => {
    if (externalThreadId && !selectedThreadExternalId) {
      setSelectedThreadExternalId(externalThreadId);
    }
  }, [externalThreadId, selectedThreadExternalId]);

  // Reasoning message handling logic moved to ThreadMessagesView component

  const triggerMenuItems = useMemo(
    () =>
      triggerNodes.map((trigger) => ({
        key: trigger.id,
        label: trigger.name,
        onClick: () => setSelectedTriggerId(trigger.id),
      })),
    [triggerNodes],
  );

  const triggerHelperText = templatesLoading
    ? 'Loading triggers...'
    : graphLoaded
      ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
      : 'Loading graph data...';

  // Memoize onLoadMoreMessages to prevent creating new function reference
  const memoizedOnLoadMoreMessages = useMemo(
    () => (hasMoreMessages ? onLoadMoreMessages : undefined),
    [hasMoreMessages, onLoadMoreMessages],
  );

  // Memoize input change handler to prevent recreation
  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setMessageInput(e.target.value);
    },
    [],
  );

  // Memoize input enter handler
  const handleInputEnter = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (!e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    },
    [handleSendMessage],
  );

  // Extract input section to prevent rerenders of ThreadMessagesView when typing
  const ChatInputSection = useMemo(
    () => (
      <div
        style={{
          padding: '12px 16px',
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fff',
        }}>
        {triggerNodes.length > 0 ? (
          <div
            style={{
              display: 'flex',
              alignItems: 'flex-end',
              gap: 12,
            }}>
            <Dropdown
              menu={{
                items: triggerMenuItems,
                selectedKeys: selectedTriggerId ? [selectedTriggerId] : [],
              }}
              trigger={['click']}>
              <Button
                type="default"
                size="middle"
                style={{
                  flexShrink: 0,
                }}>
                {triggerNodes.find((t) => t.id === selectedTriggerId)?.name ||
                  'Select trigger'}
              </Button>
            </Dropdown>
            <Input.TextArea
              placeholder="Type your message..."
              value={messageInput}
              onChange={handleInputChange}
              onPressEnter={handleInputEnter}
              disabled={sendingMessage || !selectedTriggerId}
              autoSize={{ minRows: 1, maxRows: 5 }}
              style={{ flex: 1, resize: 'none', outline: 'none' }}
            />
            {!isDraft && isThreadRunning && (
              <Tooltip title="Stop thread execution">
                <Button
                  danger
                  type="default"
                  icon={stoppingThread ? <LoadingOutlined spin /> : <XFilled />}
                  onClick={handleStopThread}
                  disabled={stoppingThread}
                  style={{ flexShrink: 0 }}
                  aria-label="Stop thread execution"
                />
              </Tooltip>
            )}
            <Button
              type="primary"
              icon={<SendOutlined />}
              onClick={handleSendMessage}
              loading={sendingMessage}
              disabled={
                !messageInput.trim() ||
                !selectedTriggerId ||
                templatesLoading ||
                sendingMessage
              }
              style={{ flexShrink: 0 }}>
              Send
            </Button>
          </div>
        ) : (
          <div style={{ textAlign: 'center', padding: '8px 0' }}>
            <Typography.Text type="secondary" style={{ fontSize: 13 }}>
              {triggerHelperText}
            </Typography.Text>
          </div>
        )}
      </div>
    ),
    [
      triggerNodes,
      triggerMenuItems,
      selectedTriggerId,
      messageInput,
      sendingMessage,
      isDraft,
      isThreadRunning,
      stoppingThread,
      templatesLoading,
      triggerHelperText,
      handleInputChange,
      handleInputEnter,
      handleStopThread,
      handleSendMessage,
    ],
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        minHeight: 0,
        ...style,
      }}>
      <div
        style={{
          flex: 1,
          minHeight: 0,
          borderRadius: 8,
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
        }}>
        <ThreadMessagesView
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={thread.id}
          isAgentNode
          onLoadMoreMessages={memoizedOnLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMore={loadingMoreMessages}
          isNodeRunning={isThreadRunning}
          isThreadStopped={
            effectiveThreadStatus === ThreadDtoStatusEnum.Stopped
          }
          currentThreadLastRunId={thread.lastRunId}
          nodeDisplayNames={nodeDisplayNames}
          showNodeHeadings
          pendingMessages={pendingMessages}
          newMessageMode={effectiveNewMessageMode}
        />
      </div>

      {ChatInputSection}
    </div>
  );
};

export default ThreadChatPanel;
