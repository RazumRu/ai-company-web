import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Button, Dropdown, Input, Typography } from 'antd';
import { SendOutlined } from '@ant-design/icons';
import type { ThreadDto, ThreadMessageDto } from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { graphsApi, threadsApi } from '../../../api';
import ThreadMessagesView from '../../graphs/components/ThreadMessagesView';
import {
  mergeMessagesReplacingStreaming,
  sortMessagesChronologically,
} from '../../../utils/threadMessages';
import {
  extractThreadSubId,
  type TriggerNodeInfo,
} from '../../../utils/graphThreads';
import { message as antdMessage } from 'antd';
import { useWebSocketEvent } from '../../../hooks/useWebSocket';
import type {
  AgentMessageNotification,
  ThreadCreateNotification,
} from '../../../services/WebSocketTypes';

const MESSAGES_PAGE_SIZE = 50;

interface ThreadChatPanelProps {
  graphId: string;
  thread: ThreadDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames?: Record<string, string>;
  templatesLoading?: boolean;
  graphLoaded?: boolean;
  onRequestThreadSwitch?: (externalThreadId: string | null) => void;
  isDraft?: boolean;
  onDraftMessageSent?: (newThreadId: string) => void;
  style?: React.CSSProperties;
}

export const ThreadChatPanel: React.FC<ThreadChatPanelProps> = ({
  graphId,
  thread,
  triggerNodes,
  nodeDisplayNames,
  templatesLoading = false,
  graphLoaded = true,
  onRequestThreadSwitch,
  isDraft = false,
  onDraftMessageSent,
  style,
}) => {
  const [messages, setMessages] = useState<ThreadMessageDto[]>([]);
  const [messagesLoading, setMessagesLoading] = useState(false);
  const [messagesLoadingMore, setMessagesLoadingMore] = useState(false);
  const [messagesOffset, setMessagesOffset] = useState(0);
  const [hasMoreMessages, setHasMoreMessages] = useState(false);
  const [selectedTriggerId, setSelectedTriggerId] = useState<
    string | undefined
  >(() => triggerNodes[0]?.id);
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(thread.externalThreadId ?? undefined);
  const [pendingDraftExternalId, setPendingDraftExternalId] = useState<
    string | undefined
  >(undefined);
  const pendingDraftExternalIdRef = useRef<string | undefined>(undefined);
  const isSendingMessageRef = useRef(false);
  const optimisticMessageIdsRef = useRef<Set<string>>(new Set());
  const pendingOptimisticMessagesRef = useRef<Map<string, ThreadMessageDto>>(
    new Map(),
  );

  useEffect(() => {
    setSelectedThreadExternalId(thread.externalThreadId ?? undefined);
    setMessageInput('');
    // Clear pending draft external ID when thread changes (e.g., draft is cleared)
    if (!isDraft) {
      setPendingDraftExternalId(undefined);
      pendingDraftExternalIdRef.current = undefined;
    }
    // Restore pending optimistic messages when thread changes (e.g., draft -> real thread)
    if (pendingOptimisticMessagesRef.current.size > 0) {
      setMessages((prev) => {
        const existingIds = new Set(prev.map((msg) => msg.id));
        const optimisticToAdd = Array.from(
          pendingOptimisticMessagesRef.current.values(),
        )
          .filter((msg) => !existingIds.has(msg.id))
          .map((msg) => ({
            ...msg,
            threadId: thread.id, // Update threadId to match new thread
          }));
        if (optimisticToAdd.length > 0) {
          return sortMessagesChronologically([...prev, ...optimisticToAdd]);
        }
        return prev;
      });
    }
  }, [thread.externalThreadId, thread.id, isDraft]);

  useEffect(() => {
    if (!triggerNodes.length) {
      setSelectedTriggerId(undefined);
      return;
    }
    setSelectedTriggerId((prev) => {
      if (prev && triggerNodes.some((node) => node.id === prev)) {
        return prev;
      }
      return triggerNodes[0].id;
    });
  }, [triggerNodes, thread.id]);

  const loadMessages = useCallback(async () => {
    try {
      setMessagesLoading(true);
      setHasMoreMessages(false);
      setMessagesOffset(0);

      const response = await threadsApi.getThreadMessages(
        thread.id,
        undefined,
        MESSAGES_PAGE_SIZE,
        0,
      );

      const fetched = response.data?.reverse() || [];

      // Preserve optimistic messages when loading real messages
      setMessages((prev) => {
        // Get optimistic messages from both state and ref
        const optimisticFromState = prev.filter((msg) =>
          optimisticMessageIdsRef.current.has(msg.id),
        );
        const optimisticFromRef = Array.from(
          pendingOptimisticMessagesRef.current.values(),
        )
          .filter((msg) => !prev.some((m) => m.id === msg.id))
          .map((msg) => ({
            ...msg,
            threadId: thread.id, // Update threadId to match current thread
          }));
        const allOptimistic = [...optimisticFromState, ...optimisticFromRef];
        return sortMessagesChronologically([...allOptimistic, ...fetched]);
      });

      setMessagesOffset(fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);

      const extId =
        fetched.find((msg) => msg.externalThreadId)?.externalThreadId ??
        thread.externalThreadId ??
        undefined;
      setSelectedThreadExternalId(extId);
    } catch (error) {
      console.error('Error loading messages', error);
      antdMessage.error('Failed to load messages for thread');
      // Preserve optimistic messages even on error
      setMessages((prev) =>
        prev.filter((msg) => optimisticMessageIdsRef.current.has(msg.id)),
      );
      setHasMoreMessages(false);
    } finally {
      setMessagesLoading(false);
    }
  }, [thread.id, thread.externalThreadId]);

  useEffect(() => {
    if (!isDraft) {
      // Don't clear messages if we're currently sending a message
      if (isSendingMessageRef.current) {
        return;
      }
      void loadMessages();
    } else {
      // For draft threads, clear all messages except optimistic ones (if sending)
      setMessages((prev) => {
        // Only keep optimistic messages if we're currently sending
        if (isSendingMessageRef.current) {
          return prev.filter((msg) =>
            optimisticMessageIdsRef.current.has(msg.id),
          );
        }
        // Otherwise, clear all messages for draft thread
        return [];
      });
      setMessagesLoading(false);
      setHasMoreMessages(false);
      // Clear optimistic message IDs when switching to draft (unless sending)
      if (!isSendingMessageRef.current) {
        optimisticMessageIdsRef.current.clear();
      }
    }
  }, [loadMessages, isDraft, thread.id]);

  const handleLoadMoreMessages = useCallback(async () => {
    if (messagesLoadingMore || !hasMoreMessages || messagesLoading) {
      return;
    }
    try {
      setMessagesLoadingMore(true);
      const response = await threadsApi.getThreadMessages(
        thread.id,
        undefined,
        MESSAGES_PAGE_SIZE,
        messagesOffset,
      );
      const fetched = response.data?.reverse() || [];
      setMessages((prev) => mergeMessagesReplacingStreaming(prev, fetched));
      setMessagesOffset((current) => current + fetched.length);
      setHasMoreMessages(fetched.length === MESSAGES_PAGE_SIZE);
    } catch (error) {
      console.error('Error loading more messages', error);
      antdMessage.error('Failed to load more messages');
      setHasMoreMessages(false);
    } finally {
      setMessagesLoadingMore(false);
    }
  }, [
    messagesLoadingMore,
    hasMoreMessages,
    messagesLoading,
    thread.id,
    messagesOffset,
  ]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }

    const messageText = messageInput.trim();
    const now = new Date().toISOString();

    // Create optimistic user message
    const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    optimisticMessageIdsRef.current.add(optimisticMessageId);

    const optimisticMessage: ThreadMessageDto = {
      id: optimisticMessageId,
      threadId: thread.id,
      nodeId: selectedTriggerId,
      externalThreadId:
        thread.externalThreadId ?? selectedThreadExternalId ?? '',
      createdAt: now,
      updatedAt: now,
      message: {
        role: 'human',
        content: messageText,
      } as ThreadMessageDto['message'],
    };

    // Store optimistic message in ref for persistence across thread switches
    pendingOptimisticMessagesRef.current.set(
      optimisticMessageId,
      optimisticMessage,
    );

    // Add optimistic message immediately and sort chronologically
    setMessages((prev) =>
      sortMessagesChronologically([...prev, optimisticMessage]),
    );
    setMessageInput('');
    isSendingMessageRef.current = true;

    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        thread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto = {
        messages: [messageText],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
      };
      const response = await graphsApi.executeTrigger(
        graphId,
        selectedTriggerId,
        executeTriggerDto,
      );

      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== thread.externalThreadId;

      if (isDraft && returnedExternalThreadId && onDraftMessageSent) {
        // For draft threads, store the external thread ID to match with thread.create event
        setPendingDraftExternalId(returnedExternalThreadId);
        pendingDraftExternalIdRef.current = returnedExternalThreadId;
        // Fallback: if thread.create event doesn't fire, try to fetch by external ID after a delay
        setTimeout(async () => {
          if (
            pendingDraftExternalIdRef.current === returnedExternalThreadId &&
            onDraftMessageSent
          ) {
            // Still pending, try to fetch the thread
            try {
              const response = await threadsApi.getThreadByExternalId(
                returnedExternalThreadId,
              );
              const existingThread = response.data;
              if (existingThread) {
                onDraftMessageSent(existingThread.id);
                setPendingDraftExternalId(undefined);
                pendingDraftExternalIdRef.current = undefined;
              }
            } catch (error) {
              console.error('Error fetching thread by external ID:', error);
            }
          }
        }, 2000);
      } else if (onRequestThreadSwitch) {
        onRequestThreadSwitch(
          shouldSelectNewThread ? returnedExternalThreadId : null,
        );
      }

      antdMessage.success('Message sent');
    } catch (error) {
      console.error('Error sending message', error);
      // Remove optimistic message on error
      optimisticMessageIdsRef.current.delete(optimisticMessageId);
      pendingOptimisticMessagesRef.current.delete(optimisticMessageId);
      setMessages((prev) =>
        prev.filter((msg) => msg.id !== optimisticMessageId),
      );
      antdMessage.error('Failed to send message');
      // Restore message input
      setMessageInput(messageText);
    } finally {
      setSendingMessage(false);
      // Don't clear isSendingMessageRef immediately - keep it true until message arrives
      // This prevents clearing optimistic messages during thread switch
    }
  }, [
    selectedTriggerId,
    messageInput,
    graphId,
    thread.id,
    thread.externalThreadId,
    selectedThreadExternalId,
    onRequestThreadSwitch,
    isDraft,
    onDraftMessageSent,
  ]);

  useWebSocketEvent(
    'agent.message',
    (notification) => {
      const agentNotification = notification as AgentMessageNotification;
      if (agentNotification.internalThreadId !== thread.id) return;
      const incomingMessage = agentNotification.data;
      if (!isDraft) {
        setMessages((prev) => {
          // If incoming message is a human message, try to match and replace optimistic message
          const incomingRole = (incomingMessage.message?.role as string) || '';
          if (incomingRole === 'human') {
            const incomingContent =
              typeof incomingMessage.message?.content === 'string'
                ? incomingMessage.message.content
                : '';
            // Find and remove matching optimistic message
            const cleaned = prev.filter((msg) => {
              if (!optimisticMessageIdsRef.current.has(msg.id)) return true;
              const msgRole = (msg.message?.role as string) || '';
              const msgContent =
                typeof msg.message?.content === 'string'
                  ? msg.message.content
                  : '';
              // Remove optimistic message if it matches the incoming human message
              if (msgRole === 'human' && msgContent === incomingContent) {
                optimisticMessageIdsRef.current.delete(msg.id);
                pendingOptimisticMessagesRef.current.delete(msg.id);
                isSendingMessageRef.current = false; // Clear sending flag when message arrives
                return false;
              }
              return true;
            });
            return mergeMessagesReplacingStreaming(cleaned, [incomingMessage]);
          } else {
            // For non-human messages, just merge normally
            // Remove any optimistic messages that are older than a few seconds
            const now = Date.now();
            const cleaned = prev.filter((msg) => {
              if (!optimisticMessageIdsRef.current.has(msg.id)) return true;
              // Keep optimistic messages that are very recent (less than 5 seconds old)
              const msgTime = new Date(msg.createdAt).getTime();
              if (now - msgTime >= 5000) {
                optimisticMessageIdsRef.current.delete(msg.id);
                pendingOptimisticMessagesRef.current.delete(msg.id);
                return false;
              }
              return true;
            });
            return mergeMessagesReplacingStreaming(cleaned, [incomingMessage]);
          }
        });
      }
      if (incomingMessage.externalThreadId) {
        setSelectedThreadExternalId(incomingMessage.externalThreadId);
      }
    },
    [thread.id, isDraft],
  );

  // Listen for thread.create event when sending from draft
  useWebSocketEvent(
    'thread.create',
    (notification) => {
      if (!isDraft || !onDraftMessageSent) return;
      const threadCreateNotification = notification as ThreadCreateNotification;
      const newThread = threadCreateNotification.data;
      const pendingId = pendingDraftExternalIdRef.current;
      if (newThread && pendingId && newThread.externalThreadId === pendingId) {
        onDraftMessageSent(newThread.id);
        setPendingDraftExternalId(undefined);
        pendingDraftExternalIdRef.current = undefined;
      }
    },
    [isDraft, onDraftMessageSent],
  );

  // Reasoning message handling logic moved to ThreadMessagesView component

  const triggerMenuItems = useMemo(
    () =>
      triggerNodes.map((trigger) => ({
        key: trigger.id,
        label: trigger.name,
        onClick: () => setSelectedTriggerId(trigger.id),
      })),
    [triggerNodes],
  );

  const triggerHelperText = templatesLoading
    ? 'Loading triggers...'
    : graphLoaded
      ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
      : 'Loading graph data...';

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        minHeight: 0,
        ...style,
      }}>
      <div
        style={{
          flex: 1,
          minHeight: 0,
          borderRadius: 8,
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
        }}>
        <ThreadMessagesView
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={thread.id}
          isAgentNode
          onLoadMoreMessages={
            hasMoreMessages ? handleLoadMoreMessages : undefined
          }
          hasMoreMessages={hasMoreMessages}
          loadingMore={messagesLoadingMore}
          isNodeRunning={thread.status === ThreadDtoStatusEnum.Running}
          nodeDisplayNames={nodeDisplayNames}
          showNodeHeadings
          graphId={graphId}
          externalThreadId={selectedThreadExternalId}
          onExternalThreadIdChange={setSelectedThreadExternalId}
          isDraft={isDraft}
          onMessagesUpdate={setMessages}
        />
      </div>

      <div
        style={{
          padding: '12px 16px',
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fff',
        }}>
        {triggerNodes.length > 0 ? (
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: 12,
            }}>
            <Dropdown
              menu={{
                items: triggerMenuItems,
                selectedKeys: selectedTriggerId ? [selectedTriggerId] : [],
              }}
              trigger={['click']}>
              <Button
                type="default"
                size="middle"
                style={{
                  flexShrink: 0,
                }}>
                {triggerNodes.find((t) => t.id === selectedTriggerId)?.name ||
                  'Select trigger'}
              </Button>
            </Dropdown>
            <Input
              placeholder="Type your message..."
              value={messageInput}
              onChange={(e) => setMessageInput(e.target.value)}
              onPressEnter={(e) => {
                if (!e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage();
                }
              }}
              disabled={sendingMessage || !selectedTriggerId}
              style={{ flex: 1 }}
            />
            <Button
              type="primary"
              icon={<SendOutlined />}
              onClick={handleSendMessage}
              loading={sendingMessage}
              disabled={
                !messageInput.trim() ||
                !selectedTriggerId ||
                templatesLoading ||
                sendingMessage
              }
              style={{ flexShrink: 0 }}>
              Send
            </Button>
          </div>
        ) : (
          <div style={{ textAlign: 'center', padding: '8px 0' }}>
            <Typography.Text type="secondary" style={{ fontSize: 13 }}>
              {triggerHelperText}
            </Typography.Text>
          </div>
        )}
      </div>
    </div>
  );
};

export default ThreadChatPanel;
