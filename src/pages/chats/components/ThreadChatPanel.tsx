import {
  BranchesOutlined,
  GithubOutlined,
  LoadingOutlined,
  SendOutlined,
  XFilled,
} from '@ant-design/icons';
import {
  App,
  Button,
  Dropdown,
  Input,
  Popover,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';

import { gitRepositoriesApi, graphsApi, threadsApi } from '../../../api';
import type {
  GitRepositoryDto,
  ThreadDto,
  ThreadMessageDto,
} from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { extractApiErrorMessage } from '../../../utils/errors';
import {
  extractThreadSubId,
  type TriggerNodeInfo,
} from '../../../utils/graphThreads';
import { sortMessagesChronologically } from '../../../utils/threadMessages';
import ThreadMessagesView from '../../graphs/components/ThreadMessagesView';
import type { PendingMessage } from '../../graphs/types/messages';

interface ThreadChatPanelProps {
  graphId: string;
  thread: ThreadDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames?: Record<string, string>;
  templatesLoading?: boolean;
  graphLoaded?: boolean;
  graphIsRunning?: boolean;
  onRequestThreadSwitch?: (externalThreadId: string | null) => void;
  isDraft?: boolean;
  onDraftMessageSent?: (newThread: ThreadDto) => void;
  style?: React.CSSProperties;
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  hasMoreMessages: boolean;
  loadingMoreMessages: boolean;
  pendingMessages?: PendingMessage[];
  externalThreadId?: string;
  onLoadMoreMessages?: () => void;
  onUpdateSharedMessages: (
    threadId: string,
    updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
    nodeId?: string,
  ) => void;
  onUpdatePendingMessages?: (
    threadId: string,
    updater: (prev: PendingMessage[]) => PendingMessage[],
    nodeId?: string,
  ) => void;
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

export const ThreadChatPanel: React.FC<ThreadChatPanelProps> = ({
  graphId,
  thread,
  triggerNodes,
  nodeDisplayNames,
  templatesLoading = false,
  graphLoaded = true,
  graphIsRunning = true,
  onRequestThreadSwitch,
  isDraft = false,
  onDraftMessageSent,
  style,
  messages,
  messagesLoading,
  hasMoreMessages,
  loadingMoreMessages,
  pendingMessages: pendingMessagesProp = [],
  externalThreadId,
  onLoadMoreMessages,
  onUpdateSharedMessages,
  onUpdatePendingMessages,
  newMessageMode = 'wait_for_completion',
}) => {
  const { message: antdMessage } = App.useApp();
  const [selectedTriggerId, setSelectedTriggerId] = useState<
    string | undefined
  >(() => triggerNodes[0]?.id);
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [stoppingThread, setStoppingThread] = useState(false);
  const [threadStatusOverride, setThreadStatusOverride] = useState<
    ThreadDto['status'] | undefined
  >(undefined);
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(externalThreadId ?? thread.externalThreadId ?? undefined);
  const pendingDraftExternalIdRef = useRef<string | undefined>(undefined);
  const previousThreadIdRef = useRef<string>(thread.id);

  // --- Repository selector state ---
  const [repos, setRepos] = useState<GitRepositoryDto[]>([]);
  const [reposLoading, setReposLoading] = useState(false);
  const [selectedRepoId, setSelectedRepoId] = useState<string | undefined>(
    () => {
      const metaRepoId = thread.metadata?.repositoryId as string | undefined;
      return metaRepoId || undefined;
    },
  );
  const [repoLocked, setRepoLocked] = useState<boolean>(
    () => !!thread.metadata?.repositoryId,
  );
  const [repoPopoverOpen, setRepoPopoverOpen] = useState(false);

  useEffect(() => {
    setSelectedThreadExternalId(
      externalThreadId ?? thread.externalThreadId ?? undefined,
    );
  }, [externalThreadId, thread.externalThreadId]);

  // Load repositories once on mount
  useEffect(() => {
    let mounted = true;
    const loadRepos = async () => {
      try {
        setReposLoading(true);
        const response = await gitRepositoriesApi.getRepositories();
        if (mounted) setRepos(response.data || []);
      } catch (error) {
        console.error('Error loading repositories', error);
      } finally {
        if (mounted) setReposLoading(false);
      }
    };
    void loadRepos();
    return () => {
      mounted = false;
    };
  }, []);

  useEffect(() => {
    const previousThreadId = previousThreadIdRef.current;
    previousThreadIdRef.current = thread.id;
    if (previousThreadId === thread.id) {
      return;
    }

    setMessageInput('');
    setThreadStatusOverride(undefined);

    // Sync repo state from thread metadata
    const metaRepoId = thread.metadata?.repositoryId as string | undefined;
    if (metaRepoId) {
      setSelectedRepoId(metaRepoId);
      setRepoLocked(true);
    } else {
      setSelectedRepoId(undefined);
      setRepoLocked(false);
    }

    if (!isDraft) {
      pendingDraftExternalIdRef.current = undefined;
    }
  }, [thread.id, isDraft, thread.metadata]);

  useEffect(() => {
    if (threadStatusOverride && thread.status !== ThreadDtoStatusEnum.Running) {
      setThreadStatusOverride(undefined);
    }
  }, [thread.status, threadStatusOverride]);

  useEffect(() => {
    if (!triggerNodes.length) {
      setSelectedTriggerId(undefined);
      return;
    }
    setSelectedTriggerId((prev) => {
      if (prev && triggerNodes.some((node) => node.id === prev)) {
        return prev;
      }
      return triggerNodes[0].id;
    });
  }, [triggerNodes, thread.id]);

  const effectiveThreadStatus = threadStatusOverride ?? thread.status;
  const isThreadRunning = effectiveThreadStatus === ThreadDtoStatusEnum.Running;
  const prevIsThreadRunningRef = useRef<boolean>(isThreadRunning);

  // Use pending messages provided from the shared store
  const pendingMessages = useMemo(() => {
    if (isDraft) return undefined;
    return pendingMessagesProp && pendingMessagesProp.length > 0
      ? pendingMessagesProp
      : undefined;
  }, [pendingMessagesProp, isDraft]);

  // Send pending messages when thread completes (for wait_for_completion mode)
  // or after tool execution (for inject_after_tool_call mode)
  const sendPendingMessage = useCallback(
    async (message: PendingMessage) => {
      if (!selectedTriggerId || isDraft) return;

      const messageText = message.content;
      const now = new Date().toISOString();
      const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;

      const optimisticMessage: ThreadMessageDto = {
        id: optimisticMessageId,
        threadId: thread.id,
        nodeId: selectedTriggerId,
        externalThreadId:
          thread.externalThreadId ?? selectedThreadExternalId ?? '',
        createdAt: now,
        updatedAt: now,
        message: {
          role: 'human',
          content: messageText,
        } as ThreadMessageDto['message'],
      };

      // Add optimistic message to both scopes
      onUpdateSharedMessages(thread.id, (prev) =>
        sortMessagesChronologically([...prev, optimisticMessage]),
      );
      onUpdateSharedMessages(
        thread.id,
        (prev) => sortMessagesChronologically([...prev, optimisticMessage]),
        selectedTriggerId,
      );

      try {
        const threadSubId = extractThreadSubId(
          thread.externalThreadId ?? selectedThreadExternalId,
        );
        const executeTriggerDto = {
          messages: [messageText],
          async: true,
          ...(threadSubId ? { threadSubId } : {}),
        };
        await graphsApi.executeTrigger(
          graphId,
          selectedTriggerId,
          executeTriggerDto,
        );
      } catch (error) {
        console.error('Error sending pending message', error);

        // Remove optimistic message on error
        onUpdateSharedMessages(thread.id, (prev) =>
          prev.filter((msg) => msg.id !== optimisticMessageId),
        );
        onUpdateSharedMessages(
          thread.id,
          (prev) => prev.filter((msg) => msg.id !== optimisticMessageId),
          selectedTriggerId,
        );

        const errorMessage = extractApiErrorMessage(
          error,
          'Failed to send pending message',
        );
        antdMessage.error(errorMessage);
      }
    },
    [
      selectedTriggerId,
      isDraft,
      thread.id,
      thread.externalThreadId,
      selectedThreadExternalId,
      onUpdateSharedMessages,
      graphId,
    ],
  );

  // Effect to send pending messages when thread transitions from Running to not-Running
  useEffect(() => {
    const wasRunning = prevIsThreadRunningRef.current;
    prevIsThreadRunningRef.current = isThreadRunning;

    // Only send pending messages when transitioning from running to not-running
    // and only in wait_for_completion mode
    if (
      wasRunning &&
      !isThreadRunning &&
      newMessageMode === 'wait_for_completion' &&
      pendingMessages &&
      pendingMessages.length > 0 &&
      onUpdatePendingMessages
    ) {
      // Send all pending messages
      pendingMessages.forEach((msg) => {
        sendPendingMessage(msg);
      });

      // Clear pending messages after sending
      onUpdatePendingMessages(thread.id, () => []);
      antdMessage.success('Pending messages sent');
    }
  }, [
    isThreadRunning,
    pendingMessages,
    sendPendingMessage,
    onUpdatePendingMessages,
    thread.id,
    newMessageMode,
  ]);

  const handleStopThread = useCallback(async () => {
    if (isDraft) return;
    try {
      setStoppingThread(true);
      setThreadStatusOverride(ThreadDtoStatusEnum.Stopped);
      const response = await threadsApi.stopThread(thread.id);
      const stoppedThread = response.data;
      if (
        stoppedThread?.status &&
        stoppedThread.status !== ThreadDtoStatusEnum.Running
      ) {
        setThreadStatusOverride(stoppedThread.status);
      }
      antdMessage.success('Thread stop requested');
    } catch (error) {
      console.error('Error stopping thread', error);
      antdMessage.error(
        extractApiErrorMessage(error, 'Failed to stop thread execution'),
      );
      setThreadStatusOverride(undefined);
    } finally {
      setStoppingThread(false);
    }
  }, [isDraft, thread.id]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }

    const messageText = messageInput.trim();

    // If thread is running, add to pending messages instead of sending immediately
    if (isThreadRunning && !isDraft && onUpdatePendingMessages) {
      const pendingMessage: PendingMessage = {
        role: 'human',
        content: messageText,
      };

      onUpdatePendingMessages(thread.id, (prev) => [...prev, pendingMessage]);
      setMessageInput('');
      antdMessage.info(
        newMessageMode === 'inject_after_tool_call'
          ? 'Message will be sent after next tool execution'
          : 'Message will be sent after agent completes current task',
      );
      return;
    }

    // Prepend repo context to the first message when a repo is selected
    const selectedRepo = selectedRepoId
      ? repos.find((r) => r.id === selectedRepoId)
      : undefined;
    const isFirstMessageWithRepo = isDraft && selectedRepo && !repoLocked;
    const repoSignature = selectedRepo
      ? `Repository: ${selectedRepo.owner}/${selectedRepo.repo}`
      : '';
    const alreadyHasRepo = repoSignature
      ? messageText.includes(repoSignature)
      : false;
    const effectiveMessageText =
      isFirstMessageWithRepo && !alreadyHasRepo
        ? `${messageText}\n\n──────────\n${repoSignature}, Branch: ${selectedRepo.defaultBranch}`
        : messageText;

    const now = new Date().toISOString();
    const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;

    const optimisticMessage: ThreadMessageDto = {
      id: optimisticMessageId,
      threadId: thread.id,
      nodeId: selectedTriggerId,
      externalThreadId:
        thread.externalThreadId ?? selectedThreadExternalId ?? '',
      createdAt: now,
      updatedAt: now,
      message: {
        role: 'human',
        content: effectiveMessageText,
      } as ThreadMessageDto['message'],
    };

    // Add optimistic message to both scopes
    onUpdateSharedMessages(thread.id, (prev) =>
      sortMessagesChronologically([...prev, optimisticMessage]),
    );
    onUpdateSharedMessages(
      thread.id,
      (prev) => sortMessagesChronologically([...prev, optimisticMessage]),
      selectedTriggerId,
    );

    setMessageInput('');

    // Lock the repo selector after first message is sent
    if (isFirstMessageWithRepo) {
      setRepoLocked(true);
    }

    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        thread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto = {
        messages: [effectiveMessageText],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
        ...(isFirstMessageWithRepo && selectedRepo
          ? {
              metadata: {
                repositoryId: selectedRepo.id,
                repositoryOwner: selectedRepo.owner,
                repositoryName: selectedRepo.repo,
                branch: selectedRepo.defaultBranch,
              },
            }
          : {}),
      };
      const response = await graphsApi.executeTrigger(
        graphId,
        selectedTriggerId,
        executeTriggerDto,
      );

      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== thread.externalThreadId;

      if (isDraft && returnedExternalThreadId && onDraftMessageSent) {
        pendingDraftExternalIdRef.current = returnedExternalThreadId;
        if (onRequestThreadSwitch) {
          onRequestThreadSwitch(returnedExternalThreadId);
        }
        setTimeout(async () => {
          if (
            pendingDraftExternalIdRef.current === returnedExternalThreadId &&
            onDraftMessageSent
          ) {
            try {
              const threadResponse = await threadsApi.getThreadByExternalId(
                returnedExternalThreadId,
              );
              const existingThread = threadResponse.data;
              if (existingThread) {
                onDraftMessageSent(existingThread);
                pendingDraftExternalIdRef.current = undefined;
              }
            } catch (error) {
              console.error('Error fetching thread by external ID:', error);
              antdMessage.error(
                extractApiErrorMessage(
                  error,
                  'Failed to load thread after sending message',
                ),
              );
            }
          }
        }, 2000);
      } else if (onRequestThreadSwitch) {
        onRequestThreadSwitch(
          shouldSelectNewThread ? returnedExternalThreadId : null,
        );
      }

      antdMessage.success('Message sent');
    } catch (error) {
      console.error('Error sending message', error);

      // Remove optimistic message on error
      onUpdateSharedMessages(thread.id, (prev) =>
        prev.filter((msg) => msg.id !== optimisticMessageId),
      );
      onUpdateSharedMessages(
        thread.id,
        (prev) => prev.filter((msg) => msg.id !== optimisticMessageId),
        selectedTriggerId,
      );

      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to send message',
      );
      antdMessage.error(errorMessage);
      setMessageInput(messageText);
    } finally {
      setSendingMessage(false);
    }
  }, [
    selectedTriggerId,
    messageInput,
    graphId,
    thread.id,
    thread.externalThreadId,
    selectedThreadExternalId,
    onRequestThreadSwitch,
    isDraft,
    onDraftMessageSent,
    onUpdateSharedMessages,
    isThreadRunning,
    onUpdatePendingMessages,
    newMessageMode,
    repos,
    selectedRepoId,
    repoLocked,
  ]);

  useEffect(() => {
    if (externalThreadId && !selectedThreadExternalId) {
      setSelectedThreadExternalId(externalThreadId);
    }
  }, [externalThreadId, selectedThreadExternalId]);

  const triggerMenuItems = useMemo(
    () =>
      triggerNodes.map((trigger) => ({
        key: trigger.id,
        label: trigger.name,
        onClick: () => setSelectedTriggerId(trigger.id),
      })),
    [triggerNodes],
  );

  const triggerHelperText = templatesLoading
    ? 'Loading triggers...'
    : graphLoaded
      ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
      : 'Loading graph data...';

  // Memoize onLoadMoreMessages to prevent creating new function reference
  const memoizedOnLoadMoreMessages = useMemo(
    () => (hasMoreMessages ? onLoadMoreMessages : undefined),
    [hasMoreMessages, onLoadMoreMessages],
  );

  // Memoize input change handler to prevent recreation
  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setMessageInput(e.target.value);
    },
    [],
  );

  // Memoize input enter handler
  const handleInputEnter = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (!e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    },
    [handleSendMessage],
  );

  const selectedRepoDisplay = useMemo(() => {
    if (!selectedRepoId) return null;
    const repo = repos.find((r) => r.id === selectedRepoId);
    if (!repo) return null;
    return { owner: repo.owner, name: repo.repo, branch: repo.defaultBranch };
  }, [selectedRepoId, repos]);

  const handleRepoChange = useCallback(
    (value: string | undefined) => {
      if (!repoLocked) {
        setSelectedRepoId(value);
        setRepoPopoverOpen(false);
      }
    },
    [repoLocked],
  );

  const repoPopoverContent = useMemo(() => {
    if (reposLoading) {
      return (
        <div style={{ padding: 8, textAlign: 'center' }}>
          <Typography.Text type="secondary" style={{ fontSize: 12 }}>
            Loading…
          </Typography.Text>
        </div>
      );
    }
    if (repos.length === 0) {
      return (
        <div style={{ padding: 8 }}>
          <Typography.Text type="secondary" style={{ fontSize: 12 }}>
            No repositories available
          </Typography.Text>
        </div>
      );
    }
    return (
      <div
        style={{
          maxHeight: 260,
          overflowY: 'auto',
          minWidth: 240,
          display: 'flex',
          flexDirection: 'column',
          gap: 2,
        }}>
        {selectedRepoId && (
          <Button
            type="text"
            size="small"
            style={{
              textAlign: 'left',
              fontSize: 11,
              color: '#8c8c8c',
              padding: '4px 8px',
              height: 'auto',
            }}
            onClick={() => handleRepoChange(undefined)}>
            Clear selection
          </Button>
        )}
        {repos.map((repo) => (
          <Button
            key={repo.id}
            type="text"
            style={{
              textAlign: 'left',
              padding: '6px 8px',
              height: 'auto',
              lineHeight: 1.3,
              display: 'flex',
              alignItems: 'center',
              gap: 6,
              width: '100%',
              background:
                repo.id === selectedRepoId ? '#f0f5ff' : 'transparent',
            }}
            onClick={() => handleRepoChange(repo.id)}>
            <GithubOutlined style={{ fontSize: 12, color: '#656d76' }} />
            <span style={{ fontWeight: 500, fontSize: 12 }}>
              {repo.owner}/{repo.repo}
            </span>
            {repo.defaultBranch && (
              <Tag
                icon={<BranchesOutlined />}
                style={{
                  fontSize: 9,
                  margin: 0,
                  borderRadius: 999,
                  padding: '0 5px',
                  lineHeight: '16px',
                }}>
                {repo.defaultBranch}
              </Tag>
            )}
          </Button>
        ))}
      </div>
    );
  }, [repos, reposLoading, selectedRepoId, handleRepoChange]);

  // Extract input section to prevent rerenders of ThreadMessagesView when typing
  const ChatInputSection = useMemo(
    () => (
      <div
        style={{
          padding: '12px 16px',
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fff',
        }}>
        {triggerNodes.length > 0 ? (
          <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
            {/* Main row: textarea + action buttons */}
            <div
              style={{
                display: 'flex',
                alignItems: 'flex-end',
                gap: 8,
              }}>
              <Input.TextArea
                placeholder={
                  !graphIsRunning
                    ? 'Graph is not running'
                    : 'Type your message...'
                }
                value={messageInput}
                onChange={handleInputChange}
                onPressEnter={handleInputEnter}
                disabled={
                  sendingMessage || !selectedTriggerId || !graphIsRunning
                }
                autoSize={{ minRows: 1, maxRows: 5 }}
                style={{ flex: 1, resize: 'none', outline: 'none' }}
              />
              {!isDraft && isThreadRunning && (
                <Tooltip title="Stop thread execution">
                  <Button
                    danger
                    type="default"
                    icon={
                      stoppingThread ? <LoadingOutlined spin /> : <XFilled />
                    }
                    onClick={handleStopThread}
                    disabled={stoppingThread}
                    style={{ flexShrink: 0 }}
                    aria-label="Stop thread execution"
                  />
                </Tooltip>
              )}
              <Button
                type="primary"
                icon={<SendOutlined />}
                onClick={handleSendMessage}
                loading={sendingMessage}
                disabled={
                  !messageInput.trim() ||
                  !selectedTriggerId ||
                  templatesLoading ||
                  sendingMessage ||
                  !graphIsRunning
                }
                style={{ flexShrink: 0 }}>
                Send
              </Button>
            </div>
            {/* Sub row: small text links for trigger + repo */}
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: 12,
                paddingLeft: 2,
              }}>
              <Dropdown
                menu={{
                  items: triggerMenuItems,
                  selectedKeys: selectedTriggerId ? [selectedTriggerId] : [],
                }}
                trigger={['click']}>
                <Typography.Text
                  style={{
                    fontSize: 11,
                    color: '#8c8c8c',
                    cursor: 'pointer',
                    userSelect: 'none',
                  }}>
                  Trigger:{' '}
                  <span style={{ color: '#1677ff' }}>
                    {triggerNodes.find((t) => t.id === selectedTriggerId)
                      ?.name || 'Select'}
                  </span>
                </Typography.Text>
              </Dropdown>
              {/* Repo selector: interactive only for draft threads, static for locked threads */}
              {isDraft && !repoLocked ? (
                <Popover
                  content={repoPopoverContent}
                  trigger="click"
                  open={repoPopoverOpen}
                  onOpenChange={setRepoPopoverOpen}
                  placement="topLeft"
                  arrow={false}
                  overlayInnerStyle={{ padding: 4 }}>
                  <Typography.Text
                    style={{
                      fontSize: 11,
                      color: '#8c8c8c',
                      cursor: 'pointer',
                      userSelect: 'none',
                    }}>
                    <GithubOutlined
                      style={{
                        fontSize: 11,
                        marginRight: 3,
                        color: '#656d76',
                      }}
                    />
                    Repo:{' '}
                    <span style={{ color: '#1677ff' }}>
                      {selectedRepoDisplay
                        ? `${selectedRepoDisplay.owner}/${selectedRepoDisplay.name}`
                        : 'Select'}
                    </span>
                  </Typography.Text>
                </Popover>
              ) : (
                selectedRepoDisplay && (
                  <Typography.Text
                    style={{
                      fontSize: 11,
                      color: '#8c8c8c',
                      userSelect: 'none',
                    }}>
                    <GithubOutlined
                      style={{
                        fontSize: 11,
                        marginRight: 3,
                        color: '#656d76',
                      }}
                    />
                    {selectedRepoDisplay.owner}/{selectedRepoDisplay.name}
                    <Tag
                      icon={<BranchesOutlined />}
                      style={{
                        fontSize: 9,
                        margin: '0 0 0 4px',
                        borderRadius: 999,
                        padding: '0 5px',
                        lineHeight: '16px',
                        verticalAlign: 'middle',
                      }}>
                      {selectedRepoDisplay.branch}
                    </Tag>
                  </Typography.Text>
                )
              )}
            </div>
          </div>
        ) : (
          <div style={{ textAlign: 'center', padding: '8px 0' }}>
            <Typography.Text type="secondary" style={{ fontSize: 13 }}>
              {triggerHelperText}
            </Typography.Text>
          </div>
        )}
      </div>
    ),
    [
      triggerNodes,
      triggerMenuItems,
      selectedTriggerId,
      messageInput,
      sendingMessage,
      isDraft,
      isThreadRunning,
      stoppingThread,
      templatesLoading,
      graphIsRunning,
      triggerHelperText,
      handleInputChange,
      handleInputEnter,
      handleStopThread,
      handleSendMessage,
      selectedRepoDisplay,
      repoLocked,
      repoPopoverOpen,
      repoPopoverContent,
    ],
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        minHeight: 0,
        ...style,
      }}>
      <div
        style={{
          flex: 1,
          minHeight: 0,
          borderRadius: 8,
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
        }}>
        <ThreadMessagesView
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={thread.id}
          isAgentNode
          onLoadMoreMessages={memoizedOnLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMore={loadingMoreMessages}
          isNodeRunning={isThreadRunning}
          isThreadStopped={
            effectiveThreadStatus === ThreadDtoStatusEnum.Stopped
          }
          currentThreadLastRunId={thread.lastRunId}
          nodeDisplayNames={nodeDisplayNames}
          showNodeHeadings
          pendingMessages={pendingMessages}
          newMessageMode={newMessageMode}
        />
      </div>

      {ChatInputSection}
    </div>
  );
};

export default ThreadChatPanel;
