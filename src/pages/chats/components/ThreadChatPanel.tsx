import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { Button, Dropdown, Input, Typography } from 'antd';
import { SendOutlined } from '@ant-design/icons';
import type { ThreadDto, ThreadMessageDto } from '../../../autogenerated';
import { ThreadDtoStatusEnum } from '../../../autogenerated';
import { graphsApi, threadsApi } from '../../../api';
import ThreadMessagesView from '../../graphs/components/ThreadMessagesView';
import type { PendingMessage } from '../../graphs/types/messages';
import {
  sortMessagesChronologically,
} from '../../../utils/threadMessages';
import {
  extractThreadSubId,
  type TriggerNodeInfo,
} from '../../../utils/graphThreads';
import { message as antdMessage } from 'antd';
import { extractApiErrorMessage } from '../../../utils/errors';

interface ThreadChatPanelProps {
  graphId: string;
  thread: ThreadDto;
  triggerNodes: TriggerNodeInfo[];
  nodeDisplayNames?: Record<string, string>;
  templatesLoading?: boolean;
  graphLoaded?: boolean;
  onRequestThreadSwitch?: (externalThreadId: string | null) => void;
  isDraft?: boolean;
  onDraftMessageSent?: (newThreadId: string) => void;
  style?: React.CSSProperties;
  messages: ThreadMessageDto[];
  messagesLoading: boolean;
  hasMoreMessages: boolean;
  loadingMoreMessages: boolean;
  pendingMessages?: PendingMessage[];
  externalThreadId?: string;
  onLoadMoreMessages?: () => void;
  onUpdateSharedMessages: (
    threadId: string,
    updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
    nodeId?: string,
  ) => void;
  onUpdateSharedPendingMessages?: (
    threadId: string,
    updater: (prev: PendingMessage[]) => PendingMessage[],
    nodeId?: string,
  ) => void;
  newMessageMode?: 'inject_after_tool_call' | 'wait_for_completion';
}

export const ThreadChatPanel: React.FC<ThreadChatPanelProps> = ({
  graphId,
  thread,
  triggerNodes,
  nodeDisplayNames,
  templatesLoading = false,
  graphLoaded = true,
  onRequestThreadSwitch,
  isDraft = false,
  onDraftMessageSent,
  style,
  messages,
  messagesLoading,
  hasMoreMessages,
  loadingMoreMessages,
  pendingMessages: pendingMessagesProp = [],
  externalThreadId,
  onLoadMoreMessages,
  onUpdateSharedMessages,
  onUpdateSharedPendingMessages,
  newMessageMode = 'wait_for_completion',
}) => {
  const effectiveNewMessageMode =
    newMessageMode ?? ('wait_for_completion' as const);
  const [selectedTriggerId, setSelectedTriggerId] = useState<
    string | undefined
  >(() => triggerNodes[0]?.id);
  const [messageInput, setMessageInput] = useState('');
  const [sendingMessage, setSendingMessage] = useState(false);
  const [selectedThreadExternalId, setSelectedThreadExternalId] = useState<
    string | undefined
  >(externalThreadId ?? thread.externalThreadId ?? undefined);
  // Keep draft external ID only in ref to avoid unused state warning
  const pendingDraftExternalIdRef = useRef<string | undefined>(undefined);
  const isSendingMessageRef = useRef(false);
  const optimisticMessageIdsRef = useRef<Set<string>>(new Set());
  const pendingOptimisticMessagesRef = useRef<Map<string, ThreadMessageDto>>(
    new Map(),
  );

  useEffect(() => {
    setSelectedThreadExternalId(
      externalThreadId ?? thread.externalThreadId ?? undefined,
    );
    setMessageInput('');
    // Clear pending draft external ID when thread changes (e.g., draft is cleared)
    if (!isDraft) {
      pendingDraftExternalIdRef.current = undefined;
    }
    // Restore pending optimistic messages when thread changes (e.g., draft -> real thread)
    if (
      pendingOptimisticMessagesRef.current.size > 0 &&
      onUpdateSharedMessages
    ) {
      onUpdateSharedMessages(thread.id, (prev) => {
        const existingIds = new Set(prev.map((msg) => msg.id));
        const optimisticToAdd = Array.from(
          pendingOptimisticMessagesRef.current.values(),
        )
          .filter((msg) => !existingIds.has(msg.id))
          .map((msg) => ({
            ...msg,
            threadId: thread.id, // Update threadId to match new thread
          }));
        if (optimisticToAdd.length > 0) {
          return sortMessagesChronologically([...prev, ...optimisticToAdd]);
        }
        return prev;
      });
    }
    if (isDraft && !isSendingMessageRef.current) {
      optimisticMessageIdsRef.current.clear();
      pendingOptimisticMessagesRef.current.clear();
    }
  }, [
    externalThreadId,
    thread.externalThreadId,
    thread.id,
    isDraft,
    onUpdateSharedMessages,
  ]);

  useEffect(() => {
    if (!triggerNodes.length) {
      setSelectedTriggerId(undefined);
      return;
    }
    setSelectedTriggerId((prev) => {
      if (prev && triggerNodes.some((node) => node.id === prev)) {
        return prev;
      }
      return triggerNodes[0].id;
    });
  }, [triggerNodes, thread.id]);

  // No node.update listener here; pending comes from shared store in GraphPage

  // Use pending messages provided from the shared store
  const pendingMessages = useMemo(() => {
    if (isDraft) return undefined;
    return pendingMessagesProp && pendingMessagesProp.length > 0
      ? pendingMessagesProp
      : undefined;
  }, [pendingMessagesProp, isDraft]);

  const handleSendMessage = useCallback(async () => {
    if (!selectedTriggerId || !messageInput.trim()) {
      antdMessage.warning('Select a trigger and enter a message');
      return;
    }

    const messageText = messageInput.trim();
    const now = new Date().toISOString();
    const isThreadRunning = thread.status === ThreadDtoStatusEnum.Running;

    // If thread is running, add message as pending instead of optimistic
    if (isThreadRunning) {
      if (onUpdateSharedPendingMessages) {
        const pending: PendingMessage = {
          content: messageText,
          role: 'human',
          additionalKwargs: {
            run_id: undefined,
            created_at: now,
          },
          createdAt: now,
        };
        onUpdateSharedPendingMessages(thread.id, (prev) => [
          ...prev,
          pending,
        ]);
        if (selectedTriggerId) {
          onUpdateSharedPendingMessages(
            thread.id,
            (prev) => [...prev, pending],
            selectedTriggerId,
          );
        }
      }
      setMessageInput('');
    } else {
      // Create optimistic user message (for non-running threads)
      const optimisticMessageId = `optimistic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      optimisticMessageIdsRef.current.add(optimisticMessageId);

      const optimisticMessage: ThreadMessageDto = {
        id: optimisticMessageId,
        threadId: thread.id,
        nodeId: selectedTriggerId,
        externalThreadId:
          thread.externalThreadId ?? selectedThreadExternalId ?? '',
        createdAt: now,
        updatedAt: now,
        message: {
          role: 'human',
          content: messageText,
        } as ThreadMessageDto['message'],
      };

      // Store optimistic message in ref for persistence across thread switches
      pendingOptimisticMessagesRef.current.set(
        optimisticMessageId,
        optimisticMessage,
      );

      onUpdateSharedMessages(thread.id, (prev) =>
        sortMessagesChronologically([...prev, optimisticMessage]),
      );
      onUpdateSharedMessages(
        thread.id,
        (prev) => sortMessagesChronologically([...prev, optimisticMessage]),
        selectedTriggerId,
      );
      setMessageInput('');
      isSendingMessageRef.current = true;
    }

    try {
      setSendingMessage(true);
      const threadSubId = extractThreadSubId(
        thread.externalThreadId ?? selectedThreadExternalId,
      );
      const executeTriggerDto = {
        messages: [messageText],
        async: true,
        ...(threadSubId ? { threadSubId } : {}),
      };
      const response = await graphsApi.executeTrigger(
        graphId,
        selectedTriggerId,
        executeTriggerDto,
      );

      const returnedExternalThreadId = response.data?.externalThreadId;
      const shouldSelectNewThread =
        returnedExternalThreadId &&
        returnedExternalThreadId !== selectedThreadExternalId &&
        returnedExternalThreadId !== thread.externalThreadId;

      if (isDraft && returnedExternalThreadId && onDraftMessageSent) {
        // For draft threads, store the external thread ID to match with thread.create event
        pendingDraftExternalIdRef.current = returnedExternalThreadId;
        // Fallback: if thread.create event doesn't fire, try to fetch by external ID after a delay
        setTimeout(async () => {
          if (
            pendingDraftExternalIdRef.current === returnedExternalThreadId &&
            onDraftMessageSent
          ) {
            // Still pending, try to fetch the thread
            try {
              const response = await threadsApi.getThreadByExternalId(
                returnedExternalThreadId,
              );
              const existingThread = response.data;
              if (existingThread) {
                onDraftMessageSent(existingThread.id);
                pendingDraftExternalIdRef.current = undefined;
              }
            } catch (error) {
              console.error('Error fetching thread by external ID:', error);
            }
          }
        }, 2000);
      } else if (onRequestThreadSwitch) {
        onRequestThreadSwitch(
          shouldSelectNewThread ? returnedExternalThreadId : null,
        );
      }

      antdMessage.success('Message sent');
    } catch (error) {
      console.error('Error sending message', error);
      const isThreadRunning = thread.status === ThreadDtoStatusEnum.Running;

      if (isThreadRunning) {
        // Remove pending message from shared store on error
        if (onUpdateSharedPendingMessages) {
          const applyKeys = [undefined, selectedTriggerId];
          applyKeys.forEach((key) => {
            onUpdateSharedPendingMessages(
              thread.id,
              (prev) => prev.filter((msg) => msg.content !== messageText),
              key,
            );
          });
        }
      } else {
        // Remove optimistic message on error
        const optimisticMessageId = Array.from(
          optimisticMessageIdsRef.current,
        ).find((id) => {
          const msg = pendingOptimisticMessagesRef.current.get(id);
          return msg?.message?.content === messageText;
        });
        if (optimisticMessageId) {
          optimisticMessageIdsRef.current.delete(optimisticMessageId);
          pendingOptimisticMessagesRef.current.delete(optimisticMessageId);
          // Remove from shared store
          if (onUpdateSharedMessages) {
            onUpdateSharedMessages(thread.id, (prev) =>
              prev.filter((msg) => msg.id !== optimisticMessageId),
            );
            onUpdateSharedMessages(
              thread.id,
              (prev) => prev.filter((msg) => msg.id !== optimisticMessageId),
              selectedTriggerId,
            );
          }
        }
      }
      const errorMessage = extractApiErrorMessage(
        error,
        'Failed to send message',
      );
      antdMessage.error(errorMessage);
      // Restore message input
      setMessageInput(messageText);
    } finally {
      setSendingMessage(false);
      // Don't clear isSendingMessageRef immediately - keep it true until message arrives
      // This prevents clearing optimistic messages during thread switch
    }
  }, [
    selectedTriggerId,
    messageInput,
    graphId,
    thread.id,
    thread.externalThreadId,
    thread.status,
    selectedThreadExternalId,
    onRequestThreadSwitch,
    isDraft,
    onDraftMessageSent,
    onUpdateSharedMessages,
    onUpdateSharedPendingMessages,
  ]);

  // Directly use shared messages as the source of truth
  // Deduplication of optimistic messages is handled in updateSharedMessages
  useEffect(() => {
    if (isDraft) return;

    const realHumanContents = new Set<string>();
    messages.forEach((msg) => {
      const isOptimistic =
        typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
      if (!isOptimistic && msg.message?.role === 'human') {
        const content =
          typeof msg.message.content === 'string' ? msg.message.content : '';
        if (content) {
          realHumanContents.add(content);
        }
        // A real human message arrived, clear sending flag
        isSendingMessageRef.current = false;
      }
    });

    if (realHumanContents.size > 0 && onUpdateSharedPendingMessages) {
      const applyKeys = [undefined, selectedTriggerId];
      applyKeys.forEach((key) => {
        onUpdateSharedPendingMessages(
          thread.id,
          (prev) => prev.filter((msg) => !realHumanContents.has(msg.content)),
          key,
        );
      });
    }
  }, [
    messages,
    isDraft,
    selectedTriggerId,
    onUpdateSharedPendingMessages,
    thread.id,
  ]);

  useEffect(() => {
    if (externalThreadId && !selectedThreadExternalId) {
      setSelectedThreadExternalId(externalThreadId);
    }
  }, [externalThreadId, selectedThreadExternalId]);

  // Reasoning message handling logic moved to ThreadMessagesView component

  const triggerMenuItems = useMemo(
    () =>
      triggerNodes.map((trigger) => ({
        key: trigger.id,
        label: trigger.name,
        onClick: () => setSelectedTriggerId(trigger.id),
      })),
    [triggerNodes],
  );

  const triggerHelperText = templatesLoading
    ? 'Loading triggers...'
    : graphLoaded
      ? 'No trigger nodes available for this graph. Add a trigger node to send messages.'
      : 'Loading graph data...';

  // Memoize onLoadMoreMessages to prevent creating new function reference
  const memoizedOnLoadMoreMessages = useMemo(
    () => (hasMoreMessages ? onLoadMoreMessages : undefined),
    [hasMoreMessages, onLoadMoreMessages],
  );

  // Memoize input change handler to prevent recreation
  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setMessageInput(e.target.value);
    },
    [],
  );

  // Memoize input enter handler
  const handleInputEnter = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (!e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    },
    [handleSendMessage],
  );

  // Extract input section to prevent rerenders of ThreadMessagesView when typing
  const ChatInputSection = useMemo(
    () => (
      <div
        style={{
          padding: '12px 16px',
          border: '1px solid #f0f0f0',
          borderRadius: 8,
          background: '#fff',
        }}>
        {triggerNodes.length > 0 ? (
          <div
            style={{
              display: 'flex',
              alignItems: 'flex-end',
              gap: 12,
            }}>
            <Dropdown
              menu={{
                items: triggerMenuItems,
                selectedKeys: selectedTriggerId ? [selectedTriggerId] : [],
              }}
              trigger={['click']}>
              <Button
                type="default"
                size="middle"
                style={{
                  flexShrink: 0,
                }}>
                {triggerNodes.find((t) => t.id === selectedTriggerId)?.name ||
                  'Select trigger'}
              </Button>
            </Dropdown>
            <Input.TextArea
              placeholder="Type your message..."
              value={messageInput}
              onChange={handleInputChange}
              onPressEnter={handleInputEnter}
              disabled={sendingMessage || !selectedTriggerId}
              autoSize={{ minRows: 1, maxRows: 5 }}
              style={{ flex: 1, resize: 'none', outline: 'none' }}
            />
            <Button
              type="primary"
              icon={<SendOutlined />}
              onClick={handleSendMessage}
              loading={sendingMessage}
              disabled={
                !messageInput.trim() ||
                !selectedTriggerId ||
                templatesLoading ||
                sendingMessage
              }
              style={{ flexShrink: 0 }}>
              Send
            </Button>
          </div>
        ) : (
          <div style={{ textAlign: 'center', padding: '8px 0' }}>
            <Typography.Text type="secondary" style={{ fontSize: 13 }}>
              {triggerHelperText}
            </Typography.Text>
          </div>
        )}
      </div>
    ),
    [
      triggerNodes,
      triggerMenuItems,
      selectedTriggerId,
      messageInput,
      sendingMessage,
      templatesLoading,
      triggerHelperText,
      handleInputChange,
      handleInputEnter,
      handleSendMessage,
    ],
  );

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        flex: 1,
        minHeight: 0,
        ...style,
      }}>
      <div
        style={{
          flex: 1,
          minHeight: 0,
          borderRadius: 8,
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
        }}>
        <ThreadMessagesView
          messages={messages}
          messagesLoading={messagesLoading}
          selectedThreadId={thread.id}
          isAgentNode
          onLoadMoreMessages={memoizedOnLoadMoreMessages}
          hasMoreMessages={hasMoreMessages}
          loadingMore={loadingMoreMessages}
          isNodeRunning={thread.status === ThreadDtoStatusEnum.Running}
          nodeDisplayNames={nodeDisplayNames}
          showNodeHeadings
          pendingMessages={pendingMessages}
          newMessageMode={effectiveNewMessageMode}
        />
      </div>

      {ChatInputSection}
    </div>
  );
};

export default ThreadChatPanel;
