import $RefParser from '@apidevtools/json-schema-ref-parser';
import Ajv, { type ErrorObject, type ValidateFunction } from 'ajv';

import type { TemplateDto, TemplateDtoInputsInner } from '../autogenerated';
import type {
  GraphEdge,
  GraphNode,
  GraphNodeData,
} from '../pages/graphs/types';

export interface ValidationError {
  nodeId: string;
  message: string;
  type: 'connection' | 'template' | 'general' | 'required' | 'config';
}

export interface ConnectionRule {
  type: 'kind' | 'template';
  value: string;
  required: boolean;
  multiple: boolean;
}

export interface InputOutputRule extends ConnectionRule {
  availableTemplates: TemplateDto[];
}

export interface ConnectionValidation {
  isValid: boolean;
  errors: ValidationError[];
}

export interface ConfigValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  normalizedConfigsByNodeId: Record<string, Record<string, unknown>>;
}

const slug = (v: string | number | undefined | null): string =>
  String(v ?? '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-');

const makeHandleId = (
  dir: 'source' | 'target',
  rule: Pick<ConnectionRule, 'type' | 'value'>,
): string => `${dir}-${rule.type}-${slug(rule.value)}`;

const getNodeData = (node: GraphNode): GraphNodeData =>
  node.data as unknown as GraphNodeData;

const isRecord = (v: unknown): v is Record<string, unknown> =>
  typeof v === 'object' && v !== null;

const asStringArray = (v: unknown): string[] =>
  Array.isArray(v) ? v.filter((x): x is string => typeof x === 'string') : [];

const cloneJson = <T>(value: T): T => {
  if (typeof structuredClone === 'function') {
    return structuredClone(value);
  }
  return JSON.parse(JSON.stringify(value)) as T;
};

const ajv = new Ajv({
  allErrors: true,
  allowUnionTypes: true,
  strict: false,
  useDefaults: true,
  // Backend schemas may use format keywords (e.g. "email") that AJV does not
  // recognise without ajv-formats.  Silently ignore them — the backend
  // handles format validation itself.
  validateFormats: false,
  // Backend schemas (especially tool specs) often disallow unknown keys.
  // Strip any additional properties during validation so we don't send fields
  // that the backend rejects (e.g. "must NOT have additional properties").
  removeAdditional: 'all',
});

const validatorCache = new Map<
  string,
  { schemaRef: unknown; validate: ValidateFunction }
>();

const ajvInstancePathToDot = (path: string): string => {
  // instancePath is a JSON pointer like "/foo/0/bar". Turn it into "foo[0].bar".
  if (!path) return '';
  const tokens = path
    .split('/')
    .filter(Boolean)
    .map((t) => t.replace(/~1/g, '/').replace(/~0/g, '~'));
  return tokens
    .map((token) => {
      const isIndex = /^\d+$/.test(token);
      if (isIndex) return `[${token}]`;
      return token;
    })
    .reduce((acc, part) => {
      if (!acc) return part;
      if (part.startsWith('[')) return `${acc}${part}`;
      return `${acc}.${part}`;
    }, '');
};

export class GraphValidationService {
  static async validateAndNormalizeNodeConfigs(
    nodes: GraphNode[],
    templates: TemplateDto[],
  ): Promise<ConfigValidationResult> {
    const errors: ValidationError[] = [];
    const normalizedConfigsByNodeId: Record<
      string,
      Record<string, unknown>
    > = {};

    const templatesById = new Map(templates.map((t) => [String(t.id), t]));
    const derefSchemasByTemplateId = new Map<string, unknown>();

    for (const node of nodes) {
      const nodeData = getNodeData(node);
      const templateId = String(nodeData.template);
      const template = templatesById.get(templateId);
      if (!template) {
        errors.push({
          nodeId: node.id,
          message: `Template '${templateId}' not found`,
          type: 'template',
        });
        continue;
      }

      const rawSchema: unknown = template.schema;
      if (!isRecord(rawSchema)) {
        normalizedConfigsByNodeId[node.id] = cloneJson(
          nodeData.config as Record<string, unknown>,
        );
        continue;
      }

      let schema: unknown = derefSchemasByTemplateId.get(templateId);
      if (!schema) {
        try {
          schema = await $RefParser.dereference(rawSchema, {
            mutateInputSchema: false,
          });
        } catch (error) {
          console.error('Failed to dereference template schema:', error);
          schema = rawSchema;
        }
        derefSchemasByTemplateId.set(templateId, schema);
      }

      const cacheKey = templateId;
      const cached = validatorCache.get(cacheKey);
      let validate: ValidateFunction;
      if (cached && cached.schemaRef === schema) {
        validate = cached.validate;
      } else {
        // Ajv schema type is `object | boolean`. Our templates always send an object schema,
        // but we keep this cast explicit to satisfy TS without weakening other types.
        validate = ajv.compile(schema as object);
        validatorCache.set(cacheKey, { schemaRef: schema, validate });
      }

      const config = cloneJson(nodeData.config as Record<string, unknown>);

      // Strip null values from config before validation — the form sets
      // cleared fields to null, but AJV will reject null if the schema
      // type is "string" etc.  Removing them lets AJV apply defaults and
      // treat absent keys as optional.
      for (const key of Object.keys(config)) {
        if (config[key] === null || config[key] === undefined) {
          delete config[key];
        }
      }

      // Ensure const values are present in the config we validate/send
      const props = (schema as { properties?: unknown })?.properties;
      if (isRecord(props)) {
        for (const [key, propUnknown] of Object.entries(props)) {
          const prop = isRecord(propUnknown) ? propUnknown : undefined;
          if (prop && prop.const !== undefined) {
            config[key] = prop.const as unknown;
          }
        }
      }

      const ok = validate(config);
      if (!ok) {
        const ajvErrors: ErrorObject[] = (validate.errors ??
          []) as ErrorObject[];
        const nodeLabel = String(nodeData.label ?? node.id);
        for (const err of ajvErrors) {
          const missing =
            err.keyword === 'required' &&
            isRecord(err.params) &&
            typeof err.params.missingProperty === 'string'
              ? String(err.params.missingProperty)
              : undefined;
          const fullPath = missing
            ? `${err.instancePath}/${missing}`
            : err.instancePath;
          const fieldPath = ajvInstancePathToDot(fullPath);
          const location = fieldPath ? ` (${fieldPath})` : '';
          errors.push({
            nodeId: node.id,
            message: `${nodeLabel}${location}: ${err.message ?? 'invalid value'}`,
            type: 'config',
          });
        }
        continue;
      }

      normalizedConfigsByNodeId[node.id] = config;
    }

    return {
      isValid: errors.length === 0,
      errors,
      normalizedConfigsByNodeId,
    };
  }

  /**
   * Validates if a connection between two nodes is allowed
   */
  static validateConnection(
    sourceNode: GraphNode,
    targetNode: GraphNode,
    templates: TemplateDto[],
    options?: { sourceHandleId?: string; targetHandleId?: string },
  ): ConnectionValidation {
    const errors: ValidationError[] = [];
    const sourceData = getNodeData(sourceNode);
    const targetData = getNodeData(targetNode);

    // Find template for source node
    const sourceTemplate = templates.find((t) => t.id === sourceData.template);
    if (!sourceTemplate) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Template '${sourceData.template}' not found`,
        type: 'template',
      });
      return { isValid: false, errors };
    }

    // Check if source template has outputs
    if (!sourceTemplate.outputs || sourceTemplate.outputs.length === 0) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Node '${sourceData.label}' cannot connect to any other nodes`,
        type: 'connection',
      });
      return { isValid: false, errors };
    }

    // Find template for target node
    const targetTemplate = templates.find((t) => t.id === targetData.template);
    if (!targetTemplate) {
      errors.push({
        nodeId: targetNode.id,
        message: `Template '${targetData.template}' not found`,
        type: 'template',
      });
      return { isValid: false, errors };
    }

    const outputRules =
      sourceTemplate.outputs?.map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: String(rule.value),
        required: Boolean(rule.required),
        multiple: Boolean(rule.multiple),
      })) ?? [];
    const inputRules =
      targetTemplate.inputs?.map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: String(rule.value),
        required: Boolean(rule.required),
        multiple: Boolean(rule.multiple),
      })) ?? [];

    const sourceHandleId = options?.sourceHandleId;
    const targetHandleId = options?.targetHandleId;

    const selectedOutputRule = sourceHandleId
      ? outputRules.find(
          (rule) => makeHandleId('source', rule) === sourceHandleId,
        )
      : undefined;
    const selectedInputRule = targetHandleId
      ? inputRules.find(
          (rule) => makeHandleId('target', rule) === targetHandleId,
        )
      : undefined;

    if (sourceHandleId && !selectedOutputRule) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Unknown source handle '${sourceHandleId}' for node '${sourceData.label}'`,
        type: 'connection',
      });
    }

    if (targetHandleId && !selectedInputRule) {
      errors.push({
        nodeId: targetNode.id,
        message: `Unknown target handle '${targetHandleId}' for node '${targetData.label}'`,
        type: 'connection',
      });
    }

    const outputAllowsTarget = selectedOutputRule
      ? this.isRuleAllowingTemplate(selectedOutputRule, targetTemplate)
      : this.isConnectionAllowed(outputRules, targetTemplate);

    const inputAllowsSource = selectedInputRule
      ? this.isRuleAllowingTemplate(selectedInputRule, sourceTemplate)
      : this.isTemplateAcceptedByInputs(inputRules, sourceTemplate);

    if (!outputAllowsTarget) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Node '${sourceNode.data.label}' cannot connect to '${targetNode.data.label}' (template: ${targetNode.data.template})`,
        type: 'connection',
      });
    }

    if (!inputAllowsSource) {
      const messageDetail = selectedInputRule
        ? `${selectedInputRule.type}: ${selectedInputRule.value}`
        : 'available inputs';
      errors.push({
        nodeId: targetNode.id,
        message: `Node '${targetNode.data.label}' does not accept connections from '${sourceNode.data.label}' on ${messageDetail}`,
        type: 'connection',
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Validates all connections in the graph
   */
  static validateGraph(
    nodes: GraphNode[],
    edges: GraphEdge[],
    templates: TemplateDto[],
  ): ConnectionValidation {
    const errors: ValidationError[] = [];

    // Validate each edge
    for (const edge of edges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const targetNode = nodes.find((n) => n.id === edge.target);

      if (!sourceNode || !targetNode) {
        errors.push({
          nodeId: edge.source || edge.target || 'unknown',
          message: `Edge references non-existent node`,
          type: 'connection',
        });
        continue;
      }

      const validation = this.validateConnection(
        sourceNode,
        targetNode,
        templates,
        {
          sourceHandleId: edge.sourceHandle ?? undefined,
          targetHandleId: edge.targetHandle ?? undefined,
        },
      );
      if (!validation.isValid) {
        errors.push(...validation.errors);
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Gets available templates that can be connected from a given node
   */
  static getAvailableTemplatesForNode(
    node: GraphNode,
    templates: TemplateDto[],
  ): TemplateDto[] {
    const nodeData = getNodeData(node);
    const nodeTemplate = templates.find((t) => t.id === nodeData.template);
    if (!nodeTemplate || !nodeTemplate.outputs) {
      return [];
    }

    const outputs =
      nodeTemplate.outputs?.map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: String(rule.value),
        required: Boolean(rule.required),
        multiple: Boolean(rule.multiple),
      })) ?? [];
    return templates.filter((template) =>
      this.isConnectionAllowed(outputs, template),
    );
  }

  /**
   * Checks if a connection is allowed based on outputs rules
   */
  private static isConnectionAllowed(
    outputs: ConnectionRule[],
    targetTemplate: TemplateDto,
  ): boolean {
    return outputs.some((rule) => {
      return this.isRuleAllowingTemplate(rule, targetTemplate);
    });
  }

  private static isTemplateAcceptedByInputs(
    inputs: ConnectionRule[],
    sourceTemplate: TemplateDto,
  ): boolean {
    if (inputs.length === 0) {
      return true;
    }
    return inputs.some((rule) =>
      this.isRuleAllowingTemplate(rule, sourceTemplate),
    );
  }

  private static isRuleAllowingTemplate(
    rule: Pick<ConnectionRule, 'type' | 'value'>,
    template: TemplateDto,
  ): boolean {
    if (rule.type === 'kind') {
      return slug(template.kind) === slug(rule.value);
    }
    if (rule.type === 'template') {
      return String(template.id) === rule.value;
    }
    return false;
  }

  /**
   * Gets validation errors for a specific node
   */
  static getNodeValidationErrors(
    nodeId: string,
    nodes: GraphNode[],
    edges: GraphEdge[],
    templates: TemplateDto[],
  ): ValidationError[] {
    const node = nodes.find((n) => n.id === nodeId);
    if (!node) return [];

    const errors: ValidationError[] = [];

    // Find all edges connected to this node
    const connectedEdges = edges.filter(
      (edge) => edge.source === nodeId || edge.target === nodeId,
    );

    for (const edge of connectedEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const targetNode = nodes.find((n) => n.id === edge.target);

      if (sourceNode && targetNode) {
        const validation = this.validateConnection(
          sourceNode,
          targetNode,
          templates,
          {
            sourceHandleId: edge.sourceHandle ?? undefined,
            targetHandleId: edge.targetHandle ?? undefined,
          },
        );
        if (!validation.isValid) {
          // Only include errors for the current node
          errors.push(
            ...validation.errors.filter((error) => error.nodeId === nodeId),
          );
        }
      }
    }

    // Check for missing required connections
    const requiredErrors = this.checkRequiredConnections(
      node,
      nodes,
      edges,
      templates,
    );
    errors.push(...requiredErrors);

    // Check for missing required configuration properties
    const configErrors = this.checkRequiredConfigProperties(node, templates);
    errors.push(...configErrors);

    return errors;
  }

  /**
   * Checks if a node has all its required connections
   */
  static checkRequiredConnections(
    node: GraphNode,
    allNodes: GraphNode[],
    allEdges: GraphEdge[],
    templates: TemplateDto[],
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const nodeData = getNodeData(node);
    const nodeTemplate = templates.find((t) => t.id === nodeData.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return errors;
    }

    // Get required connections
    const requiredConnections = nodeTemplate.inputs.filter(
      (rule) => rule.required,
    );

    for (const requiredRule of requiredConnections) {
      const hasRequiredConnection = this.hasRequiredConnection(
        node,
        requiredRule,
        allNodes,
        allEdges,
        templates,
      );

      if (!hasRequiredConnection) {
        errors.push({
          nodeId: node.id,
          message: `Node '${nodeData.label}' requires a connection to ${requiredRule.type}: ${requiredRule.value}`,
          type: 'required',
        });
      }
    }

    return errors;
  }

  /**
   * Checks if a node has a specific required connection
   */
  private static hasRequiredConnection(
    node: GraphNode,
    requiredRule: TemplateDtoInputsInner,
    allNodes: GraphNode[],
    allEdges: GraphEdge[],
    templates: TemplateDto[],
  ): boolean {
    // Find all edges connected to this node
    const connectedEdges = allEdges.filter(
      (edge) => edge.source === node.id || edge.target === node.id,
    );

    for (const edge of connectedEdges) {
      const connectedNode = allNodes.find(
        (n) => n.id === (edge.source === node.id ? edge.target : edge.source),
      );

      if (connectedNode) {
        const connectedTemplate = templates.find(
          (t) => t.id === connectedNode.data.template,
        );
        if (connectedTemplate) {
          if (
            requiredRule.type === 'kind' &&
            connectedTemplate.kind === requiredRule.value
          ) {
            return true;
          } else if (
            requiredRule.type === 'template' &&
            connectedTemplate.id === requiredRule.value
          ) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Gets required connections for a node
   */
  static getRequiredConnections(
    node: GraphNode,
    templates: TemplateDto[],
  ): ConnectionRule[] {
    const nodeData = getNodeData(node);
    const nodeTemplate = templates.find((t) => t.id === nodeData.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return [];
    }

    return nodeTemplate.inputs
      .filter((rule) => rule.required)
      .map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: rule.value,
        required: true,
        multiple: rule.multiple,
      }));
  }

  /**
   * Gets available connection types for a node (including required status)
   */
  static getAvailableConnectionTypes(
    node: GraphNode,
    templates: TemplateDto[],
  ): InputOutputRule[] {
    const nodeData = getNodeData(node);
    const nodeTemplate = templates.find((t) => t.id === nodeData.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return [];
    }

    return nodeTemplate.inputs.map((rule) => {
      const availableTemplates = templates.filter((template) => {
        if (rule.type === 'kind') {
          return template.kind === rule.value;
        } else if (rule.type === 'template') {
          return template.id === rule.value;
        }
        return false;
      });

      return {
        type: rule.type as 'kind' | 'template',
        value: rule.value,
        required: rule.required || false,
        multiple: rule.multiple,
        availableTemplates,
      };
    });
  }

  /**
   * Checks if a node has all its required configuration properties filled
   */
  static checkRequiredConfigProperties(
    node: GraphNode,
    templates: TemplateDto[],
  ): ValidationError[] {
    const nodeData = getNodeData(node);
    const errors: ValidationError[] = [];
    const nodeTemplate = templates.find((t) => t.id === nodeData.template);

    const schemaUnknown: unknown = nodeTemplate?.schema;
    if (!isRecord(schemaUnknown)) {
      return errors;
    }

    const propertiesUnknown = schemaUnknown['properties'];
    if (!isRecord(propertiesUnknown)) {
      return errors;
    }

    const requiredFields = asStringArray(schemaUnknown['required']);

    for (const fieldKey of requiredFields) {
      const propertyUnknown = propertiesUnknown[fieldKey];
      const property = isRecord(propertyUnknown) ? propertyUnknown : undefined;

      // Skip validation if the field has a default value in the schema
      // Fields with defaults are effectively optional since they'll use the default
      if (property && property['default'] !== undefined) {
        continue;
      }

      // Skip validation if the field is a const (it's always set to the const value)
      if (property && property['const'] !== undefined) {
        continue;
      }

      // Get the actual value from config
      const fieldValue = nodeData.config[fieldKey];

      // Check if the value is empty/not filled
      const isEmpty =
        fieldValue === undefined ||
        fieldValue === null ||
        fieldValue === '' ||
        (Array.isArray(fieldValue) && fieldValue.length === 0) ||
        (typeof fieldValue === 'object' &&
          fieldValue !== null &&
          !Array.isArray(fieldValue) &&
          Object.keys(fieldValue).length === 0);

      if (isEmpty) {
        const uiLabel =
          property && typeof property['x-ui:label'] === 'string'
            ? property['x-ui:label']
            : undefined;
        const title =
          property && typeof property['title'] === 'string'
            ? property['title']
            : undefined;
        const fieldTitle = uiLabel ?? title ?? fieldKey;
        errors.push({
          nodeId: node.id,
          message: `Required field '${fieldTitle}' is not filled`,
          type: 'config',
        });
      }
    }

    return errors;
  }
}
