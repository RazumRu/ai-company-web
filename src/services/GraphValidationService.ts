import type { TemplateDto, TemplateDtoInputsInner } from '../autogenerated';
import type { GraphNode, GraphEdge } from '../pages/graphs/types';

export interface ValidationError {
  nodeId: string;
  message: string;
  type: 'connection' | 'template' | 'general' | 'required';
}

export interface ConnectionRule {
  type: 'kind' | 'template';
  value: string;
  required: boolean;
  multiple: boolean;
}

export interface InputOutputRule extends ConnectionRule {
  availableTemplates: TemplateDto[];
}

export interface ConnectionValidation {
  isValid: boolean;
  errors: ValidationError[];
}

const slug = (v: string | number | undefined | null): string =>
  String(v ?? '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-');

const makeHandleId = (
  dir: 'source' | 'target',
  rule: Pick<ConnectionRule, 'type' | 'value'>,
): string => `${dir}-${rule.type}-${slug(rule.value)}`;

export class GraphValidationService {
  /**
   * Validates if a connection between two nodes is allowed
   */
  static validateConnection(
    sourceNode: GraphNode,
    targetNode: GraphNode,
    templates: TemplateDto[],
    options?: { sourceHandleId?: string; targetHandleId?: string },
  ): ConnectionValidation {
    const errors: ValidationError[] = [];

    // Find template for source node
    const sourceTemplate = templates.find(
      (t) => t.id === sourceNode.data.template,
    );
    if (!sourceTemplate) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Template '${sourceNode.data.template}' not found`,
        type: 'template',
      });
      return { isValid: false, errors };
    }

    // Check if source template has outputs
    if (!sourceTemplate.outputs || sourceTemplate.outputs.length === 0) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Node '${sourceNode.data.label}' cannot connect to any other nodes`,
        type: 'connection',
      });
      return { isValid: false, errors };
    }

    // Find template for target node
    const targetTemplate = templates.find(
      (t) => t.id === targetNode.data.template,
    );
    if (!targetTemplate) {
      errors.push({
        nodeId: targetNode.id,
        message: `Template '${targetNode.data.template}' not found`,
        type: 'template',
      });
      return { isValid: false, errors };
    }

    const outputRules =
      sourceTemplate.outputs?.map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: String(rule.value),
        required: Boolean(rule.required),
        multiple: Boolean(rule.multiple),
      })) ?? [];
    const inputRules =
      targetTemplate.inputs?.map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: String(rule.value),
        required: Boolean(rule.required),
        multiple: Boolean(rule.multiple),
      })) ?? [];

    const sourceHandleId = options?.sourceHandleId;
    const targetHandleId = options?.targetHandleId;

    const selectedOutputRule = sourceHandleId
      ? outputRules.find((rule) => makeHandleId('source', rule) === sourceHandleId)
      : undefined;
    const selectedInputRule = targetHandleId
      ? inputRules.find((rule) => makeHandleId('target', rule) === targetHandleId)
      : undefined;

    if (sourceHandleId && !selectedOutputRule) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Unknown source handle '${sourceHandleId}' for node '${sourceNode.data.label}'`,
        type: 'connection',
      });
    }

    if (targetHandleId && !selectedInputRule) {
      errors.push({
        nodeId: targetNode.id,
        message: `Unknown target handle '${targetHandleId}' for node '${targetNode.data.label}'`,
        type: 'connection',
      });
    }

    const outputAllowsTarget = selectedOutputRule
      ? this.isRuleAllowingTemplate(selectedOutputRule, targetTemplate)
      : this.isConnectionAllowed(outputRules, targetTemplate);

    const inputAllowsSource = selectedInputRule
      ? this.isRuleAllowingTemplate(selectedInputRule, sourceTemplate)
      : this.isTemplateAcceptedByInputs(inputRules, sourceTemplate);

    if (!outputAllowsTarget) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Node '${sourceNode.data.label}' cannot connect to '${targetNode.data.label}' (template: ${targetNode.data.template})`,
        type: 'connection',
      });
    }

    if (!inputAllowsSource) {
      const messageDetail = selectedInputRule
        ? `${selectedInputRule.type}: ${selectedInputRule.value}`
        : 'available inputs';
      errors.push({
        nodeId: targetNode.id,
        message: `Node '${targetNode.data.label}' does not accept connections from '${sourceNode.data.label}' on ${messageDetail}`,
        type: 'connection',
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Validates all connections in the graph
   */
  static validateGraph(
    nodes: GraphNode[],
    edges: GraphEdge[],
    templates: TemplateDto[],
  ): ConnectionValidation {
    const errors: ValidationError[] = [];

    // Validate each edge
    for (const edge of edges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const targetNode = nodes.find((n) => n.id === edge.target);

      if (!sourceNode || !targetNode) {
        errors.push({
          nodeId: edge.source || edge.target || 'unknown',
          message: `Edge references non-existent node`,
          type: 'connection',
        });
        continue;
      }

      const validation = this.validateConnection(
        sourceNode,
        targetNode,
        templates,
        {
          sourceHandleId: edge.sourceHandle,
          targetHandleId: edge.targetHandle,
        },
      );
      if (!validation.isValid) {
        errors.push(...validation.errors);
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Gets available templates that can be connected from a given node
   */
  static getAvailableTemplatesForNode(
    node: GraphNode,
    templates: TemplateDto[],
  ): TemplateDto[] {
    const nodeTemplate = templates.find((t) => t.id === node.data.template);
    if (!nodeTemplate || !nodeTemplate.outputs) {
      return [];
    }

    const outputs = nodeTemplate.outputs ?? [];
    return templates.filter((template) =>
      this.isConnectionAllowed(outputs, template),
    );
  }

  /**
   * Checks if a connection is allowed based on outputs rules
   */
  private static isConnectionAllowed(
    outputs: TemplateDtoInputsInner[],
    targetTemplate: TemplateDto,
  ): boolean {
    return outputs.some((rule) => {
      return this.isRuleAllowingTemplate(
        {
          type: rule.type as 'kind' | 'template',
          value: String(rule.value),
          required: Boolean(rule.required),
          multiple: Boolean(rule.multiple),
        },
        targetTemplate,
      );
    });
  }

  private static isTemplateAcceptedByInputs(
    inputs: ConnectionRule[],
    sourceTemplate: TemplateDto,
  ): boolean {
    if (inputs.length === 0) {
      return true;
    }
    return inputs.some((rule) =>
      this.isRuleAllowingTemplate(rule, sourceTemplate),
    );
  }

  private static isRuleAllowingTemplate(
    rule: Pick<ConnectionRule, 'type' | 'value'>,
    template: TemplateDto,
  ): boolean {
    if (rule.type === 'kind') {
      return slug(template.kind) === slug(rule.value);
    }
    if (rule.type === 'template') {
      return String(template.id) === rule.value;
    }
    return false;
  }

  /**
   * Gets validation errors for a specific node
   */
  static getNodeValidationErrors(
    nodeId: string,
    nodes: GraphNode[],
    edges: GraphEdge[],
    templates: TemplateDto[],
  ): ValidationError[] {
    const node = nodes.find((n) => n.id === nodeId);
    if (!node) return [];

    const errors: ValidationError[] = [];

    // Find all edges connected to this node
    const connectedEdges = edges.filter(
      (edge) => edge.source === nodeId || edge.target === nodeId,
    );

    for (const edge of connectedEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const targetNode = nodes.find((n) => n.id === edge.target);

      if (sourceNode && targetNode) {
        const validation = this.validateConnection(
          sourceNode,
          targetNode,
          templates,
          {
            sourceHandleId: edge.sourceHandle,
            targetHandleId: edge.targetHandle,
          },
        );
        if (!validation.isValid) {
          // Only include errors for the current node
          errors.push(
            ...validation.errors.filter((error) => error.nodeId === nodeId),
          );
        }
      }
    }

    // Check for missing required connections
    const requiredErrors = this.checkRequiredConnections(
      node,
      nodes,
      edges,
      templates,
    );
    errors.push(...requiredErrors);

    return errors;
  }

  /**
   * Checks if a node has all its required connections
   */
  static checkRequiredConnections(
    node: GraphNode,
    allNodes: GraphNode[],
    allEdges: GraphEdge[],
    templates: TemplateDto[],
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const nodeTemplate = templates.find((t) => t.id === node.data.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return errors;
    }

    // Get required connections
    const requiredConnections = nodeTemplate.inputs.filter(
      (rule) => rule.required,
    );

    for (const requiredRule of requiredConnections) {
      const hasRequiredConnection = this.hasRequiredConnection(
        node,
        requiredRule,
        allNodes,
        allEdges,
        templates,
      );

      if (!hasRequiredConnection) {
        errors.push({
          nodeId: node.id,
          message: `Node '${node.data.label}' requires a connection to ${requiredRule.type}: ${requiredRule.value}`,
          type: 'required',
        });
      }
    }

    return errors;
  }

  /**
   * Checks if a node has a specific required connection
   */
  private static hasRequiredConnection(
    node: GraphNode,
    requiredRule: TemplateDtoInputsInner,
    allNodes: GraphNode[],
    allEdges: GraphEdge[],
    templates: TemplateDto[],
  ): boolean {
    // Find all edges connected to this node
    const connectedEdges = allEdges.filter(
      (edge) => edge.source === node.id || edge.target === node.id,
    );

    for (const edge of connectedEdges) {
      const connectedNode = allNodes.find(
        (n) => n.id === (edge.source === node.id ? edge.target : edge.source),
      );

      if (connectedNode) {
        const connectedTemplate = templates.find(
          (t) => t.id === connectedNode.data.template,
        );
        if (connectedTemplate) {
          if (
            requiredRule.type === 'kind' &&
            connectedTemplate.kind === requiredRule.value
          ) {
            return true;
          } else if (
            requiredRule.type === 'template' &&
            connectedTemplate.id === requiredRule.value
          ) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Gets required connections for a node
   */
  static getRequiredConnections(
    node: GraphNode,
    templates: TemplateDto[],
  ): ConnectionRule[] {
    const nodeTemplate = templates.find((t) => t.id === node.data.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return [];
    }

    return nodeTemplate.inputs
      .filter((rule) => rule.required)
      .map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: rule.value,
        required: true,
        multiple: rule.multiple,
      }));
  }

  /**
   * Gets available connection types for a node (including required status)
   */
  static getAvailableConnectionTypes(
    node: GraphNode,
    templates: TemplateDto[],
  ): Array<InputOutputRule> {
    const nodeTemplate = templates.find((t) => t.id === node.data.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return [];
    }

    return nodeTemplate.inputs.map((rule) => {
      const availableTemplates = templates.filter((template) => {
        if (rule.type === 'kind') {
          return template.kind === rule.value;
        } else if (rule.type === 'template') {
          return template.id === rule.value;
        }
        return false;
      });

      return {
        type: rule.type as 'kind' | 'template',
        value: rule.value,
        required: rule.required || false,
        multiple: rule.multiple,
        availableTemplates,
      };
    });
  }
}
