import type { TemplateDto, TemplateDtoInputsInner } from '../autogenerated';
import type { GraphNode, GraphEdge } from '../pages/graphs/types';

export interface ValidationError {
  nodeId: string;
  message: string;
  type: 'connection' | 'template' | 'general' | 'required';
}

export interface ConnectionRule {
  type: 'kind' | 'template';
  value: string;
  required: boolean;
  multiple: boolean;
}

export interface InputOutputRule extends ConnectionRule {
  availableTemplates: TemplateDto[];
}

export interface ConnectionValidation {
  isValid: boolean;
  errors: ValidationError[];
}

export class GraphValidationService {
  /**
   * Validates if a connection between two nodes is allowed
   */
  static validateConnection(
    sourceNode: GraphNode,
    targetNode: GraphNode,
    templates: TemplateDto[],
  ): ConnectionValidation {
    const errors: ValidationError[] = [];

    // Find template for source node
    const sourceTemplate = templates.find(
      (t) => t.id === sourceNode.data.template,
    );
    if (!sourceTemplate) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Template '${sourceNode.data.template}' not found`,
        type: 'template',
      });
      return { isValid: false, errors };
    }

    // Check if source template has outputs
    if (!sourceTemplate.outputs || sourceTemplate.outputs.length === 0) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Node '${sourceNode.data.label}' cannot connect to any other nodes`,
        type: 'connection',
      });
      return { isValid: false, errors };
    }

    // Find template for target node
    const targetTemplate = templates.find(
      (t) => t.id === targetNode.data.template,
    );
    if (!targetTemplate) {
      errors.push({
        nodeId: targetNode.id,
        message: `Template '${targetNode.data.template}' not found`,
        type: 'template',
      });
      return { isValid: false, errors };
    }

    // Check if target node is allowed to be connected from source
    const isAllowed = this.isConnectionAllowed(
      sourceTemplate.outputs,
      targetTemplate,
    );
    if (!isAllowed) {
      errors.push({
        nodeId: sourceNode.id,
        message: `Node '${sourceNode.data.label}' cannot connect to '${targetNode.data.label}' (template: ${targetNode.data.template})`,
        type: 'connection',
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Validates all connections in the graph
   */
  static validateGraph(
    nodes: GraphNode[],
    edges: GraphEdge[],
    templates: TemplateDto[],
  ): ConnectionValidation {
    const errors: ValidationError[] = [];

    // Validate each edge
    for (const edge of edges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const targetNode = nodes.find((n) => n.id === edge.target);

      if (!sourceNode || !targetNode) {
        errors.push({
          nodeId: edge.source || edge.target || 'unknown',
          message: `Edge references non-existent node`,
          type: 'connection',
        });
        continue;
      }

      const validation = this.validateConnection(
        sourceNode,
        targetNode,
        templates,
      );
      if (!validation.isValid) {
        errors.push(...validation.errors);
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Gets available templates that can be connected from a given node
   */
  static getAvailableTemplatesForNode(
    node: GraphNode,
    templates: TemplateDto[],
  ): TemplateDto[] {
    const nodeTemplate = templates.find((t) => t.id === node.data.template);
    if (!nodeTemplate || !nodeTemplate.outputs) {
      return [];
    }

    return templates.filter((template) =>
      this.isConnectionAllowed(nodeTemplate.outputs!, template),
    );
  }

  /**
   * Checks if a connection is allowed based on outputs rules
   */
  private static isConnectionAllowed(
    outputs: TemplateDtoInputsInner[],
    targetTemplate: TemplateDto,
  ): boolean {
    return outputs.some((rule) => {
      if (rule.type === 'kind') {
        return targetTemplate.kind === rule.value;
      } else if (rule.type === 'template') {
        return targetTemplate.id === rule.value;
      }
      return false;
    });
  }

  /**
   * Gets validation errors for a specific node
   */
  static getNodeValidationErrors(
    nodeId: string,
    nodes: GraphNode[],
    edges: GraphEdge[],
    templates: TemplateDto[],
  ): ValidationError[] {
    const node = nodes.find((n) => n.id === nodeId);
    if (!node) return [];

    const errors: ValidationError[] = [];

    // Find all edges connected to this node
    const connectedEdges = edges.filter(
      (edge) => edge.source === nodeId || edge.target === nodeId,
    );

    for (const edge of connectedEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const targetNode = nodes.find((n) => n.id === edge.target);

      if (sourceNode && targetNode) {
        const validation = this.validateConnection(
          sourceNode,
          targetNode,
          templates,
        );
        if (!validation.isValid) {
          // Only include errors for the current node
          errors.push(
            ...validation.errors.filter((error) => error.nodeId === nodeId),
          );
        }
      }
    }

    // Check for missing required connections
    const requiredErrors = this.checkRequiredConnections(
      node,
      nodes,
      edges,
      templates,
    );
    errors.push(...requiredErrors);

    return errors;
  }

  /**
   * Checks if a node has all its required connections
   */
  static checkRequiredConnections(
    node: GraphNode,
    allNodes: GraphNode[],
    allEdges: GraphEdge[],
    templates: TemplateDto[],
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const nodeTemplate = templates.find((t) => t.id === node.data.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return errors;
    }

    // Get required connections
    const requiredConnections = nodeTemplate.inputs.filter(
      (rule) => rule.required,
    );

    for (const requiredRule of requiredConnections) {
      const hasRequiredConnection = this.hasRequiredConnection(
        node,
        requiredRule,
        allNodes,
        allEdges,
        templates,
      );

      if (!hasRequiredConnection) {
        errors.push({
          nodeId: node.id,
          message: `Node '${node.data.label}' requires a connection to ${requiredRule.type}: ${requiredRule.value}`,
          type: 'required',
        });
      }
    }

    return errors;
  }

  /**
   * Checks if a node has a specific required connection
   */
  private static hasRequiredConnection(
    node: GraphNode,
    requiredRule: TemplateDtoInputsInner,
    allNodes: GraphNode[],
    allEdges: GraphEdge[],
    templates: TemplateDto[],
  ): boolean {
    // Find all edges connected to this node
    const connectedEdges = allEdges.filter(
      (edge) => edge.source === node.id || edge.target === node.id,
    );

    for (const edge of connectedEdges) {
      const connectedNode = allNodes.find(
        (n) => n.id === (edge.source === node.id ? edge.target : edge.source),
      );

      if (connectedNode) {
        const connectedTemplate = templates.find(
          (t) => t.id === connectedNode.data.template,
        );
        if (connectedTemplate) {
          if (
            requiredRule.type === 'kind' &&
            connectedTemplate.kind === requiredRule.value
          ) {
            return true;
          } else if (
            requiredRule.type === 'template' &&
            connectedTemplate.id === requiredRule.value
          ) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Gets required connections for a node
   */
  static getRequiredConnections(
    node: GraphNode,
    templates: TemplateDto[],
  ): ConnectionRule[] {
    const nodeTemplate = templates.find((t) => t.id === node.data.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return [];
    }

    return nodeTemplate.inputs
      .filter((rule) => rule.required)
      .map((rule) => ({
        type: rule.type as 'kind' | 'template',
        value: rule.value,
        required: true,
        multiple: rule.multiple,
      }));
  }

  /**
   * Gets available connection types for a node (including required status)
   */
  static getAvailableConnectionTypes(
    node: GraphNode,
    templates: TemplateDto[],
  ): Array<InputOutputRule> {
    const nodeTemplate = templates.find((t) => t.id === node.data.template);

    if (!nodeTemplate || !nodeTemplate.inputs) {
      return [];
    }

    return nodeTemplate.inputs.map((rule) => {
      const availableTemplates = templates.filter((template) => {
        if (rule.type === 'kind') {
          return template.kind === rule.value;
        } else if (rule.type === 'template') {
          return template.id === rule.value;
        }
        return false;
      });

      return {
        type: rule.type as 'kind' | 'template',
        value: rule.value,
        required: rule.required || false,
        multiple: rule.multiple,
        availableTemplates,
      };
    });
  }
}
