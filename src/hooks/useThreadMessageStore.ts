import { useCallback, useState } from 'react';

import type { ThreadMessageDto } from '../autogenerated';
import type {
  MessageScopeKey,
  MessagesState,
  PendingMessage,
  PendingMessagesState,
} from '../pages/graphs/types/messages';

const DEFAULT_SCOPE_KEY: MessageScopeKey = 'all';

export const useThreadMessageStore = () => {
  const [messages, setMessages] = useState<MessagesState>({});
  const [pendingMessages, setPendingMessages] = useState<PendingMessagesState>(
    {},
  );
  const [externalThreadIds, setExternalThreadIds] = useState<
    Record<string, string | undefined>
  >({});

  const updateMessages = useCallback(
    (
      threadId: string,
      updater: (prev: ThreadMessageDto[]) => ThreadMessageDto[],
      nodeId?: string,
    ) => {
      setMessages((prev) => {
        const threadMessages = prev[threadId] || {};
        const key = (nodeId ?? DEFAULT_SCOPE_KEY) as MessageScopeKey;
        const currentMessages = threadMessages[key] || [];
        const updatedMessages = updater(currentMessages);

        // Deduplicate optimistic messages when real messages arrive
        const realIds = new Set<string>();
        const realContents = new Map<string, string>(); // content -> id
        updatedMessages.forEach((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
          if (!isOptimistic) {
            realIds.add(msg.id);
            const content =
              typeof msg.message?.content === 'string'
                ? msg.message.content
                : undefined;
            if (content && msg.message?.role === 'human') {
              realContents.set(content, msg.id);
            }
          }
        });

        const dedupedMessages = updatedMessages.filter((msg) => {
          const isOptimistic =
            typeof msg.id === 'string' && msg.id.startsWith('optimistic-');
          if (!isOptimistic) return true;
          const content =
            typeof msg.message?.content === 'string'
              ? msg.message.content
              : undefined;
          if (content && realContents.has(content)) {
            return false;
          }
          return true;
        });

        return {
          ...prev,
          [threadId]: {
            ...threadMessages,
            [key]: dedupedMessages,
          },
        };
      });
    },
    [],
  );

  const updatePendingMessages = useCallback(
    (
      threadId: string,
      updater: (prev: PendingMessage[]) => PendingMessage[],
      nodeId?: string,
    ) => {
      setPendingMessages((prev) => {
        const threadPendings = prev[threadId] || {};
        const key = (nodeId ?? DEFAULT_SCOPE_KEY) as MessageScopeKey;
        const current = threadPendings[key] || [];
        const next = updater(current);
        // Deduplicate by role+content to avoid duplicate pendings from send + socket
        const seen = new Set<string>();
        const deduped = next.filter((p) => {
          const contentKey = `${p.role}-${p.content}`;
          if (seen.has(contentKey)) return false;
          seen.add(contentKey);
          return true;
        });
        return {
          ...prev,
          [threadId]: {
            ...threadPendings,
            [key]: deduped,
          },
        };
      });
    },
    [],
  );

  return {
    messages,
    updateMessages,
    pendingMessages,
    updatePendingMessages,
    externalThreadIds,
    setExternalThreadIds,
  };
};
