/* tslint:disable */
/* eslint-disable */
/**
 * company-ai-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: none
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateGraphDto
 */
export interface CreateGraphDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'version': string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof CreateGraphDto
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof CreateGraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGraphDto
     */
    'temporary'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoMetadata
 */
export interface CreateGraphDtoMetadata {
    [key: string]: any;

    /**
     * Node coordinates and names by node ID
     * @type {Array<CreateGraphDtoMetadataNodesInner>}
     * @memberof CreateGraphDtoMetadata
     */
    'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
    /**
     * Zoom level for graph display
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'zoom'?: number;
    /**
     * X coordinate
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'x'?: number;
    /**
     * Y coordinate
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoMetadataNodesInner
 */
export interface CreateGraphDtoMetadataNodesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'id': string;
    /**
     * X coordinate of the node
     * @type {number}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'x'?: number;
    /**
     * Y coordinate of the node
     * @type {number}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'y'?: number;
    /**
     * Optional display name for the node
     * @type {string}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchema
 */
export interface CreateGraphDtoSchema {
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaNodesInner>}
     * @memberof CreateGraphDtoSchema
     */
    'nodes': Array<CreateGraphDtoSchemaNodesInner>;
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaEdgesInner>}
     * @memberof CreateGraphDtoSchema
     */
    'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchemaEdgesInner
 */
export interface CreateGraphDtoSchemaEdgesInner {
    /**
     * Source node ID
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'from': string;
    /**
     * Target node ID
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'to': string;
    /**
     * Optional edge label
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchemaNodesInner
 */
export interface CreateGraphDtoSchemaNodesInner {
    /**
     * Unique identifier for this node
     * @type {string}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'id': string;
    /**
     * Template name registered in TemplateRegistry
     * @type {string}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'template': string;
    /**
     * Template-specific configuration
     * @type {{ [key: string]: any; }}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'config': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ExecuteTriggerDto
 */
export interface ExecuteTriggerDto {
    /**
     * Array of messages to send to the trigger
     * @type {Array<string>}
     * @memberof ExecuteTriggerDto
     */
    'messages': Array<string>;
    /**
     * Optional thread sub-ID that will be used to create the full thread ID.
     * @type {string}
     * @memberof ExecuteTriggerDto
     */
    'threadSubId'?: string;
    /**
     * If true, do not wait for execution to finish (fire-and-forget).
     * @type {boolean}
     * @memberof ExecuteTriggerDto
     */
    'async'?: boolean;
}
/**
 * 
 * @export
 * @interface ExecuteTriggerResponseDto
 */
export interface ExecuteTriggerResponseDto {
    /**
     * The thread ID used for this execution
     * @type {string}
     * @memberof ExecuteTriggerResponseDto
     */
    'threadId': string;
    /**
     * The checkpoint namespace for this execution
     * @type {string}
     * @memberof ExecuteTriggerResponseDto
     */
    'checkpointNs'?: string;
}
/**
 * 
 * @export
 * @interface GraphDto
 */
export interface GraphDto {
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'version': string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof GraphDto
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'status': GraphDtoStatusEnum;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof GraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof GraphDto
     */
    'temporary'?: boolean | null;
}

export const GraphDtoStatusEnum = {
    Created: 'created',
    Running: 'running',
    Stopped: 'stopped',
    Error: 'error'
} as const;

export type GraphDtoStatusEnum = typeof GraphDtoStatusEnum[keyof typeof GraphDtoStatusEnum];

/**
 * 
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'kind': TemplateDtoKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TemplateDto
     */
    'schema': { [key: string]: any; };
    /**
     * 
     * @type {Array<TemplateDtoInputsInner>}
     * @memberof TemplateDto
     */
    'inputs'?: Array<TemplateDtoInputsInner>;
    /**
     * 
     * @type {Array<TemplateDtoInputsInner>}
     * @memberof TemplateDto
     */
    'outputs'?: Array<TemplateDtoInputsInner>;
}

export const TemplateDtoKindEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type TemplateDtoKindEnum = typeof TemplateDtoKindEnum[keyof typeof TemplateDtoKindEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInner
 */
export interface TemplateDtoInputsInner {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInner
     */
    'type': TemplateDtoInputsInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInner
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInner
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInner
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerTypeEnum = {
    Kind: 'kind',
    Template: 'template'
} as const;

export type TemplateDtoInputsInnerTypeEnum = typeof TemplateDtoInputsInnerTypeEnum[keyof typeof TemplateDtoInputsInnerTypeEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInnerAnyOf
 */
export interface TemplateDtoInputsInnerAnyOf {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'type': TemplateDtoInputsInnerAnyOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'value': TemplateDtoInputsInnerAnyOfValueEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerAnyOfTypeEnum = {
    Kind: 'kind'
} as const;

export type TemplateDtoInputsInnerAnyOfTypeEnum = typeof TemplateDtoInputsInnerAnyOfTypeEnum[keyof typeof TemplateDtoInputsInnerAnyOfTypeEnum];
export const TemplateDtoInputsInnerAnyOfValueEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type TemplateDtoInputsInnerAnyOfValueEnum = typeof TemplateDtoInputsInnerAnyOfValueEnum[keyof typeof TemplateDtoInputsInnerAnyOfValueEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInnerAnyOf1
 */
export interface TemplateDtoInputsInnerAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'type': TemplateDtoInputsInnerAnyOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerAnyOf1TypeEnum = {
    Template: 'template'
} as const;

export type TemplateDtoInputsInnerAnyOf1TypeEnum = typeof TemplateDtoInputsInnerAnyOf1TypeEnum[keyof typeof TemplateDtoInputsInnerAnyOf1TypeEnum];

/**
 * 
 * @export
 * @interface ThreadDto
 */
export interface ThreadDto {
    /**
     * Thread ID
     * @type {string}
     * @memberof ThreadDto
     */
    'id': string;
    /**
     * Graph ID
     * @type {string}
     * @memberof ThreadDto
     */
    'graphId': string;
    /**
     * External thread ID from LangChain
     * @type {string}
     * @memberof ThreadDto
     */
    'externalThreadId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ThreadDto
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ThreadMessageDto
 */
export interface ThreadMessageDto {
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'threadId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'nodeId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'externalThreadId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {ThreadMessageDtoMessage}
     * @memberof ThreadMessageDto
     */
    'message': ThreadMessageDtoMessage;
}
/**
 * 
 * @export
 * @interface ThreadMessageDtoMessage
 */
export interface ThreadMessageDtoMessage {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'role': ThreadMessageDtoMessageRoleEnum;
    /**
     * Parsed tool result as JSON
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessage
     */
    'content': { [key: string]: any; };
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessage
     */
    'additionalKwargs'?: { [key: string]: any; };
    /**
     * Message ID
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'id'?: string;
    /**
     * Tool calls in the message
     * @type {Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>}
     * @memberof ThreadMessageDtoMessage
     */
    'toolCalls'?: Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>;
    /**
     * Tool name
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'name': string;
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'toolCallId': string;
}

export const ThreadMessageDtoMessageRoleEnum = {
    Tool: 'tool'
} as const;

export type ThreadMessageDtoMessageRoleEnum = typeof ThreadMessageDtoMessageRoleEnum[keyof typeof ThreadMessageDtoMessageRoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf
 */
export interface ThreadMessageDtoMessageAnyOf {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf
     */
    'role': ThreadMessageDtoMessageAnyOfRoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf
     */
    'content': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOfRoleEnum = {
    Human: 'human'
} as const;

export type ThreadMessageDtoMessageAnyOfRoleEnum = typeof ThreadMessageDtoMessageAnyOfRoleEnum[keyof typeof ThreadMessageDtoMessageAnyOfRoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf1
 */
export interface ThreadMessageDtoMessageAnyOf1 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'role': ThreadMessageDtoMessageAnyOf1RoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'content': string;
    /**
     * Message ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'id'?: string;
    /**
     * Tool calls in the message
     * @type {Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'toolCalls'?: Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf1RoleEnum = {
    Ai: 'ai'
} as const;

export type ThreadMessageDtoMessageAnyOf1RoleEnum = typeof ThreadMessageDtoMessageAnyOf1RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf1RoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf1ToolCallsInner
 */
export interface ThreadMessageDtoMessageAnyOf1ToolCallsInner {
    /**
     * Tool name
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'name': string;
    /**
     * Tool arguments
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'args': { [key: string]: any; };
    /**
     * Tool call type
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'type': string;
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf2
 */
export interface ThreadMessageDtoMessageAnyOf2 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf2
     */
    'role': ThreadMessageDtoMessageAnyOf2RoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf2
     */
    'content': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf2
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf2RoleEnum = {
    System: 'system'
} as const;

export type ThreadMessageDtoMessageAnyOf2RoleEnum = typeof ThreadMessageDtoMessageAnyOf2RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf2RoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf3
 */
export interface ThreadMessageDtoMessageAnyOf3 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'role': ThreadMessageDtoMessageAnyOf3RoleEnum;
    /**
     * Tool name - shell
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'name': ThreadMessageDtoMessageAnyOf3NameEnum;
    /**
     * 
     * @type {ThreadMessageDtoMessageAnyOf3Content}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'content': ThreadMessageDtoMessageAnyOf3Content;
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'toolCallId': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf3RoleEnum = {
    ToolShell: 'tool-shell'
} as const;

export type ThreadMessageDtoMessageAnyOf3RoleEnum = typeof ThreadMessageDtoMessageAnyOf3RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf3RoleEnum];
export const ThreadMessageDtoMessageAnyOf3NameEnum = {
    Shell: 'shell'
} as const;

export type ThreadMessageDtoMessageAnyOf3NameEnum = typeof ThreadMessageDtoMessageAnyOf3NameEnum[keyof typeof ThreadMessageDtoMessageAnyOf3NameEnum];

/**
 * Parsed shell execution result
 * @export
 * @interface ThreadMessageDtoMessageAnyOf3Content
 */
export interface ThreadMessageDtoMessageAnyOf3Content {
    /**
     * Exit code of the shell command
     * @type {number}
     * @memberof ThreadMessageDtoMessageAnyOf3Content
     */
    'exitCode': number;
    /**
     * Standard output from the command
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3Content
     */
    'stdout': string;
    /**
     * Standard error from the command
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3Content
     */
    'stderr': string;
}
/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf4
 */
export interface ThreadMessageDtoMessageAnyOf4 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'role': ThreadMessageDtoMessageAnyOf4RoleEnum;
    /**
     * Tool name
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'name': string;
    /**
     * Parsed tool result as JSON
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'content': { [key: string]: any; };
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'toolCallId': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf4RoleEnum = {
    Tool: 'tool'
} as const;

export type ThreadMessageDtoMessageAnyOf4RoleEnum = typeof ThreadMessageDtoMessageAnyOf4RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf4RoleEnum];

/**
 * 
 * @export
 * @interface UpdateGraphDto
 */
export interface UpdateGraphDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'version'?: string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof UpdateGraphDto
     */
    'schema'?: CreateGraphDtoSchema;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof UpdateGraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGraphDto
     */
    'temporary'?: boolean | null;
}

/**
 * GraphsApi - axios parameter creator
 * @export
 */
export const GraphsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph: async (createGraphDto: CreateGraphDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGraphDto' is not null or undefined
            assertParamExists('createGraph', 'createGraphDto', createGraphDto)
            const localVarPath = `/api/v1/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGraphDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/destroy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeTrigger: async (graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('executeTrigger', 'graphId', graphId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('executeTrigger', 'triggerId', triggerId)
            // verify required parameter 'executeTriggerDto' is not null or undefined
            assertParamExists('executeTrigger', 'executeTriggerDto', executeTriggerDto)
            const localVarPath = `/api/v1/graphs/{graphId}/triggers/{triggerId}/execute`
                .replace(`{${"graphId"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTriggerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGraphById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findGraphById', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGraphs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph: async (id: string, updateGraphDto: UpdateGraphDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGraph', 'id', id)
            // verify required parameter 'updateGraphDto' is not null or undefined
            assertParamExists('updateGraph', 'updateGraphDto', updateGraphDto)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGraphDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphsApi - functional programming interface
 * @export
 */
export const GraphsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(createGraphDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.createGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.deleteGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.destroyGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTriggerResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeTrigger(graphId, triggerId, executeTriggerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.executeTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGraphById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGraphById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.findGraphById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGraphs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGraphs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.getAllGraphs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.runGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraph(id, updateGraphDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.updateGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphsApi - factory interface
 * @export
 */
export const GraphsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.createGraph(createGraphDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.destroyGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteTriggerResponseDto> {
            return localVarFp.executeTrigger(graphId, triggerId, executeTriggerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGraphById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.findGraphById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGraphs(options?: RawAxiosRequestConfig): AxiosPromise<Array<GraphDto>> {
            return localVarFp.getAllGraphs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.runGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.updateGraph(id, updateGraphDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphsApi - object-oriented interface
 * @export
 * @class GraphsApi
 * @extends {BaseAPI}
 */
export class GraphsApi extends BaseAPI {
    /**
     * 
     * @param {CreateGraphDto} createGraphDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).createGraph(createGraphDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public deleteGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).deleteGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public destroyGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).destroyGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId 
     * @param {string} triggerId 
     * @param {ExecuteTriggerDto} executeTriggerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).executeTrigger(graphId, triggerId, executeTriggerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public findGraphById(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).findGraphById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public getAllGraphs(options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).getAllGraphs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public runGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).runGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateGraphDto} updateGraphDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).updateGraph(id, updateGraphDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.getAllTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<TemplateDto>> {
            return localVarFp.getAllTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getAllTemplates(options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getAllTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThreadsApi - axios parameter creator
 * @export
 */
export const ThreadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThread: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('deleteThread', 'threadId', threadId)
            const localVarPath = `/api/v1/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} externalThreadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadByExternalId: async (externalThreadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalThreadId' is not null or undefined
            assertParamExists('getThreadByExternalId', 'externalThreadId', externalThreadId)
            const localVarPath = `/api/v1/threads/external/{externalThreadId}`
                .replace(`{${"externalThreadId"}}`, encodeURIComponent(String(externalThreadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadById: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getThreadById', 'threadId', threadId)
            const localVarPath = `/api/v1/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} threadId 
         * @param {string} [nodeId] Filter messages by node ID (agent node)
         * @param {number} [limit] Maximum number of messages to return
         * @param {number} [offset] Number of messages to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadMessages: async (threadId: string, nodeId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getThreadMessages', 'threadId', threadId)
            const localVarPath = `/api/v1/threads/{threadId}/messages`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId Filter by graph ID
         * @param {number} [limit] Maximum number of threads to return
         * @param {number} [offset] Number of threads to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreads: async (graphId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getThreads', 'graphId', graphId)
            const localVarPath = `/api/v1/threads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (graphId !== undefined) {
                localVarQueryParameter['graphId'] = graphId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadsApi - functional programming interface
 * @export
 */
export const ThreadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThreadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThread(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThread(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.deleteThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} externalThreadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadByExternalId(externalThreadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadByExternalId(externalThreadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreadByExternalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadById(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadById(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreadById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} threadId 
         * @param {string} [nodeId] Filter messages by node ID (agent node)
         * @param {number} [limit] Maximum number of messages to return
         * @param {number} [offset] Number of messages to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadMessages(threadId: string, nodeId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadMessages(threadId, nodeId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreadMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId Filter by graph ID
         * @param {number} [limit] Maximum number of threads to return
         * @param {number} [offset] Number of threads to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreads(graphId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreads(graphId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThreadsApi - factory interface
 * @export
 */
export const ThreadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThreadsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteThread(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} externalThreadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadByExternalId(externalThreadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadDto> {
            return localVarFp.getThreadByExternalId(externalThreadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadById(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadDto> {
            return localVarFp.getThreadById(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} threadId 
         * @param {string} [nodeId] Filter messages by node ID (agent node)
         * @param {number} [limit] Maximum number of messages to return
         * @param {number} [offset] Number of messages to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadMessages(threadId: string, nodeId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThreadMessageDto>> {
            return localVarFp.getThreadMessages(threadId, nodeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId Filter by graph ID
         * @param {number} [limit] Maximum number of threads to return
         * @param {number} [offset] Number of threads to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreads(graphId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThreadDto>> {
            return localVarFp.getThreads(graphId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadsApi - object-oriented interface
 * @export
 * @class ThreadsApi
 * @extends {BaseAPI}
 */
export class ThreadsApi extends BaseAPI {
    /**
     * 
     * @param {string} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public deleteThread(threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).deleteThread(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} externalThreadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreadByExternalId(externalThreadId: string, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreadByExternalId(externalThreadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreadById(threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreadById(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} threadId 
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreadMessages(threadId: string, nodeId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreadMessages(threadId, nodeId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId Filter by graph ID
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreads(graphId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreads(graphId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



