/* tslint:disable */
/* eslint-disable */
/**
 * company-ai-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: none
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateGraphDto
 */
export interface CreateGraphDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'version': string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof CreateGraphDto
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof CreateGraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGraphDto
     */
    'temporary'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoMetadata
 */
export interface CreateGraphDtoMetadata {
    [key: string]: any;

    /**
     * Node coordinates and names by node ID
     * @type {Array<CreateGraphDtoMetadataNodesInner>}
     * @memberof CreateGraphDtoMetadata
     */
    'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
    /**
     * Zoom level for graph display
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'zoom'?: number;
    /**
     * X coordinate
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'x'?: number;
    /**
     * Y coordinate
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoMetadataNodesInner
 */
export interface CreateGraphDtoMetadataNodesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'id': string;
    /**
     * X coordinate of the node
     * @type {number}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'x'?: number;
    /**
     * Y coordinate of the node
     * @type {number}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'y'?: number;
    /**
     * Optional display name for the node
     * @type {string}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchema
 */
export interface CreateGraphDtoSchema {
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaNodesInner>}
     * @memberof CreateGraphDtoSchema
     */
    'nodes': Array<CreateGraphDtoSchemaNodesInner>;
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaEdgesInner>}
     * @memberof CreateGraphDtoSchema
     */
    'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchemaEdgesInner
 */
export interface CreateGraphDtoSchemaEdgesInner {
    /**
     * Source node ID
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'from': string;
    /**
     * Target node ID
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'to': string;
    /**
     * Optional edge label
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchemaNodesInner
 */
export interface CreateGraphDtoSchemaNodesInner {
    /**
     * Unique identifier for this node
     * @type {string}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'id': string;
    /**
     * Template name registered in TemplateRegistry
     * @type {string}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'template': string;
    /**
     * Template-specific configuration
     * @type {{ [key: string]: any; }}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'config': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ExecuteTriggerDto
 */
export interface ExecuteTriggerDto {
    /**
     * Array of messages to send to the trigger
     * @type {Array<string>}
     * @memberof ExecuteTriggerDto
     */
    'messages': Array<string>;
    /**
     * Optional thread sub-ID that will be used to create the full thread ID.
     * @type {string}
     * @memberof ExecuteTriggerDto
     */
    'threadSubId'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteTriggerResponseDto
 */
export interface ExecuteTriggerResponseDto {
    /**
     * The thread ID used for this execution
     * @type {string}
     * @memberof ExecuteTriggerResponseDto
     */
    'threadId': string;
    /**
     * The checkpoint namespace for this execution
     * @type {string}
     * @memberof ExecuteTriggerResponseDto
     */
    'checkpointNs'?: string;
}
/**
 * 
 * @export
 * @interface GraphDto
 */
export interface GraphDto {
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'version': string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof GraphDto
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'status': GraphDtoStatusEnum;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof GraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof GraphDto
     */
    'temporary'?: boolean | null;
}

export const GraphDtoStatusEnum = {
    Created: 'created',
    Running: 'running',
    Stopped: 'stopped',
    Error: 'error'
} as const;

export type GraphDtoStatusEnum = typeof GraphDtoStatusEnum[keyof typeof GraphDtoStatusEnum];

/**
 * 
 * @export
 * @interface GraphMessagesResponseDto
 */
export interface GraphMessagesResponseDto {
    /**
     * Node ID
     * @type {string}
     * @memberof GraphMessagesResponseDto
     */
    'nodeId': string;
    /**
     * Array of threads with their messages
     * @type {Array<GraphMessagesResponseDtoThreadsInner>}
     * @memberof GraphMessagesResponseDto
     */
    'threads': Array<GraphMessagesResponseDtoThreadsInner>;
}
/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInner
 */
export interface GraphMessagesResponseDtoThreadsInner {
    /**
     * Thread ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInner
     */
    'id': string;
    /**
     * Array of messages in this thread
     * @type {Array<GraphMessagesResponseDtoThreadsInnerMessagesInner>}
     * @memberof GraphMessagesResponseDtoThreadsInner
     */
    'messages': Array<GraphMessagesResponseDtoThreadsInnerMessagesInner>;
}
/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInner
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInner {
    /**
     * Message role
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'role': GraphMessagesResponseDtoThreadsInnerMessagesInnerRoleEnum;
    /**
     * Parsed tool result as JSON
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'content': { [key: string]: any; };
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'additionalKwargs'?: { [key: string]: any; };
    /**
     * Message ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'id'?: string;
    /**
     * Tool calls in the message
     * @type {Array<GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner>}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'toolCalls'?: Array<GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner>;
    /**
     * Tool name
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'name': string;
    /**
     * Tool call ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInner
     */
    'toolCallId': string;
}

export const GraphMessagesResponseDtoThreadsInnerMessagesInnerRoleEnum = {
    Tool: 'tool'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerRoleEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerRoleEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerRoleEnum];

/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf {
    /**
     * Message role
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf
     */
    'role': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOfRoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf
     */
    'content': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOfRoleEnum = {
    Human: 'human'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOfRoleEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOfRoleEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOfRoleEnum];

/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1 {
    /**
     * Message role
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1
     */
    'role': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1RoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1
     */
    'content': string;
    /**
     * Message ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1
     */
    'id'?: string;
    /**
     * Tool calls in the message
     * @type {Array<GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner>}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1
     */
    'toolCalls'?: Array<GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner>;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1RoleEnum = {
    Ai: 'ai'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1RoleEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1RoleEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1RoleEnum];

/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner {
    /**
     * Tool name
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner
     */
    'name': string;
    /**
     * Tool arguments
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner
     */
    'args': { [key: string]: any; };
    /**
     * Tool call type
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner
     */
    'type': string;
    /**
     * Tool call ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf1ToolCallsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2 {
    /**
     * Message role
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2
     */
    'role': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2RoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2
     */
    'content': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2RoleEnum = {
    System: 'system'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2RoleEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2RoleEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf2RoleEnum];

/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3 {
    /**
     * Message role
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3
     */
    'role': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3RoleEnum;
    /**
     * Tool name - shell
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3
     */
    'name': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3NameEnum;
    /**
     * 
     * @type {GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3
     */
    'content': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content;
    /**
     * Tool call ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3
     */
    'toolCallId': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3RoleEnum = {
    ToolShell: 'tool-shell'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3RoleEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3RoleEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3RoleEnum];
export const GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3NameEnum = {
    Shell: 'shell'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3NameEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3NameEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3NameEnum];

/**
 * Parsed shell execution result
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content {
    /**
     * Exit code of the shell command
     * @type {number}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content
     */
    'exitCode': number;
    /**
     * Standard output from the command
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content
     */
    'stdout': string;
    /**
     * Standard error from the command
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content
     */
    'stderr': string;
    /**
     * The command that was executed
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content
     */
    'cmd': string;
    /**
     * Whether the command failed
     * @type {boolean}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf3Content
     */
    'fail'?: boolean;
}
/**
 * 
 * @export
 * @interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4
 */
export interface GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4 {
    /**
     * Message role
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4
     */
    'role': GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4RoleEnum;
    /**
     * Tool name
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4
     */
    'name': string;
    /**
     * Parsed tool result as JSON
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4
     */
    'content': { [key: string]: any; };
    /**
     * Tool call ID
     * @type {string}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4
     */
    'toolCallId': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4RoleEnum = {
    Tool: 'tool'
} as const;

export type GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4RoleEnum = typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4RoleEnum[keyof typeof GraphMessagesResponseDtoThreadsInnerMessagesInnerAnyOf4RoleEnum];

/**
 * 
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'kind': TemplateDtoKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TemplateDto
     */
    'schema': { [key: string]: any; };
    /**
     * 
     * @type {Array<TemplateDtoInputsInner>}
     * @memberof TemplateDto
     */
    'inputs'?: Array<TemplateDtoInputsInner>;
    /**
     * 
     * @type {Array<TemplateDtoInputsInner>}
     * @memberof TemplateDto
     */
    'outputs'?: Array<TemplateDtoInputsInner>;
}

export const TemplateDtoKindEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type TemplateDtoKindEnum = typeof TemplateDtoKindEnum[keyof typeof TemplateDtoKindEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInner
 */
export interface TemplateDtoInputsInner {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInner
     */
    'type': TemplateDtoInputsInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInner
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInner
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInner
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerTypeEnum = {
    Kind: 'kind',
    Template: 'template'
} as const;

export type TemplateDtoInputsInnerTypeEnum = typeof TemplateDtoInputsInnerTypeEnum[keyof typeof TemplateDtoInputsInnerTypeEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInnerAnyOf
 */
export interface TemplateDtoInputsInnerAnyOf {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'type': TemplateDtoInputsInnerAnyOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'value': TemplateDtoInputsInnerAnyOfValueEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerAnyOfTypeEnum = {
    Kind: 'kind'
} as const;

export type TemplateDtoInputsInnerAnyOfTypeEnum = typeof TemplateDtoInputsInnerAnyOfTypeEnum[keyof typeof TemplateDtoInputsInnerAnyOfTypeEnum];
export const TemplateDtoInputsInnerAnyOfValueEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type TemplateDtoInputsInnerAnyOfValueEnum = typeof TemplateDtoInputsInnerAnyOfValueEnum[keyof typeof TemplateDtoInputsInnerAnyOfValueEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInnerAnyOf1
 */
export interface TemplateDtoInputsInnerAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'type': TemplateDtoInputsInnerAnyOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerAnyOf1TypeEnum = {
    Template: 'template'
} as const;

export type TemplateDtoInputsInnerAnyOf1TypeEnum = typeof TemplateDtoInputsInnerAnyOf1TypeEnum[keyof typeof TemplateDtoInputsInnerAnyOf1TypeEnum];

/**
 * 
 * @export
 * @interface UpdateGraphDto
 */
export interface UpdateGraphDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'version'?: string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof UpdateGraphDto
     */
    'schema'?: CreateGraphDtoSchema;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof UpdateGraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGraphDto
     */
    'temporary'?: boolean | null;
}

/**
 * GraphsApi - axios parameter creator
 * @export
 */
export const GraphsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph: async (createGraphDto: CreateGraphDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGraphDto' is not null or undefined
            assertParamExists('createGraph', 'createGraphDto', createGraphDto)
            const localVarPath = `/api/v1/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGraphDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/destroy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeTrigger: async (graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('executeTrigger', 'graphId', graphId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('executeTrigger', 'triggerId', triggerId)
            // verify required parameter 'executeTriggerDto' is not null or undefined
            assertParamExists('executeTrigger', 'executeTriggerDto', executeTriggerDto)
            const localVarPath = `/api/v1/graphs/{graphId}/triggers/{triggerId}/execute`
                .replace(`{${"graphId"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTriggerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGraphById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findGraphById', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGraphs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} nodeId 
         * @param {string} threadId Full thread ID (e.g., \&quot;graphId:threadComponent\&quot;)
         * @param {number} [limit] Maximum number of messages to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeMessages: async (graphId: string, nodeId: string, threadId: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getNodeMessages', 'graphId', graphId)
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('getNodeMessages', 'nodeId', nodeId)
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getNodeMessages', 'threadId', threadId)
            const localVarPath = `/api/v1/graphs/{graphId}/nodes/{nodeId}/messages`
                .replace(`{${"graphId"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['threadId'] = threadId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph: async (id: string, updateGraphDto: UpdateGraphDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGraph', 'id', id)
            // verify required parameter 'updateGraphDto' is not null or undefined
            assertParamExists('updateGraph', 'updateGraphDto', updateGraphDto)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGraphDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphsApi - functional programming interface
 * @export
 */
export const GraphsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(createGraphDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.createGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.deleteGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.destroyGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTriggerResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeTrigger(graphId, triggerId, executeTriggerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.executeTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGraphById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGraphById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.findGraphById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGraphs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGraphs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.getAllGraphs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} nodeId 
         * @param {string} threadId Full thread ID (e.g., \&quot;graphId:threadComponent\&quot;)
         * @param {number} [limit] Maximum number of messages to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeMessages(graphId: string, nodeId: string, threadId: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphMessagesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeMessages(graphId, nodeId, threadId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.getNodeMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.runGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraph(id, updateGraphDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.updateGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphsApi - factory interface
 * @export
 */
export const GraphsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.createGraph(createGraphDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.destroyGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteTriggerResponseDto> {
            return localVarFp.executeTrigger(graphId, triggerId, executeTriggerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGraphById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.findGraphById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGraphs(options?: RawAxiosRequestConfig): AxiosPromise<Array<GraphDto>> {
            return localVarFp.getAllGraphs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} nodeId 
         * @param {string} threadId Full thread ID (e.g., \&quot;graphId:threadComponent\&quot;)
         * @param {number} [limit] Maximum number of messages to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeMessages(graphId: string, nodeId: string, threadId: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GraphMessagesResponseDto> {
            return localVarFp.getNodeMessages(graphId, nodeId, threadId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.runGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.updateGraph(id, updateGraphDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphsApi - object-oriented interface
 * @export
 * @class GraphsApi
 * @extends {BaseAPI}
 */
export class GraphsApi extends BaseAPI {
    /**
     * 
     * @param {CreateGraphDto} createGraphDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).createGraph(createGraphDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public deleteGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).deleteGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public destroyGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).destroyGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId 
     * @param {string} triggerId 
     * @param {ExecuteTriggerDto} executeTriggerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).executeTrigger(graphId, triggerId, executeTriggerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public findGraphById(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).findGraphById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public getAllGraphs(options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).getAllGraphs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId 
     * @param {string} nodeId 
     * @param {string} threadId Full thread ID (e.g., \&quot;graphId:threadComponent\&quot;)
     * @param {number} [limit] Maximum number of messages to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public getNodeMessages(graphId: string, nodeId: string, threadId: string, limit?: number, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).getNodeMessages(graphId, nodeId, threadId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public runGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).runGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateGraphDto} updateGraphDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).updateGraph(id, updateGraphDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.getAllTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<TemplateDto>> {
            return localVarFp.getAllTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getAllTemplates(options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getAllTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



