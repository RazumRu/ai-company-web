/* tslint:disable */
/* eslint-disable */
/**
 * company-ai-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: none
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface CreateGraphDto
 */
export interface CreateGraphDto {
  /**
   *
   * @type {string}
   * @memberof CreateGraphDto
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof CreateGraphDto
   */
  'description'?: string | null;
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof CreateGraphDto
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {CreateGraphDtoMetadata}
   * @memberof CreateGraphDto
   */
  'metadata'?: CreateGraphDtoMetadata | null;
  /**
   *
   * @type {boolean}
   * @memberof CreateGraphDto
   */
  'temporary'?: boolean | null;
}
/**
 *
 * @export
 * @interface CreateGraphDtoMetadata
 */
export interface CreateGraphDtoMetadata {
  [key: string]: any;

  /**
   * Node coordinates and names by node ID
   * @type {Array<CreateGraphDtoMetadataNodesInner>}
   * @memberof CreateGraphDtoMetadata
   */
  'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
  /**
   * Zoom level for graph display
   * @type {number}
   * @memberof CreateGraphDtoMetadata
   */
  'zoom'?: number;
  /**
   * X coordinate
   * @type {number}
   * @memberof CreateGraphDtoMetadata
   */
  'x'?: number;
  /**
   * Y coordinate
   * @type {number}
   * @memberof CreateGraphDtoMetadata
   */
  'y'?: number;
}
/**
 *
 * @export
 * @interface CreateGraphDtoMetadataNodesInner
 */
export interface CreateGraphDtoMetadataNodesInner {
  /**
   *
   * @type {string}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'id': string;
  /**
   * X coordinate of the node
   * @type {number}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'x'?: number;
  /**
   * Y coordinate of the node
   * @type {number}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'y'?: number;
  /**
   * Optional display name for the node
   * @type {string}
   * @memberof CreateGraphDtoMetadataNodesInner
   */
  'name'?: string;
}
/**
 *
 * @export
 * @interface CreateGraphDtoSchema
 */
export interface CreateGraphDtoSchema {
  /**
   *
   * @type {Array<CreateGraphDtoSchemaNodesInner>}
   * @memberof CreateGraphDtoSchema
   */
  'nodes': Array<CreateGraphDtoSchemaNodesInner>;
  /**
   *
   * @type {Array<CreateGraphDtoSchemaEdgesInner>}
   * @memberof CreateGraphDtoSchema
   */
  'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 *
 * @export
 * @interface CreateGraphDtoSchemaEdgesInner
 */
export interface CreateGraphDtoSchemaEdgesInner {
  /**
   * Source node ID
   * @type {string}
   * @memberof CreateGraphDtoSchemaEdgesInner
   */
  'from': string;
  /**
   * Target node ID
   * @type {string}
   * @memberof CreateGraphDtoSchemaEdgesInner
   */
  'to': string;
  /**
   * Optional edge label
   * @type {string}
   * @memberof CreateGraphDtoSchemaEdgesInner
   */
  'label'?: string;
}
/**
 *
 * @export
 * @interface CreateGraphDtoSchemaNodesInner
 */
export interface CreateGraphDtoSchemaNodesInner {
  /**
   * Unique identifier for this node
   * @type {string}
   * @memberof CreateGraphDtoSchemaNodesInner
   */
  'id': string;
  /**
   * Template id registered in TemplateRegistry
   * @type {string}
   * @memberof CreateGraphDtoSchemaNodesInner
   */
  'template': string;
  /**
   * Template-specific configuration
   * @type {{ [key: string]: any; }}
   * @memberof CreateGraphDtoSchemaNodesInner
   */
  'config': { [key: string]: any };
}
/**
 *
 * @export
 * @interface ExecuteTriggerDto
 */
export interface ExecuteTriggerDto {
  /**
   * Array of messages to send to the trigger
   * @type {Array<string>}
   * @memberof ExecuteTriggerDto
   */
  'messages': Array<string>;
  /**
   * Optional thread sub-ID that will be used to create the full thread ID.
   * @type {string}
   * @memberof ExecuteTriggerDto
   */
  'threadSubId'?: string;
  /**
   * If true, do not wait for execution to finish (fire-and-forget).
   * @type {boolean}
   * @memberof ExecuteTriggerDto
   */
  'async'?: boolean;
}
/**
 *
 * @export
 * @interface ExecuteTriggerResponseDto
 */
export interface ExecuteTriggerResponseDto {
  /**
   * The thread ID used for this execution
   * @type {string}
   * @memberof ExecuteTriggerResponseDto
   */
  'externalThreadId': string;
  /**
   * The checkpoint namespace for this execution
   * @type {string}
   * @memberof ExecuteTriggerResponseDto
   */
  'checkpointNs'?: string;
}
/**
 *
 * @export
 * @interface GraphDto
 */
export interface GraphDto {
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'description'?: string | null;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'error'?: string | null;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'version': string;
  /**
   * Target version after all queued revisions are applied
   * @type {string}
   * @memberof GraphDto
   */
  'targetVersion': string;
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof GraphDto
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'status': GraphDtoStatusEnum;
  /**
   *
   * @type {CreateGraphDtoMetadata}
   * @memberof GraphDto
   */
  'metadata'?: CreateGraphDtoMetadata | null;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof GraphDto
   */
  'updatedAt': string;
  /**
   *
   * @type {boolean}
   * @memberof GraphDto
   */
  'temporary'?: boolean | null;
}

export const GraphDtoStatusEnum = {
  Created: 'created',
  Compiling: 'compiling',
  Running: 'running',
  Stopped: 'stopped',
  Error: 'error',
} as const;

export type GraphDtoStatusEnum =
  (typeof GraphDtoStatusEnum)[keyof typeof GraphDtoStatusEnum];

/**
 *
 * @export
 * @interface GraphNodeWithStatusDto
 */
export interface GraphNodeWithStatusDto {
  /**
   * Node ID
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'id': string;
  /**
   * Display name for node
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'name': string;
  /**
   * Template identifier
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'template': string;
  /**
   * Node kind
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'type': GraphNodeWithStatusDtoTypeEnum;
  /**
   * Current node status
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'status': GraphNodeWithStatusDtoStatusEnum;
  /**
   *
   * @type {any}
   * @memberof GraphNodeWithStatusDto
   */
  'config': any;
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDto
   */
  'error'?: string | null;
  /**
   *
   * @type {GraphNodeWithStatusDtoMetadata}
   * @memberof GraphNodeWithStatusDto
   */
  'metadata'?: GraphNodeWithStatusDtoMetadata;
  /**
   * Additional metadata exposed by the node implementation
   * @type {{ [key: string]: any; }}
   * @memberof GraphNodeWithStatusDto
   */
  'additionalNodeMetadata'?: { [key: string]: any };
}

export const GraphNodeWithStatusDtoTypeEnum = {
  Runtime: 'runtime',
  Tool: 'tool',
  SimpleAgent: 'simpleAgent',
  Trigger: 'trigger',
  Resource: 'resource',
} as const;

export type GraphNodeWithStatusDtoTypeEnum =
  (typeof GraphNodeWithStatusDtoTypeEnum)[keyof typeof GraphNodeWithStatusDtoTypeEnum];
export const GraphNodeWithStatusDtoStatusEnum = {
  Stopped: 'stopped',
  Starting: 'starting',
  Running: 'running',
  Idle: 'idle',
} as const;

export type GraphNodeWithStatusDtoStatusEnum =
  (typeof GraphNodeWithStatusDtoStatusEnum)[keyof typeof GraphNodeWithStatusDtoStatusEnum];

/**
 *
 * @export
 * @interface GraphNodeWithStatusDtoMetadata
 */
export interface GraphNodeWithStatusDtoMetadata {
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDtoMetadata
   */
  'threadId'?: string;
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDtoMetadata
   */
  'runId'?: string;
  /**
   *
   * @type {string}
   * @memberof GraphNodeWithStatusDtoMetadata
   */
  'parentThreadId'?: string;
}
/**
 *
 * @export
 * @interface GraphRevisionDto
 */
export interface GraphRevisionDto {
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'graphId': string;
  /**
   * Version the client changes were based on
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'baseVersion': string;
  /**
   * New head version after this revision
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'toVersion': string;
  /**
   * JSON Patch (RFC 6902) operations between old and new schemas
   * @type {Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>}
   * @memberof GraphRevisionDto
   */
  'configurationDiff': Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionClientSchema}
   * @memberof GraphRevisionDto
   */
  'clientSchema': UpdateGraphResponseDtoRevisionClientSchema;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionNewSchema}
   * @memberof GraphRevisionDto
   */
  'newSchema': UpdateGraphResponseDtoRevisionNewSchema;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'status': GraphRevisionDtoStatusEnum;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'error'?: string;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof GraphRevisionDto
   */
  'updatedAt': string;
}

export const GraphRevisionDtoStatusEnum = {
  Pending: 'pending',
  Applying: 'applying',
  Applied: 'applied',
  Failed: 'failed',
} as const;

export type GraphRevisionDtoStatusEnum =
  (typeof GraphRevisionDtoStatusEnum)[keyof typeof GraphRevisionDtoStatusEnum];

/**
 *
 * @export
 * @interface LiteLlmModelDto
 */
export interface LiteLlmModelDto {
  /**
   * Model identifier
   * @type {string}
   * @memberof LiteLlmModelDto
   */
  'id': string;
  /**
   * Owner of the model
   * @type {string}
   * @memberof LiteLlmModelDto
   */
  'ownedBy': string;
}
/**
 *
 * @export
 * @interface SuggestAgentInstructionsDto
 */
export interface SuggestAgentInstructionsDto {
  /**
   * User request describing how to adjust agent instructions
   * @type {string}
   * @memberof SuggestAgentInstructionsDto
   */
  'userRequest': string;
  /**
   * Optional thread id to continue a previous suggestion conversation
   * @type {string}
   * @memberof SuggestAgentInstructionsDto
   */
  'threadId'?: string;
}
/**
 *
 * @export
 * @interface SuggestAgentInstructionsResponseDto
 */
export interface SuggestAgentInstructionsResponseDto {
  /**
   * Updated agent instructions generated by the LLM
   * @type {string}
   * @memberof SuggestAgentInstructionsResponseDto
   */
  'instructions': string;
  /**
   * Thread id used for this suggestion session
   * @type {string}
   * @memberof SuggestAgentInstructionsResponseDto
   */
  'threadId': string;
}
/**
 *
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'description': string;
  /**
   *
   * @type {string}
   * @memberof TemplateDto
   */
  'kind': TemplateDtoKindEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof TemplateDto
   */
  'schema': { [key: string]: any };
  /**
   *
   * @type {Array<TemplateDtoInputsInner>}
   * @memberof TemplateDto
   */
  'inputs'?: Array<TemplateDtoInputsInner>;
  /**
   *
   * @type {Array<TemplateDtoInputsInner>}
   * @memberof TemplateDto
   */
  'outputs'?: Array<TemplateDtoInputsInner>;
}

export const TemplateDtoKindEnum = {
  Runtime: 'runtime',
  Tool: 'tool',
  SimpleAgent: 'simpleAgent',
  Trigger: 'trigger',
  Resource: 'resource',
} as const;

export type TemplateDtoKindEnum =
  (typeof TemplateDtoKindEnum)[keyof typeof TemplateDtoKindEnum];

/**
 * @type TemplateDtoInputsInner
 * @export
 */
export type TemplateDtoInputsInner =
  | TemplateDtoInputsInnerOneOf
  | TemplateDtoInputsInnerOneOf1;

/**
 *
 * @export
 * @interface TemplateDtoInputsInnerOneOf
 */
export interface TemplateDtoInputsInnerOneOf {
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'type': TemplateDtoInputsInnerOneOfTypeEnum;
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'value': TemplateDtoInputsInnerOneOfValueEnum;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'required'?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf
   */
  'multiple': boolean;
}

export const TemplateDtoInputsInnerOneOfTypeEnum = {
  Kind: 'kind',
} as const;

export type TemplateDtoInputsInnerOneOfTypeEnum =
  (typeof TemplateDtoInputsInnerOneOfTypeEnum)[keyof typeof TemplateDtoInputsInnerOneOfTypeEnum];
export const TemplateDtoInputsInnerOneOfValueEnum = {
  Runtime: 'runtime',
  Tool: 'tool',
  SimpleAgent: 'simpleAgent',
  Trigger: 'trigger',
  Resource: 'resource',
} as const;

export type TemplateDtoInputsInnerOneOfValueEnum =
  (typeof TemplateDtoInputsInnerOneOfValueEnum)[keyof typeof TemplateDtoInputsInnerOneOfValueEnum];

/**
 *
 * @export
 * @interface TemplateDtoInputsInnerOneOf1
 */
export interface TemplateDtoInputsInnerOneOf1 {
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'type': TemplateDtoInputsInnerOneOf1TypeEnum;
  /**
   *
   * @type {string}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'value': string;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'required'?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TemplateDtoInputsInnerOneOf1
   */
  'multiple': boolean;
}

export const TemplateDtoInputsInnerOneOf1TypeEnum = {
  Template: 'template',
} as const;

export type TemplateDtoInputsInnerOneOf1TypeEnum =
  (typeof TemplateDtoInputsInnerOneOf1TypeEnum)[keyof typeof TemplateDtoInputsInnerOneOf1TypeEnum];

/**
 *
 * @export
 * @interface ThreadAnalysisRequestDto
 */
export interface ThreadAnalysisRequestDto {
  /**
   * Optional user-provided input to guide the analysis
   * @type {string}
   * @memberof ThreadAnalysisRequestDto
   */
  'userInput'?: string;
  /**
   * Optional LLM conversation id to continue the existing suggestion thread
   * @type {string}
   * @memberof ThreadAnalysisRequestDto
   */
  'threadId'?: string;
}
/**
 *
 * @export
 * @interface ThreadAnalysisResponseDto
 */
export interface ThreadAnalysisResponseDto {
  /**
   * LLM-generated analysis and improvement suggestions
   * @type {string}
   * @memberof ThreadAnalysisResponseDto
   */
  'analysis': string;
  /**
   * Identifier of the LLM conversation used for the analysis
   * @type {string}
   * @memberof ThreadAnalysisResponseDto
   */
  'conversationId': string;
}
/**
 *
 * @export
 * @interface ThreadDto
 */
export interface ThreadDto {
  /**
   * Thread ID
   * @type {string}
   * @memberof ThreadDto
   */
  'id': string;
  /**
   * Graph ID
   * @type {string}
   * @memberof ThreadDto
   */
  'graphId': string;
  /**
   * External thread ID from LangChain
   * @type {string}
   * @memberof ThreadDto
   */
  'externalThreadId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'updatedAt': string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ThreadDto
   */
  'metadata'?: { [key: string]: any } | null;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'source'?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadDto
   */
  'name'?: string | null;
  /**
   * Thread execution status
   * @type {string}
   * @memberof ThreadDto
   */
  'status': ThreadDtoStatusEnum;
}

export const ThreadDtoStatusEnum = {
  Running: 'running',
  Done: 'done',
  NeedMoreInfo: 'need_more_info',
  Stopped: 'stopped',
} as const;

export type ThreadDtoStatusEnum =
  (typeof ThreadDtoStatusEnum)[keyof typeof ThreadDtoStatusEnum];

/**
 *
 * @export
 * @interface ThreadMessageDto
 */
export interface ThreadMessageDto {
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'threadId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'nodeId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'externalThreadId': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof ThreadMessageDto
   */
  'updatedAt': string;
  /**
   *
   * @type {ThreadMessageDtoMessage}
   * @memberof ThreadMessageDto
   */
  'message': ThreadMessageDtoMessage;
}
/**
 * @type ThreadMessageDtoMessage
 * @export
 */
export type ThreadMessageDtoMessage =
  | ThreadMessageDtoMessageOneOf
  | ThreadMessageDtoMessageOneOf1
  | ThreadMessageDtoMessageOneOf2
  | ThreadMessageDtoMessageOneOf3
  | ThreadMessageDtoMessageOneOf4
  | ThreadMessageDtoMessageOneOf5;

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf
 */
export interface ThreadMessageDtoMessageOneOf {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'role': ThreadMessageDtoMessageOneOfRoleEnum;
  /**
   * Message content
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'content': string;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOfRoleEnum = {
  Human: 'human',
} as const;

export type ThreadMessageDtoMessageOneOfRoleEnum =
  (typeof ThreadMessageDtoMessageOneOfRoleEnum)[keyof typeof ThreadMessageDtoMessageOneOfRoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf1
 */
export interface ThreadMessageDtoMessageOneOf1 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'role': ThreadMessageDtoMessageOneOf1RoleEnum;
  /**
   * Message content
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'content': string;
  /**
   * Message ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'id'?: string;
  /**
   *
   * @type {any}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'rawContent'?: any;
  /**
   * Tool calls in the message
   * @type {Array<ThreadMessageDtoMessageOneOf1ToolCallsInner>}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'toolCalls'?: Array<ThreadMessageDtoMessageOneOf1ToolCallsInner>;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf1
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf1RoleEnum = {
  Ai: 'ai',
} as const;

export type ThreadMessageDtoMessageOneOf1RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf1RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf1RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf1ToolCallsInner
 */
export interface ThreadMessageDtoMessageOneOf1ToolCallsInner {
  /**
   * Tool name
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'name': string;
  /**
   * Tool arguments
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'args': { [key: string]: any };
  /**
   * Tool call type
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'type': string;
  /**
   * Tool call ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf1ToolCallsInner
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf2
 */
export interface ThreadMessageDtoMessageOneOf2 {
  /**
   * Message ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'id'?: string;
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'role': ThreadMessageDtoMessageOneOf2RoleEnum;
  /**
   * Reasoning trace emitted by the model
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'content': string;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf2
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf2RoleEnum = {
  Reasoning: 'reasoning',
} as const;

export type ThreadMessageDtoMessageOneOf2RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf2RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf2RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf3
 */
export interface ThreadMessageDtoMessageOneOf3 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'role': ThreadMessageDtoMessageOneOf3RoleEnum;
  /**
   * Message content
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'content': string;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf3
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf3RoleEnum = {
  System: 'system',
} as const;

export type ThreadMessageDtoMessageOneOf3RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf3RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf3RoleEnum];

/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf4
 */
export interface ThreadMessageDtoMessageOneOf4 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'role': ThreadMessageDtoMessageOneOf4RoleEnum;
  /**
   * Tool name - shell
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'name': ThreadMessageDtoMessageOneOf4NameEnum;
  /**
   *
   * @type {ThreadMessageDtoMessageOneOf4Content}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'content': ThreadMessageDtoMessageOneOf4Content;
  /**
   * Tool call ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'toolCallId': string;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf4
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf4RoleEnum = {
  ToolShell: 'tool-shell',
} as const;

export type ThreadMessageDtoMessageOneOf4RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf4RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf4RoleEnum];
export const ThreadMessageDtoMessageOneOf4NameEnum = {
  Shell: 'shell',
} as const;

export type ThreadMessageDtoMessageOneOf4NameEnum =
  (typeof ThreadMessageDtoMessageOneOf4NameEnum)[keyof typeof ThreadMessageDtoMessageOneOf4NameEnum];

/**
 * Parsed shell execution result
 * @export
 * @interface ThreadMessageDtoMessageOneOf4Content
 */
export interface ThreadMessageDtoMessageOneOf4Content {
  /**
   * Exit code of the shell command
   * @type {number}
   * @memberof ThreadMessageDtoMessageOneOf4Content
   */
  'exitCode': number;
  /**
   * Standard output from the command
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4Content
   */
  'stdout': string;
  /**
   * Standard error from the command
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf4Content
   */
  'stderr': string;
}
/**
 *
 * @export
 * @interface ThreadMessageDtoMessageOneOf5
 */
export interface ThreadMessageDtoMessageOneOf5 {
  /**
   * Message role
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf5
   */
  'role': ThreadMessageDtoMessageOneOf5RoleEnum;
  /**
   * Tool name
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf5
   */
  'name': string;
  /**
   * Parsed tool result as JSON
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf5
   */
  'content': { [key: string]: any };
  /**
   * Tool call ID
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf5
   */
  'toolCallId': string;
  /**
   * Optional human-readable tool call title
   * @type {string}
   * @memberof ThreadMessageDtoMessageOneOf5
   */
  'title'?: string;
  /**
   * Additional message metadata
   * @type {{ [key: string]: any; }}
   * @memberof ThreadMessageDtoMessageOneOf5
   */
  'additionalKwargs'?: { [key: string]: any };
}

export const ThreadMessageDtoMessageOneOf5RoleEnum = {
  Tool: 'tool',
} as const;

export type ThreadMessageDtoMessageOneOf5RoleEnum =
  (typeof ThreadMessageDtoMessageOneOf5RoleEnum)[keyof typeof ThreadMessageDtoMessageOneOf5RoleEnum];

/**
 *
 * @export
 * @interface UpdateGraphDto
 */
export interface UpdateGraphDto {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof UpdateGraphDto
   */
  'name'?: string;
  /**
   *
   * @type {UpdateGraphDtoDescription}
   * @memberof UpdateGraphDto
   */
  'description'?: UpdateGraphDtoDescription;
  /**
   *
   * @type {UpdateGraphDtoSchema}
   * @memberof UpdateGraphDto
   */
  'schema'?: UpdateGraphDtoSchema;
  /**
   *
   * @type {UpdateGraphDtoMetadata}
   * @memberof UpdateGraphDto
   */
  'metadata'?: UpdateGraphDtoMetadata;
  /**
   *
   * @type {UpdateGraphDtoTemporary}
   * @memberof UpdateGraphDto
   */
  'temporary'?: UpdateGraphDtoTemporary;
  /**
   * Current version of the graph (for optimistic locking and 3-way merge base)
   * @type {string}
   * @memberof UpdateGraphDto
   */
  'currentVersion': string;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoDescription
 */
export interface UpdateGraphDtoDescription {}
/**
 *
 * @export
 * @interface UpdateGraphDtoMetadata
 */
export interface UpdateGraphDtoMetadata {
  /**
   * Node coordinates and names by node ID
   * @type {Array<CreateGraphDtoMetadataNodesInner>}
   * @memberof UpdateGraphDtoMetadata
   */
  'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
  /**
   * Zoom level for graph display
   * @type {number}
   * @memberof UpdateGraphDtoMetadata
   */
  'zoom'?: number;
  /**
   * X coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadata
   */
  'x'?: number;
  /**
   * Y coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadata
   */
  'y'?: number;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoMetadataAnyOf
 */
export interface UpdateGraphDtoMetadataAnyOf {
  [key: string]: any;

  /**
   * Node coordinates and names by node ID
   * @type {Array<CreateGraphDtoMetadataNodesInner>}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
  /**
   * Zoom level for graph display
   * @type {number}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'zoom'?: number;
  /**
   * X coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'x'?: number;
  /**
   * Y coordinate
   * @type {number}
   * @memberof UpdateGraphDtoMetadataAnyOf
   */
  'y'?: number;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoSchema
 */
export interface UpdateGraphDtoSchema {
  /**
   *
   * @type {Array<UpdateGraphDtoSchemaNodesInner>}
   * @memberof UpdateGraphDtoSchema
   */
  'nodes': Array<UpdateGraphDtoSchemaNodesInner>;
  /**
   *
   * @type {Array<UpdateGraphDtoSchemaEdgesInner>}
   * @memberof UpdateGraphDtoSchema
   */
  'edges'?: Array<UpdateGraphDtoSchemaEdgesInner>;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoSchemaEdgesInner
 */
export interface UpdateGraphDtoSchemaEdgesInner {
  /**
   * Source node ID
   * @type {string}
   * @memberof UpdateGraphDtoSchemaEdgesInner
   */
  'from': string;
  /**
   * Target node ID
   * @type {string}
   * @memberof UpdateGraphDtoSchemaEdgesInner
   */
  'to': string;
  /**
   * Optional edge label
   * @type {string}
   * @memberof UpdateGraphDtoSchemaEdgesInner
   */
  'label'?: string;
}
/**
 *
 * @export
 * @interface UpdateGraphDtoSchemaNodesInner
 */
export interface UpdateGraphDtoSchemaNodesInner {
  /**
   * Unique identifier for this node
   * @type {string}
   * @memberof UpdateGraphDtoSchemaNodesInner
   */
  'id': string;
  /**
   * Template id registered in TemplateRegistry
   * @type {string}
   * @memberof UpdateGraphDtoSchemaNodesInner
   */
  'template': string;
  /**
   * Template-specific configuration
   * @type {{ [key: string]: any; }}
   * @memberof UpdateGraphDtoSchemaNodesInner
   */
  'config': { [key: string]: any };
}
/**
 * If true, graph will be deleted instead of restored after server restart
 * @export
 * @interface UpdateGraphDtoTemporary
 */
export interface UpdateGraphDtoTemporary {}
/**
 *
 * @export
 * @interface UpdateGraphResponseDto
 */
export interface UpdateGraphResponseDto {
  /**
   *
   * @type {UpdateGraphResponseDtoGraph}
   * @memberof UpdateGraphResponseDto
   */
  'graph': UpdateGraphResponseDtoGraph;
  /**
   *
   * @type {UpdateGraphResponseDtoRevision}
   * @memberof UpdateGraphResponseDto
   */
  'revision'?: UpdateGraphResponseDtoRevision | null;
}
/**
 * Updated graph
 * @export
 * @interface UpdateGraphResponseDtoGraph
 */
export interface UpdateGraphResponseDtoGraph {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'description'?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'error'?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'version': string;
  /**
   * Target version after all queued revisions are applied
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'targetVersion': string;
  /**
   *
   * @type {CreateGraphDtoSchema}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'schema': CreateGraphDtoSchema;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'status': UpdateGraphResponseDtoGraphStatusEnum;
  /**
   *
   * @type {CreateGraphDtoMetadata}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'metadata'?: CreateGraphDtoMetadata | null;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'updatedAt': string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateGraphResponseDtoGraph
   */
  'temporary'?: boolean | null;
}

export const UpdateGraphResponseDtoGraphStatusEnum = {
  Created: 'created',
  Compiling: 'compiling',
  Running: 'running',
  Stopped: 'stopped',
  Error: 'error',
} as const;

export type UpdateGraphResponseDtoGraphStatusEnum =
  (typeof UpdateGraphResponseDtoGraphStatusEnum)[keyof typeof UpdateGraphResponseDtoGraphStatusEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevision
 */
export interface UpdateGraphResponseDtoRevision {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'graphId': string;
  /**
   * Version the client changes were based on
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'baseVersion': string;
  /**
   * New head version after this revision
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'toVersion': string;
  /**
   * JSON Patch (RFC 6902) operations between old and new schemas
   * @type {Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'configurationDiff': Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionClientSchema}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'clientSchema': UpdateGraphResponseDtoRevisionClientSchema;
  /**
   *
   * @type {UpdateGraphResponseDtoRevisionNewSchema}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'newSchema': UpdateGraphResponseDtoRevisionNewSchema;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'status': UpdateGraphResponseDtoRevisionStatusEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'error'?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'createdAt': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevision
   */
  'updatedAt': string;
}

export const UpdateGraphResponseDtoRevisionStatusEnum = {
  Pending: 'pending',
  Applying: 'applying',
  Applied: 'applied',
  Failed: 'failed',
} as const;

export type UpdateGraphResponseDtoRevisionStatusEnum =
  (typeof UpdateGraphResponseDtoRevisionStatusEnum)[keyof typeof UpdateGraphResponseDtoRevisionStatusEnum];

/**
 * Schema submitted by the client
 * @export
 * @interface UpdateGraphResponseDtoRevisionClientSchema
 */
export interface UpdateGraphResponseDtoRevisionClientSchema {
  /**
   *
   * @type {Array<CreateGraphDtoSchemaNodesInner>}
   * @memberof UpdateGraphResponseDtoRevisionClientSchema
   */
  'nodes': Array<CreateGraphDtoSchemaNodesInner>;
  /**
   *
   * @type {Array<CreateGraphDtoSchemaEdgesInner>}
   * @memberof UpdateGraphResponseDtoRevisionClientSchema
   */
  'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 * @type UpdateGraphResponseDtoRevisionConfigurationDiffInner
 * @export
 */
export type UpdateGraphResponseDtoRevisionConfigurationDiffInner =
  | UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf
  | UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1
  | UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2
  | UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3
  | UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4
  | UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5;

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf
   */
  'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOfOpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf
   */
  'path': string;
  /**
   *
   * @type {any}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf
   */
  'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOfOpEnum = {
  Add: 'add',
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOfOpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOfOpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOfOpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1
   */
  'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1
   */
  'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1OpEnum =
  {
    Remove: 'remove',
  } as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf1OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2
   */
  'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2
   */
  'path': string;
  /**
   *
   * @type {any}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2
   */
  'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2OpEnum =
  {
    Replace: 'replace',
  } as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf2OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3
   */
  'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3
   */
  'from': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3
   */
  'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3OpEnum =
  {
    Move: 'move',
  } as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf3OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4
   */
  'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4
   */
  'from': string;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4
   */
  'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4OpEnum =
  {
    Copy: 'copy',
  } as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf4OpEnum];

/**
 *
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5 {
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5
   */
  'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5OpEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5
   */
  'path': string;
  /**
   *
   * @type {any}
   * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5
   */
  'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5OpEnum =
  {
    Test: 'test',
  } as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5OpEnum =
  (typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5OpEnum)[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOneOf5OpEnum];

/**
 * Merged schema result
 * @export
 * @interface UpdateGraphResponseDtoRevisionNewSchema
 */
export interface UpdateGraphResponseDtoRevisionNewSchema {
  /**
   *
   * @type {Array<CreateGraphDtoSchemaNodesInner>}
   * @memberof UpdateGraphResponseDtoRevisionNewSchema
   */
  'nodes': Array<CreateGraphDtoSchemaNodesInner>;
  /**
   *
   * @type {Array<CreateGraphDtoSchemaEdgesInner>}
   * @memberof UpdateGraphResponseDtoRevisionNewSchema
   */
  'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}

/**
 * GraphRevisionsApi - axios parameter creator
 * @export
 */
export const GraphRevisionsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} graphId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevision: async (
      graphId: string,
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('getGraphRevision', 'graphId', graphId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGraphRevision', 'id', id);
      const localVarPath = `/api/v1/graphs/{graphId}/revisions/{id}`
        .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {GetGraphRevisionsStatusEnum} [status]
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevisions: async (
      graphId: string,
      status?: GetGraphRevisionsStatusEnum,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('getGraphRevisions', 'graphId', graphId);
      const localVarPath = `/api/v1/graphs/{graphId}/revisions`.replace(
        `{${'graphId'}}`,
        encodeURIComponent(String(graphId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphRevisionsApi - functional programming interface
 * @export
 */
export const GraphRevisionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GraphRevisionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} graphId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGraphRevision(
      graphId: string,
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GraphRevisionDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGraphRevision(graphId, id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphRevisionsApi.getGraphRevision']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {GetGraphRevisionsStatusEnum} [status]
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGraphRevisions(
      graphId: string,
      status?: GetGraphRevisionsStatusEnum,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GraphRevisionDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGraphRevisions(
          graphId,
          status,
          limit,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphRevisionsApi.getGraphRevisions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GraphRevisionsApi - factory interface
 * @export
 */
export const GraphRevisionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphRevisionsApiFp(configuration);
  return {
    /**
     *
     * @param {string} graphId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevision(
      graphId: string,
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphRevisionDto> {
      return localVarFp
        .getGraphRevision(graphId, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {GetGraphRevisionsStatusEnum} [status]
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGraphRevisions(
      graphId: string,
      status?: GetGraphRevisionsStatusEnum,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GraphRevisionDto>> {
      return localVarFp
        .getGraphRevisions(graphId, status, limit, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphRevisionsApi - object-oriented interface
 * @export
 * @class GraphRevisionsApi
 * @extends {BaseAPI}
 */
export class GraphRevisionsApi extends BaseAPI {
  /**
   *
   * @param {string} graphId
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphRevisionsApi
   */
  public getGraphRevision(
    graphId: string,
    id: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphRevisionsApiFp(this.configuration)
      .getGraphRevision(graphId, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {GetGraphRevisionsStatusEnum} [status]
   * @param {number} [limit] Maximum number of revisions to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphRevisionsApi
   */
  public getGraphRevisions(
    graphId: string,
    status?: GetGraphRevisionsStatusEnum,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphRevisionsApiFp(this.configuration)
      .getGraphRevisions(graphId, status, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetGraphRevisionsStatusEnum = {
  Pending: 'pending',
  Applying: 'applying',
  Applied: 'applied',
  Failed: 'failed',
} as const;
export type GetGraphRevisionsStatusEnum =
  (typeof GetGraphRevisionsStatusEnum)[keyof typeof GetGraphRevisionsStatusEnum];

/**
 * GraphsApi - axios parameter creator
 * @export
 */
export const GraphsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateGraphDto} createGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGraph: async (
      createGraphDto: CreateGraphDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createGraphDto' is not null or undefined
      assertParamExists('createGraph', 'createGraphDto', createGraphDto);
      const localVarPath = `/api/v1/graphs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGraphDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteGraph', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    destroyGraph: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('destroyGraph', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}/destroy`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {string} triggerId
     * @param {ExecuteTriggerDto} executeTriggerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeTrigger: async (
      graphId: string,
      triggerId: string,
      executeTriggerDto: ExecuteTriggerDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('executeTrigger', 'graphId', graphId);
      // verify required parameter 'triggerId' is not null or undefined
      assertParamExists('executeTrigger', 'triggerId', triggerId);
      // verify required parameter 'executeTriggerDto' is not null or undefined
      assertParamExists(
        'executeTrigger',
        'executeTriggerDto',
        executeTriggerDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/triggers/{triggerId}/execute`
          .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
          .replace(`{${'triggerId'}}`, encodeURIComponent(String(triggerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        executeTriggerDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGraphById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('findGraphById', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGraphs: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/graphs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {string} [threadId]
     * @param {string} [runId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompiledNodes: async (
      id: string,
      threadId?: string,
      runId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCompiledNodes', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}/nodes`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (threadId !== undefined) {
        localVarQueryParameter['threadId'] = threadId;
      }

      if (runId !== undefined) {
        localVarQueryParameter['runId'] = runId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGraph: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('runGraph', 'id', id);
      const localVarPath = `/api/v1/graphs/{id}/run`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions: async (
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'graphId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'graphId', graphId);
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('suggestAgentInstructions', 'nodeId', nodeId);
      // verify required parameter 'suggestAgentInstructionsDto' is not null or undefined
      assertParamExists(
        'suggestAgentInstructions',
        'suggestAgentInstructionsDto',
        suggestAgentInstructionsDto,
      );
      const localVarPath =
        `/api/v1/graphs/{graphId}/nodes/{nodeId}/suggest-instructions`
          .replace(`{${'graphId'}}`, encodeURIComponent(String(graphId)))
          .replace(`{${'nodeId'}}`, encodeURIComponent(String(nodeId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        suggestAgentInstructionsDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {UpdateGraphDto} updateGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph: async (
      id: string,
      updateGraphDto: UpdateGraphDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateGraph', 'id', id);
      // verify required parameter 'updateGraphDto' is not null or undefined
      assertParamExists('updateGraph', 'updateGraphDto', updateGraphDto);
      const localVarPath = `/api/v1/graphs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGraphDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphsApi - functional programming interface
 * @export
 */
export const GraphsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GraphsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateGraphDto} createGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGraph(
      createGraphDto: CreateGraphDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(
        createGraphDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.createGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraph(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.deleteGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async destroyGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.destroyGraph(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.destroyGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {string} triggerId
     * @param {ExecuteTriggerDto} executeTriggerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeTrigger(
      graphId: string,
      triggerId: string,
      executeTriggerDto: ExecuteTriggerDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ExecuteTriggerResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeTrigger(
        graphId,
        triggerId,
        executeTriggerDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.executeTrigger']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findGraphById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findGraphById(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.findGraphById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllGraphs(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GraphDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllGraphs(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.getAllGraphs']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {string} [threadId]
     * @param {string} [runId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompiledNodes(
      id: string,
      threadId?: string,
      runId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GraphNodeWithStatusDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCompiledNodes(
          id,
          threadId,
          runId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.getCompiledNodes']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGraph(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.runGraph']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SuggestAgentInstructionsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.suggestAgentInstructions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {UpdateGraphDto} updateGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGraph(
      id: string,
      updateGraphDto: UpdateGraphDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateGraphResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraph(
        id,
        updateGraphDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['GraphsApi.updateGraph']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * GraphsApi - factory interface
 * @export
 */
export const GraphsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphsApiFp(configuration);
  return {
    /**
     *
     * @param {CreateGraphDto} createGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGraph(
      createGraphDto: CreateGraphDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .createGraph(createGraphDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteGraph(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    destroyGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .destroyGraph(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {string} triggerId
     * @param {ExecuteTriggerDto} executeTriggerDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeTrigger(
      graphId: string,
      triggerId: string,
      executeTriggerDto: ExecuteTriggerDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ExecuteTriggerResponseDto> {
      return localVarFp
        .executeTrigger(graphId, triggerId, executeTriggerDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGraphById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .findGraphById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGraphs(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GraphDto>> {
      return localVarFp
        .getAllGraphs(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {string} [threadId]
     * @param {string} [runId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompiledNodes(
      id: string,
      threadId?: string,
      runId?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GraphNodeWithStatusDto>> {
      return localVarFp
        .getCompiledNodes(id, threadId, runId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGraph(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GraphDto> {
      return localVarFp
        .runGraph(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} graphId
     * @param {string} nodeId
     * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestAgentInstructions(
      graphId: string,
      nodeId: string,
      suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuggestAgentInstructionsResponseDto> {
      return localVarFp
        .suggestAgentInstructions(
          graphId,
          nodeId,
          suggestAgentInstructionsDto,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {UpdateGraphDto} updateGraphDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGraph(
      id: string,
      updateGraphDto: UpdateGraphDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateGraphResponseDto> {
      return localVarFp
        .updateGraph(id, updateGraphDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphsApi - object-oriented interface
 * @export
 * @class GraphsApi
 * @extends {BaseAPI}
 */
export class GraphsApi extends BaseAPI {
  /**
   *
   * @param {CreateGraphDto} createGraphDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public createGraph(
    createGraphDto: CreateGraphDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .createGraph(createGraphDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public deleteGraph(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .deleteGraph(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public destroyGraph(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .destroyGraph(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {string} triggerId
   * @param {ExecuteTriggerDto} executeTriggerDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public executeTrigger(
    graphId: string,
    triggerId: string,
    executeTriggerDto: ExecuteTriggerDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .executeTrigger(graphId, triggerId, executeTriggerDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public findGraphById(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .findGraphById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public getAllGraphs(options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .getAllGraphs(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {string} [threadId]
   * @param {string} [runId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public getCompiledNodes(
    id: string,
    threadId?: string,
    runId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .getCompiledNodes(id, threadId, runId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public runGraph(id: string, options?: RawAxiosRequestConfig) {
    return GraphsApiFp(this.configuration)
      .runGraph(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} graphId
   * @param {string} nodeId
   * @param {SuggestAgentInstructionsDto} suggestAgentInstructionsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public suggestAgentInstructions(
    graphId: string,
    nodeId: string,
    suggestAgentInstructionsDto: SuggestAgentInstructionsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .suggestAgentInstructions(
        graphId,
        nodeId,
        suggestAgentInstructionsDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {UpdateGraphDto} updateGraphDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public updateGraph(
    id: string,
    updateGraphDto: UpdateGraphDto,
    options?: RawAxiosRequestConfig,
  ) {
    return GraphsApiFp(this.configuration)
      .updateGraph(id, updateGraphDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LitellmApi - axios parameter creator
 * @export
 */
export const LitellmApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listModels: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/litellm/models`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LitellmApi - functional programming interface
 * @export
 */
export const LitellmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LitellmApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listModels(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LiteLlmModelDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listModels(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LitellmApi.listModels']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LitellmApi - factory interface
 * @export
 */
export const LitellmApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LitellmApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listModels(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<LiteLlmModelDto>> {
      return localVarFp
        .listModels(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LitellmApi - object-oriented interface
 * @export
 * @class LitellmApi
 * @extends {BaseAPI}
 */
export class LitellmApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LitellmApi
   */
  public listModels(options?: RawAxiosRequestConfig) {
    return LitellmApiFp(this.configuration)
      .listModels(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TemplatesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTemplates(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TemplateDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllTemplates(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TemplatesApi.getAllTemplates']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TemplatesApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<TemplateDto>> {
      return localVarFp
        .getAllTemplates(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public getAllTemplates(options?: RawAxiosRequestConfig) {
    return TemplatesApiFp(this.configuration)
      .getAllTemplates(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ThreadsApi - axios parameter creator
 * @export
 */
export const ThreadsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread: async (
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('analyzeThread', 'threadId', threadId);
      // verify required parameter 'threadAnalysisRequestDto' is not null or undefined
      assertParamExists(
        'analyzeThread',
        'threadAnalysisRequestDto',
        threadAnalysisRequestDto,
      );
      const localVarPath = `/api/v1/threads/{threadId}/analyze`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        threadAnalysisRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThread: async (
      threadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('deleteThread', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadByExternalId: async (
      externalThreadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalThreadId' is not null or undefined
      assertParamExists(
        'getThreadByExternalId',
        'externalThreadId',
        externalThreadId,
      );
      const localVarPath =
        `/api/v1/threads/external/{externalThreadId}`.replace(
          `{${'externalThreadId'}}`,
          encodeURIComponent(String(externalThreadId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadById: async (
      threadId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('getThreadById', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} threadId
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadMessages: async (
      threadId: string,
      nodeId?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'threadId' is not null or undefined
      assertParamExists('getThreadMessages', 'threadId', threadId);
      const localVarPath = `/api/v1/threads/{threadId}/messages`.replace(
        `{${'threadId'}}`,
        encodeURIComponent(String(threadId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (nodeId !== undefined) {
        localVarQueryParameter['nodeId'] = nodeId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [graphId] Filter by graph ID
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreads: async (
      graphId?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/threads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (graphId !== undefined) {
        localVarQueryParameter['graphId'] = graphId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ThreadsApi - functional programming interface
 * @export
 */
export const ThreadsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ThreadsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ThreadAnalysisResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeThread(
        threadId,
        threadAnalysisRequestDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.analyzeThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteThread(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThread(
        threadId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.deleteThread']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadByExternalId(
      externalThreadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getThreadByExternalId(
          externalThreadId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadByExternalId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadById(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadById(
        threadId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} threadId
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadMessages(
      threadId: string,
      nodeId?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ThreadMessageDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getThreadMessages(
          threadId,
          nodeId,
          limit,
          offset,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreadMessages']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [graphId] Filter by graph ID
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreads(
      graphId?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ThreadDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThreads(
        graphId,
        limit,
        offset,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ThreadsApi.getThreads']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ThreadsApi - factory interface
 * @export
 */
export const ThreadsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ThreadsApiFp(configuration);
  return {
    /**
     *
     * @param {string} threadId
     * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeThread(
      threadId: string,
      threadAnalysisRequestDto: ThreadAnalysisRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadAnalysisResponseDto> {
      return localVarFp
        .analyzeThread(threadId, threadAnalysisRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThread(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteThread(threadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} externalThreadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadByExternalId(
      externalThreadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .getThreadByExternalId(externalThreadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadById(
      threadId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ThreadDto> {
      return localVarFp
        .getThreadById(threadId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} threadId
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadMessages(
      threadId: string,
      nodeId?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ThreadMessageDto>> {
      return localVarFp
        .getThreadMessages(threadId, nodeId, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [graphId] Filter by graph ID
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreads(
      graphId?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ThreadDto>> {
      return localVarFp
        .getThreads(graphId, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ThreadsApi - object-oriented interface
 * @export
 * @class ThreadsApi
 * @extends {BaseAPI}
 */
export class ThreadsApi extends BaseAPI {
  /**
   *
   * @param {string} threadId
   * @param {ThreadAnalysisRequestDto} threadAnalysisRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public analyzeThread(
    threadId: string,
    threadAnalysisRequestDto: ThreadAnalysisRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .analyzeThread(threadId, threadAnalysisRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public deleteThread(threadId: string, options?: RawAxiosRequestConfig) {
    return ThreadsApiFp(this.configuration)
      .deleteThread(threadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} externalThreadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadByExternalId(
    externalThreadId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreadByExternalId(externalThreadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadById(threadId: string, options?: RawAxiosRequestConfig) {
    return ThreadsApiFp(this.configuration)
      .getThreadById(threadId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} threadId
   * @param {string} [nodeId] Filter messages by node ID (agent node)
   * @param {number} [limit] Maximum number of messages to return
   * @param {number} [offset] Number of messages to skip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadMessages(
    threadId: string,
    nodeId?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreadMessages(threadId, nodeId, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [graphId] Filter by graph ID
   * @param {number} [limit] Maximum number of threads to return
   * @param {number} [offset] Number of threads to skip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreads(
    graphId?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreads(graphId, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
