/* tslint:disable */
/* eslint-disable */
/**
 * company-ai-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: none
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateGraphDto
 */
export interface CreateGraphDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof CreateGraphDto
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof CreateGraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGraphDto
     */
    'temporary'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoMetadata
 */
export interface CreateGraphDtoMetadata {
    [key: string]: any;

    /**
     * Node coordinates and names by node ID
     * @type {Array<CreateGraphDtoMetadataNodesInner>}
     * @memberof CreateGraphDtoMetadata
     */
    'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
    /**
     * Zoom level for graph display
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'zoom'?: number;
    /**
     * X coordinate
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'x'?: number;
    /**
     * Y coordinate
     * @type {number}
     * @memberof CreateGraphDtoMetadata
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoMetadataNodesInner
 */
export interface CreateGraphDtoMetadataNodesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'id': string;
    /**
     * X coordinate of the node
     * @type {number}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'x'?: number;
    /**
     * Y coordinate of the node
     * @type {number}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'y'?: number;
    /**
     * Optional display name for the node
     * @type {string}
     * @memberof CreateGraphDtoMetadataNodesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchema
 */
export interface CreateGraphDtoSchema {
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaNodesInner>}
     * @memberof CreateGraphDtoSchema
     */
    'nodes': Array<CreateGraphDtoSchemaNodesInner>;
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaEdgesInner>}
     * @memberof CreateGraphDtoSchema
     */
    'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchemaEdgesInner
 */
export interface CreateGraphDtoSchemaEdgesInner {
    /**
     * Source node ID
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'from': string;
    /**
     * Target node ID
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'to': string;
    /**
     * Optional edge label
     * @type {string}
     * @memberof CreateGraphDtoSchemaEdgesInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphDtoSchemaNodesInner
 */
export interface CreateGraphDtoSchemaNodesInner {
    /**
     * Unique identifier for this node
     * @type {string}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'id': string;
    /**
     * Template name registered in TemplateRegistry
     * @type {string}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'template': string;
    /**
     * Template-specific configuration
     * @type {{ [key: string]: any; }}
     * @memberof CreateGraphDtoSchemaNodesInner
     */
    'config': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ExecuteTriggerDto
 */
export interface ExecuteTriggerDto {
    /**
     * Array of messages to send to the trigger
     * @type {Array<string>}
     * @memberof ExecuteTriggerDto
     */
    'messages': Array<string>;
    /**
     * Optional thread sub-ID that will be used to create the full thread ID.
     * @type {string}
     * @memberof ExecuteTriggerDto
     */
    'threadSubId'?: string;
    /**
     * If true, do not wait for execution to finish (fire-and-forget).
     * @type {boolean}
     * @memberof ExecuteTriggerDto
     */
    'async'?: boolean;
}
/**
 * 
 * @export
 * @interface ExecuteTriggerResponseDto
 */
export interface ExecuteTriggerResponseDto {
    /**
     * The thread ID used for this execution
     * @type {string}
     * @memberof ExecuteTriggerResponseDto
     */
    'externalThreadId': string;
    /**
     * The checkpoint namespace for this execution
     * @type {string}
     * @memberof ExecuteTriggerResponseDto
     */
    'checkpointNs'?: string;
}
/**
 * 
 * @export
 * @interface GraphDto
 */
export interface GraphDto {
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'version': string;
    /**
     * Target version after all queued revisions are applied
     * @type {string}
     * @memberof GraphDto
     */
    'targetVersion': string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof GraphDto
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'status': GraphDtoStatusEnum;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof GraphDto
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GraphDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof GraphDto
     */
    'temporary'?: boolean | null;
}

export const GraphDtoStatusEnum = {
    Created: 'created',
    Compiling: 'compiling',
    Running: 'running',
    Stopped: 'stopped',
    Error: 'error'
} as const;

export type GraphDtoStatusEnum = typeof GraphDtoStatusEnum[keyof typeof GraphDtoStatusEnum];

/**
 * 
 * @export
 * @interface GraphNodeWithStatusDto
 */
export interface GraphNodeWithStatusDto {
    /**
     * Node ID
     * @type {string}
     * @memberof GraphNodeWithStatusDto
     */
    'id': string;
    /**
     * Display name for node
     * @type {string}
     * @memberof GraphNodeWithStatusDto
     */
    'name': string;
    /**
     * Template identifier
     * @type {string}
     * @memberof GraphNodeWithStatusDto
     */
    'template': string;
    /**
     * Node kind
     * @type {string}
     * @memberof GraphNodeWithStatusDto
     */
    'type': GraphNodeWithStatusDtoTypeEnum;
    /**
     * Current node status
     * @type {string}
     * @memberof GraphNodeWithStatusDto
     */
    'status': GraphNodeWithStatusDtoStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof GraphNodeWithStatusDto
     */
    'config': any;
    /**
     * 
     * @type {string}
     * @memberof GraphNodeWithStatusDto
     */
    'error'?: string | null;
    /**
     * 
     * @type {GraphNodeWithStatusDtoMetadata}
     * @memberof GraphNodeWithStatusDto
     */
    'metadata'?: GraphNodeWithStatusDtoMetadata;
    /**
     * Additional metadata exposed by the node implementation
     * @type {{ [key: string]: any; }}
     * @memberof GraphNodeWithStatusDto
     */
    'additionalNodeMetadata'?: { [key: string]: any; };
}

export const GraphNodeWithStatusDtoTypeEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type GraphNodeWithStatusDtoTypeEnum = typeof GraphNodeWithStatusDtoTypeEnum[keyof typeof GraphNodeWithStatusDtoTypeEnum];
export const GraphNodeWithStatusDtoStatusEnum = {
    Stopped: 'stopped',
    Starting: 'starting',
    Running: 'running',
    Idle: 'idle'
} as const;

export type GraphNodeWithStatusDtoStatusEnum = typeof GraphNodeWithStatusDtoStatusEnum[keyof typeof GraphNodeWithStatusDtoStatusEnum];

/**
 * 
 * @export
 * @interface GraphNodeWithStatusDtoMetadata
 */
export interface GraphNodeWithStatusDtoMetadata {
    /**
     * 
     * @type {string}
     * @memberof GraphNodeWithStatusDtoMetadata
     */
    'threadId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphNodeWithStatusDtoMetadata
     */
    'runId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphNodeWithStatusDtoMetadata
     */
    'parentThreadId'?: string;
}
/**
 * 
 * @export
 * @interface GraphRevisionDto
 */
export interface GraphRevisionDto {
    /**
     * 
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'graphId': string;
    /**
     * Version the client changes were based on
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'baseVersion': string;
    /**
     * New head version after this revision
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'toVersion': string;
    /**
     * JSON Patch (RFC 6902) operations between old and new schemas
     * @type {Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>}
     * @memberof GraphRevisionDto
     */
    'configurationDiff': Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>;
    /**
     * 
     * @type {UpdateGraphResponseDtoRevisionClientSchema}
     * @memberof GraphRevisionDto
     */
    'clientSchema': UpdateGraphResponseDtoRevisionClientSchema;
    /**
     * 
     * @type {UpdateGraphResponseDtoRevisionNewSchema}
     * @memberof GraphRevisionDto
     */
    'newSchema': UpdateGraphResponseDtoRevisionNewSchema;
    /**
     * 
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'status': GraphRevisionDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GraphRevisionDto
     */
    'updatedAt': string;
}

export const GraphRevisionDtoStatusEnum = {
    Pending: 'pending',
    Applying: 'applying',
    Applied: 'applied',
    Failed: 'failed'
} as const;

export type GraphRevisionDtoStatusEnum = typeof GraphRevisionDtoStatusEnum[keyof typeof GraphRevisionDtoStatusEnum];

/**
 * 
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'kind': TemplateDtoKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TemplateDto
     */
    'schema': { [key: string]: any; };
    /**
     * 
     * @type {Array<TemplateDtoInputsInner>}
     * @memberof TemplateDto
     */
    'inputs'?: Array<TemplateDtoInputsInner>;
    /**
     * 
     * @type {Array<TemplateDtoInputsInner>}
     * @memberof TemplateDto
     */
    'outputs'?: Array<TemplateDtoInputsInner>;
}

export const TemplateDtoKindEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type TemplateDtoKindEnum = typeof TemplateDtoKindEnum[keyof typeof TemplateDtoKindEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInner
 */
export interface TemplateDtoInputsInner {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInner
     */
    'type': TemplateDtoInputsInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInner
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInner
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInner
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerTypeEnum = {
    Kind: 'kind',
    Template: 'template'
} as const;

export type TemplateDtoInputsInnerTypeEnum = typeof TemplateDtoInputsInnerTypeEnum[keyof typeof TemplateDtoInputsInnerTypeEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInnerAnyOf
 */
export interface TemplateDtoInputsInnerAnyOf {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'type': TemplateDtoInputsInnerAnyOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'value': TemplateDtoInputsInnerAnyOfValueEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerAnyOfTypeEnum = {
    Kind: 'kind'
} as const;

export type TemplateDtoInputsInnerAnyOfTypeEnum = typeof TemplateDtoInputsInnerAnyOfTypeEnum[keyof typeof TemplateDtoInputsInnerAnyOfTypeEnum];
export const TemplateDtoInputsInnerAnyOfValueEnum = {
    Runtime: 'runtime',
    Tool: 'tool',
    SimpleAgent: 'simpleAgent',
    Trigger: 'trigger',
    Resource: 'resource'
} as const;

export type TemplateDtoInputsInnerAnyOfValueEnum = typeof TemplateDtoInputsInnerAnyOfValueEnum[keyof typeof TemplateDtoInputsInnerAnyOfValueEnum];

/**
 * 
 * @export
 * @interface TemplateDtoInputsInnerAnyOf1
 */
export interface TemplateDtoInputsInnerAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'type': TemplateDtoInputsInnerAnyOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateDtoInputsInnerAnyOf1
     */
    'multiple': boolean;
}

export const TemplateDtoInputsInnerAnyOf1TypeEnum = {
    Template: 'template'
} as const;

export type TemplateDtoInputsInnerAnyOf1TypeEnum = typeof TemplateDtoInputsInnerAnyOf1TypeEnum[keyof typeof TemplateDtoInputsInnerAnyOf1TypeEnum];

/**
 * 
 * @export
 * @interface ThreadDto
 */
export interface ThreadDto {
    /**
     * Thread ID
     * @type {string}
     * @memberof ThreadDto
     */
    'id': string;
    /**
     * Graph ID
     * @type {string}
     * @memberof ThreadDto
     */
    'graphId': string;
    /**
     * External thread ID from LangChain
     * @type {string}
     * @memberof ThreadDto
     */
    'externalThreadId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ThreadDto
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThreadDto
     */
    'name'?: string | null;
    /**
     * Thread execution status
     * @type {string}
     * @memberof ThreadDto
     */
    'status': ThreadDtoStatusEnum;
}

export const ThreadDtoStatusEnum = {
    Running: 'running',
    Done: 'done',
    NeedMoreInfo: 'need_more_info',
    Stopped: 'stopped'
} as const;

export type ThreadDtoStatusEnum = typeof ThreadDtoStatusEnum[keyof typeof ThreadDtoStatusEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDto
 */
export interface ThreadMessageDto {
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'threadId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'nodeId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'externalThreadId': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadMessageDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {ThreadMessageDtoMessage}
     * @memberof ThreadMessageDto
     */
    'message': ThreadMessageDtoMessage;
}
/**
 * 
 * @export
 * @interface ThreadMessageDtoMessage
 */
export interface ThreadMessageDtoMessage {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'role': ThreadMessageDtoMessageRoleEnum;
    /**
     * Parsed tool result as JSON
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessage
     */
    'content': { [key: string]: any; };
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessage
     */
    'additionalKwargs'?: { [key: string]: any; };
    /**
     * Message ID
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'id'?: string;
    /**
     * Tool calls in the message
     * @type {Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>}
     * @memberof ThreadMessageDtoMessage
     */
    'toolCalls'?: Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>;
    /**
     * Tool name
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'name': string;
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessage
     */
    'toolCallId': string;
}

export const ThreadMessageDtoMessageRoleEnum = {
    Tool: 'tool'
} as const;

export type ThreadMessageDtoMessageRoleEnum = typeof ThreadMessageDtoMessageRoleEnum[keyof typeof ThreadMessageDtoMessageRoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf
 */
export interface ThreadMessageDtoMessageAnyOf {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf
     */
    'role': ThreadMessageDtoMessageAnyOfRoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf
     */
    'content': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOfRoleEnum = {
    Human: 'human'
} as const;

export type ThreadMessageDtoMessageAnyOfRoleEnum = typeof ThreadMessageDtoMessageAnyOfRoleEnum[keyof typeof ThreadMessageDtoMessageAnyOfRoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf1
 */
export interface ThreadMessageDtoMessageAnyOf1 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'role': ThreadMessageDtoMessageAnyOf1RoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'content': string;
    /**
     * Message ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'id'?: string;
    /**
     * Tool calls in the message
     * @type {Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'toolCalls'?: Array<ThreadMessageDtoMessageAnyOf1ToolCallsInner>;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf1
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf1RoleEnum = {
    Ai: 'ai'
} as const;

export type ThreadMessageDtoMessageAnyOf1RoleEnum = typeof ThreadMessageDtoMessageAnyOf1RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf1RoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf1ToolCallsInner
 */
export interface ThreadMessageDtoMessageAnyOf1ToolCallsInner {
    /**
     * Tool name
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'name': string;
    /**
     * Tool arguments
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'args': { [key: string]: any; };
    /**
     * Tool call type
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'type': string;
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf1ToolCallsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf2
 */
export interface ThreadMessageDtoMessageAnyOf2 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf2
     */
    'role': ThreadMessageDtoMessageAnyOf2RoleEnum;
    /**
     * Message content
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf2
     */
    'content': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf2
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf2RoleEnum = {
    System: 'system'
} as const;

export type ThreadMessageDtoMessageAnyOf2RoleEnum = typeof ThreadMessageDtoMessageAnyOf2RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf2RoleEnum];

/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf3
 */
export interface ThreadMessageDtoMessageAnyOf3 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'role': ThreadMessageDtoMessageAnyOf3RoleEnum;
    /**
     * Tool name - shell
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'name': ThreadMessageDtoMessageAnyOf3NameEnum;
    /**
     * 
     * @type {ThreadMessageDtoMessageAnyOf3Content}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'content': ThreadMessageDtoMessageAnyOf3Content;
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'toolCallId': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf3
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf3RoleEnum = {
    ToolShell: 'tool-shell'
} as const;

export type ThreadMessageDtoMessageAnyOf3RoleEnum = typeof ThreadMessageDtoMessageAnyOf3RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf3RoleEnum];
export const ThreadMessageDtoMessageAnyOf3NameEnum = {
    Shell: 'shell'
} as const;

export type ThreadMessageDtoMessageAnyOf3NameEnum = typeof ThreadMessageDtoMessageAnyOf3NameEnum[keyof typeof ThreadMessageDtoMessageAnyOf3NameEnum];

/**
 * Parsed shell execution result
 * @export
 * @interface ThreadMessageDtoMessageAnyOf3Content
 */
export interface ThreadMessageDtoMessageAnyOf3Content {
    /**
     * Exit code of the shell command
     * @type {number}
     * @memberof ThreadMessageDtoMessageAnyOf3Content
     */
    'exitCode': number;
    /**
     * Standard output from the command
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3Content
     */
    'stdout': string;
    /**
     * Standard error from the command
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf3Content
     */
    'stderr': string;
}
/**
 * 
 * @export
 * @interface ThreadMessageDtoMessageAnyOf4
 */
export interface ThreadMessageDtoMessageAnyOf4 {
    /**
     * Message role
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'role': ThreadMessageDtoMessageAnyOf4RoleEnum;
    /**
     * Tool name
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'name': string;
    /**
     * Parsed tool result as JSON
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'content': { [key: string]: any; };
    /**
     * Tool call ID
     * @type {string}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'toolCallId': string;
    /**
     * Additional message metadata
     * @type {{ [key: string]: any; }}
     * @memberof ThreadMessageDtoMessageAnyOf4
     */
    'additionalKwargs'?: { [key: string]: any; };
}

export const ThreadMessageDtoMessageAnyOf4RoleEnum = {
    Tool: 'tool'
} as const;

export type ThreadMessageDtoMessageAnyOf4RoleEnum = typeof ThreadMessageDtoMessageAnyOf4RoleEnum[keyof typeof ThreadMessageDtoMessageAnyOf4RoleEnum];

/**
 * 
 * @export
 * @interface UpdateGraphDto
 */
export interface UpdateGraphDto {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'name'?: string;
    /**
     * 
     * @type {UpdateGraphDtoDescription}
     * @memberof UpdateGraphDto
     */
    'description'?: UpdateGraphDtoDescription;
    /**
     * 
     * @type {UpdateGraphDtoSchema}
     * @memberof UpdateGraphDto
     */
    'schema'?: UpdateGraphDtoSchema;
    /**
     * 
     * @type {UpdateGraphDtoMetadata}
     * @memberof UpdateGraphDto
     */
    'metadata'?: UpdateGraphDtoMetadata;
    /**
     * 
     * @type {UpdateGraphDtoTemporary}
     * @memberof UpdateGraphDto
     */
    'temporary'?: UpdateGraphDtoTemporary;
    /**
     * Current version of the graph (for optimistic locking and 3-way merge base)
     * @type {string}
     * @memberof UpdateGraphDto
     */
    'currentVersion': string;
}
/**
 * 
 * @export
 * @interface UpdateGraphDtoDescription
 */
export interface UpdateGraphDtoDescription {
}
/**
 * 
 * @export
 * @interface UpdateGraphDtoMetadata
 */
export interface UpdateGraphDtoMetadata {
    /**
     * Node coordinates and names by node ID
     * @type {Array<CreateGraphDtoMetadataNodesInner>}
     * @memberof UpdateGraphDtoMetadata
     */
    'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
    /**
     * Zoom level for graph display
     * @type {number}
     * @memberof UpdateGraphDtoMetadata
     */
    'zoom'?: number;
    /**
     * X coordinate
     * @type {number}
     * @memberof UpdateGraphDtoMetadata
     */
    'x'?: number;
    /**
     * Y coordinate
     * @type {number}
     * @memberof UpdateGraphDtoMetadata
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface UpdateGraphDtoMetadataAnyOf
 */
export interface UpdateGraphDtoMetadataAnyOf {
    [key: string]: any;

    /**
     * Node coordinates and names by node ID
     * @type {Array<CreateGraphDtoMetadataNodesInner>}
     * @memberof UpdateGraphDtoMetadataAnyOf
     */
    'nodes'?: Array<CreateGraphDtoMetadataNodesInner>;
    /**
     * Zoom level for graph display
     * @type {number}
     * @memberof UpdateGraphDtoMetadataAnyOf
     */
    'zoom'?: number;
    /**
     * X coordinate
     * @type {number}
     * @memberof UpdateGraphDtoMetadataAnyOf
     */
    'x'?: number;
    /**
     * Y coordinate
     * @type {number}
     * @memberof UpdateGraphDtoMetadataAnyOf
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface UpdateGraphDtoSchema
 */
export interface UpdateGraphDtoSchema {
    /**
     * 
     * @type {Array<UpdateGraphDtoSchemaNodesInner>}
     * @memberof UpdateGraphDtoSchema
     */
    'nodes': Array<UpdateGraphDtoSchemaNodesInner>;
    /**
     * 
     * @type {Array<UpdateGraphDtoSchemaEdgesInner>}
     * @memberof UpdateGraphDtoSchema
     */
    'edges'?: Array<UpdateGraphDtoSchemaEdgesInner>;
}
/**
 * 
 * @export
 * @interface UpdateGraphDtoSchemaEdgesInner
 */
export interface UpdateGraphDtoSchemaEdgesInner {
    /**
     * Source node ID
     * @type {string}
     * @memberof UpdateGraphDtoSchemaEdgesInner
     */
    'from': string;
    /**
     * Target node ID
     * @type {string}
     * @memberof UpdateGraphDtoSchemaEdgesInner
     */
    'to': string;
    /**
     * Optional edge label
     * @type {string}
     * @memberof UpdateGraphDtoSchemaEdgesInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface UpdateGraphDtoSchemaNodesInner
 */
export interface UpdateGraphDtoSchemaNodesInner {
    /**
     * Unique identifier for this node
     * @type {string}
     * @memberof UpdateGraphDtoSchemaNodesInner
     */
    'id': string;
    /**
     * Template name registered in TemplateRegistry
     * @type {string}
     * @memberof UpdateGraphDtoSchemaNodesInner
     */
    'template': string;
    /**
     * Template-specific configuration
     * @type {{ [key: string]: any; }}
     * @memberof UpdateGraphDtoSchemaNodesInner
     */
    'config': { [key: string]: any; };
}
/**
 * If true, graph will be deleted instead of restored after server restart
 * @export
 * @interface UpdateGraphDtoTemporary
 */
export interface UpdateGraphDtoTemporary {
}
/**
 * 
 * @export
 * @interface UpdateGraphResponseDto
 */
export interface UpdateGraphResponseDto {
    /**
     * 
     * @type {UpdateGraphResponseDtoGraph}
     * @memberof UpdateGraphResponseDto
     */
    'graph': UpdateGraphResponseDtoGraph;
    /**
     * 
     * @type {UpdateGraphResponseDtoRevision}
     * @memberof UpdateGraphResponseDto
     */
    'revision'?: UpdateGraphResponseDtoRevision | null;
}
/**
 * Updated graph
 * @export
 * @interface UpdateGraphResponseDtoGraph
 */
export interface UpdateGraphResponseDtoGraph {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'version': string;
    /**
     * Target version after all queued revisions are applied
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'targetVersion': string;
    /**
     * 
     * @type {CreateGraphDtoSchema}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'schema': CreateGraphDtoSchema;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'status': UpdateGraphResponseDtoGraphStatusEnum;
    /**
     * 
     * @type {CreateGraphDtoMetadata}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'metadata'?: CreateGraphDtoMetadata | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGraphResponseDtoGraph
     */
    'temporary'?: boolean | null;
}

export const UpdateGraphResponseDtoGraphStatusEnum = {
    Created: 'created',
    Compiling: 'compiling',
    Running: 'running',
    Stopped: 'stopped',
    Error: 'error'
} as const;

export type UpdateGraphResponseDtoGraphStatusEnum = typeof UpdateGraphResponseDtoGraphStatusEnum[keyof typeof UpdateGraphResponseDtoGraphStatusEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevision
 */
export interface UpdateGraphResponseDtoRevision {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'graphId': string;
    /**
     * Version the client changes were based on
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'baseVersion': string;
    /**
     * New head version after this revision
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'toVersion': string;
    /**
     * JSON Patch (RFC 6902) operations between old and new schemas
     * @type {Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'configurationDiff': Array<UpdateGraphResponseDtoRevisionConfigurationDiffInner>;
    /**
     * 
     * @type {UpdateGraphResponseDtoRevisionClientSchema}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'clientSchema': UpdateGraphResponseDtoRevisionClientSchema;
    /**
     * 
     * @type {UpdateGraphResponseDtoRevisionNewSchema}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'newSchema': UpdateGraphResponseDtoRevisionNewSchema;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'status': UpdateGraphResponseDtoRevisionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevision
     */
    'updatedAt': string;
}

export const UpdateGraphResponseDtoRevisionStatusEnum = {
    Pending: 'pending',
    Applying: 'applying',
    Applied: 'applied',
    Failed: 'failed'
} as const;

export type UpdateGraphResponseDtoRevisionStatusEnum = typeof UpdateGraphResponseDtoRevisionStatusEnum[keyof typeof UpdateGraphResponseDtoRevisionStatusEnum];

/**
 * Schema submitted by the client
 * @export
 * @interface UpdateGraphResponseDtoRevisionClientSchema
 */
export interface UpdateGraphResponseDtoRevisionClientSchema {
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaNodesInner>}
     * @memberof UpdateGraphResponseDtoRevisionClientSchema
     */
    'nodes': Array<CreateGraphDtoSchemaNodesInner>;
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaEdgesInner>}
     * @memberof UpdateGraphResponseDtoRevisionClientSchema
     */
    'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}
/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInner
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInner {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInner
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerOpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInner
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInner
     */
    'value': any;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInner
     */
    'from': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerOpEnum = {
    Test: 'test'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerOpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerOpEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOfOpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf
     */
    'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOfOpEnum = {
    Add: 'add'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOfOpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOfOpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOfOpEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1OpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1
     */
    'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1OpEnum = {
    Remove: 'remove'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1OpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1OpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf1OpEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2 {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2OpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2
     */
    'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2OpEnum = {
    Replace: 'replace'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2OpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2OpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf2OpEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3 {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3OpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3
     */
    'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3OpEnum = {
    Move: 'move'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3OpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3OpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf3OpEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4 {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4OpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4
     */
    'path': string;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4OpEnum = {
    Copy: 'copy'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4OpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4OpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf4OpEnum];

/**
 * 
 * @export
 * @interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5
 */
export interface UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5 {
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5
     */
    'op': UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5OpEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5
     */
    'value': any;
}

export const UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5OpEnum = {
    Test: 'test'
} as const;

export type UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5OpEnum = typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5OpEnum[keyof typeof UpdateGraphResponseDtoRevisionConfigurationDiffInnerAnyOf5OpEnum];

/**
 * Merged schema result
 * @export
 * @interface UpdateGraphResponseDtoRevisionNewSchema
 */
export interface UpdateGraphResponseDtoRevisionNewSchema {
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaNodesInner>}
     * @memberof UpdateGraphResponseDtoRevisionNewSchema
     */
    'nodes': Array<CreateGraphDtoSchemaNodesInner>;
    /**
     * 
     * @type {Array<CreateGraphDtoSchemaEdgesInner>}
     * @memberof UpdateGraphResponseDtoRevisionNewSchema
     */
    'edges'?: Array<CreateGraphDtoSchemaEdgesInner>;
}

/**
 * GraphRevisionsApi - axios parameter creator
 * @export
 */
export const GraphRevisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} graphId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphRevision: async (graphId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getGraphRevision', 'graphId', graphId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGraphRevision', 'id', id)
            const localVarPath = `/api/v1/graphs/{graphId}/revisions/{id}`
                .replace(`{${"graphId"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId 
         * @param {GetGraphRevisionsStatusEnum} [status] 
         * @param {number} [limit] Maximum number of revisions to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphRevisions: async (graphId: string, status?: GetGraphRevisionsStatusEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getGraphRevisions', 'graphId', graphId)
            const localVarPath = `/api/v1/graphs/{graphId}/revisions`
                .replace(`{${"graphId"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphRevisionsApi - functional programming interface
 * @export
 */
export const GraphRevisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphRevisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} graphId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphRevision(graphId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphRevisionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphRevision(graphId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphRevisionsApi.getGraphRevision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId 
         * @param {GetGraphRevisionsStatusEnum} [status] 
         * @param {number} [limit] Maximum number of revisions to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphRevisions(graphId: string, status?: GetGraphRevisionsStatusEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphRevisionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphRevisions(graphId, status, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphRevisionsApi.getGraphRevisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphRevisionsApi - factory interface
 * @export
 */
export const GraphRevisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphRevisionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} graphId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphRevision(graphId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphRevisionDto> {
            return localVarFp.getGraphRevision(graphId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId 
         * @param {GetGraphRevisionsStatusEnum} [status] 
         * @param {number} [limit] Maximum number of revisions to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphRevisions(graphId: string, status?: GetGraphRevisionsStatusEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GraphRevisionDto>> {
            return localVarFp.getGraphRevisions(graphId, status, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphRevisionsApi - object-oriented interface
 * @export
 * @class GraphRevisionsApi
 * @extends {BaseAPI}
 */
export class GraphRevisionsApi extends BaseAPI {
    /**
     * 
     * @param {string} graphId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphRevisionsApi
     */
    public getGraphRevision(graphId: string, id: string, options?: RawAxiosRequestConfig) {
        return GraphRevisionsApiFp(this.configuration).getGraphRevision(graphId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId 
     * @param {GetGraphRevisionsStatusEnum} [status] 
     * @param {number} [limit] Maximum number of revisions to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphRevisionsApi
     */
    public getGraphRevisions(graphId: string, status?: GetGraphRevisionsStatusEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return GraphRevisionsApiFp(this.configuration).getGraphRevisions(graphId, status, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetGraphRevisionsStatusEnum = {
    Pending: 'pending',
    Applying: 'applying',
    Applied: 'applied',
    Failed: 'failed'
} as const;
export type GetGraphRevisionsStatusEnum = typeof GetGraphRevisionsStatusEnum[keyof typeof GetGraphRevisionsStatusEnum];


/**
 * GraphsApi - axios parameter creator
 * @export
 */
export const GraphsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph: async (createGraphDto: CreateGraphDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGraphDto' is not null or undefined
            assertParamExists('createGraph', 'createGraphDto', createGraphDto)
            const localVarPath = `/api/v1/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGraphDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/destroy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeTrigger: async (graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('executeTrigger', 'graphId', graphId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('executeTrigger', 'triggerId', triggerId)
            // verify required parameter 'executeTriggerDto' is not null or undefined
            assertParamExists('executeTrigger', 'executeTriggerDto', executeTriggerDto)
            const localVarPath = `/api/v1/graphs/{graphId}/triggers/{triggerId}/execute`
                .replace(`{${"graphId"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTriggerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGraphById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findGraphById', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGraphs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/graphs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [threadId] 
         * @param {string} [runId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompiledNodes: async (id: string, threadId?: string, runId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCompiledNodes', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (threadId !== undefined) {
                localVarQueryParameter['threadId'] = threadId;
            }

            if (runId !== undefined) {
                localVarQueryParameter['runId'] = runId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runGraph: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runGraph', 'id', id)
            const localVarPath = `/api/v1/graphs/{id}/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph: async (id: string, updateGraphDto: UpdateGraphDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGraph', 'id', id)
            // verify required parameter 'updateGraphDto' is not null or undefined
            assertParamExists('updateGraph', 'updateGraphDto', updateGraphDto)
            const localVarPath = `/api/v1/graphs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGraphDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphsApi - functional programming interface
 * @export
 */
export const GraphsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(createGraphDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.createGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.deleteGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.destroyGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTriggerResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeTrigger(graphId, triggerId, executeTriggerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.executeTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGraphById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGraphById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.findGraphById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGraphs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGraphs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.getAllGraphs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [threadId] 
         * @param {string} [runId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompiledNodes(id: string, threadId?: string, runId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraphNodeWithStatusDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompiledNodes(id, threadId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.getCompiledNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runGraph(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runGraph(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.runGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateGraphResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraph(id, updateGraphDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphsApi.updateGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphsApi - factory interface
 * @export
 */
export const GraphsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateGraphDto} createGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.createGraph(createGraphDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.destroyGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId 
         * @param {string} triggerId 
         * @param {ExecuteTriggerDto} executeTriggerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteTriggerResponseDto> {
            return localVarFp.executeTrigger(graphId, triggerId, executeTriggerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGraphById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.findGraphById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGraphs(options?: RawAxiosRequestConfig): AxiosPromise<Array<GraphDto>> {
            return localVarFp.getAllGraphs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [threadId] 
         * @param {string} [runId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompiledNodes(id: string, threadId?: string, runId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GraphNodeWithStatusDto>> {
            return localVarFp.getCompiledNodes(id, threadId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runGraph(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GraphDto> {
            return localVarFp.runGraph(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateGraphDto} updateGraphDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig): AxiosPromise<UpdateGraphResponseDto> {
            return localVarFp.updateGraph(id, updateGraphDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphsApi - object-oriented interface
 * @export
 * @class GraphsApi
 * @extends {BaseAPI}
 */
export class GraphsApi extends BaseAPI {
    /**
     * 
     * @param {CreateGraphDto} createGraphDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public createGraph(createGraphDto: CreateGraphDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).createGraph(createGraphDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public deleteGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).deleteGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public destroyGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).destroyGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId 
     * @param {string} triggerId 
     * @param {ExecuteTriggerDto} executeTriggerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public executeTrigger(graphId: string, triggerId: string, executeTriggerDto: ExecuteTriggerDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).executeTrigger(graphId, triggerId, executeTriggerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public findGraphById(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).findGraphById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public getAllGraphs(options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).getAllGraphs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [threadId] 
     * @param {string} [runId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public getCompiledNodes(id: string, threadId?: string, runId?: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).getCompiledNodes(id, threadId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public runGraph(id: string, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).runGraph(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateGraphDto} updateGraphDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphsApi
     */
    public updateGraph(id: string, updateGraphDto: UpdateGraphDto, options?: RawAxiosRequestConfig) {
        return GraphsApiFp(this.configuration).updateGraph(id, updateGraphDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.getAllTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<TemplateDto>> {
            return localVarFp.getAllTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getAllTemplates(options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getAllTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThreadsApi - axios parameter creator
 * @export
 */
export const ThreadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThread: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('deleteThread', 'threadId', threadId)
            const localVarPath = `/api/v1/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} externalThreadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadByExternalId: async (externalThreadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalThreadId' is not null or undefined
            assertParamExists('getThreadByExternalId', 'externalThreadId', externalThreadId)
            const localVarPath = `/api/v1/threads/external/{externalThreadId}`
                .replace(`{${"externalThreadId"}}`, encodeURIComponent(String(externalThreadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadById: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getThreadById', 'threadId', threadId)
            const localVarPath = `/api/v1/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} threadId 
         * @param {string} [nodeId] Filter messages by node ID (agent node)
         * @param {number} [limit] Maximum number of messages to return
         * @param {number} [offset] Number of messages to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadMessages: async (threadId: string, nodeId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getThreadMessages', 'threadId', threadId)
            const localVarPath = `/api/v1/threads/{threadId}/messages`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} graphId Filter by graph ID
         * @param {number} [limit] Maximum number of threads to return
         * @param {number} [offset] Number of threads to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreads: async (graphId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getThreads', 'graphId', graphId)
            const localVarPath = `/api/v1/threads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (graphId !== undefined) {
                localVarQueryParameter['graphId'] = graphId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadsApi - functional programming interface
 * @export
 */
export const ThreadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThreadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThread(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThread(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.deleteThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} externalThreadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadByExternalId(externalThreadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadByExternalId(externalThreadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreadByExternalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadById(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadById(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreadById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} threadId 
         * @param {string} [nodeId] Filter messages by node ID (agent node)
         * @param {number} [limit] Maximum number of messages to return
         * @param {number} [offset] Number of messages to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadMessages(threadId: string, nodeId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadMessages(threadId, nodeId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreadMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} graphId Filter by graph ID
         * @param {number} [limit] Maximum number of threads to return
         * @param {number} [offset] Number of threads to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreads(graphId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreads(graphId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadsApi.getThreads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThreadsApi - factory interface
 * @export
 */
export const ThreadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThreadsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteThread(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} externalThreadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadByExternalId(externalThreadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadDto> {
            return localVarFp.getThreadByExternalId(externalThreadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} threadId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadById(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadDto> {
            return localVarFp.getThreadById(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} threadId 
         * @param {string} [nodeId] Filter messages by node ID (agent node)
         * @param {number} [limit] Maximum number of messages to return
         * @param {number} [offset] Number of messages to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadMessages(threadId: string, nodeId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThreadMessageDto>> {
            return localVarFp.getThreadMessages(threadId, nodeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} graphId Filter by graph ID
         * @param {number} [limit] Maximum number of threads to return
         * @param {number} [offset] Number of threads to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreads(graphId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ThreadDto>> {
            return localVarFp.getThreads(graphId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadsApi - object-oriented interface
 * @export
 * @class ThreadsApi
 * @extends {BaseAPI}
 */
export class ThreadsApi extends BaseAPI {
    /**
     * 
     * @param {string} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public deleteThread(threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).deleteThread(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} externalThreadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreadByExternalId(externalThreadId: string, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreadByExternalId(externalThreadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} threadId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreadById(threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreadById(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} threadId 
     * @param {string} [nodeId] Filter messages by node ID (agent node)
     * @param {number} [limit] Maximum number of messages to return
     * @param {number} [offset] Number of messages to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreadMessages(threadId: string, nodeId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreadMessages(threadId, nodeId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} graphId Filter by graph ID
     * @param {number} [limit] Maximum number of threads to return
     * @param {number} [offset] Number of threads to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public getThreads(graphId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThreadsApiFp(this.configuration).getThreads(graphId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



