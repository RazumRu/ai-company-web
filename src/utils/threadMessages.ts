import type { ThreadMessageDto } from '../autogenerated';

export interface ReasoningChunkEntry {
  reasoningId: string;
  content: string;
  createdAt?: string;
  updatedAt?: string;
  runId?: string;
  threadId?: string;
}

export const STREAMING_REASONING_FLAG = '__streamingReasoning';

const isPlainObject = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null && !Array.isArray(value);

const getMessageString = (
  payload: ThreadMessageDto['message'],
  key: string,
): string | undefined => {
  if (!payload || typeof payload !== 'object') {
    return undefined;
  }
  const value = (payload as unknown as Record<string, unknown>)[key];
  return typeof value === 'string' ? value : undefined;
};

export const sortMessagesChronologically = (
  msgs: ThreadMessageDto[],
): ThreadMessageDto[] =>
  [...msgs].sort(
    (a, b) =>
      new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),
  );

export const extractReasoningEntries = (
  source: unknown,
  context: { threadId?: string; runId?: string } = {},
): ReasoningChunkEntry[] => {
  if (!isPlainObject(source)) {
    return [];
  }

  const entries: ReasoningChunkEntry[] = [];

  Object.entries(source).forEach(([key, raw]) => {
    if (typeof raw === 'string') {
      entries.push({
        reasoningId: key,
        content: raw,
        threadId: context.threadId,
        runId: context.runId,
      });
      return;
    }

    if (isPlainObject(raw)) {
      const rawObject = raw as Record<string, unknown>;
      const nestedThreadId =
        (typeof rawObject.threadId === 'string' ? rawObject.threadId : undefined) ??
        context.threadId ??
        (key.includes(':') ? key : undefined);
      const nestedRunId =
        (typeof rawObject.runId === 'string' ? rawObject.runId : undefined) ??
        context.runId ??
        (key.startsWith('run-') ? key : undefined);

      if (typeof rawObject.content === 'string') {
        entries.push({
          reasoningId: key,
          content: rawObject.content,
          createdAt:
            typeof rawObject.createdAt === 'string'
              ? rawObject.createdAt
              : undefined,
          updatedAt:
            typeof rawObject.updatedAt === 'string'
              ? rawObject.updatedAt
              : undefined,
          runId: nestedRunId,
          threadId: nestedThreadId,
        });
        return;
      }

      entries.push(
        ...extractReasoningEntries(rawObject, {
          threadId: nestedThreadId,
          runId: nestedRunId,
        }),
      );
    }
  });

  return entries;
};

export const narrowReasoningContainer = (
  source: unknown,
  keys: Array<string | undefined>,
): unknown => {
  if (!isPlainObject(source)) return source;
  let current: unknown = source;
  let narrowed = false;

  keys.forEach((key) => {
    if (!key || !isPlainObject(current)) return;
    const next = (current as Record<string, unknown>)[key];
    if (next !== undefined) {
      current = next;
      narrowed = true;
    }
  });

  return narrowed ? current : source;
};

export const isReasoningMessage = (msg: ThreadMessageDto): boolean =>
  (msg.message?.role as string) === 'reasoning';

export const getReasoningIdentifier = (
  msg: ThreadMessageDto,
): string | undefined => {
  if (!isReasoningMessage(msg)) return undefined;
  const reasoningId = getMessageString(msg.message, 'id');
  if (typeof reasoningId === 'string' && reasoningId.length > 0) {
    return reasoningId;
  }
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  const fallback = kwargs?.reasoningId;
  return typeof fallback === 'string' && fallback.length > 0
    ? fallback
    : undefined;
};

export const getMessageRunId = (msg: ThreadMessageDto): string | undefined => {
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  if (!kwargs) return undefined;
  const runId = kwargs.run_id;
  return typeof runId === 'string' ? runId : undefined;
};

export const isStreamingReasoningMessage = (
  msg: ThreadMessageDto,
): boolean => {
  if (!isReasoningMessage(msg)) return false;
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  if (!kwargs) return false;
  return Boolean(kwargs[STREAMING_REASONING_FLAG]);
};

export const removeStreamingReasoningMessages = (
  msgs: ThreadMessageDto[],
  predicate: (msg: ThreadMessageDto) => boolean,
): ThreadMessageDto[] => {
  if (!predicate) return msgs;
  return msgs.filter((msg) => {
    if (!isStreamingReasoningMessage(msg)) return true;
    return !predicate(msg);
  });
};

export const mergeMessagesReplacingStreaming = (
  prev: ThreadMessageDto[],
  incoming: ThreadMessageDto[],
): ThreadMessageDto[] => {
  if (incoming.length === 0) {
    return prev;
  }

  const reasoningIds = new Set(
    incoming
      .map((msg) => getReasoningIdentifier(msg))
      .filter((id): id is string => Boolean(id)),
  );

  const reasoningRunIds = new Set(
    incoming
      .filter((msg) => isReasoningMessage(msg))
      .map((msg) => getMessageRunId(msg))
      .filter((runId): runId is string => Boolean(runId)),
  );

  const cleanedPrev =
    reasoningIds.size > 0 || reasoningRunIds.size > 0
      ? removeStreamingReasoningMessages(prev, (msg) => {
          if (!isStreamingReasoningMessage(msg)) {
            return false;
          }
          const reasoningId = getReasoningIdentifier(msg);
          if (reasoningId && reasoningIds.has(reasoningId)) {
            return true;
          }
          const runId = getMessageRunId(msg);
          if (runId && reasoningRunIds.has(runId)) {
            return true;
          }
          return false;
        })
      : prev;

  const map = new Map<string, ThreadMessageDto>();
  cleanedPrev.forEach((msg) => map.set(msg.id, msg));
  incoming.forEach((msg) => map.set(msg.id, msg));

  return sortMessagesChronologically(Array.from(map.values()));
};

export const buildIdSet = (
  ...values: Array<string | undefined>
): Set<string> | undefined => {
  const filtered = values.filter((value): value is string => Boolean(value));
  return filtered.length > 0 ? new Set(filtered) : undefined;
};

