import type { ThreadMessageDto } from '../autogenerated';

export interface ReasoningChunkEntry {
  reasoningId: string;
  content: string;
  createdAt?: string;
  updatedAt?: string;
  runId?: string;
  threadId?: string;
}

export const STREAMING_REASONING_FLAG = '__streamingReasoning';

const isPlainObject = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null && !Array.isArray(value);

const getMessageString = (
  payload: ThreadMessageDto['message'],
  key: string,
): string | undefined => {
  if (!payload || typeof payload !== 'object') {
    return undefined;
  }
  const value = (payload as unknown as Record<string, unknown>)[key];
  return typeof value === 'string' ? value : undefined;
};

export const sortMessagesChronologically = (
  msgs: ThreadMessageDto[],
): ThreadMessageDto[] =>
  [...msgs].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),
  );

export const extractReasoningEntries = (
  source: unknown,
  context: { threadId?: string; runId?: string } = {},
): ReasoningChunkEntry[] => {
  if (!isPlainObject(source)) {
    return [];
  }

  const entries: ReasoningChunkEntry[] = [];

  Object.entries(source).forEach(([key, raw]) => {
    if (typeof raw === 'string') {
      entries.push({
        reasoningId: key,
        content: raw,
        threadId: context.threadId,
        runId: context.runId,
      });
      return;
    }

    if (isPlainObject(raw)) {
      const rawObject = raw as Record<string, unknown>;
      const nestedThreadId =
        (typeof rawObject.threadId === 'string'
          ? rawObject.threadId
          : undefined) ??
        context.threadId ??
        (key.includes(':') ? key : undefined);
      const nestedRunId =
        (typeof rawObject.runId === 'string' ? rawObject.runId : undefined) ??
        context.runId ??
        (key.startsWith('run-') ? key : undefined);

      if (typeof rawObject.content === 'string') {
        entries.push({
          reasoningId: key,
          content: rawObject.content,
          createdAt:
            typeof rawObject.createdAt === 'string'
              ? rawObject.createdAt
              : undefined,
          updatedAt:
            typeof rawObject.updatedAt === 'string'
              ? rawObject.updatedAt
              : undefined,
          runId: nestedRunId,
          threadId: nestedThreadId,
        });
        return;
      }

      entries.push(
        ...extractReasoningEntries(rawObject, {
          threadId: nestedThreadId,
          runId: nestedRunId,
        }),
      );
    }
  });

  return entries;
};

export const narrowReasoningContainer = (
  source: unknown,
  keys: Array<string | undefined>,
): unknown => {
  if (!isPlainObject(source)) return source;
  let current: unknown = source;
  let narrowed = false;

  keys.forEach((key) => {
    if (!key || !isPlainObject(current)) return;
    const next = (current as Record<string, unknown>)[key];
    if (next !== undefined) {
      current = next;
      narrowed = true;
    }
  });

  return narrowed ? current : source;
};

export const isReasoningMessage = (msg: ThreadMessageDto): boolean =>
  (msg.message?.role as string) === 'reasoning';

export const getReasoningIdentifier = (
  msg: ThreadMessageDto,
): string | undefined => {
  if (!isReasoningMessage(msg)) return undefined;
  const reasoningId = getMessageString(msg.message, 'id');
  if (typeof reasoningId === 'string' && reasoningId.length > 0) {
    return reasoningId;
  }
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  const fallback = kwargs?.reasoningId;
  return typeof fallback === 'string' && fallback.length > 0
    ? fallback
    : undefined;
};

export const getMessageRunId = (msg: ThreadMessageDto): string | undefined => {
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  if (!kwargs) return undefined;
  const runId = kwargs.run_id;
  return typeof runId === 'string' ? runId : undefined;
};

export const isStreamingReasoningMessage = (msg: ThreadMessageDto): boolean => {
  if (!isReasoningMessage(msg)) return false;
  const kwargs = msg.message?.additionalKwargs as
    | Record<string, unknown>
    | undefined;
  if (!kwargs) return false;
  return Boolean(kwargs[STREAMING_REASONING_FLAG]);
};

export const removeStreamingReasoningMessages = (
  msgs: ThreadMessageDto[],
  predicate: (msg: ThreadMessageDto) => boolean,
): ThreadMessageDto[] => {
  if (!predicate) return msgs;
  return msgs.filter((msg) => {
    if (!isStreamingReasoningMessage(msg)) return true;
    return !predicate(msg);
  });
};

export const mergeMessagesReplacingStreaming = (
  prev: ThreadMessageDto[],
  incoming: ThreadMessageDto[],
): ThreadMessageDto[] => {
  if (incoming.length === 0) {
    return prev;
  }

  const reasoningIds = new Set(
    incoming
      .map((msg) => getReasoningIdentifier(msg))
      .filter((id): id is string => Boolean(id)),
  );

  const reasoningRunIds = new Set(
    incoming
      .filter((msg) => isReasoningMessage(msg))
      .map((msg) => getMessageRunId(msg))
      .filter((runId): runId is string => Boolean(runId)),
  );

  const cleanedPrev =
    reasoningIds.size > 0 || reasoningRunIds.size > 0
      ? removeStreamingReasoningMessages(prev, (msg) => {
          if (!isStreamingReasoningMessage(msg)) {
            return false;
          }
          const reasoningId = getReasoningIdentifier(msg);
          if (reasoningId && reasoningIds.has(reasoningId)) {
            return true;
          }
          const runId = getMessageRunId(msg);
          if (runId && reasoningRunIds.has(runId)) {
            return true;
          }
          return false;
        })
      : prev;

  const map = new Map<string, ThreadMessageDto>();
  cleanedPrev.forEach((msg) => map.set(msg.id, msg));
  incoming.forEach((msg) => map.set(msg.id, msg));

  return sortMessagesChronologically(Array.from(map.values()));
};

export const buildIdSet = (
  ...values: Array<string | undefined>
): Set<string> | undefined => {
  const filtered = values.filter((value): value is string => Boolean(value));
  return filtered.length > 0 ? new Set(filtered) : undefined;
};

export interface ReasoningUpsertContext {
  externalThreadId?: string;
  runId?: string;
  selectedThreadId?: string;
  nodeId?: string;
}

const buildReasoningThreadMessage = (
  entry: ReasoningChunkEntry,
  existing: ThreadMessageDto | undefined,
  context: ReasoningUpsertContext,
): ThreadMessageDto => {
  const nowIso = new Date().toISOString();
  const existingMessage = existing?.message as
    | (ThreadMessageDto['message'] & {
        additionalKwargs?: Record<string, unknown>;
        content?: string;
      })
    | undefined;
  const existingAdditional =
    (existingMessage?.additionalKwargs as Record<string, unknown>) ?? {};

  const resolvedExternalThreadId =
    context.externalThreadId ??
    entry.threadId ??
    existing?.externalThreadId ??
    context.selectedThreadId ??
    '';

  const createdAt =
    existing?.createdAt ??
    entry.createdAt ??
    (typeof existingAdditional.created_at === 'string'
      ? (existingAdditional.created_at as string)
      : nowIso);
  const updatedAt = entry.updatedAt ?? existing?.updatedAt ?? nowIso;

  const additionalKwargs: Record<string, unknown> = {
    ...existingAdditional,
    reasoningId: entry.reasoningId,
    [STREAMING_REASONING_FLAG]: true,
  };

  const resolvedRunId =
    context.runId ??
    entry.runId ??
    (typeof existingAdditional.run_id === 'string'
      ? (existingAdditional.run_id as string)
      : undefined);
  if (resolvedRunId) {
    additionalKwargs.run_id = resolvedRunId;
  }

  if (entry.createdAt) {
    additionalKwargs.created_at = entry.createdAt;
  } else if (!additionalKwargs.created_at) {
    additionalKwargs.created_at = createdAt;
  }

  if (!additionalKwargs.reasoningId) {
    additionalKwargs.reasoningId = entry.reasoningId;
  }

  return {
    id: entry.reasoningId,
    threadId: context.selectedThreadId ?? '',
    nodeId: context.nodeId ?? entry.reasoningId,
    externalThreadId: resolvedExternalThreadId,
    createdAt,
    updatedAt,
    message: {
      id: entry.reasoningId,
      role: 'reasoning' as string,
      content: entry.content,
      additionalKwargs,
    } as ThreadMessageDto['message'],
  };
};

export const upsertReasoningEntries = (
  prev: ThreadMessageDto[],
  entries: ReasoningChunkEntry[],
  context: ReasoningUpsertContext,
): ThreadMessageDto[] => {
  if (!entries.length) return prev;

  let hasChanges = false;
  const byId = new Map<string, ThreadMessageDto>();
  prev.forEach((msg) => {
    byId.set(msg.id, msg);
  });

  entries.forEach((entry) => {
    const existing = byId.get(entry.reasoningId);
    const existingMessage = existing?.message as
      | (ThreadMessageDto['message'] & {
          additionalKwargs?: Record<string, unknown>;
          content?: string;
        })
      | undefined;
    const existingAdditional =
      (existingMessage?.additionalKwargs as Record<string, unknown>) ?? {};
    const isExistingStreaming = Boolean(
      existingAdditional?.[STREAMING_REASONING_FLAG],
    );

    if (existing && !isExistingStreaming) {
      return;
    }

    const existingContent =
      typeof existingMessage?.content === 'string'
        ? existingMessage.content
        : '';

    const nextMessage = buildReasoningThreadMessage(entry, existing, context);

    // If we already have a streaming message for this reasoningId, append
    // new chunk content so we accumulate text as it streams.
    const nextMessageContent =
      typeof nextMessage.message?.content === 'string'
        ? (nextMessage.message.content as string)
        : '';

    if (isExistingStreaming && nextMessageContent.length > 0) {
      const shouldUseIncoming =
        nextMessageContent.startsWith(existingContent) ||
        nextMessageContent.length > existingContent.length;
      const mergedContent = shouldUseIncoming
        ? nextMessageContent
        : `${existingContent}${nextMessageContent}`;
      (nextMessage.message as ThreadMessageDto['message']).content =
        mergedContent.length > existingContent.length
          ? mergedContent
          : nextMessageContent;
    }

    const nextContent = entry.content;
    const additionalChanged =
      JSON.stringify(existingAdditional) !==
      JSON.stringify(nextMessage.message?.additionalKwargs ?? {});

    if (
      !existing ||
      existingContent !== nextContent ||
      existing?.updatedAt !== nextMessage.updatedAt ||
      additionalChanged ||
      Boolean(
        (
          nextMessage.message?.additionalKwargs as
            | Record<string, unknown>
            | undefined
        )?.[STREAMING_REASONING_FLAG],
      )
    ) {
      hasChanges = true;
    }

    byId.set(entry.reasoningId, nextMessage);
  });

  if (!hasChanges) {
    return prev;
  }

  return sortMessagesChronologically(Array.from(byId.values()));
};

export const clearStreamingReasoningForContext = (
  prev: ThreadMessageDto[],
  options: {
    targetThreadId?: string;
    selectedThreadId?: string;
    runIds?: Set<string>;
  },
): ThreadMessageDto[] => {
  const {
    targetThreadId,
    selectedThreadId: selectedThreadIdForContext,
    runIds,
  } = options;

  const predicate = (msg: ThreadMessageDto) => {
    const threadMatches = targetThreadId
      ? msg.externalThreadId === targetThreadId ||
        (!msg.externalThreadId && targetThreadId === selectedThreadIdForContext)
      : !msg.externalThreadId ||
        msg.externalThreadId === selectedThreadIdForContext;

    if (!threadMatches) {
      return false;
    }

    if (runIds && runIds.size > 0) {
      const msgRunId = getMessageRunId(msg);
      if (!msgRunId || !runIds.has(msgRunId)) {
        return false;
      }
    }

    return true;
  };

  return removeStreamingReasoningMessages(prev, predicate);
};
